<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="097754d345b7fa422b073a53a9d67740ea99c72d" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82368140" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows イベント ログとの相互作用を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> を使用すると、重要なソフトウェアまたはハードウェアイベントに関する情報を記録する Windows イベントログにアクセスしたり、カスタマイズしたりすることができます。 <xref:System.Diagnostics.EventLog>を使用すると、既存のログを読み取り、ログにエントリを書き込んだり、イベントソースを作成または削除したり、ログを削除したり、ログエントリに応答したりすることができます。 また、イベントソースを作成するときに、新しいログを作成することもできます。  
  
> [!IMPORTANT]
>  この型は <xref:System.IDisposable> インターフェイスを実装します。 型の使用が完了したら、直接的または間接的に型を破棄する必要があります。 直接的に型を破棄するには、`try`/`catch` ブロック内で <xref:System.IDisposable.Dispose%2A> メソッドを呼び出します。 間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。 詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。  
  
 個々のイベントログとそのエントリへのアクセスを提供するだけでなく、<xref:System.Diagnostics.EventLog> クラスを使用して、すべてのイベントログのコレクションにアクセスできます。 <xref:System.Diagnostics.EventLog> の `static` メンバーを使用して、ログの削除、ログ一覧の取得、ソースの作成または削除、またはコンピューターに特定のソースが既に含まれているかどうかの確認を行うことができます。  
  
 既定のイベントログには、アプリケーション、システム、およびセキュリティの3つがあります。 セキュリティログは読み取り専用です。 Active Directory など、インストールするその他のアプリケーションやサービスには、追加のイベントログが含まれる場合があります。  
  
 <xref:System.Diagnostics.EventLog> クラスを使用する場合は、セキュリティ上の考慮事項があります。 <xref:System.Diagnostics.EventLog> には .NET Framework 2.0 以降のバージョンの特定のアクションに対する <xref:System.Diagnostics.EventLogPermission> アクセス許可、または .NET Framework 1.0 と1.1 での完全な信頼が必要です。 部分的に信頼されたコードには <xref:System.Diagnostics.EventLogPermission> 付与しないことをお勧めします。  <xref:System.Diagnostics.EventLogEntryCollection> および <xref:System.Diagnostics.EventLogEntry> オブジェクトを含むイベントログオブジェクトを、より低い信頼度の低いコードに渡すことは避けてください。 たとえば、<xref:System.Diagnostics.EventLog> オブジェクトを作成し、エントリを書き込み、<xref:System.Diagnostics.EventLog> オブジェクトを部分的に信頼されたコードに渡すと、セキュリティ上の問題が発生する可能性があります。これは、イベントログに対する読み取りと書き込みを行う機能によって、他のアプリケーションの名前でイベントログメッセージを発行するなどの操作をコードで実行できるためです。  
  
 Windows Vista 以降では、ユーザーアカウント制御 (UAC) によってユーザーの資格情報が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティログにアクセスするコードを実行するには、まず、資格情報を標準ユーザーから管理者に昇格させる必要があります。 アプリケーションを起動するときに、アプリケーションのショートカットメニューを開き (マウスを使用している場合はアプリケーションアイコンを右クリックして)、管理者として実行することを指定します。  
  
 <xref:System.Diagnostics.EventLog> を使用すると、サーバーのイベントビューアーを通じて表示できるカスタムイベントログを作成できます。 <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> メソッドを使用して、イベントログのローカライズされた名前をイベントビューアーに表示します。 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> メソッドを使用して、ログの最大サイズに達したときのイベントログの動作を構成します。  
  
 イベントログから読み取るには、イベントログのログ名 (<xref:System.Diagnostics.EventLog.Log%2A> プロパティ) とサーバーコンピューター名 (<xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを指定します。 サーバーコンピューター名を指定しない場合は、ローカルコンピューター "." が使用されます。 ソースはログに書き込むためにのみ必要であるため、イベントソース (<xref:System.Diagnostics.EventLog.Source%2A> プロパティ) を指定する必要はありません。 <xref:System.Diagnostics.EventLog.Entries%2A> プロパティには、イベントログのエントリの一覧が自動的に入力されます。  
  
 イベントログに書き込むには、イベントソース (<xref:System.Diagnostics.EventLog.Source%2A> プロパティ) を指定または作成します。 新しいイベントソースを作成するには、コンピューターの管理者の資格情報が必要です。 イベントソースは、アプリケーションを有効なエントリのソースとしてイベントログに登録します。 イベントソースを使用すると、一度に1つのログにのみ書き込むことができます。 <xref:System.Diagnostics.EventLog.Source%2A> プロパティには任意のランダムな文字列を指定できますが、名前はコンピューター上の他のソースと区別する必要があります。 イベントソースは、通常、アプリケーションの名前、または別の識別文字列です。 重複する <xref:System.Diagnostics.EventLog.Source%2A> 値を作成しようとすると、例外がスローされます。 ただし、1つのイベントログを複数のソースに関連付けることができます。  
  
 <xref:System.Diagnostics.EventLog> インスタンスに関連付けられているイベントログのイベントソースが存在しない場合は、新しいイベントソースが作成されます。 Windows Vista 以降または Windows Server 2003 でイベントソースを作成するには、管理者の資格情報が必要です。  
  
 この要件は、イベントソースが一意であるかどうかを確認するために、セキュリティログを含むすべてのイベントログを検索する必要があるためです。 Windows Vista 以降では、セキュリティログにアクセスするためのアクセス許可がユーザーに付与されていません。したがって、<xref:System.Security.SecurityException> がスローされます。  
  
> [!IMPORTANT]
>  イベントソースを作成または削除するには、名前付きミューテックスを使用して、基になるコードを同期する必要があります。 高い特権を持つアプリケーションが名前付きミューテックスをロックした場合、イベントソースを作成または削除しようとすると、ロックが解除されるまでアプリケーションは応答を停止します。 この問題を回避するために、信頼されていないコードには <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> アクセス許可を付与しないでください。 また、<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> アクセス許可によって他のアクセス許可がバイパスされる可能性があるため、信頼性の高いコードにのみ付与する必要があります。  
  
 アプリケーションとサービスは、アプリケーションログまたはカスタムログに書き込む必要があります。 デバイスドライバーは、システムログに書き込む必要があります。 <xref:System.Diagnostics.EventLog.Log%2A> プロパティを明示的に設定しない場合、イベントログの既定値はアプリケーションログになります。  
  
> [!NOTE]
>  アプリケーションが登録されたソースとして書き込むことを保護することはできません。  アプリケーションに <xref:System.Diagnostics.EventLogPermissionAccess.Write> アクセス許可が付与されている場合、コンピューターに登録されている有効なソースのイベントを書き込むことができます。  
  
 イベントログにイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドと <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドを使用します。 イベントを書き込むには、イベントソースを指定する必要があります。ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新していない状態で、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 <xref:System.Diagnostics.EventLogInstaller> オブジェクトまたは <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドを使用して、新しいソースを構成できます。 新しいイベントソースを作成するには、コンピューターの管理者の資格情報が必要です。  
  
 各ソースは一度に1つのイベントログにのみ書き込むことができます。ただし、アプリケーションで複数のソースを使用して複数のイベントログに書き込むことができます。 たとえば、アプリケーションによっては、異なるイベントログまたは異なるリソースファイル用に複数のソースが構成されている必要があります。 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションまたはコンポーネントが既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
 イベントソースは、イベントカテゴリとメッセージ文字列のローカライズされたリソースに登録できます。 アプリケーションでは、実際の文字列値を指定する代わりに、リソース識別子を使用してイベントログエントリを書き込むことができます。 リソースファイルを使用したソースの構成の詳細については、<xref:System.Diagnostics.EventLogInstaller> と <xref:System.Diagnostics.EventSourceCreationData> のクラスを参照してください。  
  
 アプリケーションが文字列値をイベントログに直接書き込む場合は、ソースのリソースファイルプロパティを設定する必要はありません。 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
 イベントを作成する場合は、少なくともメッセージ文字列のメッセージ文字列またはリソース識別子を指定する必要があります。 その他のイベントプロパティは省略可能です。 オプションのイベント設定の例を次に示します。  
  
-   <xref:System.Diagnostics.EventLogEntryType> を設定して、イベントビューアーがエントリに対して表示するアイコンを指定できます。  
  
-   アプリケーションでカテゴリを使用してイベントをフィルター処理する場合は、イベントのカテゴリ識別子を指定できます。  
  
-   指定したイベントに追加情報を関連付ける場合は、イベントエントリにバイナリデータを添付できます。  
  
> [!IMPORTANT]
>  イベントログは、ディスク領域、プロセッサ時間、およびその他のシステムリソースを消費します。 重要な情報のみをログに記録することが重要です。 イベントログの呼び出しは、メインコードパスではなくエラーパスに配置することをお勧めします。これにより、パフォーマンスに悪影響を与えません。  
  
 <xref:System.Diagnostics.EventLog>のインスタンスの初期プロパティ値の一覧については、<xref:System.Diagnostics.EventLog.%23ctor%2A> コンストラクターを参照してください。  
  
   
  
## Examples  
 次の例では、イベントソースがまだ存在しない場合は `MySource` 作成し、イベントログ `MyNewLog`にエントリを書き込みます。  
  
> [!NOTE]
>  Windows Vista 以降では、このアプリケーションを管理者として実行する必要があります。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 このインスタンスは、ログとは関連付けられません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に、<xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを指定します。 ログから <xref:System.Diagnostics.EventLog.Entries%2A> を読み取るだけの場合は、<xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティのみを指定することもできます。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.MachineName%2A>を指定しない場合は、ローカルコンピューター (".") と見なされます。  
  
 次の表に、<xref:System.Diagnostics.EventLog>のインスタンスのプロパティの初期値を示します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカルコンピューター (".")。|  
  
   
  
## Examples  
 次の例では、ソース `MySource` がまだ存在しない場合は作成し、イベントログ `MyNewLog`にエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">ローカル コンピューター上のログの名前。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 ローカル コンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、<xref:System.Diagnostics.EventLog.Log%2A> プロパティを `logName` パラメーターに設定します。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に、<xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを指定します。 ログから <xref:System.Diagnostics.EventLog.Entries%2A> を読み取るだけの場合は、<xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティのみを指定することもできます。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.MachineName%2A>を指定しない場合は、ローカルコンピューター (".") と見なされます。 コンストラクターのこのオーバーロードは、<xref:System.Diagnostics.EventLog.Log%2A> プロパティを指定しますが、<xref:System.Diagnostics.EventLog.Entries%2A> プロパティを読み取る前にこれを変更できます。  
  
 <xref:System.Diagnostics.EventLog.Source%2A> プロパティに指定したソースがコンピューター上の他のソースから一意である場合、<xref:System.Diagnostics.EventLog.WriteEntry%2A> を呼び出すと、指定した名前のログがまだ存在しない場合は、そのログが作成されます。  
  
 次の表に、<xref:System.Diagnostics.EventLog>のインスタンスのプロパティの初期値を示します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカルコンピューター (".")。|  
  
   
  
## Examples  
 次の例では、ローカルコンピューター上のイベントログ "myNewLog" のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が無効です。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、<xref:System.Diagnostics.EventLog.Log%2A> プロパティを `logName` パラメーターに、<xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを `machineName` パラメーターに設定します。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に、<xref:System.Diagnostics.EventLog>の <xref:System.Diagnostics.EventLog.Source%2A> プロパティを指定します。 ログから <xref:System.Diagnostics.EventLog.Entries%2A> を読み取るだけの場合は、<xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティのみを指定することもできます。  
  
> [!NOTE]
>  コンストラクターのこのオーバーロードには、<xref:System.Diagnostics.EventLog.Log%2A> プロパティと <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティが指定されていますが、<xref:System.Diagnostics.EventLog.Entries%2A> プロパティを読み取る前に変更することができます。  
  
 次の表に、<xref:System.Diagnostics.EventLog>のインスタンスのプロパティの初期値を示します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` パラメーター。|  
  
   
  
## Examples  
 次の例では、コンピューター "myServer" のイベントログ "myNewLog" のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が無効です。  
  
 - または -  
  
 コンピューター名が無効です。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <param name="source">イベント ログ エントリのソース。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付け、指定したソースを作成するか、または <see cref="T:System.Diagnostics.EventLog" /> に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、<xref:System.Diagnostics.EventLog.Log%2A> プロパティを `logName` パラメーター、<xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを `machineName` パラメーターに、および <xref:System.Diagnostics.EventLog.Source%2A> プロパティを `source` パラメーターに設定します。 イベントログに書き込む場合は、<xref:System.Diagnostics.EventLog.Source%2A> プロパティが必要です。 ただし、イベントログからの読み取りのみを行う場合は、<xref:System.Diagnostics.EventLog.Log%2A> プロパティと <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティのみが必要です (サーバーのイベントログに既に関連付けられているソースがある場合)。 イベントログからの読み取りのみを行う場合は、コンストラクターの別のオーバーロードで十分な場合があります。  
  
 次の表に、<xref:System.Diagnostics.EventLog>のインスタンスのプロパティの初期値を示します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` パラメーター。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` パラメーター。|  
  
   
  
## Examples  
 次の例では、ソース "MySource" を使用して、ローカルコンピューター上のイベントログ "MyNewLog" にエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が無効です。  
  
 - または -  
  
 コンピューター名が無効です。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントによって使用されるコンポーネントの初期化を開始します。 <xref:System.Diagnostics.EventLog.EndInit%2A> メソッドは、初期化を終了します。 <xref:System.Diagnostics.EventLog.BeginInit%2A> メソッドと <xref:System.Diagnostics.EventLog.EndInit%2A> メソッドを使用すると、完全に初期化される前にコントロールが使用されなくなります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> は、既に初期化されています。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログからすべてのエントリを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントログには、含めることができるエントリの数を決定する最大サイズが設定されます。 イベントログがいっぱいになると、新しいイベント情報の記録が停止されるか、以前のエントリの上書きが開始されます。 イベント記録が停止した場合は、このメソッドを使用して既存のエントリのログを消去し、イベントの記録を再開できます。 イベントログエントリを消去するには、ログが置かれているコンピューターに対する管理者権限が必要です。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> は、イベントログを閉じ、イベントハンドルを解放し、新しい読み取りおよび書き込みハンドルを取得して、イベントログを開きます。 メソッドの呼び出し後に受け取ったイベントは、既存のイベントと共にクリアされません。  
  
   
  
## Examples  
 次の例では、イベントログをクリアします。  
  
> [!CAUTION]
>  アプリケーション、システム、セキュリティ、およびその他の非カスタムログには、重要な情報が含まれている可能性があります。このコード例を実行する前に、必ずカスタムログを指定してください。 次の例では、カスタムログ `myNewLog`を削除します。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログが正常に消去されませんでした。  
  
 - または -  
  
 ログを開くことができません。 Windows のエラー コードは使用できません。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Log" /> プロパティの値が指定されていません。 ログ名が空の文字列でないことを確認してください。</exception>
        <exception cref="T:System.InvalidOperationException">ログが存在しません。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログを閉じ、読み取りハンドルと書き込みハンドルを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A> メソッドは、protected <xref:System.ComponentModel.Component.Dispose%2A> メソッドによって呼び出されます。 <xref:System.ComponentModel.Component.Dispose%2A>を呼び出す前に <xref:System.Diagnostics.EventLog.Close%2A> を呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログの読み取りハンドルまたは書き込みハンドルが解放されませんでした。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>システム上の特定のログにイベント情報を書き込むことができるようにアプリケーションを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">イベント ソースおよび対象のイベント ログの構成プロパティ。</param>
        <summary>イベント ソースおよび対応するイベント ログに指定された構成プロパティを使用して、ローカライズされたイベント メッセージを書き込むための有効なイベント ソースを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカルコンピューターまたはリモートコンピューターのイベントログにエントリを書き込むための新しいソースを構成するには、このオーバーロードを使用します。 このメソッドを使用して、イベントログから読み取る必要はありません。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドでは、入力 `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>、<xref:System.Diagnostics.EventSourceCreationData.LogName%2A> および <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> の各プロパティを使用して、新しいソースとそれに関連付けられているイベントログのターゲットコンピューターでレジストリ値を作成します。 新しいソース名は、既存のソース名またはターゲットコンピューターの既存のイベントログ名と一致することはできません。 <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> プロパティが設定されていない場合、ソースはアプリケーションイベントログに登録されます。 <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> が設定されていない場合、ソースはローカルコンピューターに登録されます。  
  
> [!NOTE]
>  Windows Vista 以降または Windows Server 2003 でイベントソースを作成するには、管理者特権が必要です。  
>   
>  この要件の理由は、イベントソースが一意かどうかを判断するために、セキュリティを含むすべてのイベントログを検索する必要があるためです。 Windows Vista 以降では、セキュリティログにアクセスするためのアクセス許可がユーザーに付与されていません。したがって、<xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザーアカウント制御 (UAC) によってユーザーの特権が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティログにアクセスするコードを実行するには、まず、特権を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 イベントログにイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> を使用します。 イベントを書き込むには、イベントソースを指定する必要があります。ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 既存のイベントログまたは新しいイベントログのイベントソースを作成できます。 新しいイベントログ用に新しいソースを作成すると、そのログのソースが登録されますが、最初のエントリが書き込まれるまでログは作成されません。  
  
 オペレーティング システムではイベント ログはファイルとして保存されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を使用して新しいイベントログを作成する場合、関連付けられているファイルは、指定したコンピューターの%SystemRoot%\System32\Config ディレクトリに格納されます。 ファイル名を設定するには、<xref:System.Diagnostics.EventLog.Log%2A> プロパティの最初の8文字に ".evt" というファイル名拡張子を追加します。  
  
 各ソースは、一度に1つのイベントログにのみ書き込むことができます。ただし、アプリケーションで複数のソースを使用して複数のイベントログに書き込むことができます。 たとえば、アプリケーションによっては、異なるイベントログまたは異なるリソースファイル用に複数のソースが構成されている必要があります。  
  
 イベントソースは、イベントカテゴリとメッセージ文字列のローカライズされたリソースファイルに登録できます。 アプリケーションでは、実際の文字列を指定するのではなく、リソース識別子を使用してイベントログエントリを書き込むことができます。 イベントビューアーは、リソース識別子を使用して、ローカライズされたリソースファイルの対応する文字列を検索し、現在の言語設定に基づいて表示します。 イベントカテゴリ、メッセージ、およびパラメーター挿入文字列用に別のファイルを登録したり、3種類の文字列すべてに同じリソースファイルを登録したりすることができます。 <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>、<xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>、<xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>、および <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> プロパティを使用して、ローカライズされたエントリをイベントログに書き込むようにソースを構成します。 アプリケーションが文字列値をイベントログに直接書き込む場合は、これらのプロパティを設定する必要はありません。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションまたはコンポーネントが既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースがイベントログ用に構成されていて、別のイベントログに対して再構成する場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、`SampleApplicationSource` という名前のイベントソースがローカルコンピューターに登録されているかどうかを確認します。 イベントソースが存在しない場合、この例では、ソースのメッセージリソースファイルを設定し、新しいイベントソースを作成します。 最後に、この例では、`DisplayNameMsgId` のリソース識別子の値と `messageFile`のリソースファイルパスを使用して、イベントログのローカライズされた表示名を設定します。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 この例では、リソースライブラリ EventLogMsgs に組み込まれている次のメッセージテキストファイルを使用します。 メッセージテキストファイルは、メッセージリソースファイルの作成元のソースです。 メッセージテキストファイルは、カテゴリ、イベントメッセージ、およびパラメーター挿入文字列のリソース識別子とテキストを定義します。 具体的には、リソース識別子5001は、イベントログのローカライズされた名前に対して定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceData" /> で指定されたコンピューター名が無効です。  
  
- または - 
<paramref name="sourceData" /> で指定されたソース名が <see langword="null" /> です。  
  
- または - 
<paramref name="sourceData" /> で指定されたログ名が無効です。 イベント ログ名は、印字可能な文字で構成されている必要があります。文字 '*'、'?'、または '\\' を含めないでください。  
  
- または - 
<paramref name="sourceData" /> で指定されたログ名は、ユーザー ログの作成には無効です。 イベント ログ名 AppEvent、SysEvent、および SecEvent は、システムで使用するために予約されています。  
  
- または - 
ログ名が既存のイベント ソース名に一致します。  
  
- または - 
<paramref name="sourceData" /> で指定されたソース名は、254 文字を超えるレジストリ キーのパスになります。  
  
- または - 
<paramref name="sourceData" /> で指定されたログ名の最初の 8 文字が一意ではありません。  
  
- または - 
<paramref name="sourceData" /> で指定されたソース名は既に登録されています。  
  
- または - 
<paramref name="sourceData" /> で指定されたソース名が既存のイベント ログ名に一致しません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" /> が <see langword="null" />です。</exception>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションをローカル コンピューター上に登録するときに使用するソース名。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。</param>
        <summary>ローカル コンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 また、このメソッドによってローカル コンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、カスタムログを作成するか、ローカルコンピューター上の既存のログに <xref:System.Diagnostics.EventLog.Source%2A> を作成して登録します。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>を呼び出したときに `logName` が `null` または空の文字列 ("") の場合、ログの既定値はアプリケーションログになります。 ログがローカルコンピューターに存在しない場合、システムはカスタムログを作成し、そのログの <xref:System.Diagnostics.EventLog.Source%2A> としてアプリケーションを登録します。  
  
> [!NOTE]
>  Windows Vista 以降または Windows Server 2003 でイベントソースを作成するには、管理者特権が必要です。  
>   
>  この要件の理由は、イベントソースが一意かどうかを判断するために、セキュリティを含むすべてのイベントログを検索する必要があるためです。 Windows Vista 以降では、セキュリティログにアクセスするためのアクセス許可がユーザーに付与されていません。したがって、<xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティログにアクセスするコードを実行するには、まず、特権を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 イベントログに書き込む場合にのみ、イベントソースを作成する必要があります。 イベントログにエントリを書き込む前に、イベントソースを有効なイベントのソースとしてイベントログに登録する必要があります。 ログエントリを作成すると、システムは <xref:System.Diagnostics.EventLog.Source%2A> を使用して、エントリを配置する適切なログを検索します。 イベントログを読み取る場合は、<xref:System.Diagnostics.EventLog.Source%2A>、<xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A>のいずれかを指定できます。  
  
> [!NOTE]
>  ローカルコンピューター上のログに接続している場合は、<xref:System.Diagnostics.EventLog.MachineName%2A> を指定する必要はありません。 ログからの読み取り時に <xref:System.Diagnostics.EventLog.MachineName%2A> を指定しなかった場合は、ローカルコンピューター (".") と見なされます。  
  
 イベントログにイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> を使用します。 イベントを書き込むには、イベントソースを指定する必要があります。ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 既存のイベントログまたは新しいイベントログのイベントソースを作成できます。 新しいイベントログ用に新しいソースを作成すると、そのログのソースが登録されますが、最初のエントリが書き込まれるまでログは作成されません。  
  
 オペレーティング システムではイベント ログはファイルとして保存されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を使用して新しいイベントログを作成する場合、関連付けられているファイルは、指定したコンピューターの%SystemRoot%\System32\Config ディレクトリに格納されます。 ファイル名を設定するには、<xref:System.Diagnostics.EventLog.Log%2A> プロパティの最初の8文字に ".evt" というファイル名拡張子を追加します。  
  
 ソースは、ローカルコンピューター上で一意である必要があります。新しいソース名は、既存のソース名または既存のイベントログ名と一致することはできません。 各ソースは一度に1つのイベントログにのみ書き込むことができます。ただし、アプリケーションで複数のソースを使用して複数のイベントログに書き込むことができます。 たとえば、アプリケーションによっては、異なるイベントログまたは異なるリソースファイル用に複数のソースが構成されている必要があります。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションまたはコンポーネントが既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースが既にログにマップされていて、新しいログに再マップする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソース `MySource` がまだ存在しない場合は作成し、イベントログ `MyNewLog`にエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> が空の文字列 ("") または <see langword="null" />  
  
- または - 
 <paramref name="logName" /> が有効なイベント ログ名ではありません。 イベント ログ名は、印字可能な文字で構成されている必要があります。文字 '*'、'?'、または '\\' を含めないでください。  
  
- または - 
 <paramref name="logName" /> はユーザー ログの作成に有効ではありません。 イベント ログ名 AppEvent、SysEvent、および SecEvent は、システムで使用するために予約されています。  
  
- または - 
ログ名が既存のイベント ソース名に一致します。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。  
  
- または - 
<paramref name="logName" /> の最初の 8 文字が既存のイベント ログ名の最初の 8 文字に一致します。  
  
- または - 
ローカル コンピューター上に既にソースが存在するため、ソースを登録できません。  
  
- または - 
ソース名が既存のイベント ログ名に一致します。</exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;dotnet-plat-ext-3.0;netcore-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。 値を指定しなかった場合、<paramref name="logName" /> は既定によりアプリケーションに設定されます。</param>
        <param name="machineName">このイベント ソースを登録するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 このメソッドを使用して、指定したコンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、カスタムログを作成するか、指定したコンピューター上の既存のログに <xref:System.Diagnostics.EventLog.Source%2A> を作成して登録します。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>を呼び出したときに `logName` が `null` または空の文字列 ("") の場合、ログの既定値はアプリケーションログになります。 指定したコンピューター上にログが存在しない場合、システムはカスタムログを作成し、そのログの <xref:System.Diagnostics.EventLog.Source%2A> としてアプリケーションを登録します。  
  
 イベントログに書き込む場合にのみ、イベントソースを作成する必要があります。 イベントログにエントリを書き込む前に、イベントソースを有効なイベントのソースとしてイベントログに登録する必要があります。 ログエントリを作成すると、システムは <xref:System.Diagnostics.EventLog.Source%2A> を使用して、エントリを配置する適切なログを検索します。 イベントログを読み取る場合は、<xref:System.Diagnostics.EventLog.Source%2A>、<xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A>のいずれかを指定できます。  
  
> [!NOTE]
>  Windows Vista 以降または Windows Server 2003 でイベントソースを作成するには、管理者特権が必要です。  
>   
>  この要件の理由は、イベントソースが一意かどうかを判断するために、セキュリティを含むすべてのイベントログを検索する必要があるためです。 Windows Vista 以降では、セキュリティログへのアクセス許可がユーザーに付与されていません。したがって、<xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティログにアクセスするコードを実行するには、まず、特権を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 イベントログにイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> を使用します。 イベントを書き込むには、イベントソースを指定する必要があります。ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 既存のイベントログまたは新しいイベントログのイベントソースを作成できます。 新しいイベントログ用に新しいソースを作成すると、そのログのソースが登録されますが、最初のエントリが書き込まれるまでログは作成されません。  
  
 オペレーティング システムではイベント ログはファイルとして保存されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を使用して新しいイベントログを作成する場合、関連付けられているファイルは、指定したコンピューターの%SystemRoot%\System32\Config ディレクトリに格納されます。 ファイル名を設定するには、<xref:System.Diagnostics.EventLog.Log%2A> プロパティの最初の8文字に ".evt" というファイル名拡張子を追加します。  
  
 ソースは、ローカルコンピューター上で一意である必要があります。新しいソース名は、既存のソース名または既存のイベントログ名と一致することはできません。 各ソースは一度に1つのイベントログにのみ書き込むことができます。ただし、アプリケーションで複数のソースを使用して複数のイベントログに書き込むことができます。 たとえば、アプリケーションによっては、異なるイベントログまたは異なるリソースファイル用に複数のソースが構成されている必要があります。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションまたはコンポーネントが既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースが既にログにマップされていて、新しいログに再マップする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、コンピューター `MyServer`にソース `MySource` を作成し、エントリをイベントログ `MyNewLog`に書き込みます。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> が有効なコンピューター名ではありません。  
  
- または - 
 <paramref name="source" /> が空の文字列 ("") または <see langword="null" />  
  
- または - 
 <paramref name="logName" /> が有効なイベント ログ名ではありません。 イベント ログ名は、印字可能な文字で構成されている必要があります。文字 '*'、'?'、または '\\' を含めないでください。  
  
- または - 
 <paramref name="logName" /> はユーザー ログの作成に有効ではありません。 イベント ログ名 AppEvent、SysEvent、および SecEvent は、システムで使用するために予約されています。  
  
- または - 
ログ名が既存のイベント ソース名に一致します。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。  
  
- または - 
<paramref name="logName" /> の最初の 8 文字が指定したコンピューター上の既存のイベント ログ名の最初の 8 文字に一致します。  
  
- または - 
指定したコンピューター上に既にソースが存在するため、ソースを登録できません。  
  
- または - 
ソース名が既存のイベント ソース名に一致します。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ログ リソースを削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 次のような値となる場合があります。アプリケーション、セキュリティ、システム、およびコンピューター上の任意のカスタム イベント ログ。</param>
        <summary>ローカル コンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 削除するログがローカルコンピューター上にある場合は、この方法を使用します。 適切なレジストリアクセス許可を持っていれば、コンピューター上のすべてのログを削除できます。  
  
 `logName` によって指定されたログをローカルコンピューターから削除 <xref:System.Diagnostics.EventLog.Delete%2A> ます。 ログに登録されているソースのみを削除する場合は、<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>を呼び出します。 ログエントリのみを削除する場合は、<xref:System.Diagnostics.EventLog.Clear%2A>を呼び出します。 <xref:System.Diagnostics.EventLog.Delete%2A> と <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッドであるため、クラス自体で呼び出すことができます。 どちらのメソッドを呼び出す場合でも、<xref:System.Diagnostics.EventLog> の新しいインスタンスを作成する必要はありません。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> メソッドは、ログの内容を保持しているファイルを最初に削除します。 次に、レジストリにアクセスし、そのログに登録されているすべてのイベントソースを削除します。 後でログを再作成する場合は、再利用する場合は、イベントソースを再度登録する必要があります。 イベントソースを登録せず、他のユーザーがログ名を指定せずにイベントソースに書き込む場合は、アプリケーションイベントログにイベントソースが作成されます。 このため、以前に削除して再作成したログにエントリを書き込むことができたアプリケーションは、イベントソースが含まれるようになったため、代わりにアプリケーションログに書き込みます。  
  
> [!NOTE]
>  イベントログを再作成することは、困難なプロセスになることがあります。 システムで作成されたイベントログ (アプリケーションログなど) の削除は避けてください。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> の呼び出しを使用してログを削除すると、そのログに登録されているソースが自動的に削除されます。 これにより、そのログを使用する他のアプリケーションが動作しないようにできます。  
  
   
  
## Examples  
 次の例では、ローカルコンピューターからログを削除します。 この例では、ソースからログを確認します。  
  
> [!NOTE]
>  複数のソースがイベントログに書き込む可能性があります。 カスタムログを削除する前に、そのログに書き込むソースが他にないことを確認してください。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> が空の文字列 ("") または <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューター上のイベント ログのレジストリ キーを開けませんでした。  
  
- または -
  
 ローカル コンピューター上にログが存在しません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログが正常に消去されませんでした。  
  
 - または -  
  
 ログを開くことができません。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 次のような値となる場合があります。アプリケーション、セキュリティ、システム、および指定したコンピューター上の任意のカスタム イベント ログ。</param>
        <param name="machineName">ログを削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この方法は、削除するログがリモートコンピューター上にある場合に使用します。 適切なレジストリアクセス許可を持っていれば、コンピューター上のすべてのログを削除できます。  
  
 `logName` によって指定されたログを `machineName`によって指定されたコンピューターから削除 <xref:System.Diagnostics.EventLog.Delete%2A> ます。 ログに登録されているソースのみを削除する場合は、<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>を呼び出します。 ログエントリのみを削除する場合は、<xref:System.Diagnostics.EventLog.Clear%2A>を呼び出します。 <xref:System.Diagnostics.EventLog.Delete%2A> と <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッドであるため、クラス自体で呼び出すことができます。 どちらのメソッドを呼び出す場合でも、<xref:System.Diagnostics.EventLog> のインスタンスを作成する必要はありません。  
  
 このメソッドは、ログの内容を保持しているファイルを最初に削除します。 次に、レジストリにアクセスし、そのログに登録されているすべてのイベントソースを削除します。 後でログを再作成する場合は、再利用する場合は、イベントソースを再度登録する必要があります。 イベントソースを登録せず、他のユーザーがログ名を指定せずにイベントソースに書き込む場合は、アプリケーションイベントログにイベントソースが作成されます。 このため、以前に削除して再作成したログにエントリを書き込むことができたアプリケーションは、イベントソースが含まれるようになったため、代わりにアプリケーションログに書き込みます。  
  
> [!NOTE]
>  イベントログを再作成することは、困難なプロセスになることがあります。 システムで作成されたイベントログ (アプリケーションログなど) の削除は避けてください。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> の呼び出しを使用してログを削除すると、そのログに登録されているソースが自動的に削除されます。 これにより、そのログを使用する他のアプリケーションが動作しないようにできます。  
  
   
  
## Examples  
 次の例では、指定したコンピューターからログを削除します。 この例では、ソースからログを確認します。  
  
> [!NOTE]
>  複数のソースがイベントログに書き込む可能性があります。 カスタムログを削除する前に、そのログに書き込むソースが他にないことを確認してください。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> が空の文字列 ("") または <see langword="null" />  
  
- または - 
 <paramref name="machineName" /> が有効なコンピューター名ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。  
  
- または -
  
 指定したコンピューター上にログが存在しません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログが正常に消去されませんでした。  
  
 - または -  
  
 ログを開くことができません。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログからアプリケーションのイベント ソース登録を削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <summary>ローカル コンピューターのイベント ログからイベント ソースの登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ローカルコンピューターから <xref:System.Diagnostics.EventLog.Source%2A> の登録を削除します。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は、ローカルコンピューター上のレジストリにアクセスし、アプリケーションの登録を有効なイベントのソースとして削除します。  
  
 このログにエントリを書き込む必要がなくなった場合は、コンポーネントを有効なイベントソースとして削除できます。 たとえば、コンポーネントをあるログから別のログに変更する必要がある場合に、この操作を行うことができます。 ソースは一度に1つのログにしか登録できないため、ログを変更するには、現在の登録を削除する必要があります。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は、ログに登録されているソースのみを削除します。 ログ自体を削除する場合は、<xref:System.Diagnostics.EventLog.Delete%2A>を呼び出します。 ログエントリのみを削除する場合は、<xref:System.Diagnostics.EventLog.Clear%2A>を呼び出します。 <xref:System.Diagnostics.EventLog.Delete%2A> と <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッドであるため、クラス自体で呼び出すことができます。 どちらのメソッドを呼び出す場合でも、<xref:System.Diagnostics.EventLog> のインスタンスを作成する必要はありません。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> の呼び出しを使用してログを削除すると、そのログに登録されているソースが自動的に削除されます。 これにより、そのログを使用する他のアプリケーションが動作しないようにできます。  
  
> [!NOTE]
>  ソースが既にログにマップされていて、新しいログに再マップする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソースをローカルコンピューターから削除します。 この例では、ソースからログを確認してから、ログを削除します。  
  
> [!NOTE]
>  複数のソースがイベントログに書き込む可能性があります。 カスタムログを削除する前に、そのログに書き込むソースが他にないことを確認してください。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ローカル コンピューターのレジストリに <paramref name="source" /> パラメーターがありません。  
  
- または - 
イベント ログのレジストリ キーに対する書き込みアクセス許可がありません。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <param name="machineName">登録を削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからアプリケーションのイベント ソース登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、リモートコンピューターから <xref:System.Diagnostics.EventLog.Source%2A> の登録を削除します。 `machineName` によって指定されたコンピューターのレジストリにアクセスし、アプリケーションの登録を有効なイベントのソースとして削除する <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ます。  
  
 このログにエントリを書き込む必要がなくなった場合は、コンポーネントを有効なイベントソースとして削除できます。 たとえば、コンポーネントをあるログから別のログに変更する必要がある場合に、この操作を行うことができます。 ソースは一度に1つのログにしか登録できないため、ログを変更するには、現在の登録を削除する必要があります。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は、ログに登録されているソースのみを削除します。 ログ自体を削除する場合は、<xref:System.Diagnostics.EventLog.Delete%2A>を呼び出します。 ログエントリのみを削除する場合は、<xref:System.Diagnostics.EventLog.Clear%2A>を呼び出します。 <xref:System.Diagnostics.EventLog.Delete%2A> と <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッドであるため、クラス自体で呼び出すことができます。 どちらのメソッドを呼び出す場合でも、<xref:System.Diagnostics.EventLog> のインスタンスを作成する必要はありません。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> の呼び出しを使用してログを削除すると、そのログに登録されているソースが自動的に削除されます。 これにより、そのログを使用する他のアプリケーションが動作しないようにできます。  
  
> [!NOTE]
>  ソースが既にログにマップされていて、新しいログに再マップする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、指定したコンピューターからソースを削除します。 この例では、ソースからログを確認してから、ログを削除します。  
  
> [!NOTE]
>  複数のソースがイベントログに書き込む可能性があります。 カスタムログを削除する前に、そのログに書き込むソースが他にないことを確認してください。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターが正しくありません。  
  
- または - 
指定したコンピューターのレジストリに <paramref name="source" /> パラメーターがありません。  
  
- または - 
イベント ログのレジストリ キーに対する書き込みアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException">レジストリで <paramref name="source" /> の親レジストリ キーに同じ名前のサブキーが含まれないため、<paramref name="source" /> は削除できません。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> が使用しているアンマネージド リソースを解放します。オプションとして、マネージド リソースを解放することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックな `Dispose()` メソッドと <xref:System.Object.Finalize%2A> メソッドによって呼び出されます。 `Dispose()` は、`disposing` パラメーターを `true`に設定して、protected `Dispose(Boolean)` メソッドを呼び出します。 <xref:System.Object.Finalize%2A> は `disposing` を `false`に設定して `Dispose` を呼び出します。  
  
 `disposing` パラメーターが true の場合、このメソッドは、この <xref:System.Diagnostics.EventLog> が参照するすべてのマネージオブジェクトによって保持されているすべてのリソースを解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 をオーバーライドする場合は <see langword="Dispose(Boolean)" /> 以前に <see langword="Dispose" />を呼び出したときに破棄されたオブジェクトを参照しないように注意してください。 <see langword="Dispose(Boolean)" />を実装する方法の詳細については、「 [Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)」を参照してください。  
  
<see langword="Dispose" /> と <see cref="M:System.Object.Finalize" />の詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」を参照してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Diagnostics.EventLog" /> が <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベント通知を受信するかどうかを示す値を取得または設定します。</summary>
        <value>エントリがログに書き込まれたときに <see cref="T:System.Diagnostics.EventLog" /> が通知を受信する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> プロパティは、エントリがログに書き込まれたときに <xref:System.Diagnostics.EventLog> がイベントを発生させるかどうかを決定します。 プロパティが `true`場合、<xref:System.Diagnostics.EventLog.EntryWritten> イベントを受け取るコンポーネントは、<xref:System.Diagnostics.EventLog.Log%2A> プロパティで指定されたログにエントリが書き込まれるたびに通知を受け取ります。 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> が `false`場合、イベントは発生しません。  
  
> [!NOTE]
>  イベント通知を受信できるのは、ローカルコンピューターにエントリが書き込まれた場合のみです。 リモートコンピューターに書き込まれたエントリの通知を受け取ることはできません。  
  
   
  
## Examples  
 次の例では、<xref:System.Diagnostics.EventLog.EntryWritten> イベントを処理します。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベント ログは、リモート コンピューター上にあります。</exception>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントによって使用されるコンポーネントの初期化を終了します。 <xref:System.Diagnostics.EventLog.BeginInit%2A> メソッドは、初期化を開始します。 <xref:System.Diagnostics.EventLog.BeginInit%2A> メソッドと <xref:System.Diagnostics.EventLog.EndInit%2A> メソッドを使用すると、完全に初期化される前にコントロールが使用されなくなります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの内容を取得します。</summary>
        <value>イベント ログのエントリを保持している <see cref="T:System.Diagnostics.EventLogEntryCollection" />。 1 つのエントリが <see cref="T:System.Diagnostics.EventLogEntry" /> クラスの 1 つのインスタンスに関連付けられます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントログから読み取りを行う場合は、<xref:System.Diagnostics.EventLog.Entries%2A> メンバーを使用します。  
  
 プロパティは読み取り専用であるため、<xref:System.Diagnostics.EventLog.Entries%2A>を使用してエントリを変更したりログに書き込んだりすることはできません。 代わりに、<xref:System.Diagnostics.EventLog.Source%2A> を指定し、<xref:System.Diagnostics.EventLog.WriteEntry%2A> を呼び出して新しいログエントリを書き込みます。 <xref:System.Diagnostics.EventLog.Entries%2A> を使用して、イベントログ内のエントリの数をカウントし、コレクション内の各 <xref:System.Diagnostics.EventLogEntry> を表示できます。 <xref:System.Diagnostics.EventLogEntry.Message%2A>、<xref:System.Diagnostics.EventLogEntry.Category%2A>、<xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>、<xref:System.Diagnostics.EventLogEntry.EntryType%2A>など、特定のエントリに関する情報を取得するには、インデックス付き <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> メンバーを使用します。  
  
 ログからの読み取りのみを行う場合は、<xref:System.Diagnostics.EventLog.Source%2A> を指定する必要はありません。 <xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.Log%2A> 名と <xref:System.Diagnostics.EventLog.MachineName%2A> (サーバーコンピューター名) のプロパティのみを指定できます。 どちらの場合も、<xref:System.Diagnostics.EventLog.Entries%2A> メンバーには、イベントログのエントリの一覧が自動的に設定されます。 この一覧の項目に適切なインデックスを選択すると、個々のエントリを読み取ることができます。  
  
 ログエントリの読み取りと書き込みの重要な違いは、read メソッドを明示的に呼び出す必要がないことです。 <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> を指定すると、<xref:System.Diagnostics.EventLog.Entries%2A> プロパティが自動的に設定されます。 <xref:System.Diagnostics.EventLog.Log%2A> または <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティの値を変更すると、次回の読み取り時に <xref:System.Diagnostics.EventLog.Entries%2A> プロパティが再作成されます。  
  
> [!NOTE]
>  ログに接続している場合は、<xref:System.Diagnostics.EventLog.MachineName%2A> を指定する必要はありません。 <xref:System.Diagnostics.EventLog.MachineName%2A>を指定しない場合は、ローカルコンピューター "." が使用されます。  
  
   
  
## Examples  
 次の例では、ローカルコンピューター上のイベントログ "MyNewLog" のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル コンピューター上のイベント ログにエントリが書き込まれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント通知を取得するには、<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> を `true`に設定する必要があります。 イベント通知を受信できるのは、ローカルコンピューターにエントリが書き込まれたときだけです。 リモートコンピューターに書き込まれたエントリの通知を受け取ることはできません。  
  
 <xref:System.Diagnostics.EventLog.EntryWritten> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 イベントハンドラーは、デリゲートを削除するまで、イベントが発生するたびに呼び出されます。 デリゲートを使用したイベントの処理の詳細については、「[イベントの処理と発生](~/docs/standard/events/index.md)」を参照してください。  
  
 システムは、前回の書き込みイベントが少なくとも6秒前に発生した場合にのみ <xref:System.Diagnostics.EventLog.WriteEntry%2A> に応答します。 これは、複数のイベントログの変更が発生した場合でも、6秒間隔で1つの <xref:System.Diagnostics.EventLog.EntryWritten> イベント通知のみを受け取ることを意味します。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>の呼び出しの間に、十分に長いスリープ間隔 (約10秒) を挿入すると、イベントを見逃しなくなる可能性が低くなります。 ただし、書き込みイベントがより頻繁に発生する場合は、次の期間までイベント通知を受信しない可能性があります。 通常、見つからなかったイベント通知は失われませんが、遅延します。  
  
   
  
## Examples  
 次の例では、エントリ書き込みイベントを処理します。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したログが存在するかどうかを確認します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログの名前。 次のような値となる場合があります。アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ (Active Directory に関連するログなど)、またはコンピューター上の任意のカスタム ログ。</param>
        <summary>ローカル コンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>ローカル コンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ローカルコンピューター上にログが存在するかどうかを確認します。 ソースがローカルコンピューターに存在するかどうかを確認するには、<xref:System.Diagnostics.EventLog.SourceExists%2A>を使用します。  
  
 このメソッドはレジストリにアクセスするため、ローカルコンピューターに対する適切なレジストリアクセス許可を持っている必要があります。それ以外の場合、クエリは `false`を返します。  
  
 新しいログには同じコンピューター上の既存のログ名を指定できないため、新しいログを作成してから、指定した `logName` がローカルコンピューターに既に存在するかどうかを確認するには、この方法を使用します。 `logName` パラメーターでは、大文字と小文字は区別されません。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> は `static` メソッドであるため、クラス自体で呼び出すことができます。 <xref:System.Diagnostics.EventLog.Exists%2A>を呼び出すために <xref:System.Diagnostics.EventLog> のインスタンスを作成する必要はありません。  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName が <see langword="null" /> です。または値が空です。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログ。 次のような値となる場合があります。アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ (Active Directory に関連するログなど)、またはコンピューター上の任意のカスタム ログ。</param>
        <param name="machineName">ログ検索の対象となるコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>指定したコンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この方法は、ログがリモートコンピューターに存在するかどうかを判断するために使用します。 ソースがリモートコンピューターに存在するかどうかを確認するには、<xref:System.Diagnostics.EventLog.SourceExists%2A>を使用します。  
  
 このメソッドはレジストリにアクセスするため、指定したコンピューターに対する適切なレジストリアクセス許可を持っている必要があります。それ以外の場合、クエリは `false`を返します。  
  
 新しいログには同じコンピューター上の既存のログ名を指定できないので、この方法を使用して新しいログを作成し、指定した `logName` のものが、`machineName` パラメーターで指定されたサーバーに既に存在するかどうかを確認します。 `logName` パラメーターと `machineName` パラメーターでは、大文字と小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> は `static` メソッドであるため、クラス自体で呼び出すことができます。 <xref:System.Diagnostics.EventLog.Exists%2A>を呼び出すために <xref:System.Diagnostics.EventLog> の新しいインスタンスを作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの書式が無効です。 検索しているコンピューターに対して正しい構文を使用したかどうかを確認してください。  
  
- または - 
<paramref name="logName" /> が <see langword="null" /> です。または値が空です。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログの配列を作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>ローカル コンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> オブジェクトの配列は、<xref:System.Diagnostics.EventLog.GetEventLogs%2A> の呼び出しが行われたときのローカルコンピューター上のすべてのイベントログのスナップショットです。 これは動的なコレクションではないため、リアルタイムでのログの削除や作成は反映されません。 配列内のログは、読み取りまたは書き込みの前に存在していることを確認する必要があります。 通常、配列には、アプリケーション、システム、およびセキュリティの3つ以上のログが含まれます。 ローカルコンピューターでカスタムログを作成した場合は、配列にも表示されます。  
  
 イベントログの一覧を取得するには、適切なレジストリ権限が必要です。 これらのアクセス許可は、<xref:System.Diagnostics.EventLog.Exists%2A> と <xref:System.Diagnostics.EventLog.SourceExists%2A>を呼び出すために必要な権限と同じです。  
  
   
  
## Examples  
 次の例では、ローカルコンピューターで定義されているイベントログを列挙し、各イベントログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">レジストリの読み取りアクセス許可がありません。  
  
 - または -  
  
 コンピューター上にイベント ログ サービスがありません。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">イベント ログの検索対象となるコンピューター。</param>
        <summary>指定したコンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>指定したコンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> オブジェクトの配列は、<xref:System.Diagnostics.EventLog.GetEventLogs%2A> の呼び出しが行われるときに、`machineName` パラメーターで指定されたコンピューター上のすべてのイベントログのスナップショットです。 これは動的なコレクションではないため、リアルタイムでのログの削除や作成は反映されません。 配列内のログは、読み取りまたは書き込みの前に存在していることを確認する必要があります。 通常、配列には、アプリケーション、システム、およびセキュリティの3つ以上のログが含まれます。 指定したコンピューターでカスタムログを作成した場合は、配列にも表示されます。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> は `static` メソッドであるため、<xref:System.Diagnostics.EventLog> クラス自体で呼び出すことができます。 <xref:System.Diagnostics.EventLog> オブジェクトのインスタンスを作成して、メソッドを呼び出す必要はありません。  
  
 イベントログの一覧を取得するには、適切なレジストリ権限が必要です。 これらのアクセス許可は、<xref:System.Diagnostics.EventLog.Exists%2A> と <xref:System.Diagnostics.EventLog.SourceExists%2A>を呼び出すために必要な権限と同じです。  
  
   
  
## Examples  
 次の例では、コンピューター "myServer" 上のログの一覧を取得します。 次に、各ログの名前が出力されます。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターに無効なコンピューター名が指定されています。</exception>
        <exception cref="T:System.InvalidOperationException">レジストリの読み取りアクセス許可がありません。  
  
 - または -  
  
 コンピューター上にイベント ログ サービスがありません。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取るログまたは書き込むログの名前を取得または設定します。</summary>
        <value>ログの名前。 ログ名には、アプリケーション ログ名、システム ログ名、セキュリティ ログ名、またはカスタム ログ名を指定できます。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバーには、アプリケーション、システム、およびセキュリティの3つのログファイルが既定で存在します。 アプリケーションとサービスは、アプリケーションログファイルを使用します。 デバイスドライバーは、システムログファイルを使用します。 監査が有効になっている場合、システムはセキュリティログに成功と失敗の監査イベントを生成します。 Windows サーバー上の Active Directory など、他のアプリケーションがインストールされている場合は、他の既定のログファイルが存在する可能性があります。 また、ローカルコンピューターまたはリモートコンピューター上にカスタムログファイルを作成することもできます。 カスタムログを使用すると、コンポーネントが既定のアプリケーションログにイベントを書き込む場合に許可されるよりも詳細な方法でエントリを整理できます。  
  
> [!NOTE]
>  ログ名は、8文字までに制限されています。 システムによっては、MyLogSample1 と MyLogSample2 は同じログになります。  
  
 イベントログに書き込む場合は、<xref:System.Diagnostics.EventLog.Log%2A> プロパティを指定するだけでは不十分です。 特定のログに接続するには、<xref:System.Diagnostics.EventLog.Source%2A> プロパティをイベントログリソースに関連付ける必要があります。 ログからの読み取りのみを行う場合は、<xref:System.Diagnostics.EventLog.Source%2A> を指定する必要はありませんが、イベントソースは、サーバーのレジストリのイベントログリソースに関連付けられている必要があります。 <xref:System.Diagnostics.EventLog.Log%2A> 名と <xref:System.Diagnostics.EventLog.MachineName%2A> (サーバーコンピューター名) のみを指定して、その名前から読み取ることができます。  
  
> [!NOTE]
>  ログに接続している場合は、<xref:System.Diagnostics.EventLog.MachineName%2A> を指定する必要はありません。 <xref:System.Diagnostics.EventLog.MachineName%2A>を指定しなかった場合は、ローカルコンピューター (".") と見なされます。  
  
 <xref:System.Diagnostics.EventLog.Source%2A> プロパティが指定されていない場合、<xref:System.Diagnostics.EventLog.Log%2A> を呼び出すと、<xref:System.Diagnostics.EventLog.Log%2A> が明示的に設定されていない場合は空の文字列が返されます (<xref:System.Diagnostics.EventLog.Log%2A> プロパティを設定するか、コンストラクターを使用します)。 <xref:System.Diagnostics.EventLog.Source%2A> が指定されている場合、<xref:System.Diagnostics.EventLog.Log%2A> は、そのソースが登録されているログの名前を返します。  
  
 ソースは、一度に1つのログにしか登録できません。 <xref:System.Diagnostics.EventLog>のインスタンスに対して <xref:System.Diagnostics.EventLog.Source%2A> プロパティが設定されている場合は、<xref:System.Diagnostics.EventLog.Source%2A> の値を変更したり、<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 最初にを呼び出したりせずに、その <xref:System.Diagnostics.EventLog> の <xref:System.Diagnostics.EventLog.Log%2A> プロパティを変更することはできません。 <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定した後に <xref:System.Diagnostics.EventLog.Log%2A> プロパティを変更すると、ログエントリの書き込みで例外がスローされます。  
  
 オペレーティング システムではイベント ログはファイルとして保存されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を使用して新しいイベントログを作成する場合、関連付けられているファイルは、指定したコンピューターの%SystemRoot%\System32\Config ディレクトリに格納されます。 ファイル名を設定するには、<xref:System.Diagnostics.EventLog.Log%2A> プロパティの最初の8文字に ".evt" というファイル名拡張子を追加します。  
  
 <xref:System.Diagnostics.EventLog.Log%2A> プロパティだけを使用して新しいログを作成することはできません (ログのソースを指定する必要はありません)。 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>を呼び出して、新しいログ名をパラメーターとして渡し、<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>を呼び出すことができます。 ただし、通常は、アプリケーション固有の新しいログを作成 (またはエントリを書き込む) するか、既存のログを読み取るかを指定します。  
  
 <xref:System.Diagnostics.EventLog.Log%2A> 値が変更されると、イベントログが閉じられ、すべてのイベントハンドルが解放されます。  
  
> [!CAUTION]
>  <xref:System.Diagnostics.EventLog.Log%2A> プロパティを存在しないログの名前に設定すると、システムによって <xref:System.Diagnostics.EventLog> がアプリケーションログにアタッチされますが、指定したログ以外のログが使用されていることを示す警告は表示されません。  
  
   
  
## Examples  
 次の例では、ローカルコンピューター上のイベントログ "NewEventLog" のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの表示名を取得します。</summary>
        <value>システムのイベント ビューアーのイベント ログを表す名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Windows Vista 以降では、セキュリティログにアクセスするためのアクセス許可がユーザーに与えられていません。 Windows Vista 以降をユーザーとして実行している場合は、セキュリティログ内のイベントの表示名にアクセスしようとすると <xref:System.Security.SecurityException> が表示されます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティログにアクセスするコードを実行するには、まず、特権を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
   
  
## Examples  
 次の例では、ローカルコンピューターに定義されているイベントログを列挙し、各イベントログの <xref:System.Diagnostics.EventLog.LogDisplayName%2A> を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このコンピューターのレジストリに、指定した <see cref="P:System.Diagnostics.EventLog.Log" /> が存在しません。</exception>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したソースが登録されているログの名前を取得します。</summary>
        <returns>レジストリ内で指定したソースに関連付けられているログの名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントソースは、イベントをログに記録するかどうかを示します。 多くの場合、アプリケーションの名前、またはアプリケーションのサブコンポーネントの名前 (アプリケーションのサイズが大きい場合) です。 アプリケーションとサービスは、アプリケーションログまたはカスタムログに書き込む必要があります。 デバイスドライバーは、システムログに書き込む必要があります。  
  
 一度に1つのログのみに書き込むことができる新しいソースを作成すると、システムはアプリケーションを有効なエントリのソースとしてイベントログに登録します。 <xref:System.Diagnostics.EventLog.Source%2A> プロパティには任意の文字列を指定できますが、その名前はコンピューター上の他のソースでは使用できません。 重複する <xref:System.Diagnostics.EventLog.Source%2A> 値を作成しようとすると、例外がスローされます。 ただし、1つのイベントログにさまざまなソースを書き込むことができます。  
  
   
  
## Examples  
 次の例では、ソースをローカルコンピューターから削除します。 この例では、ソースからログを確認してから、ログを削除します。  
  
> [!NOTE]
>  複数のソースがイベントログに書き込む可能性があります。 カスタムログを削除する前に、そのログに書き込むソースが他にないことを確認してください。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを読み取るコンピューターまたは書き込むコンピューターの名前を取得または設定します。</summary>
        <value>イベント ログが存在するサーバーの名前。 既定値はローカル コンピューター (".") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントログに書き込む場合は、<xref:System.Diagnostics.EventLog.Source%2A> をイベントログオブジェクトに関連付けて、特定のログに接続する必要があります。 ログからの読み取りのみを行う場合は、<xref:System.Diagnostics.EventLog.Source%2A> プロパティを指定する必要はありません。 <xref:System.Diagnostics.EventLog.Log%2A> 名と <xref:System.Diagnostics.EventLog.MachineName%2A> (サーバーコンピューター名) のみを指定できます。  
  
> [!NOTE]
>  ログに接続する場合は、<xref:System.Diagnostics.EventLog.MachineName%2A> を指定する必要はありません。 <xref:System.Diagnostics.EventLog.MachineName%2A>を指定しなかった場合は、ローカルコンピューター (".") と見なされます。  
  
 ソースは、一度に1つのログにしか登録できません。 <xref:System.Diagnostics.EventLog>のインスタンスに対して <xref:System.Diagnostics.EventLog.Source%2A> プロパティが設定されている場合は、<xref:System.Diagnostics.EventLog.Source%2A> の値を変更したり、<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 最初にを呼び出したりせずに、その <xref:System.Diagnostics.EventLog> の <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを変更することはできません。 <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを変更すると、<xref:System.Diagnostics.EventLog> はすべてのハンドルを閉じ、新しいコンピューター上のログとソースに再度アタッチします。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> 値を空の文字列にすることはできません。 明示的に設定されていない場合は、既定でローカルコンピューター (".") に設定されます。  
  
   
  
## Examples  
 次の例では、指定されたコンピューター上のイベントログ "NewEventLog" のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">コンピューター名が無効です。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの最大サイズを KB 単位で取得または設定します。</summary>
        <value>イベント ログの最大サイズ。単位は KB です。 既定値は、512 KB の最大ファイル サイズを示す 512 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> プロパティは、イベントログファイルのサイズの制限を表します。 イベントログがサイズの上限に達すると、構成された <xref:System.Diagnostics.EventLog.OverflowAction%2A> の値によって、新しいエントリが破棄されるかどうか、または新しいエントリが古いエントリを上書きするかどうかが決まります。  
  
> [!NOTE]
>  このプロパティは、このインスタンスによって表されるイベントログの構成設定を表します。 イベントログが最大サイズに達すると、このプロパティは、イベントログに登録されているすべてのイベントソースによって書き込まれた新しいエントリをオペレーティングシステムがどのように処理するかを指定します。  
  
   
  
## Examples  
 次の例では、ローカルコンピューターで定義されているイベントログを列挙し、各イベントログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した値が 64 未満か、4194240 を超える値です。または、64 の倍数ではありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
- または - 
ターゲット コンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログ内のエントリを保持する日数を取得します。</summary>
        <value>イベント ログ内のエントリが保持される日数。 既定値は 7 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントログの現在の設定を確認するには、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> プロパティを使用します。 イベントログの各エントリを保持する必要がある最小日数を変更するには、<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> を使用します。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 値は、イベントログの構成されたオーバーフロー動作によって異なります。 イベントログの <xref:System.Diagnostics.OverflowAction> プロパティが <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>に設定されている場合、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 値は0になります。 イベントログの <xref:System.Diagnostics.OverflowAction> プロパティが <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>に設定されている場合、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> の値は-1 になります。 イベントログの <xref:System.Diagnostics.OverflowAction> プロパティが <xref:System.Diagnostics.OverflowAction.OverwriteOlder>に設定されている場合、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> の値は0より大きくなり、イベントログがいっぱいになったときにイベントログエントリを保持する日数を表します。  
  
 オーバーフロー動作は、イベントログのサイズが制限に達した場合にのみ発生します。 <xref:System.Diagnostics.EventLog> の <xref:System.Diagnostics.EventLog.OverflowAction%2A> が <xref:System.Diagnostics.OverflowAction.OverwriteOlder>に設定されていて、イベントログが最大サイズに達した場合、新しいエントリは、age が <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 期間を超えているエントリを置き換えることができる場合にのみ書き込まれます。 イベントログを定期的にアーカイブする場合は、最小期間にわたってイベントエントリを保持することが適切です。 そうしないと、イベントログが制限に達したときに新しいエントリが失われる危険性があります。 新しいイベント情報が失われないようにするには、特定のイベントログのアーカイブスケジュールに基づいて、イベントの最小保持日数を設定します。  
  
   
  
## Examples  
 次の例では、ローカルコンピューターで定義されているイベントログを列挙し、各イベントログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">イベント ログに新しいエントリを書き込むためのオーバーフロー動作。</param>
        <param name="retentionDays">イベント ログの各エントリが保持される最小日数。 このパラメーターは、<paramref name="action" /> が <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> に設定されている場合にのみ使用されます。</param>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを書き込むように構成された動作を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントログのオーバーフロー動作は、最大ファイルサイズに達したログに新しいエントリが書き込まれたときの動作を指定します。  
  
> [!NOTE]
>  オーバーフローの動作は、イベントログが最大ファイルサイズに達した場合にのみ有効になります。 オーバーフロー動作は、追加のイベントログエントリに対応できるログへの新しいエントリの書き込みには影響しません。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> メソッドは、イベントログのオーバーフロー動作を構成します。 <xref:System.Diagnostics.EventLog> インスタンス。 <xref:System.Diagnostics.EventLog.Log%2A> プロパティによって指定されたイベントログに対してこのメソッドを呼び出した後、<xref:System.Diagnostics.EventLog.OverflowAction%2A> と <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> のプロパティ値に、新しく構成されたオーバーフロー動作が反映されます。  
  
> [!NOTE]
>  このプロパティは、このインスタンスによって表されるイベントログの構成設定を表します。 イベントログが最大サイズに達すると、このプロパティは、イベントログに登録されているすべてのイベントソースによって書き込まれた新しいエントリをオペレーティングシステムがどのように処理するかを指定します。  
  
 `action` パラメーターを <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> に設定すると、<xref:System.Diagnostics.EventLog> が最大サイズに達したときに、新しいエントリによって最も古いエントリが上書きされることを示します。 `action` パラメーターが <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>に設定されている場合、`retentionDays` パラメーターの値は無視されます。  
  
 `action` パラメーターを <xref:System.Diagnostics.OverflowAction.OverwriteOlder> に設定して、<xref:System.Diagnostics.EventLog> が最大サイズに達したときに、新しいエントリが古いエントリを上書きすることを示します。 `retentionDays` パラメーターを使用して、ログにイベントを保持する日数を指定します。 保有期間の範囲内に書き込まれたイベントは、新しいエントリによって上書きされません。  
  
 最大ログサイズに達したときに新しいイベントを破棄するには、`action` パラメーターを <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> に設定します。 `action` パラメーターが <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>に設定されている場合、`retentionDays` パラメーターの値は無視されます。  
  
> [!CAUTION]
>  オーバーフローポリシーを <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> に設定すると、イベントログがいっぱいになったときに新しいエントリが破棄されることを指定します。 この設定を使用する場合は、最大サイズの制限に達しないように、定期的にイベントログをアーカイブしてクリアするようにしてください。  
  
   
  
## Examples  
 次の例では、指定されたイベントログに対して構成されたオーバーフローポリシーを表示し、ユーザーがイベントログの新しいオーバーフローポリシー設定を選択できるようにします。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> は有効な <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retentionDays" /> が 1 未満であるか、365 を超えています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
- または - 
ターゲット コンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを格納するように構成された動作を取得します。</summary>
        <value>イベント ログが最大サイズに達した場合に、新しいエントリを格納するために構成された動作を指定する <see cref="T:System.Diagnostics.OverflowAction" /> 値。 既定値は、<see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントログは、新しいイベントが書き込まれるときにサイズが大きくなります。 各イベントログには、最大サイズの制限が構成されています。<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> プロパティは、イベントログファイルのサイズとして許容される最大キロバイト数を定義します。  
  
 <xref:System.Diagnostics.EventLog.OverflowAction%2A> プロパティ値を使用して、イベントログの最大サイズで構成されたオーバーフローの動作を確認します。 イベントログのオーバーフロー動作を変更するには、<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> メソッドを使用します。  
  
> [!NOTE]
>  オーバーフローの動作は、イベントログが最大ファイルサイズに達した場合にのみ有効になります。 オーバーフロー動作は、追加のイベントログエントリに対応できるログへの新しいエントリの書き込みには影響しません。  
  
   
  
## Examples  
 次の例では、ローカルコンピューターで定義されているイベントログを列挙し、各イベントログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">ローカライズされたリソース ファイルの完全指定パス。</param>
        <param name="resourceId">リソース ファイル内のローカライズされた文字列のインデックスを示すリソース識別子。</param>
        <summary>イベント ログのローカライズされた名前を指定します。これは、サーバーのイベント ビューアーに表示されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタムイベントログのイベントビューアーにローカライズされた名前を登録して表示するには、<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> を使用します。  
  
 指定されたリソース識別子は、リソースファイルで定義されているローカライズされた文字列に対応している必要があります。 イベントビューアーに、ローカライズされた文字列と現在のカルチャ設定を使用して、カスタムイベントログ名が表示されます。 たとえば、リソースファイルのカルチャごとにローカライズされた複数のイベントログ名を定義できます。 イベントビューアーには、現在のユーザーのカルチャ設定に対応するローカライズされた文字列が表示されます。  
  
 イベントビューアーがリソースファイルからローカライズされた文字列を読み込むことができない場合、またはイベントログに表示名が登録されていない場合は、イベントビューアーに <xref:System.Diagnostics.EventLog.Log%2A>で定義されているイベントログの名前が表示されます。  
  
> [!NOTE]
>  定義済みのイベントログの表示名を登録する必要はありません。 オペレーティングシステムによって、アプリケーション、システム、およびセキュリティイベントログのローカライズされた表示名が登録されます。  
  
   
  
## Examples  
 次の例では、`SampleApplicationSource` という名前のイベントソースがローカルコンピューターに登録されているかどうかを確認します。 イベントソースが存在しない場合、この例では、ソースのメッセージリソースファイルを設定し、新しいイベントソースを作成します。 最後に、この例では、`DisplayNameMsgId` のリソース識別子の値と `messageFile`のリソースファイルパスを使用して、イベントログのローカライズされた表示名を設定します。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 この例では、リソースライブラリ EventLogMsgs に組み込まれている次のメッセージテキストファイルを使用します。 メッセージテキストファイルは、メッセージリソースファイルの作成元のソースです。 メッセージテキストファイルは、カテゴリ、イベントメッセージ、およびパラメーター挿入文字列のリソース識別子とテキストを定義します。 具体的には、リソース識別子5001は、イベントログのローカライズされた名前に対して定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
- または - 
ターゲット コンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" /> が <see langword="null" />です。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログを書き込むときに登録して使用するソース名を取得または設定します。</summary>
        <value>エントリのソースとしてイベント ログに登録される名前。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントソースは、イベントをログに記録するかどうかを示します。 多くの場合、アプリケーションの名前、またはアプリケーションのサブコンポーネントの名前 (アプリケーションのサイズが大きい場合) です。 アプリケーションとサービスは、アプリケーションログまたはカスタムログに書き込む必要があります。 デバイスドライバーは、システムログに書き込む必要があります。  
  
 イベントログに書き込む場合にのみ、イベントソースを指定する必要があります。 イベントログにエントリを書き込む前に、イベントソースを有効なイベントのソースとしてイベントログに登録する必要があります。 ログエントリを作成すると、システムは <xref:System.Diagnostics.EventLog.Source%2A> プロパティを使用して、エントリを配置する適切なログを検索します。 イベントログを読み取る場合は、<xref:System.Diagnostics.EventLog.Source%2A>、<xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A>のいずれかを指定できます。  
  
> [!NOTE]
>  ローカルコンピューター上のログに接続している場合は、<xref:System.Diagnostics.EventLog.MachineName%2A> を指定する必要はありません。 <xref:System.Diagnostics.EventLog.MachineName%2A>を指定しなかった場合は、ローカルコンピューター (".") と見なされます。  
  
 イベントログにイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> を使用します。 イベントを書き込むには、イベントソースを指定する必要があります。ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 既存のイベントログまたは新しいイベントログのイベントソースを作成できます。 新しいイベントログ用に新しいソースを作成すると、そのログのソースが登録されますが、最初のエントリが書き込まれるまでログは作成されません。  
  
 ソースは、ローカルコンピューター上で一意である必要があります。新しいソース名は、既存のソース名または既存のイベントログ名と一致することはできません。 各ソースは一度に1つのイベントログにのみ書き込むことができます。ただし、アプリケーションで複数のソースを使用して複数のイベントログに書き込むことができます。 たとえば、アプリケーションによっては、異なるイベントログまたは異なるリソースファイル用に複数のソースが構成されている必要があります。  
  
 <xref:System.Diagnostics.EventLog.Source%2A> 値を変更すると、それが登録されている <xref:System.Diagnostics.EventLog> が閉じられ、すべてのイベントハンドルが解放されます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションまたはコンポーネントが既存のソースを使用する場合は、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースが既にログにマップされていて、新しいログに再マップする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソース `MySource` がまだ存在しない場合は作成し、イベントログ `MyNewLog`にエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コンピューターのレジストリ内で、指定したイベント ソースを検索します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <summary>ローカル コンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>ローカル コンピューターにイベント ソースが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、イベントソースがローカルコンピューターに存在するかどうかを判断するために使用します。 ログがローカルコンピューターに存在するかどうかを確認するには、<xref:System.Diagnostics.EventLog.Exists%2A>を使用します。  
  
 このメソッドはレジストリにアクセスするため、ローカルコンピューターに対する適切なレジストリアクセス許可を持っている必要があります。それ以外の場合は、<xref:System.Security.SecurityException> がスローされます。  
  
> [!NOTE]
>  Windows Vista 以降または Windows Server 2003 でイベントソースを検索するには、管理者特権が必要です。  
>   
>  この要件の理由は、イベントソースが一意かどうかを判断するために、セキュリティを含むすべてのイベントログを検索する必要があるためです。 Windows Vista 以降では、セキュリティログにアクセスするためのアクセス許可がユーザーに付与されていません。したがって、<xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザーアカウント制御 (UAC) によってユーザーの特権が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンスカウンターにアクセスするコードを実行するには、まず、特権を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceAccount.LocalSystem> アカウントで実行されているサービスには、このメソッドを実行するために必要な特権がありません。 この問題を解決するには、イベントソースが <xref:System.ServiceProcess.ServiceInstaller>に存在するかどうかを確認し、存在しない場合はインストーラーでソースを作成します。  
  
 新しいソースに同じコンピューター上の既存のソースの名前を指定することはできないため、`source` で指定された名前のソースがローカルコンピューターに存在していないことを確認するために、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> を呼び出す前にこの方法を使用します。 `source` パラメーターでは、大文字と小文字は区別されません。  
  
   
  
## Examples  
 次の例では、ソース `MySource` がまだ存在しない場合は作成し、イベントログ `MyNewLog`にエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> が見つかりませんでしたが、イベント ログの一部またはすべてが検索できませんでした。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>指定したコンピューターにイベント ソースが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`machineName` パラメーターによって指定されたコンピューターにイベントソースが存在するかどうかを判断するために使用します。 指定したコンピューターにログが存在するかどうかを確認する場合は、<xref:System.Diagnostics.EventLog.Exists%2A>を使用します。  
  
 このメソッドはレジストリにアクセスするため、特定のサーバーに対する適切なレジストリ権限を持っている必要があります。それ以外の場合は、<xref:System.Security.SecurityException> がスローされます。  
  
> [!NOTE]
>  Windows Vista 以降または Windows Server 2003 でイベントソースを検索するには、管理者特権が必要です。  
>   
>  この要件の理由は、イベントソースが一意かどうかを判断するために、セキュリティを含むすべてのイベントログを検索する必要があるためです。 Windows Vista 以降では、セキュリティログにアクセスするためのアクセス許可がユーザーに付与されていません。したがって、<xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザーアカウント制御 (UAC) によってユーザーの特権が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンスカウンターにアクセスするコードを実行するには、まず、特権を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceAccount.LocalSystem> アカウントで実行されているサービスには、このメソッドを実行するために必要な特権がありません。 この問題を解決するには、イベントソースが <xref:System.ServiceProcess.ServiceInstaller>に存在するかどうかを確認し、存在しない場合はインストーラーでソースを作成します。  
  
 新しいソースに同じコンピューター上の既存のソースの名前を指定することはできないため、`source` で指定された名前のソースがコンピューターに存在していないことを確認するために、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> を呼び出す前にこの方法を使用します。 `source` パラメーターと `machineName` パラメーターでは、大文字と小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> は `static` メソッドであるため、クラス自体で呼び出すことができます。 <xref:System.Diagnostics.EventLog.SourceExists%2A>を呼び出すために <xref:System.Diagnostics.EventLog> のインスタンスを作成する必要はありません。  
  
   
  
## Examples  
 次の例では、コンピューター `MyServer`にソース `MySource` を作成し、エントリをイベントログ `MyNewLog`に書き込みます。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> が無効なコンピューター名です。</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> が見つかりませんでしたが、イベント ログの一部またはすべてが検索できませんでした。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1;dotnet-plat-ext-5.0;net-5.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Diagnostics.EventLog" /> エントリ書き込みイベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>イベント ログの <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> が `null`場合、<xref:System.Diagnostics.EventLog.EntryWritten> イベントを処理するメソッドは、システムスレッドプールからのスレッドで呼び出されます。 システムスレッドプールの詳細については、「<xref:System.Threading.ThreadPool>」を参照してください。  
  
 <xref:System.Diagnostics.EventLog.EntryWritten> イベントが、ボタンなどのビジュアル Windows フォームコンポーネントによって処理されると、システムスレッドプールを介してコンポーネントにアクセスできない場合や、例外が発生する場合があります。 これを回避するには、<xref:System.Diagnostics.EventLog.SynchronizingObject%2A> を Windows フォームコンポーネントに設定します。これにより、<xref:System.Diagnostics.EventLog.EntryWritten> イベントを処理するメソッドが、コンポーネントが作成されたのと同じスレッドで呼び出されます。  
  
 <xref:System.Diagnostics.EventLog> が Windows フォームデザイナーの [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 内で使用されている場合、<xref:System.Diagnostics.EventLog.SynchronizingObject%2A> は自動的に <xref:System.Diagnostics.EventLog>を含むコントロールに設定されます。 たとえば、Form1 のデザイナー (<xref:System.Windows.Forms.Form>から継承) に <xref:System.Diagnostics.EventLog> を配置した場合、<xref:System.Diagnostics.EventLog> の <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> プロパティは、Form1 のインスタンスに設定されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログにエントリを書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、この <xref:System.Diagnostics.EventLog> インスタンスに関連付けられているイベントログに情報エントリを書き込みます。 他の <xref:System.Diagnostics.EventLogEntryType>を指定する場合は、<xref:System.Diagnostics.EventLog.WriteEntry%2A>の別のオーバーロードを使用します。  
  
> [!NOTE]
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
 ログにエントリを書き込むには、<xref:System.Diagnostics.EventLog> コンポーネントの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定する必要があります。 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 この <xref:System.Diagnostics.EventLog> インスタンスの [<xref:System.Diagnostics.EventLog.Source%2A>] プロパティで指定されたソースが、コンポーネントの書き込み先のコンピューターに登録されていない場合、<xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を呼び出してソースを登録します。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に <xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.MachineName%2A> を指定しなかった場合は、ローカルコンピューター (".") が想定されます。  
  
 システムが <xref:System.Diagnostics.EventLog.WriteEntry%2A> の呼び出しによって <xref:System.Diagnostics.EventLog.Source%2A> を登録する必要があり、<xref:System.Diagnostics.EventLog> インスタンスに <xref:System.Diagnostics.EventLog.Log%2A> プロパティが設定されていない場合、ログの既定値はアプリケーションログになります。  
  
> [!NOTE]
>  上記の例外の多くは、<xref:System.Diagnostics.EventLog.Source%2A>の登録プロセス中に発生したエラーによって生成されます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートコンピューターにエントリを書き込む場合、リモートコンピューターで .NET Framework が実行されていないと、メッセージの値 (文字列) が予期したとおりではない可能性があります。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、ソース `MySource` がまだ存在しない場合は作成し、イベントログ `MyNewLog`にエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
- または - 
ソースは既に別のイベント ログに登録されています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <summary>エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、指定した <xref:System.Diagnostics.EventLogEntryType> のエントリをイベントログに書き込みます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。  
  
> [!NOTE]
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
 ログにエントリを書き込むには、<xref:System.Diagnostics.EventLog> コンポーネントの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定する必要があります。 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 この <xref:System.Diagnostics.EventLog> インスタンスの [<xref:System.Diagnostics.EventLog.Source%2A>] プロパティで指定されたソースが、コンポーネントの書き込み先のコンピューターに登録されていない場合、<xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を呼び出してソースを登録します。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に <xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.MachineName%2A> を指定しなかった場合は、ローカルコンピューター (".") が想定されます。  
  
 システムが <xref:System.Diagnostics.EventLog.WriteEntry%2A> の呼び出しによって <xref:System.Diagnostics.EventLog.Source%2A> を登録する必要があり、<xref:System.Diagnostics.EventLog> インスタンスに <xref:System.Diagnostics.EventLog.Log%2A> プロパティが設定されていない場合、ログの既定値はアプリケーションログになります。  
  
> [!NOTE]
>  上記の例外の多くは、<xref:System.Diagnostics.EventLog.Source%2A>の登録プロセス中に発生したエラーによって生成されます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートコンピューターにエントリを書き込む場合、リモートコンピューターで .NET Framework が実行されていないと、メッセージの値 (文字列) が予期したとおりではない可能性があります。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、警告エントリをローカルコンピューター上のイベントログ "MyNewLog" に書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
- または - 
ソースは既に別のイベント ログに登録されています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>指定した登録イベント ソースを使用して、種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、適切なログのイベントソースとして既に登録されているソースを使用して、イベントログに情報エントリを書き込みます。 他の <xref:System.Diagnostics.EventLogEntryType>を指定する場合は、<xref:System.Diagnostics.EventLog.WriteEntry%2A>の別のオーバーロードを使用します。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
>   
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
   
  
## Examples  
 次の例では、ソース `MySource` がまだ存在しない場合は作成し、イベントログ `MyNewLog`にエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 値が空の文字列 ("") です。  
  
- または - 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>エントリを、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーションで定義された `eventID` のエントリをイベントログに書き込みます。 `eventID` は、ソースと共にイベントを一意に識別します。 各アプリケーションは、独自の番号付きイベントと、マップ先の説明文字列を定義できます。 イベントビューアーには、発生した問題をユーザーが理解し、実行するアクションを提案できるように、これらの文字列値が表示されます。  
  
> [!NOTE]
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
 イベント識別子に加えて、イベントログに書き込まれるイベントの <xref:System.Diagnostics.EventLogEntryType> を指定できます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、成功の監査、または失敗の監査のいずれであるかを示します。  
  
 ログにエントリを書き込むには、<xref:System.Diagnostics.EventLog> コンポーネントの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定する必要があります。 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 この <xref:System.Diagnostics.EventLog> インスタンスの [<xref:System.Diagnostics.EventLog.Source%2A>] プロパティで指定されたソースが、コンポーネントの書き込み先のコンピューターに登録されていない場合、<xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を呼び出してソースを登録します。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に <xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.MachineName%2A> を指定しなかった場合は、ローカルコンピューター (".") が想定されます。  
  
 システムが <xref:System.Diagnostics.EventLog.WriteEntry%2A> の呼び出しによって <xref:System.Diagnostics.EventLog.Source%2A> を登録する必要があり、<xref:System.Diagnostics.EventLog> インスタンスに <xref:System.Diagnostics.EventLog.Log%2A> プロパティが設定されていない場合、ログの既定値はアプリケーションログになります。  
  
> [!NOTE]
>  上記の例外の多くは、<xref:System.Diagnostics.EventLog.Source%2A>の登録プロセス中に発生したエラーによって生成されます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートコンピューターにエントリを書き込む場合、リモートコンピューターで .NET Framework が実行されていないと、メッセージの値 (文字列) が予期したとおりではない可能性があります。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
- または - 
ソースは既に別のイベント ログに登録されています。  
  
- または - 
 <paramref name="eventID" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <summary>指定した登録イベント ソースを使用して、エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、適切なログのイベントソースとして既に登録されているソースを使用して、指定した <xref:System.Diagnostics.EventLogEntryType> のエントリをイベントログに書き込むことができます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。  
  
> [!NOTE]
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、警告エントリをローカルコンピューター上のイベントログ "MyNewLog" に書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 値が空の文字列 ("") です。  
  
- または - 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーションで定義された `category` のエントリをイベントログに書き込みます。 イベントビューアーは、カテゴリを使用して、イベントソースによって書き込まれたイベントをフィルター処理します。 イベントビューアーでは、カテゴリを数値として表示できます。また、カテゴリをリソース識別子として使用して、ローカライズされたカテゴリ文字列を表示することもできます。  
  
> [!NOTE]
>  `category` パラメーターは正の値である必要があります。 負のカテゴリの値は、イベントビューアーの補完的な正の数値として表示されます。 たとえば、-10 は65526として、-1 は65535として表示されます。  
  
> [!NOTE]
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
 イベントビューアーでローカライズされたカテゴリ文字列を表示するには、カテゴリリソースファイルで構成されたイベントソースを使用し、カテゴリリソースファイル内のリソース識別子に `category` を設定する必要があります。 イベントソースにカテゴリリソースファイルが構成されていない場合、または指定された `category` がカテゴリリソースファイル内の文字列にインデックスを設定していない場合、イベントビューアーにはそのエントリの数値カテゴリの値が表示されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスを使用して、リソースファイル内のカテゴリの文字列の数と共にカテゴリリソースファイルを構成します。  
  
 カテゴリに加えて、イベントログに書き込まれるイベントのイベント識別子を指定することもできます。 イベント識別子は、イベントソースと共に、イベントを一意に識別します。 各アプリケーションは、独自の番号付きイベントと、マップ先の説明文字列を定義できます。 イベントビューアーには、発生した問題をユーザーが理解し、実行するアクションを提案できるように、これらの文字列値が表示されます。  
  
 最後に、イベントログに書き込まれるイベントの <xref:System.Diagnostics.EventLogEntryType> を指定できます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、成功の監査、または失敗の監査のいずれであるかを示します。  
  
 ログにエントリを書き込むには、<xref:System.Diagnostics.EventLog> コンポーネントの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定する必要があります。 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 この <xref:System.Diagnostics.EventLog> インスタンスの [<xref:System.Diagnostics.EventLog.Source%2A>] プロパティで指定されたソースが、コンポーネントの書き込み先のコンピューターに登録されていない場合、<xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を呼び出してソースを登録します。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に <xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.MachineName%2A> を指定しなかった場合は、ローカルコンピューター (".") が想定されます。  
  
 システムが <xref:System.Diagnostics.EventLog.WriteEntry%2A> の呼び出しによって <xref:System.Diagnostics.EventLog.Source%2A> を登録する必要があり、<xref:System.Diagnostics.EventLog> インスタンスに <xref:System.Diagnostics.EventLog.Log%2A> プロパティが設定されていない場合、ログの既定値はアプリケーションログになります。  
  
> [!NOTE]
>  上記の例外の多くは、<xref:System.Diagnostics.EventLog.Source%2A>の登録プロセス中に発生したエラーによって生成されます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートコンピューターにエントリを書き込む場合、リモートコンピューターで .NET Framework が実行されていないと、メッセージの値 (文字列) が予期したとおりではない可能性があります。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
- または - 
ソースは既に別のイベント ログに登録されています。  
  
- または - 
 <paramref name="eventID" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、適切なログのイベントソースとして既に登録されているソースを使用して、アプリケーション定義の `eventID` と共にエントリをイベントログに書き込みます。 `eventID`は、ソースと共にイベントを一意に識別します。 各アプリケーションは、独自の番号付きイベントと、マップ先の説明文字列を定義できます。 イベントビューアーは、これらの文字列をユーザーに提示して、問題の原因を把握し、実行するアクションを提案します。  
  
> [!NOTE]
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
 イベント識別子に加えて、この <xref:System.Diagnostics.EventLog.WriteEntry%2A> のオーバーロードでは、イベントログに書き込まれるイベントの <xref:System.Diagnostics.EventLogEntryType> を指定できます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、成功の監査、または失敗の監査のいずれであるかを示します。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 値が空の文字列 ("") です。  
  
- または - 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
- または - 
 <paramref name="eventID" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、アプリケーション定義のイベント固有のデータをイベントログに書き込みます。 イベントビューアーは、このデータを解釈しません。生データは、16進数とテキスト形式の組み合わせでのみ表示されます。 イベント固有のデータは控えめに使用してください。これは、問題をデバッグするユーザーにとって役に立つ場合にのみ使用します。 また、イベント固有のデータを使用して、アプリケーションがイベントビューアーとは関係なく処理できる情報を格納することもできます。 たとえば、イベント用のビューアーを作成したり、ログファイルをスキャンするプログラムを記述したり、イベント固有のデータからの情報を含むレポートを作成したりすることができます。  
  
 バイナリデータに加えて、アプリケーション定義のカテゴリとアプリケーション定義のイベント識別子を指定できます。 イベントビューアーは、カテゴリを使用して、イベントソースによって書き込まれたイベントをフィルター処理します。 イベントビューアーでは、カテゴリを数値として表示できます。また、カテゴリをリソース識別子として使用して、ローカライズされたカテゴリ文字列を表示することもできます。  
  
> [!NOTE]
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
> [!NOTE]
>  `category` パラメーターは正の値である必要があります。 負のカテゴリの値は、イベントビューアーの補完的な正の数値として表示されます。 たとえば、-10 は65526として、-1 は65535として表示されます。  
  
 イベントビューアーでローカライズされたカテゴリ文字列を表示するには、カテゴリリソースファイルで構成されたイベントソースを使用し、カテゴリリソースファイル内のリソース識別子に `category` を設定する必要があります。 イベントソースにカテゴリリソースファイルが構成されていない場合、または指定された `category` がカテゴリリソースファイル内の文字列にインデックスを設定していない場合、イベントビューアーにはそのエントリの数値カテゴリの値が表示されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスを使用して、リソースファイル内のカテゴリの文字列の数と共にカテゴリリソースファイルを構成します。  
  
 イベント識別子は、イベントソースと共に、イベントを一意に識別します。 各アプリケーションは、独自の番号付きイベントと、マップ先の説明文字列を定義できます。 イベントビューアーには、発生した問題をユーザーが理解し、実行するアクションを提案できるように、これらの文字列値が表示されます。  
  
 最後に、イベントログに書き込まれるイベントの <xref:System.Diagnostics.EventLogEntryType> を指定できます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、成功の監査、または失敗の監査のいずれであるかを示します。  
  
 ログにエントリを書き込むには、<xref:System.Diagnostics.EventLog> コンポーネントの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定する必要があります。 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。  
  
 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 この <xref:System.Diagnostics.EventLog> インスタンスの [<xref:System.Diagnostics.EventLog.Source%2A>] プロパティで指定されたソースが、コンポーネントの書き込み先のコンピューターに登録されていない場合、<xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> を呼び出してソースを登録します。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に <xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.MachineName%2A> を指定しなかった場合は、ローカルコンピューター (".") が想定されます。  
  
 システムが <xref:System.Diagnostics.EventLog.WriteEntry%2A> の呼び出しによって <xref:System.Diagnostics.EventLog.Source%2A> を登録する必要があり、<xref:System.Diagnostics.EventLog> インスタンスに <xref:System.Diagnostics.EventLog.Log%2A> プロパティが設定されていない場合、ログの既定値はアプリケーションログになります。  
  
> [!NOTE]
>  上記の例外の多くは、<xref:System.Diagnostics.EventLog.Source%2A>の登録プロセス中に発生したエラーによって生成されます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートコンピューターにエントリを書き込む場合、リモートコンピューターで .NET Framework が実行されていないと、メッセージの値 (文字列) が予期したとおりではない可能性があります。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
- または - 
ソースは既に別のイベント ログに登録されています。  
  
- または - 
 <paramref name="eventID" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定した登録イベント ソースを使用して、メッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。 <paramref name="category" /> は、イベント ビューアーでログ内のイベントをフィルター処理するときに使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、適切なログのイベントソースとして既に登録されているソースを使用して、アプリケーション定義の `category` と共にエントリをイベントログに書き込みます。 イベントビューアーは、カテゴリを使用して、イベントソースによって書き込まれたイベントをフィルター処理します。 イベントビューアーでは、カテゴリを数値として表示できます。また、カテゴリをリソース識別子として使用して、ローカライズされたカテゴリ文字列を表示することもできます。  
  
> [!NOTE]
>  `category` パラメーターは正の値である必要があります。 負のカテゴリの値は、イベントビューアーの補完的な正の数値として表示されます。 たとえば、-10 は65526として、-1 は65535として表示されます。  
  
 イベントビューアーでローカライズされたカテゴリ文字列を表示するには、カテゴリリソースファイルで構成されたイベントソースを使用し、カテゴリリソースファイル内のリソース識別子に `category` を設定する必要があります。 イベントソースにカテゴリリソースファイルが構成されていない場合、または指定された `category` がカテゴリリソースファイル内の文字列にインデックスを設定していない場合、イベントビューアーにはそのエントリの数値カテゴリの値が表示されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスを使用して、リソースファイル内のカテゴリの文字列の数と共にカテゴリリソースファイルを構成します。  
  
 カテゴリに加えて、イベントログに書き込まれるイベントのイベント識別子を指定することもできます。 イベント識別子は、イベントソースと共に、イベントを一意に識別します。 各アプリケーションは、独自の番号付きイベントと、マップ先の説明文字列を定義できます。 イベントビューアーには、発生した問題をユーザーが理解し、実行するアクションを提案できるように、これらの文字列値が表示されます。  
  
 最後に、イベントログに書き込まれるイベントの <xref:System.Diagnostics.EventLogEntryType> を指定できます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、成功の監査、または失敗の監査のいずれであるかを示します。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
>   
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 値が空の文字列 ("") です。  
  
- または - 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
- または - 
 <paramref name="eventID" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、適切なログのイベントソースとして既に登録されているソースを使用して、アプリケーション定義のイベント固有のデータをイベントログに書き込むことができます。 イベントビューアーは、このデータを解釈しません。生データは、16進数とテキスト形式の組み合わせでのみ表示されます。 イベント固有のデータは控えめに使用します。役に立つ場合にのみ含めてください。 また、イベント固有のデータを使用して、アプリケーションがイベントビューアーとは関係なく処理できる情報を格納することもできます。 たとえば、イベント用のビューアーを作成したり、ログファイルをスキャンするプログラムを記述したり、イベント固有のデータからの情報を含むレポートを作成したりすることができます。  
  
 バイナリデータに加えて、アプリケーション定義のカテゴリとアプリケーション定義のイベント識別子を指定できます。 イベントビューアーは、カテゴリを使用して、イベントソースによって書き込まれたイベントをフィルター処理します。 イベントビューアーでは、カテゴリを数値として表示できます。また、カテゴリをリソース識別子として使用して、ローカライズされたカテゴリ文字列を表示することもできます。  
  
> [!NOTE]
>  `category` パラメーターは正の値である必要があります。 負のカテゴリの値は、イベントビューアーの補完的な正の数値として表示されます。 たとえば、-10 は65526として表示され、-1 は65535として表示されます。  
  
 イベントビューアーでローカライズされたカテゴリ文字列を表示するには、カテゴリリソースファイルで構成されたイベントソースを使用し、カテゴリリソースファイル内のリソース識別子に `category` を設定する必要があります。 イベントソースにカテゴリリソースファイルが構成されていない場合、または指定された `category` がカテゴリリソースファイル内の文字列にインデックスを設定していない場合、イベントビューアーにはそのエントリの数値カテゴリの値が表示されます。 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスを使用して、リソースファイル内のカテゴリの文字列の数と共にカテゴリリソースファイルを構成します。  
  
 イベント識別子は、イベントソースと共に、イベントを一意に識別します。 各アプリケーションは、独自の番号付きイベントと、マップ先の説明文字列を定義できます。 イベントビューアーには、発生した問題をユーザーが理解し、実行するアクションを提案できるように、これらの文字列値が表示されます。  
  
 最後に、イベントログに書き込まれるイベントの <xref:System.Diagnostics.EventLogEntryType> を指定できます。 `type` は、ログのイベントビューアーの [型] 列のアイコンとテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、成功の監査、または失敗の監査のいずれであるかを示します。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、指定された文字列をイベントログに直接書き込みます。ローカライズ可能なメッセージリソースファイルは使用しません。 ローカライズされたメッセージリソースファイルを使用してイベントを書き込むには、<xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  `message` パラメーターに NUL 文字が含まれている場合、イベントログ内のメッセージは NUL 文字で終了します。  
>   
>  `message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーが挿入文字列として扱います。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 値が空の文字列 ("") です。  
  
- または - 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
- または - 
 <paramref name="eventID" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
メッセージ文字列は 31,839 バイト (Windows Vista より前の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ローカライズされたイベント エントリをイベント ログに書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>ローカライズされたエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ローカライズされたエントリをイベントログに書き込みます。 イベントプロパティは、文字列値ではなくリソース識別子を使用して指定します。 イベントビューアーは、リソース識別子を使用して、<xref:System.Diagnostics.EventLog.Source%2A>のローカライズされたリソースファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを作成する前に、ソースを対応するリソースファイルに登録する必要があります。  
  
 入力 `instance` インスタンスでは、イベントメッセージとプロパティを指定します。 送信元メッセージリソースファイルで定義されているメッセージの `instance` 入力の <xref:System.Diagnostics.EventInstance.InstanceId%2A> を設定します。 必要に応じて、`instance` 入力の <xref:System.Diagnostics.EventInstance.CategoryId%2A> と <xref:System.Diagnostics.EventInstance.EntryType%2A> を設定して、イベントエントリのカテゴリとイベントの種類を定義することもできます。 また、言語に依存しない文字列の配列を指定して、ローカライズされたメッセージテキストに挿入することもできます。 イベントメッセージに置換文字列の書式設定プレースホルダーが含まれていない場合は、`values` を `null` に設定します。  
  
 <xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前に、<xref:System.Diagnostics.EventLog> コンポーネントの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定する必要があります。 ローカライズされたエントリをログに書き込むように、指定したソースが構成されている必要があります。ソースには、少なくともメッセージリソースファイルが定義されている必要があります。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションが文字列値をイベントログに直接書き込む場合は、<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートコンピューターにエントリを書き込む場合、リモートコンピューターで .NET Framework を実行していないと、`message` 文字列の値が期待どおりではない可能性があります。 また、`message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーでは挿入文字列として扱われるためです。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
   
  
## Examples  
 次の例では、2つの監査エントリをイベントログ `myNewLog`に書き込みます。 この例では、新しいイベントソースと新しいイベントログがローカルコンピューターに存在しない場合は、それを作成します。 イベントメッセージテキストは、リソースファイル内のリソース識別子を使用して指定されます。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 この例では、リソースライブラリ EventLogMsgs に組み込まれている次のメッセージテキストファイルを使用します。 メッセージテキストファイルは、メッセージリソースファイルの作成元のソースです。 メッセージテキストファイルは、カテゴリ、イベントメッセージ、およびパラメーター挿入文字列のリソース識別子とテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
- または - 
ソースは既に別のイベント ログに登録されています。  
  
- または - 
 <paramref name="instance.InstanceId" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
- または - 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ローカライズされたエントリを追加のイベント固有のデータと共にイベントログに書き込みます。 イベントプロパティは、文字列値ではなくリソース識別子を使用して指定します。 イベントビューアーは、リソース識別子を使用して、<xref:System.Diagnostics.EventLog.Source%2A>のローカライズされたリソースファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを作成する前に、ソースを対応するリソースファイルに登録する必要があります。  
  
 入力 `instance` インスタンスでは、イベントメッセージとプロパティを指定します。 送信元メッセージリソースファイルで定義されているメッセージの `instance` 入力の <xref:System.Diagnostics.EventInstance.InstanceId%2A> を設定します。 必要に応じて、`instance` 入力の <xref:System.Diagnostics.EventInstance.CategoryId%2A> と <xref:System.Diagnostics.EventInstance.EntryType%2A> を設定して、イベントエントリのカテゴリとイベントの種類を定義することもできます。 また、言語に依存しない文字列の配列を指定して、ローカライズされたメッセージテキストに挿入することもできます。 イベントメッセージに置換文字列の書式設定プレースホルダーが含まれていない場合は、`values` を `null` に設定します。  
  
 イベントに追加の詳細を指定する必要がある場合は、イベントでバイナリデータを指定します。 たとえば、`data` パラメーターを使用して、特定のエラーに関する情報を含めることができます。 イベントビューアーは、関連付けられているイベントデータを解釈しません。データは、16進数とテキスト形式の組み合わせで表示されます。 イベント固有のデータは控えめに使用します。役に立つ場合にのみ含めてください。 また、イベント固有のデータを使用して、アプリケーションがイベントビューアーとは関係なく処理できる情報を格納することもできます。 たとえば、イベント専用のビューアーを作成したり、イベントログをスキャンしてイベント固有のデータからの情報を含むレポートを作成するプログラムを記述したりすることができます。  
  
 <xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前に、コンポーネントの前に <xref:System.Diagnostics.EventLog> コンポーネントの <xref:System.Diagnostics.EventLog.Source%2A> プロパティを設定する必要があります。 ローカライズされたエントリをログに書き込むように、指定したソースが構成されている必要があります。ソースには、少なくともメッセージリソースファイルが定義されている必要があります。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.WriteEvent%2A>を呼び出す前に <xref:System.Diagnostics.EventLog> インスタンスの <xref:System.Diagnostics.EventLog.MachineName%2A> を指定しなかった場合は、ローカルコンピューター (".") と見なされます。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションが文字列値をイベントログに直接書き込む場合は、<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートコンピューターにエントリを書き込む場合、リモートコンピューターで .NET Framework を実行していないと、`message` 文字列の値が期待どおりではない可能性があります。 また、`message` 文字列には%*n*を含めることができません。ここで、 *n*は整数値 (たとえば、%1) です。これは、イベントビューアーでは挿入文字列として扱われるためです。 インターネットプロトコルバージョン 6 (IPv6) アドレスにはこの文字シーケンスを含めることができるため、IPv6 アドレスを含むイベントメッセージをログに記録することはできません。  
  
   
  
## Examples  
 次の例では、2つの監査エントリをイベントログ `myNewLog`に書き込みます。 この例では、新しいイベントソースと新しいイベントログがローカルコンピューターに存在しない場合は、それを作成します。 イベントメッセージテキストは、リソースファイル内のリソース識別子を使用して指定されます。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 この例では、リソースライブラリ EventLogMsgs に組み込まれている次のメッセージテキストファイルを使用します。 メッセージテキストファイルは、メッセージリソースファイルの作成元のソースです。 メッセージテキストファイルは、カテゴリ、イベントメッセージ、およびパラメーター挿入文字列のリソース識別子とテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> の <see cref="T:System.Diagnostics.EventLog" /> プロパティが設定されていません。  
  
- または - 
メソッドが新しいイベント ソースを登録しようとしましたが、<see cref="P:System.Diagnostics.EventLog.MachineName" /> のコンピューター名が無効です。  
  
- または - 
ソースは既に別のイベント ログに登録されています。  
  
- または - 
 <paramref name="instance.InstanceId" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
- または - 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データとメッセージ置換文字列と共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、適切なログのイベントソースとして既に登録されているソースを使用して、ローカライズされたエントリをイベントログに書き込むことができます。 イベントプロパティは、文字列値ではなくリソース識別子を使用して指定します。 イベントビューアーは、リソース識別子を使用して、ソースのローカライズされたリソースファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを作成する前に、ソースを対応するリソースファイルに登録する必要があります。  
  
 入力 `instance` インスタンスでは、イベントメッセージとプロパティを指定します。 送信元メッセージリソースファイルで定義されているメッセージの `instance` 入力の <xref:System.Diagnostics.EventInstance.InstanceId%2A> を設定します。 必要に応じて、`instance` 入力の <xref:System.Diagnostics.EventInstance.CategoryId%2A> と <xref:System.Diagnostics.EventInstance.EntryType%2A> を設定して、イベントエントリのカテゴリとイベントの種類を定義することもできます。 また、言語に依存しない文字列の配列を指定して、ローカライズされたメッセージテキストに挿入することもできます。 イベントメッセージに置換文字列の書式設定プレースホルダーが含まれていない場合は、`values` を `null` に設定します。  
  
 <xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前に、指定したソースがイベントログに登録されている必要があります。 ローカライズされたエントリをログに書き込むように、指定したソースが構成されている必要があります。ソースには、少なくともメッセージリソースファイルが定義されている必要があります。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションが文字列値をイベントログに直接書き込む場合は、<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
   
  
## Examples  
 次の例では、情報イベントエントリと警告イベントエントリを既存のイベントログに書き込みます。 イベントメッセージテキストは、リソースファイル内のリソース識別子を使用して指定されます。 この例では、対応するリソースファイルがソースに対して登録されていることを前提としています。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 この例では、リソースライブラリ EventLogMsgs に組み込まれている次のメッセージテキストファイルを使用します。 メッセージテキストファイルは、メッセージリソースファイルの作成元のソースです。 メッセージテキストファイルは、カテゴリ、イベントメッセージ、およびパラメーター挿入文字列のリソース識別子とテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 値が空の文字列 ("") です。  
  
- または - 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
- または - 
 <paramref name="instance.InstanceId" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
- または - 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、適切なログのイベントソースとして既に登録されているソースを使用して、イベント固有の追加データを含むローカライズされたエントリをイベントログに書き込む場合に使用します。 イベントプロパティは、文字列値ではなくリソース識別子を使用して指定します。 イベントビューアーは、リソース識別子を使用して、ソースのローカライズされたリソースファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを作成する前に、ソースを対応するリソースファイルに登録する必要があります。  
  
 入力 `instance` インスタンスでは、イベントメッセージとプロパティを指定します。 送信元メッセージリソースファイルで定義されているメッセージの `instance` 入力の <xref:System.Diagnostics.EventInstance.InstanceId%2A> を設定します。 必要に応じて、`instance` 入力の <xref:System.Diagnostics.EventInstance.CategoryId%2A> と <xref:System.Diagnostics.EventInstance.EntryType%2A> を設定して、イベントエントリのカテゴリとイベントの種類を定義することもできます。 また、言語に依存しない文字列の配列を指定して、ローカライズされたメッセージテキストに挿入することもできます。 イベントメッセージに置換文字列の書式設定プレースホルダーが含まれていない場合は、`values` を `null` に設定します。  
  
 イベントに追加の詳細を指定する必要がある場合は、イベントでバイナリデータを指定します。 たとえば、`data` パラメーターを使用して、特定のエラーに関する情報を含めることができます。 イベントビューアーは、関連付けられているイベントデータを解釈しません。データは、16進数とテキスト形式の組み合わせで表示されます。 イベント固有のデータは控えめに使用します。役に立つ場合にのみ含めてください。 また、イベント固有のデータを使用して、アプリケーションがイベントビューアーとは関係なく処理できる情報を格納することもできます。 たとえば、イベント専用のビューアーを作成したり、イベントログをスキャンしてイベント固有のデータからの情報を含むレポートを作成するプログラムを記述したりすることができます。  
  
 <xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前に、指定したソースがイベントログに登録されている必要があります。 ローカライズされたエントリをログに書き込むように、指定したソースが構成されている必要があります。ソースには、少なくともメッセージリソースファイルが定義されている必要があります。  
  
 ソースとの最初のエントリを書き込む前に、イベントソースを作成して構成する必要があります。 アプリケーションのインストール時に新しいイベントソースを作成します。 これにより、オペレーティングシステムが登録済みのイベントソースとその構成の一覧を更新できるようになります。 オペレーティングシステムがイベントソースの一覧を更新しておらず、新しいソースでイベントを作成しようとすると、書き込み操作は失敗します。 新しいソースを構成するには、<xref:System.Diagnostics.EventLogInstaller>を使用するか、<xref:System.Diagnostics.EventLog.CreateEventSource%2A> 方法を使用します。 新しいイベントソースを作成するには、コンピューターの管理者権限が必要です。  
  
 ソースは、ローカライズされたエントリを書き込むか、または直接文字列を書き込むために構成する必要があります。 アプリケーションが文字列値をイベントログに直接書き込む場合は、<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドを使用します。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2つの異なるソースを登録する必要があります。 たとえば、リソースファイルを使用して1つのソースを構成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEvent%2A> メソッドで使用して、リソース識別子を使用してエントリをイベントログに書き込みます。 次に、リソースファイルを含まない別のソースを作成し、そのソースを <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドで使用して、そのソースを使用して、イベントログに直接文字列を書き込みます。  
  
   
  
## Examples  
 次の例では、情報イベントエントリと警告イベントエントリを既存のイベントログに書き込みます。 イベントメッセージテキストは、リソースファイル内のリソース識別子を使用して指定されます。 この例では、対応するリソースファイルがソースに対して登録されていることを前提としています。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 この例では、リソースライブラリ EventLogMsgs に組み込まれている次のメッセージテキストファイルを使用します。 メッセージテキストファイルは、メッセージリソースファイルの作成元のソースです。 メッセージテキストファイルは、カテゴリ、イベントメッセージ、およびパラメーター挿入文字列のリソース識別子とテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 値が空の文字列 ("") です。  
  
- または - 
<paramref name="source" /> 値は <see langword="null" /> です。  
  
- または - 
 <paramref name="instance.InstanceId" /> が 0 未満であるか、<see cref="F:System.UInt16.MaxValue" /> を超えています。  
  
- または - 
 <paramref name="values" /> には 256 を超える要素が格納されています。  
  
- または - 
<paramref name="values" /> 要素の 1 つが 32766 バイトを超えています。  
  
- または - 
ソース名は、254 文字を超えるレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント エントリをイベント ログに書き込むときにオペレーティング システムからエラーが報告されました。 Windows のエラー コードは使用できません。</exception>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>
