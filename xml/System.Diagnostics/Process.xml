<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fe4170c72b933903f1daac0fcaadbd8f472758a7" /><Meta Name="ms.sourcegitcommit" Value="6c0b6310824199ff476e4a9eec6e9ed0bd1a51c9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/05/2019" /><Meta Name="ms.locfileid" Value="74874840" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ローカル プロセスやリモート プロセスへのアクセスを提供し、ローカル システム プロセスの起動と停止ができるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> コンポーネントは、コンピューターで実行されているプロセスへのアクセスを提供します。 プロセスとは、簡単に言えば実行中のアプリです。 スレッドは、オペレーティング システムがプロセッサ時間を割り当てる基本単位です。 スレッドは、別のスレッドによって実行されている部分を含む、プロセスのコードの任意の部分を実行できます。  
  
 <xref:System.Diagnostics.Process>コンポーネントは、アプリの起動、停止、制御、および監視を行うための便利なツールです。 <xref:System.Diagnostics.Process>コンポーネントを使用して、実行中のプロセスの一覧を取得したり、新しいプロセスを開始したりできます。 システム プロセスにアクセスするには、<xref:System.Diagnostics.Process> コンポーネントを使用します。 <xref:System.Diagnostics.Process>コンポーネントを初期化した後は、実行中のプロセスに関する情報を取得するために使用できます。 そのような情報には、スレッドのセットや、読み込まれたモジュール (.dll と .exe ファイル)、プロセスが使用しているメモリの量などのパフォーマンス情報が含まれます。  
  
 この型は <xref:System.IDisposable> インターフェイスを実装します。 型の使用が完了したら、直接的または間接的に型を破棄する必要があります。 直接的に型を破棄するには、`try` / `finally` ブロック内で <xref:System.IDisposable.Dispose%2A> メソッドを呼び出します。 間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。 詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。  
  
> [!NOTE]
>  32 ビット プロセスは 64 ビット プロセスのモジュールにアクセスできません。 32 ビット プロセスから 64 ビット プロセスの詳細情報を取得しようとすると、<xref:System.ComponentModel.Win32Exception> 例外が発生します。 一方で、64 ビット プロセスは 32 ビット プロセスのモジュールにアクセスできます。  
  
 プロセス コンポーネントは、一度にすべてのプロパティのグループに関する情報を取得します。 <xref:System.Diagnostics.Process> コンポーネントは、いずれかのグループの 1 つのメンバーに関する情報を取得した後は、そのグループ内の他のプロパティの値をキャッシュします。そして、<xref:System.Diagnostics.Process.Refresh%2A> メソッドを呼び出すまで、そのグループの他のメンバーに関する新しい情報を取得しません。 そのため、プロパティ値は、最後の <xref:System.Diagnostics.Process.Refresh%2A> メソッドの呼び出しよりも新しい値を保証しません。 グループの内訳はオペレーティング システムに依存します。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
 システム プロセスは、プロセス識別子によって、システムで一意に識別されます。 多くの Windows リソースと同様に、プロセスはそれのハンドルによっても識別されますが、ハンドルはコンピューター上で一意でない場合があります。 ハンドルはリソースの識別子の総称です。 プロセス ハンドルは、オペレーティング システムによって保持され、<xref:System.Diagnostics.Process.Handle%2A> コンポーネントの <xref:System.Diagnostics.Process> プロパティを通じてアクセスできます。 これはプロセスが終了した場合でもアクセスできます。これにより、<xref:System.Diagnostics.Process.ExitCode%2A> (通常は、成功を示す 0 か、0 以外のエラー コードのどちらかです) や <xref:System.Diagnostics.Process.ExitTime%2A> などの、プロセスの管理情報を取得できます。 ハンドルは非常に貴重なリソースなので、ハンドル リークはメモリ リークよりも有害です。  
  
> [!NOTE]
>  このクラスには、リンク確認要求と、すべてのメンバーに適用されるクラス レベルの継承確認要求が含まれています。 直接の呼び出し元か派生クラスのいずれかに完全信頼アクセス許可がない場合、<xref:System.Security.SecurityException> がスローされます。 セキュリティ要求の詳細については、「[リンク確認要求](~/docs/framework/misc/link-demands.md)」を参照してください。  
  
<a name="Core"></a>   
## <a name="includenet_coreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] での注意  
 .NET Framework では、既定では <xref:System.Diagnostics.Process> クラスは <xref:System.Console> のエンコードを使用します。これは、入力ストリーム、出力ストリーム、およびエラー ストリームについては、通常はコード ページ エンコードです。 コード例では、システムのカルチャが英語 (米国) で、コード ページ 437 が <xref:System.Console> クラスの既定のエンコードです。 しかし、[!INCLUDE[net_core](~/includes/net-core-md.md)] では、これらのエンコードの限られたサブセットしか使用できないことがあります。 その場合は、<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> を既定のエンコードとして使用します。  
  
 <xref:System.Diagnostics.Process> オブジェクトが特定のコード ページ エンコードに依存している場合、<xref:System.Diagnostics.Process> のメソッドを呼び出す*前に*次の手順を行うと、特定のコード ページ エンコードも利用できます。  
  
1.  プロジェクトに、参照を追加して、コードページ...........................  
  
2.  <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> プロパティから、<xref:System.Text.EncodingProvider> オブジェクトを取得します。  
  
3.  <xref:System.Text.EncodingProvider> オブジェクトを <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> メソッドに渡すと、エンコーディング プロバイダーでサポートされているその他のエンコードを利用できるようになります。  
  
 <xref:System.Diagnostics.Process> のメソッドを呼び出す前にエンコーディング プロバイダーを登録していれば、<xref:System.Diagnostics.Process> クラスは、UTF8 ではなく既定のシステム エンコードを自動的に使用します。  
  
   
  
## Examples  
 次の例では、<xref:System.Diagnostics.Process> クラスのインスタンスを使用してプロセスを開始します。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 次の例では、<xref:System.Diagnostics.Process> クラス自体と静的な <xref:System.Diagnostics.Process.Start%2A> メソッドを使用してプロセスを開始します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 次F#の例では、プロセスを開始し、すべての出力とエラー情報をキャプチャし、プロセスが実行したミリ秒数を記録する `runProc` 関数を定義します。  `runProc` 関数には、起動するアプリケーションの名前、アプリケーションに渡す引数、開始ディレクトリという3つのパラメーターがあります。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 `runProc` 関数のコードは[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)によって記述されており、 [Microsoft のパブリックライセンス](https://opensource.org/licenses/ms-pl)で入手できます。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このクラスは、部分的に信頼されているコードから使用することはできません。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">継承者に対する完全な信頼の場合。 このクラスを、部分的に信頼されているコードが継承することはできません。</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">.NET Process クラスの使用</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.MachineName%2A> プロパティを指定しない場合、既定値はローカルコンピューター (".") になります。  
  
 新しい <xref:System.Diagnostics.Process> コンポーネントをコンピューター上のプロセスと関連付けるには、2つのオプションがあります。 1つ目のオプションは、コンストラクターを使用して <xref:System.Diagnostics.Process> コンポーネントを作成し、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティの適切なメンバーを設定し <xref:System.Diagnostics.Process.Start%2A> を呼び出して、<xref:System.Diagnostics.Process> を新しいシステムプロセスに関連付けます。 2つ目のオプションは、<xref:System.Diagnostics.Process.GetProcessById%2A> または <xref:System.Diagnostics.Process.GetProcesses%2A> の戻り値のいずれかを使用して、<xref:System.Diagnostics.Process> を実行中のシステムプロセスに関連付けることです。  
  
 <xref:System.Diagnostics.Process.Start%2A> メソッドの `static` のオーバーロードを使用して新しいシステムプロセスを開始すると、メソッドによって新しい <xref:System.Diagnostics.Process> コンポーネントが作成され、プロセスに関連付けられます。  
  
 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> プロパティが既定値に設定されている場合、`true`、Windows `Start` メニューの [`Run`] ダイアログボックスを使用した場合と同様の方法でアプリケーションとドキュメントを開始できます。 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> が `false`場合は、実行可能ファイルのみを開始できます。  
  
 コマンドラインから呼び出すことができる実行可能ファイルは、次の2つの方法のいずれかで起動できます。 <xref:System.Diagnostics.Process.StartInfo%2A> プロパティの適切なメンバーを設定し、パラメーターを指定せずに <xref:System.Diagnostics.Process.Start%2A> メソッドを呼び出すか、または `static`<xref:System.Diagnostics.Process.Start%2A> メンバーに適切なパラメーターを渡します。  
  
 コンストラクター、静的 <xref:System.Diagnostics.Process.Start%2A> オーバーロードのいずれか、または <xref:System.Diagnostics.Process.GetProcessById%2A>、<xref:System.Diagnostics.Process.GetProcesses%2A>、または <xref:System.Diagnostics.Process.GetProcessesByName%2A> メソッドのいずれかを使用して、<xref:System.Diagnostics.Process> コンポーネントを作成できます。 完了すると、関連付けられているプロセスのビューが表示されます。 これは、プロセスのプロパティがメモリ内で変更されたときに自動的に更新される動的ビューではありません。 代わりに、コンポーネントの <xref:System.Diagnostics.Process.Refresh%2A> を呼び出して、アプリケーションの <xref:System.Diagnostics.Process> プロパティ情報を更新する必要があります。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの基本優先順位を取得します。</summary>
        <value>関連付けられたプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> から算出される基本優先順位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスの <xref:System.Diagnostics.Process.BasePriority%2A> は、関連付けられているプロセス内で作成されるスレッドの開始優先順位です。 基本優先順位に関する情報は、システムモニターの優先順位ベースカウンターを使用して表示できます。  
  
 オペレーティングシステムは、経過時間またはその他のブーストに基づいて、プロセスを他のプロセスの前に配置する必要があるときに基本優先順位を変更できます。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> プロパティを使用すると、プロセスに割り当てられた開始の優先順位を表示できます。 ただし、読み取り専用であるため、<xref:System.Diagnostics.Process.BasePriority%2A> を使用してプロセスの優先順位を設定することはできません。 優先順位を変更するには、<xref:System.Diagnostics.Process.PriorityClass%2A> プロパティを使用します。 <xref:System.Diagnostics.Process.BasePriority%2A> はシステムモニターを使用して表示できますが、<xref:System.Diagnostics.Process.PriorityClass%2A> は表示されません。 <xref:System.Diagnostics.Process.BasePriority%2A> と <xref:System.Diagnostics.Process.PriorityClass%2A> は、どちらもプログラムによって表示できます。 次の表は、<xref:System.Diagnostics.Process.BasePriority%2A> 値と <xref:System.Diagnostics.Process.PriorityClass%2A> 値の関係を示しています。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
 - または -  
  
 プロセスが開始されていないため、プロセス ID はありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> ストリームは、同期的または非同期的に読み取ることができます。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>、<xref:System.IO.StreamReader.ReadToEnd%2A> などのメソッドは、プロセスのエラー出力ストリームに対して同期読み取り操作を実行します。 これらの同期読み取り操作は、関連付けられた <xref:System.Diagnostics.Process> が <xref:System.Diagnostics.Process.StandardError%2A> ストリームに書き込むか、ストリームを閉じるまで完了しません。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> は、<xref:System.Diagnostics.Process.StandardError%2A> ストリームで非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 <xref:System.Diagnostics.Process> の <xref:System.Diagnostics.Process.StandardError%2A> に対して非同期の読み取り操作を実行するには、次の手順に従います。  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> を `true` に設定します。  
  
3.  イベントハンドラーを <xref:System.Diagnostics.Process.ErrorDataReceived> イベントに追加します。 イベントハンドラーは <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> デリゲートシグネチャと一致する必要があります。  
  
4.  <xref:System.Diagnostics.Process>を開始します。  
  
5.  <xref:System.Diagnostics.Process>に対して <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> を呼び出します。 この呼び出しは、<xref:System.Diagnostics.Process.StandardError%2A>に対して非同期の読み取り操作を開始します。  
  
 非同期の読み取り操作を開始すると、関連付けられた <xref:System.Diagnostics.Process> が <xref:System.Diagnostics.Process.StandardError%2A> ストリームにテキスト行を書き込むたびに、イベントハンドラーが呼び出されます。  
  
 <xref:System.Diagnostics.Process.CancelErrorRead%2A>を呼び出すことにより、非同期の読み取り操作を取り消すことができます。 読み取り操作は、呼び出し元またはイベントハンドラーによって取り消すことができます。 キャンセル後、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> をもう一度呼び出して、非同期の読み取り操作を再開できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 <xref:System.Diagnostics.Process> のリダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームでのすべての読み取り操作は同じモードである必要があります。 たとえば、<xref:System.Diagnostics.Process.StandardError%2A> ストリームで <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことによって <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> に従わないでください。その逆も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> を呼び出し、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームの <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことができます。  
  
   
  
## Examples  
 次の例では、`net view` コマンドを使用して、リモートコンピューター上の使用可能なネットワークリソースを一覧表示します。 ユーザーは、ターゲットコンピューターの名前をコマンドライン引数として指定します。 ユーザーは、エラー出力のファイル名を指定することもできます。 この例では、net コマンドの出力を収集し、プロセスが終了するまで待機してから、出力結果をコンソールに書き込みます。 ユーザーがオプションのエラーファイルを指定した場合、この例ではエラーがファイルに書き込まれます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティが <see langword="false" /> です。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで非同期読み取り操作は既に実行されています。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームは、同期的または非同期的に読み取ることができます。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>、<xref:System.IO.StreamReader.ReadToEnd%2A> などのメソッドは、プロセスの出力ストリームに対して同期読み取り操作を実行します。 これらの同期読み取り操作は、関連付けられた <xref:System.Diagnostics.Process> が <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームに書き込むか、ストリームを閉じるまで完了しません。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> は、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームで非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 <xref:System.Diagnostics.Process> の <xref:System.Diagnostics.Process.StandardOutput%2A> に対して非同期の読み取り操作を実行するには、次の手順に従います。  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> を `true` に設定します。  
  
3.  イベントハンドラーを <xref:System.Diagnostics.Process.OutputDataReceived> イベントに追加します。 イベントハンドラーは <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> デリゲートシグネチャと一致する必要があります。  
  
4.  <xref:System.Diagnostics.Process>を開始します。  
  
5.  <xref:System.Diagnostics.Process>に対して <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> を呼び出します。 この呼び出しは、<xref:System.Diagnostics.Process.StandardOutput%2A>に対して非同期の読み取り操作を開始します。  
  
 非同期の読み取り操作を開始すると、関連付けられた <xref:System.Diagnostics.Process> が <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームにテキスト行を書き込むたびに、イベントハンドラーが呼び出されます。  
  
 <xref:System.Diagnostics.Process.CancelOutputRead%2A>を呼び出すことにより、非同期の読み取り操作を取り消すことができます。 読み取り操作は、呼び出し元またはイベントハンドラーによって取り消すことができます。 キャンセル後、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> をもう一度呼び出して、非同期の読み取り操作を再開できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 <xref:System.Diagnostics.Process> のリダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームでのすべての読み取り操作は同じモードである必要があります。 たとえば、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームで <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことによって <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> に従わないでください。その逆も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> を呼び出し、<xref:System.Diagnostics.Process.StandardError%2A> ストリームの <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことができます。  
  
   
  
## Examples  
 次の例は、`sort` コマンドのリダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームで非同期読み取り操作を実行する方法を示しています。 `sort` コマンドは、テキスト入力の読み取りと並べ替えを行うコンソールアプリケーションです。  
  
 この例では、`SortOutputHandler` イベントハンドラーのイベントデリゲートを作成し、それを <xref:System.Diagnostics.Process.OutputDataReceived> イベントに関連付けます。 イベントハンドラーは、リダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームからテキスト行を受信し、テキストを書式設定して、画面にテキストを書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> プロパティが <see langword="false" /> です。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで非同期読み取り操作は既に実行されています。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> は、<xref:System.Diagnostics.Process.StandardError%2A> ストリームで非同期の読み取り操作を開始します。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> は、非同期の読み取り操作を終了します。  
  
 キャンセルした後、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> を再度呼び出して、非同期の読み取り操作を再開できます。  
  
 <xref:System.Diagnostics.Process.CancelErrorRead%2A>を呼び出すと、<xref:System.Diagnostics.Process.StandardError%2A> に対して実行中のすべての読み取り操作が完了し、イベントハンドラーが無効になります。 さらに、<xref:System.Diagnostics.Process.StandardError%2A> にリダイレクトされる出力はすべて失われます。 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>の呼び出しを使用してイベントハンドラーを再び有効にすると、非同期の読み取り操作が再開されます。 非同期の読み取り操作を再開する前にイベントハンドラーを変更する場合は、新しいイベントハンドラーを追加する前に既存のイベントハンドラーを削除する必要があります。  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  リダイレクトされた <xref:System.Diagnostics.Process.StandardError%2A> ストリームでは、非同期および同期読み取り操作を混在させることはできません。 <xref:System.Diagnostics.Process> のリダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームでのすべての読み取り操作は同じモードである必要があります。 <xref:System.Diagnostics.Process.StandardError%2A> に対して非同期の読み取り操作をキャンセルしてから、もう一度ストリームから読み取る必要がある場合は、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> を使用して非同期の読み取り操作を再開する必要があります。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>、<xref:System.IO.StreamReader.ReadToEnd%2A>など、<xref:System.Diagnostics.Process.StandardError%2A> の同期読み取りメソッドを呼び出す場合は、<xref:System.Diagnostics.Process.CancelErrorRead%2A> に従わないでください。  
  
   
  
## Examples  
 次の例では、ユーザーが指定した引数を使用して `nmake` コマンドを開始します。 エラーストリームと出力ストリームは非同期に読み込まれます。収集されたテキスト行は、コンソールに表示されるだけでなく、ログファイルに書き込まれます。 コマンドの出力が指定された行数を超えた場合、非同期の読み取り操作は取り消されます。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> は、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームで非同期の読み取り操作を開始します。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> は、非同期の読み取り操作を終了します。  
  
 キャンセルした後、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> を再度呼び出して、非同期の読み取り操作を再開できます。  
  
 <xref:System.Diagnostics.Process.CancelOutputRead%2A>を呼び出すと、<xref:System.Diagnostics.Process.StandardOutput%2A> に対して実行中のすべての読み取り操作が完了し、イベントハンドラーが無効になります。 さらに、<xref:System.Diagnostics.Process.StandardOutput%2A> にリダイレクトされる出力はすべてバッファーに保存されます。 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>の呼び出しを使用してイベントハンドラーを再度有効にすると、保存された出力がイベントハンドラーに送信され、非同期の読み取り操作が再開されます。 非同期の読み取り操作を再開する前にイベントハンドラーを変更する場合は、新しいイベントハンドラーを追加する前に既存のイベントハンドラーを削除する必要があります。  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  リダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームでは、非同期および同期読み取り操作を混在させることはできません。 <xref:System.Diagnostics.Process> のリダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームでのすべての読み取り操作は同じモードである必要があります。 <xref:System.Diagnostics.Process.StandardOutput%2A> に対して非同期の読み取り操作をキャンセルしてから、もう一度ストリームから読み取る必要がある場合は、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> を使用して非同期の読み取り操作を再開する必要があります。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>、<xref:System.IO.StreamReader.ReadToEnd%2A>など、<xref:System.Diagnostics.Process.StandardOutput%2A> の同期読み取りメソッドを呼び出す場合は、<xref:System.Diagnostics.Process.CancelOutputRead%2A> に従わないでください。  
  
   
  
## Examples  
 次の例では、ユーザーが指定した引数を使用して `nmake` コマンドを開始します。 エラーストリームと出力ストリームは非同期に読み込まれます。収集されたテキスト行は、コンソールに表示されるだけでなく、ログファイルに書き込まれます。 コマンドの出力が指定された行数を超えた場合、非同期の読み取り操作は取り消されます。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このコンポーネントに関連付けられているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> メソッドを使用すると、プロセスは待機している場合は終了を待機し、プロセスハンドルを閉じ、プロセス固有のプロパティをクリアします。 <xref:System.Diagnostics.Process.Close%2A> は、外部から参照されている場合に、標準出力、入力、およびエラーリーダーとライターを閉じません。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> メソッドは <xref:System.Diagnostics.Process.Close%2A> を呼び出します。 `using` ブロックに <xref:System.Diagnostics.Process> オブジェクトを配置すると、<xref:System.Diagnostics.Process.Close%2A>を呼び出す必要なくリソースが解放されます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を、最大で10秒間、2秒間隔で取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メイン ウィンドウにクローズ メッセージを送信して、ユーザー インターフェイスがあるプロセスを終了します。</summary>
        <returns>クローズ メッセージが正常に送信された場合は <see langword="true" />。関連付けられたプロセスにメイン ウィンドウがない場合、またはメイン ウィンドウが使用できない場合 (モーダル ダイアログ ボックスが表示されているときなど) は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスが実行されると、そのメッセージループは待機状態になります。 メッセージループは、Windows メッセージがオペレーティングシステムによってプロセスに送信されるたびに実行されます。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> を呼び出すと、メインウィンドウを閉じる要求が送信されます。これは、適切な形式のアプリケーションで、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージループを取り消します。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> を呼び出すことによってプロセスを終了する要求では、アプリケーションが強制的に終了されることはありません。 アプリケーションは、終了する前にユーザーの確認を要求することも、終了を拒否することもできます。 アプリケーションを強制的に終了するには、<xref:System.Diagnostics.Process.Kill%2A> メソッドを使用します。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> の動作は、[システム] メニューを使用してアプリケーションのメインウィンドウを閉じるユーザーの動作と同じです。 そのため、メインウィンドウを閉じてプロセスを終了する要求では、アプリケーションが直ちに終了することはありません。  
  
 プロセスによって編集されたデータまたはプロセスに割り当てられたリソースは、<xref:System.Diagnostics.Process.Kill%2A>を呼び出すと失われることがあります。 <xref:System.Diagnostics.Process.Kill%2A> によって異常なプロセスが終了し、必要な場合にのみ使用する必要があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> を使用すると、プロセスが正常に終了し、すべてのウィンドウが閉じます。そのため、インターフェイスを持つアプリケーションに適しています。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> が失敗した場合は、<xref:System.Diagnostics.Process.Kill%2A> を使用してプロセスを終了できます。 <xref:System.Diagnostics.Process.Kill%2A> は、グラフィカルインターフェイスを持たないプロセスを終了する唯一の方法です。  
  
 ローカルコンピューター上で実行されているプロセスに対してのみ <xref:System.Diagnostics.Process.Kill%2A> および <xref:System.Diagnostics.Process.CloseMainWindow%2A> を呼び出すことができます。 リモートコンピューター上のプロセスを終了させることはできません。 リモートコンピューター上で実行されているプロセスの情報のみを表示できます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を2秒間隔で最大10秒間取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>このプロセスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させるかどうかを取得または設定します。</summary>
        <value>正常終了または <see cref="M:System.Diagnostics.Process.Kill" /> の呼び出しによって関連付けられたプロセスが終了したときに <see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。 <see cref="E:System.Diagnostics.Process.Exited" /> イベントは、ユーザーが <see cref="P:System.Diagnostics.Process.HasExited" /> チェックを実行する前にプロセスが終了したときに <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> の値が <see langword="false" /> 場合にも発生します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> プロパティは、オペレーティングシステムがプロセスをシャットダウンしたときにコンポーネントに通知する必要があるかどうかを示します。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> プロパティは、プロセスが終了したことをアプリケーションに通知するために、非同期処理で使用されます。 アプリケーションが終了イベント (終了イベントが発生するまでアプリケーションの処理を中断する) を同期的に待機するには、<xref:System.Diagnostics.Process.WaitForExit%2A> メソッドを使用します。

> [!NOTE]
> Visual Studio を使用していて、プロジェクト内の <xref:System.Diagnostics.Process> コンポーネントをダブルクリックすると、<xref:System.Diagnostics.Process.Exited> イベントデリゲートとイベントハンドラーが自動的に生成されます。 追加のコードは、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> プロパティを `false`に設定します。 関連付けられたプロセスが終了したときにイベントハンドラーが実行されるようにするには、このプロパティを `true` に変更する必要があります。

コンポーネントの <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 値が `true`場合、または <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> が `false`、コンポーネントによって <xref:System.Diagnostics.Process.HasExited%2A> チェックが呼び出された場合、コンポーネントは、関連付けられているプロセスの管理情報にアクセスできます。これは、オペレーティングシステムによって保存されたままです。 このような情報には、<xref:System.Diagnostics.Process.ExitTime%2A> と <xref:System.Diagnostics.Process.ExitCode%2A>が含まれます。

関連付けられたプロセスが終了すると、コンポーネントの <xref:System.Diagnostics.Process.Handle%2A> は既存のプロセスリソースを参照しなくなります。 代わりに、プロセスリソースに関するオペレーティングシステムの情報にアクセスするためにのみ使用できます。 オペレーティングシステムは、<xref:System.Diagnostics.Process> コンポーネントによって解放されていないプロセスを終了するハンドルがあることを認識しているため、<xref:System.Diagnostics.Process.ExitTime%2A> と <xref:System.Diagnostics.Process.Handle%2A> の情報をメモリに保持します。

プロセスを終了するための監視に関連するコストが発生します。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> が `true`場合、関連付けられたプロセスが終了すると、<xref:System.Diagnostics.Process.Exited> イベントが発生します。 <xref:System.Diagnostics.Process.Exited> イベントのプロシージャは、その時点で実行されます。

場合によっては、アプリケーションはプロセスを開始しますが、そのクロージャの通知は必要ありません。 たとえば、アプリケーションでメモ帳を起動して、ユーザーがテキスト編集を実行することを許可し、メモ帳アプリケーションをそれ以上使用しないようにすることができます。 プロセスが終了したときに通知されないようにすることもできます。これは、アプリケーションの継続操作には関係がないためです。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> を `false` に設定すると、システムリソースを節約できます。

## Examples  
次のコード例では、ファイルを出力するプロセスを作成します。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> プロパティを設定して、プロセスが終了時に <xref:System.Diagnostics.Process.Exited> イベントを発生させます。 <xref:System.Diagnostics.Process.Exited> イベントハンドラーには、プロセス情報が表示されます。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのネイティブ プロパティ <see langword="SeDebugPrivilege" /> を有効にすることにより、<see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部のオペレーティングシステムプロセスは、特別なモードで実行されます。 コンポーネントで <xref:System.Diagnostics.Process.EnterDebugMode%2A> を呼び出していない限り、これらのプロセスのプロパティを読み取ろうとしたり、これらのプロセスにアタッチしたりすることはできません。 特殊モードで実行されるこれらのプロセスにアクセスする必要がなくなった場合は、<xref:System.Diagnostics.Process.LeaveDebugMode%2A> を呼び出します。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームに書き込む場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> イベントは、関連付けられたプロセスがリダイレクトされた <xref:System.Diagnostics.Process.StandardError%2A> ストリームに書き込まれたことを示します。  
  
 イベントは、<xref:System.Diagnostics.Process.StandardError%2A>での非同期読み取り操作中にのみ発生します。 非同期読み取り操作を開始するには、<xref:System.Diagnostics.Process>の <xref:System.Diagnostics.Process.StandardError%2A> ストリームをリダイレクトし、イベントハンドラーを <xref:System.Diagnostics.Process.ErrorDataReceived> イベントに追加して、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>を呼び出す必要があります。 その後、<xref:System.Diagnostics.Process.ErrorDataReceived> イベントは、プロセスが終了するか <xref:System.Diagnostics.Process.CancelErrorRead%2A>を呼び出すまで、リダイレクトされた <xref:System.Diagnostics.Process.StandardError%2A> ストリームに行を書き込むたびに通知します。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションは、<xref:System.Diagnostics.Process.WaitForExit> メソッドを呼び出して、出力バッファーがフラッシュされたことを確認する必要があります。 <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> のオーバーロードを使用してタイムアウトを指定しても、出力バッファーがフラッシュされて*い*ないことに注意してください。
  
   
  
## Examples  
 次の例では、`net view` コマンドを使用して、リモートコンピューター上の使用可能なネットワークリソースを一覧表示します。 ユーザーは、ターゲットコンピューターの名前をコマンドライン引数として指定します。 ユーザーは、エラー出力のファイル名を指定することもできます。 この例では、net コマンドの出力を収集し、プロセスが終了するまで待機してから、出力結果をコンソールに書き込みます。 ユーザーがオプションのエラーファイルを指定した場合、この例ではエラーがファイルに書き込まれます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了したときにプロセスによって指定された値を取得します。</summary>
        <value>関連付けられたプロセスが終了したときにプロセスによって指定されたコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 システムプロセスが終了したときに返された状態を取得するには、<xref:System.Diagnostics.Process.ExitCode%2A> を使用します。 終了コードは、`main()` プロシージャからの整数の戻り値と同じように使用できます。  
  
 プロセスの <xref:System.Diagnostics.Process.ExitCode%2A> 値には、そのプロセスのアプリケーション開発者によって実装される特定の規則が反映されます。 終了コード値を使用してコード内で決定を行う場合は、アプリケーションプロセスで使用される終了コード規則がわかっていることを確認してください。  
  
 通常、開発者は、<xref:System.Diagnostics.Process.ExitCode%2A> 値がゼロであることを示し、呼び出し元のメソッドが異常なプロセス終了の原因を特定するために使用できる0以外の値によってエラーを指定します。 これらのガイドラインに従う必要はありませんが、規則です。  
  
 プロセスが終了する前に <xref:System.Diagnostics.Process.ExitCode%2A> を取得しようとすると、例外がスローされます。 最初に <xref:System.Diagnostics.Process.HasExited%2A> プロパティを調べて、関連付けられたプロセスが終了したかどうかを確認します。  
  
> [!NOTE]
>  標準出力が非同期イベントハンドラーにリダイレクトされた場合、<xref:System.Diagnostics.Process.HasExited%2A> が `true`を返すと、出力処理が完了しない可能性があります。 非同期イベント処理が完了したことを確認するには、<xref:System.Diagnostics.Process.HasExited%2A>を確認する前に、パラメーターを取らない <xref:System.Diagnostics.Process.WaitForExit> オーバーロードを呼び出します。  
  
 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A> メソッドを使用して、関連付けられたプロセスを終了させることができます。  
  
 関連付けられたプロセスが終了すると、同期的かつ非同期的に通知される2つの方法があります。 同期通知は、関連するコンポーネントが終了するまで、アプリケーションの処理を一時停止するために <xref:System.Diagnostics.Process.WaitForExit%2A> メソッドを呼び出すことに依存します。 非同期通知は、<xref:System.Diagnostics.Process.Exited> イベントに依存します。 非同期通知を使用する場合は、プロセスが終了したことを通知するために、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> を <xref:System.Diagnostics.Process> コンポーネントで `true` に設定する必要があります。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスは終了していません。  
  
- または - 
プロセス <see cref="P:System.Diagnostics.Process.Handle" /> は終了していません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> イベントは、関連付けられたプロセスが終了したことを示します。 この現象は、プロセスが終了 (中止) されたか、または正常に終了したことを意味します。 このイベントは、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> プロパティの値が `true`場合にのみ発生します。  
  
 関連付けられたプロセスが終了すると、同期的かつ非同期的に通知される2つの方法があります。 同期通知とは、プロセスが終了するまで、<xref:System.Diagnostics.Process.WaitForExit%2A> メソッドを呼び出して現在のスレッドをブロックすることを意味します。 非同期通知は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。これにより、呼び出し元のスレッドは、その間に実行を継続できます。 後者の場合、呼び出し元のアプリケーションが終了イベントを受け取るには、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> を `true` に設定する必要があります。  
  
 オペレーティングシステムは、プロセスをシャットダウンすると、終了したイベントに対してハンドラーが登録されている他のすべてのプロセスに通知します。 現時点では、終了したばかりのプロセスのハンドルを使用して、<xref:System.Diagnostics.Process.ExitTime%2A> などのいくつかのプロパティにアクセスしたり、そのハンドルを完全に解放するまでオペレーティングシステムが保持する <xref:System.Diagnostics.Process.HasExited%2A> したりできます。  
  
> [!NOTE]
>  終了したプロセスへのハンドルがある場合でも、<xref:System.Diagnostics.Process.Start%2A> を再度呼び出して同じプロセスに再接続することはできません。 <xref:System.Diagnostics.Process.Start%2A> を呼び出すと、関連付けられているプロセスが自動的に解放され、同じファイルを持つプロセスに接続しますが、完全に新しい <xref:System.Diagnostics.Process.Handle%2A>ます。  
  
 Windows フォームアプリケーションでの <xref:System.Diagnostics.Process.Exited> イベントの使用の詳細については、<xref:System.Diagnostics.Process.SynchronizingObject%2A> プロパティを参照してください。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 プロセスの作成時に <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> プロパティが設定されていたため、プロセスが終了したときに <xref:System.Diagnostics.Process.Exited> イベントが発生します。 <xref:System.Diagnostics.Process.Exited> イベントハンドラーには、プロセス情報が表示されます。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了した時刻を取得します。</summary>
        <value>関連付けられたプロセスが終了した時刻を示す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスが終了していない場合、<xref:System.Diagnostics.Process.ExitTime%2A> プロパティを取得しようとすると、例外がスローされます。 <xref:System.Diagnostics.Process.ExitTime%2A> プロパティを取得して、関連付けられたプロセスが終了したかどうかを判断する前に、<xref:System.Diagnostics.Process.HasExited%2A> を使用します。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 プロセスは、終了時に <xref:System.Diagnostics.Process.Exited> イベントを発生させ、イベントハンドラーは <xref:System.Diagnostics.Process.ExitTime%2A> プロパティおよびその他のプロセス情報を表示します。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを取得し、現在アクティブなプロセスに関連付けます。</summary>
        <returns>呼び出し元のアプリケーションを実行しているプロセス リソースに関連付けられた新しい <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい <xref:System.Diagnostics.Process> インスタンスを作成し、ローカルコンピューター上のプロセスリソースに関連付けます。  
  
 同様の <xref:System.Diagnostics.Process.GetProcessById%2A>、<xref:System.Diagnostics.Process.GetProcessesByName%2A>、および <xref:System.Diagnostics.Process.GetProcesses%2A> メソッドと同様に、<xref:System.Diagnostics.Process.GetCurrentProcess%2A> は既存のリソースを新しい <xref:System.Diagnostics.Process> コンポーネントに関連付けます。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成し、指定した既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <summary>ローカル コンピューター上のプロセス ID が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるローカル プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい <xref:System.Diagnostics.Process> コンポーネントを作成し、ローカルコンピューター上のプロセスリソースに関連付けます。 プロセスリソースはコンピューターに既に存在している必要があります。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> はシステムリソースを作成せず、リソースをアプリケーションによって生成される <xref:System.Diagnostics.Process> コンポーネントに関連付けます。 プロセス <xref:System.Diagnostics.Process.Id%2A> は、コンピューターで現在実行されているプロセスに対してのみ取得できます。 プロセスが終了した後で、期限切れの識別子を渡した場合、<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> は例外をスローします。  
  
 特定のコンピューターでは、プロセスの識別子は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> は、最大で1つのプロセスを返します。 特定のアプリケーションを実行しているすべてのプロセスを取得する場合は、<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>を使用します。 指定したアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合、<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> は、関連付けられているすべてのプロセスを含む配列を返します。 これらの各プロセスに対して、その識別子に対してクエリを実行できます。 プロセス識別子は、Windows タスクマネージャーの [`Processes`] パネルで表示できます。 `PID` 列には、プロセスに割り当てられているプロセス識別子が表示されます。  
  
 `processId` パラメーターは <xref:System.Int32> (32 ビット符号付き整数) ですが、基になる Windows API では、同様の Api に `DWORD` (符号なし32ビット整数) が使用されます。 これは、歴史的な理由によるものです。
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>プロセス ID とネットワーク上のコンピューターの名前が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるリモート プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい <xref:System.Diagnostics.Process> コンポーネントを作成し、ネットワーク上のリモートコンピューター上のプロセスリソースに関連付けます。 プロセスリソースは、指定されたコンピューターに既に存在している必要があります。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> はシステムリソースを作成せず、リソースをアプリケーションによって生成される <xref:System.Diagnostics.Process> コンポーネントに関連付けます。 プロセス <xref:System.Diagnostics.Process.Id%2A> は、コンピューターで現在実行されているプロセスに対してのみ取得できます。 プロセスが終了した後で、期限切れの識別子を渡した場合、<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> は例外をスローします。  
  
 特定のコンピューターでは、プロセスの識別子は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> は、最大で1つのプロセスを返します。 特定のアプリケーションを実行しているすべてのプロセスを取得する場合は、<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>を使用します。 指定したアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合、<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> は、関連付けられているすべてのプロセスを含む配列を返します。 これらの各プロセスに対して、その識別子に対してクエリを実行できます。 プロセス識別子は、Windows タスクマネージャーの [`Processes`] パネルで表示できます。 `PID` 列には、プロセスに割り当てられているプロセス識別子が表示されます。  
  
 `machineName`を指定しない場合は、ローカルコンピューターが使用されます。 または、`machineName` を値 "." または空の文字列 ("") に設定して、ローカルコンピューターを指定することもできます。  
  
 `processId` パラメーターは <xref:System.Int32> (32 ビット符号付き整数) ですが、基になる Windows API では、同様の Api に `DWORD` (符号なし32ビット整数) が使用されます。 これは、歴史的な理由によるものです。   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。  
  
- または - 
<paramref name="machineName" /> パラメーターの構文が正しくありません。 名前の長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>ローカル コンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい <xref:System.Diagnostics.Process> コンポーネントの配列を作成し、ローカルコンピューター上のすべてのプロセスリソースに関連付けます。 プロセスリソースは、ローカルコンピューターに既に存在している必要があります。 <xref:System.Diagnostics.Process.GetProcesses%2A> はシステムリソースを作成せず、リソースをアプリケーションによって生成される <xref:System.Diagnostics.Process> コンポーネントに関連付けます。 オペレーティングシステム自体がバックグラウンドプロセスを実行しているため、この配列は空になりません。  
  
 コンピューター上で実行されているすべてのプロセスを取得しない場合は、<xref:System.Diagnostics.Process.GetProcessById%2A> または <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法を使用して、その番号を制限できます。 <xref:System.Diagnostics.Process.GetProcessById%2A> は、メソッドに渡すプロセス識別子によってシステムで識別されるプロセスに関連付けられた <xref:System.Diagnostics.Process> コンポーネントを作成します。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> は、メソッドに渡す実行可能ファイルを、関連付けられたプロセスリソースが共有する <xref:System.Diagnostics.Process> コンポーネントの配列を作成します。  
  
> [!NOTE]
>  サービスホストプロセス (svchost.exe) の同じインスタンス内に複数の Windows サービスを読み込むことができます。 GetProcesses は、これらの個々のサービスを識別しません。詳細については、「<xref:System.ServiceProcess.ServiceController.GetServices%2A>」を参照してください。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プロセスの一覧を読み取る対象のコンピューター。</param>
        <summary>指定したコンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>指定したコンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい <xref:System.Diagnostics.Process> コンポーネントの配列を作成し、指定した (通常はリモート) コンピューター上のすべてのプロセスリソースに関連付けます。 プロセスリソースは、ローカルコンピューターに既に存在している必要があります。 <xref:System.Diagnostics.Process.GetProcesses%2A> はシステムリソースを作成せず、リソースをアプリケーションによって生成される <xref:System.Diagnostics.Process> コンポーネントに関連付けます。 オペレーティングシステム自体がバックグラウンドプロセスを実行しているため、この配列は空になりません。  
  
 コンピューター上で実行されているすべてのプロセスを取得しない場合は、<xref:System.Diagnostics.Process.GetProcessById%2A> または <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法を使用して、その番号を制限できます。 <xref:System.Diagnostics.Process.GetProcessById%2A> は、メソッドに渡すプロセス識別子によってシステムで識別されるプロセスに関連付けられた <xref:System.Diagnostics.Process> コンポーネントを作成します。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> は、メソッドに渡す実行可能ファイルを、関連付けられたプロセスリソースが共有する <xref:System.Diagnostics.Process> コンポーネントの配列を作成します。  
  
 <xref:System.Diagnostics.Process.GetProcesses%2A> メソッドのこのオーバーロードは、通常、ネットワーク上のリモートコンピューター上で実行されているプロセスリソースの一覧を取得するために使用されますが、"." を渡すことによってローカルコンピューターを指定することもできます。  
  
> [!NOTE]
>  サービスホストプロセス (svchost.exe) の同じインスタンス内に複数の Windows サービスを読み込むことができます。 GetProcesses は、これらの個々のサービスを識別しません。詳細については、「<xref:System.ServiceProcess.ServiceController.GetServices%2A>」を参照してください。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有する既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するローカル コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい <xref:System.Diagnostics.Process> コンポーネントの配列を作成し、ローカルコンピューター上で同じ実行可能ファイルを実行しているすべてのプロセスリソースに関連付けます。 プロセスリソースはコンピューターに既に存在している必要があります。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> はシステムリソースを作成せず、アプリケーションによって生成される <xref:System.Diagnostics.Process> コンポーネントに関連付けます。 ローカルコンピューターで現在実行されていない実行可能ファイルに対して `processName` を指定できます。そのため、メソッドが返す配列は空にすることができます。  
  
 プロセス名は、Outlook などのプロセスのフレンドリ名です。この名前には、.exe 拡張子やパスは含まれません。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> は、同じ実行可能ファイルに関連付けられているすべてのプロセスを取得して操作する場合に役立ちます。 たとえば、実行可能ファイルの実行中のすべてのインスタンスをシャットダウンするために、実行可能ファイル名を `processName` パラメーターとして渡すことができます。  
  
 プロセス <xref:System.Diagnostics.Process.Id%2A> はシステム上の1つのプロセスリソースに対して一意ですが、ローカルコンピューター上の複数のプロセスで、`processName` パラメーターで指定されたアプリケーションを実行できます。 したがって、<xref:System.Diagnostics.Process.GetProcessById%2A> は、最大で1つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A> は、関連付けられているすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用してプロセスを操作する必要がある場合は、その識別子に対してこれらの各プロセスを順番にクエリできます。 プロセスリソースにはプロセス名だけではアクセスできませんが、プロセスリソースに関連付けられている <xref:System.Diagnostics.Process> コンポーネントの配列を取得した後は、システムリソースを開始、終了、または操作できます。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するリモート コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい <xref:System.Diagnostics.Process> コンポーネントの配列を作成し、指定したコンピューター上で同じ実行可能ファイルを実行しているすべてのプロセスリソースに関連付けます。 プロセスリソースはコンピューターに既に存在している必要があります。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> はシステムリソースを作成せず、アプリケーションによって生成される <xref:System.Diagnostics.Process> コンポーネントに関連付けます。 ローカルコンピューターで現在実行されていない実行可能ファイルに対して `processName` を指定できます。そのため、メソッドが返す配列は空にすることができます。  
  
 プロセス名は、Outlook などのプロセスのフレンドリ名です。この名前には、.exe 拡張子やパスは含まれません。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> は、同じ実行可能ファイルに関連付けられているすべてのプロセスを取得して操作する場合に役立ちます。 たとえば、実行可能ファイルの実行中のすべてのインスタンスをシャットダウンするために、実行可能ファイル名を `processName` パラメーターとして渡すことができます。  
  
 プロセス <xref:System.Diagnostics.Process.Id%2A> はシステム上の1つのプロセスリソースに対して一意ですが、ローカルコンピューター上の複数のプロセスで、`processName` パラメーターで指定されたアプリケーションを実行できます。 したがって、<xref:System.Diagnostics.Process.GetProcessById%2A> は、最大で1つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A> は、関連付けられているすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用してプロセスを操作する必要がある場合は、その識別子に対してこれらの各プロセスを順番にクエリできます。 プロセスリソースにはプロセス名だけではアクセスできませんが、プロセスリソースに関連付けられている <xref:System.Diagnostics.Process> コンポーネントの配列を取得した後は、システムリソースを開始、終了、または操作できます。  
  
 このオーバーロードを使用して、ローカルコンピューターおよびリモートコンピューター上のプロセスを取得できます。 "." を使用してローカルコンピューターを指定します。 既定では、ローカルコンピューターを使用する別のオーバーロードが存在します。  
  
 リモートコンピューター上のプロセスには、プロセスに関する統計情報などの情報を表示するためだけにアクセスできます。 リモートコンピューター上のプロセスを閉じたり、終了したり (<xref:System.Diagnostics.Process.Kill%2A>を使用) したり、プロセスを開始したりすることはできません。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="machineName" /> に接続する試みが失敗しました。

- または - 
プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを呼び出す。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのネイティブ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスを起動したときに、オペレーティング システムがプロセスに割り当てたハンドル。 システムはこのハンドルを使用して、プロセス属性の追跡を続けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションは、多くのプロセス情報および制御関数のパラメーターとして使用できるプロセスのハンドルを取得できます。 このハンドルを使用すると、<xref:System.Threading.WaitHandle> を初期化したり、プラットフォーム呼び出しを使用してネイティブメソッドを呼び出すことができます。  
  
 このプロセスハンドルはアプリケーションに対してプライベートです。つまり、プロセスハンドルを共有することはできません。 また、プロセスには <xref:System.Diagnostics.Process.Id%2A> プロセスも含まれています。これは、<xref:System.Diagnostics.Process.Handle%2A>とは異なり、システム全体で有効であり、そのためには一意である必要があります。  
  
 の呼び出しによって開始されたプロセスのみが、対応する <xref:System.Diagnostics.Process> インスタンスの <xref:System.Diagnostics.Process.Handle%2A> プロパティ <xref:System.Diagnostics.Process.Start%2A> 設定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが開始されていないか、終了しました。 この <see cref="T:System.Diagnostics.Process" /> インスタンスにプロセスが関連付けられていないので、<see cref="P:System.Diagnostics.Process.Handle" /> プロパティを読み取ることができません。  
  
- または - 
<see cref="T:System.Diagnostics.Process" /> インスタンスは実行中のプロセスにアタッチされていますが、フル アクセス権を持つハンドルを取得するために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.Handle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが開いたハンドルの数を取得します。</summary>
        <value>プロセスが開いたオペレーティング システム ハンドルの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、プロセスがオブジェクトを参照する方法を提供します。 プロセスでは、ファイル、リソース、メッセージキューなどのさまざまなオペレーティングシステムオブジェクトへのハンドルを取得できます。 オペレーティングシステムは、ハンドル数が0の場合にのみ、プロセスに関連付けられているメモリを解放します。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているプロセスが終了したかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Diagnostics.Process" /> コンポーネントが参照するオペレーティング システム プロセスが終了している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.HasExited%2A> の `true` の値は、関連付けられたプロセスが通常または異常に終了したことを示します。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A>を呼び出すことによって、関連付けられているプロセスを強制的に終了するように要求または強制できます。 ハンドルがプロセスに対して開かれている場合、オペレーティングシステムはプロセスが終了したときにプロセスメモリを解放しますが、ハンドル、終了コード、終了時刻など、プロセスに関する管理情報を保持します。 この情報を取得するには、<xref:System.Diagnostics.Process.ExitCode%2A> プロパティと <xref:System.Diagnostics.Process.ExitTime%2A> プロパティを使用します。 これらのプロパティは、このコンポーネントによって開始されたプロセスに対して自動的に設定されます。 システムプロセスに関連付けられているすべての <xref:System.Diagnostics.Process> コンポーネントが破棄され、終了したプロセスに対するハンドルがなくなったときに、管理情報がリリースされます。  
  
 プロセスは、コードとは無関係に終了できます。 このコンポーネントを使用してプロセスを開始した場合、関連付けられているプロセスが個別に終了した場合でも、システムによって <xref:System.Diagnostics.Process.HasExited%2A> の値が自動的に更新されます。  
  
> [!NOTE]
>  標準出力が非同期イベントハンドラーにリダイレクトされた場合、このプロパティが `true`を返したときに出力処理が完了していない可能性があります。 非同期イベント処理が完了したことを確認するには、<xref:System.Diagnostics.Process.HasExited%2A>を確認する前に、パラメーターを取らない <xref:System.Diagnostics.Process.WaitForExit> オーバーロードを呼び出します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を2秒間隔で最大10秒間取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">プロセスの終了コードを取得できませんでした。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.HasExited" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの一意の識別子を取得します。</summary>
        <value>この <see cref="T:System.Diagnostics.Process" /> インスタンスが参照する、システムが生成したプロセスの一意の識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス <xref:System.Diagnostics.Process.Id%2A> は、関連付けられているプロセスが実行されていない場合は無効です。 そのため、<xref:System.Diagnostics.Process.Id%2A> のプロパティを取得する前に、プロセスが実行されていることを確認する必要があります。 プロセスが終了するまで、プロセス識別子はシステム全体のプロセスを一意に識別します。  
  
 プロセス識別子を <xref:System.Diagnostics.Process.GetProcessById%2A> 方法に渡すことによって、ローカルコンピューターまたはリモートコンピューターで実行されているプロセスを新しい <xref:System.Diagnostics.Process> インスタンスに接続できます。 <xref:System.Diagnostics.Process.GetProcessById%2A> は、新しいコンポーネントを作成し、新しい <xref:System.Diagnostics.Process> インスタンスの <xref:System.Diagnostics.Process.Id%2A> プロパティを自動的に設定する `static` メソッドです。  
  
 プロセス識別子は、システムで再利用できます。 <xref:System.Diagnostics.Process.Id%2A> プロパティ値は、関連付けられているプロセスが実行されている場合にのみ一意です。 プロセスが終了すると、システムは関連のないプロセスに対して <xref:System.Diagnostics.Process.Id%2A> プロパティ値を再利用できます。  
  
 識別子はシステム上で一意であるため、<xref:System.Diagnostics.Process> インスタンスを渡す代わりに、他のスレッドに渡すことができます。 この操作により、システムリソースを節約しながら、プロセスが正しく識別されることを保証できます。  
  
   
  
## Examples  
 次の例は、アプリケーションの実行中のすべてのインスタンスの <xref:System.Diagnostics.Process.Id%2A> を取得する方法を示しています。 このコードは、メモ帳の新しいインスタンスを作成し、メモ帳のすべてのインスタンスを一覧表示し、ユーザーが <xref:System.Diagnostics.Process.Id%2A> 番号を入力して特定のインスタンスを削除できるようにします。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスの <see cref="P:System.Diagnostics.Process.Id" /> プロパティが設定されていません。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Kill">
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`Kill` メソッドはプロセスを強制的に終了しますが、<xref:System.Diagnostics.Process.CloseMainWindow%2A> は終了を要求します。 グラフィカルインターフェイスを持つプロセスが実行されている場合、そのメッセージループは待機状態になります。 メッセージループは、Windows メッセージがオペレーティングシステムによってプロセスに送信されるたびに実行されます。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> を呼び出すと、メインウィンドウを閉じる要求が送信されます。これは、適切な形式のアプリケーションで、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージループを取り消します。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> を呼び出すことによってプロセスを終了する要求では、アプリケーションが強制的に終了されることはありません。
アプリケーションは、終了する前にユーザーの確認を要求することも、終了を拒否することもできます。 アプリケーションを強制的に終了するには、`Kill` メソッドを使用します。

<xref:System.Diagnostics.Process.CloseMainWindow%2A> の動作は、[システム] メニューを使用してアプリケーションのメインウィンドウを閉じるユーザーの動作と同じです。
そのため、メインウィンドウを閉じてプロセスを終了する要求では、アプリケーションが直ちに終了することはありません。
  
> [!NOTE]
> <xref:System.Diagnostics.Process.Kill%2A> メソッドは、非同期的に実行されます。 `Kill` メソッドを呼び出した後、<xref:System.Diagnostics.Process.WaitForExit%2A> メソッドを呼び出してプロセスが終了するまで待機するか、<xref:System.Diagnostics.Process.HasExited%2A> プロパティを調べてプロセスが終了したかどうかを確認します。

> [!NOTE]
> <xref:System.Diagnostics.Process.WaitForExit%2A> メソッドと <xref:System.Diagnostics.Process.HasExited%2A> プロパティには、子孫プロセスの状態は反映されません。
> `Kill(entireProcessTree: true)` を使用すると、<xref:System.Diagnostics.Process.WaitForExit%2A> と <xref:System.Diagnostics.Process.HasExited%2A> は、指定されたプロセスが終了した後に、すべての子孫がまだ終了していない場合でも、終了が完了したことを示します。
  
プロセスによって編集されたデータまたはプロセスに割り当てられたリソースは、`Kill`を呼び出すと失われることがあります。 
`Kill` によって異常なプロセスが終了し、必要な場合にのみ使用する必要があります。
<xref:System.Diagnostics.Process.CloseMainWindow%2A> を使用すると、プロセスが正常に終了し、すべてのウィンドウが閉じます。そのため、インターフェイスを持つアプリケーションに適しています。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> が失敗した場合は、`Kill` を使用してプロセスを終了できます。
`Kill` は、グラフィカルインターフェイスを持たないプロセスを終了する唯一の方法です。
  
ローカルコンピューター上で実行されているプロセスに対してのみ `Kill` および <xref:System.Diagnostics.Process.CloseMainWindow%2A> を呼び出すことができます。
リモートコンピューター上のプロセスを終了させることはできません。 リモートコンピューター上で実行されているプロセスの情報のみを表示できます。
  
> [!NOTE]
> プロセスの終了中に `Kill` メソッドの呼び出しが行われた場合、アクセスが拒否されると <xref:System.ComponentModel.Win32Exception> がスローされます。
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスを即時中断します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられたプロセスを終了できませんでした。  
  
 - または -  
  
 プロセスを終了しています。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.Kill" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree"><see langword="true" /> の場合、関連付けられているプロセスとその子孫が中止されます。<see langword="false" /> の場合、関連付けられているプロセスのみが中止されます。</param>
        <summary>関連付けられているプロセスと、任意で、その子/子孫プロセスを直ちに停止します。</summary>
        <remarks><paramref name="entireProcessTree" /> が <see langword="true" />に設定されている場合、呼び出しに詳細を表示するアクセス許可がないプロセスは、子孫終了プロセスによって、そのプロセスが子孫であるかどうかを判断できないため、暗黙的にスキップされます。</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられたプロセスを終了できませんでした。  
  
 - または -  
  
 プロセスを終了しています。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.Kill" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。

- または -

呼び出しプロセスは、関連付けられているプロセスの子孫ツリーのメンバーです。</exception>
        <exception cref="T:System.AggregateException">関連付けられているプロセスの子孫ツリーの一部のプロセスを強制終了できませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態から解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部のオペレーティングシステムプロセスは、特別なモードで実行されます。 コンポーネントで <xref:System.Diagnostics.Process.EnterDebugMode%2A> を呼び出していない限り、これらのプロセスのプロパティを読み取ろうとしたり、これらのプロセスにアタッチしたりすることはできません。 特殊モードで実行されるこれらのプロセスにアクセスする必要がなくなった場合は、<xref:System.Diagnostics.Process.LeaveDebugMode%2A> を呼び出します。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスを実行しているコンピューターの名前を取得します。</summary>
        <value>関連付けられたプロセスを実行しているコンピューターの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リモートコンピューター上で実行されているプロセスの統計データとプロセス情報を表示できますが、リモートコンピューターで <xref:System.Diagnostics.Process.Start%2A>、<xref:System.Diagnostics.Process.CloseMainWindow%2A>、または <xref:System.Diagnostics.Process.Kill%2A> を呼び出すことはできません。  
  
> [!NOTE]
>  関連付けられたプロセスがローカルコンピューター上で実行されている場合、このプロパティはコンピューター名のピリオド (".") を返します。 正しいコンピューター名を取得するには、<xref:System.Environment.MachineName%2A?displayProperty=nameWithType> プロパティを使用する必要があります。  
  
   
  
## Examples  
 次の例を使用するには、まず、リモートコンピューター上でメモ帳のインスタンスを少なくとも1つ起動する必要があります。 この例では、メモ帳が実行されているリモートコンピューターの名前を要求し、各インスタンスの <xref:System.Diagnostics.Process.ProcessName%2A>、<xref:System.Diagnostics.Process.Id%2A>、および <xref:System.Diagnostics.Process.MachineName%2A> の各プロパティを表示します。  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン モジュールを取得します。</summary>
        <value>プロセスを開始する際に使用した <see cref="T:System.Diagnostics.ProcessModule" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスモジュールは、特定のプロセスに読み込まれる .dll または .exe ファイルを表します。 <xref:System.Diagnostics.Process.MainModule%2A> プロパティを使用すると、モジュール名、ファイル名、モジュールメモリの詳細など、プロセスの開始に使用する実行可能ファイルに関する情報を表示できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainModule" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 ビット プロセスが 64 ビット プロセスのモジュールにアクセスしようとしています。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
- または - 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン ウィンドウで使用するウィンドウ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスのメイン ウィンドウで使用する、システムが生成したウィンドウ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メインウィンドウは、現在フォーカスがあるプロセス (<xref:System.Windows.Forms.Form.TopLevel%2A> フォーム) によって開かれたウィンドウです。 <xref:System.Diagnostics.Process.Refresh%2A> メソッドを使用して、<xref:System.Diagnostics.Process> オブジェクトを更新し、現在のメインウィンドウのハンドルが変更されている場合はそのハンドルを取得する必要があります。 一般に、ウィンドウハンドルはキャッシュされているため、<xref:System.Diagnostics.Process.Refresh%2A> を事前に使用して、現在のハンドルを確実に取得できるようにします。  
  
 <xref:System.Diagnostics.Process.MainWindowHandle%2A> プロパティは、ローカルコンピューター上で実行されているプロセスに対してのみ取得できます。 <xref:System.Diagnostics.Process.MainWindowHandle%2A> プロパティは、プロセスに関連付けられているウィンドウを一意に識別する値です。  
  
 プロセスには、プロセスにグラフィカルインターフェイスがある場合にのみ、関連付けられているメインウィンドウがあります。 関連付けられたプロセスにメインウィンドウがない場合、<xref:System.Diagnostics.Process.MainWindowHandle%2A> 値は0になります。 この値は、非表示になっているプロセス (タスクバーに表示されないプロセス) でも0になります。 これは、タスクバーの右端にある通知領域にアイコンとして表示されるプロセスの場合に発生する可能性があります。  
  
 プロセスを開始したばかりで、メインウィンドウハンドルを使用する場合は、<xref:System.Diagnostics.Process.WaitForInputIdle%2A> メソッドを使用して、プロセスの開始を許可し、メインウィンドウハンドルが作成されていることを確認します。 この操作を行わない場合、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowHandle" /> が定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのメイン ウィンドウのキャプションを取得します。</summary>
        <value>プロセスのメイン ウィンドウのタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスには、プロセスにグラフィカルインターフェイスがある場合にのみ、関連付けられているメインウィンドウがあります。 関連付けられたプロセスにメインウィンドウがない場合 (<xref:System.Diagnostics.Process.MainWindowHandle%2A> がゼロの場合)、<xref:System.Diagnostics.Process.MainWindowTitle%2A> は空の文字列 ("") になります。 プロセスを開始したばかりで、メインウィンドウタイトルを使用する場合は、<xref:System.Diagnostics.Process.WaitForInputIdle%2A> メソッドを使用して、プロセスの開始を許可し、メインウィンドウハンドルが作成されていることを確認します。 それ以外の場合、例外がスローされます。  
  
> [!NOTE]
>  メインウィンドウは、現在フォーカスがあるウィンドウです。これは、プロセスの主要なウィンドウではない可能性があることに注意してください。 <xref:System.Diagnostics.Process.Refresh%2A> メソッドを使用して、<xref:System.Diagnostics.Process> オブジェクトを更新し、現在のメインウィンドウのハンドルが変更されている場合はそのハンドルを取得する必要があります。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動して、プロセスのメインウィンドウのキャプションを取得します。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティが定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最大サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに許可されるメモリ上のワーキング セットの最大サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、アプリケーションによって実行されるすべての命令を含むページが含まれます。これには、.dll ファイル内のページとシステム .dll ファイルも含まれます。 ワーキングセットのサイズが増加するにつれて、メモリの需要が増加します。  
  
 プロセスのワーキングセットのサイズは、最小値と最大値です。 プロセスリソースが作成されるたびに、プロセスのワーキングセットの最小サイズと同じ量のメモリがシステムによって予約されます。 仮想メモリマネージャーは、プロセスがアクティブなときに少なくとも最小メモリ容量を維持しようとしますが、最大サイズを超えることはありません。  
  
 既定のワーキングセットのサイズは、システムによって設定されます。 これらのサイズを変更するには、<xref:System.Diagnostics.Process.MaxWorkingSet%2A> と <xref:System.Diagnostics.Process.MinWorkingSet%2A> メンバーを使用します。 ただし、これらの値を設定しても、メモリが予約されているか常駐しているかは保証されません。  
  
> [!NOTE]
>  プロセスのワーキングセットのサイズを大きくすると、システムの他の部分から物理メモリを離れた場所に移動します。 ワーキングセットのサイズの最小値または最大値を要求しないようにしてください。そうしないと、システムのパフォーマンスが低下する可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最大サイズが正しくありません。 この値は、ワーキング セットの最小サイズ以上である必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
 - または -  
  
 プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
- または - 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最小サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに必要なメモリ上のワーキング セットの最小サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、アプリケーションによって実行されるすべての命令を含むページが含まれます。これには、.dll ファイル内のページとシステム .dll ファイルも含まれます。 ワーキングセットのサイズが増加するにつれて、メモリの需要が増加します。  
  
 プロセスのワーキングセットのサイズは、最小値と最大値です。 プロセスリソースが作成されるたびに、プロセスのワーキングセットの最小サイズと同じ量のメモリがシステムによって予約されます。 仮想メモリマネージャーは、プロセスがアクティブなときに少なくとも最小メモリ容量を維持しようとしますが、最大サイズを超えることはありません。  
  
 既定のワーキングセットのサイズは、システムによって設定されます。 これらのサイズを変更するには、<xref:System.Diagnostics.Process.MaxWorkingSet%2A> と <xref:System.Diagnostics.Process.MinWorkingSet%2A> メンバーを使用します。 ただし、これらの値を設定しても、メモリが予約されているか常駐しているかは保証されません。  
  
> [!NOTE]
>  プロセスのワーキングセットのサイズを大きくすると、システムの他の部分から物理メモリを離れた場所に移動します。 ワーキングセットのサイズの最小値または最大値を要求しないようにしてください。そうしないと、システムのパフォーマンスが低下する可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最小サイズが正しくありません。 この値は、ワーキング セットの最大サイズ以下にする必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
 - または -  
  
 プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
- または - 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに読み込まれたモジュールを取得します。</summary>
        <value>関連付けられたプロセスに読み込まれたモジュールを表す <see cref="T:System.Diagnostics.ProcessModule" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスモジュールは、特定のプロセスに読み込まれる .dll または .exe ファイルを表します。 <xref:System.Diagnostics.ProcessModule> インスタンスを使用すると、モジュール名、ファイル名、モジュールメモリの詳細など、モジュールに関する情報を表示できます。  
  
 プロセスでは、複数のモジュールをメモリに読み込むことができます。 たとえば、追加の .dll ファイルを読み込む .exe ファイルには、複数のモジュールがあります。  
  
 プロセスの開始後、このコレクションは、システムによってプロセスが読み込まれるまで空になります。 プロセスにメインウィンドウがある場合は、リストを取得したときにコレクションが空でないことを確認するために、このプロパティを取得する前に <xref:System.Diagnostics.Process.WaitForInputIdle%2A> を呼び出すことができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">システム プロセスまたはアイドル状態のプロセスのいずれかの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 これらのプロセスには、モジュールが存在しません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるページシステムメモリの現在のサイズ (バイト単位) を表します。 システムメモリはオペレーティングシステムによって使用される物理メモリであり、ページングされたプールと非ページプールに分かれています。 ページングされていないメモリ割り当ては、システムメモリに残り、仮想メモリページングファイルにはページングされません。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの "**プールの非ページバイト数**" パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> は、<xref:System.Diagnostics.Process.Exited> イベントを発生させる API メソッドです。 <xref:System.Diagnostics.Process.OnExited%2A> を呼び出すと、<xref:System.Diagnostics.Process.Exited> イベントが発生し、<xref:System.Diagnostics.Process> コンポーネントを使用してイベントを発生させる唯一の方法となります。 <xref:System.Diagnostics.Process.OnExited%2A> は、主にコンポーネントからクラスを派生させるときに使用します。  
  
 <xref:System.Diagnostics.Process.OnExited%2A>の代わりに、独自のイベントハンドラーを作成することもできます。 独自のイベントハンドラーデリゲートと独自のイベント処理メソッドを作成します。  
  
> [!NOTE]
>  Visual Studio 環境を使用している場合は、<xref:System.Diagnostics.Process> コンポーネントをフォームにドラッグし、アイコンをダブルクリックすると、イベントハンドラーデリゲート (AddOnExited) とイベント処理メソッド (Process1_Exited) が作成されます。 <xref:System.Diagnostics.Process.Exited> イベントが発生したときに実行するために作成したコードは、Process1_Exited プロシージャに入力されます。 <xref:System.Diagnostics.Process.OnExited%2A> メンバーは、実装されているため、作成する必要はありません。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、「[イベントの処理と発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次の例は、派生クラスで <xref:System.Diagnostics.Process.OnExited%2A> メソッドを使用する方法を示しています。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが、リダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームに行を書き込む度に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> イベントは、関連付けられた <xref:System.Diagnostics.Process> が、リダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームに改行文字で終了する行を書き込んだことを示します。  
  
 イベントは、<xref:System.Diagnostics.Process.StandardOutput%2A>での非同期読み取り操作中に有効になります。 非同期読み取り操作を開始するには、<xref:System.Diagnostics.Process>の <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームをリダイレクトし、イベントハンドラーを <xref:System.Diagnostics.Process.OutputDataReceived> イベントに追加して、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出す必要があります。 その後、<xref:System.Diagnostics.Process.OutputDataReceived> イベントは、プロセスが終了するか <xref:System.Diagnostics.Process.CancelOutputRead%2A>を呼び出すまで、リダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームに行を書き込むたびに通知します。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションは、<xref:System.Diagnostics.Process.WaitForExit%2A> メソッドを呼び出して、出力バッファーがフラッシュされたことを確認する必要があります。  
  
   
  
## Examples  
 次の例は、`ipconfig` コマンドのリダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームで非同期読み取り操作を実行する方法を示しています。  
  
 この例では、`OutputHandler` イベントハンドラーのイベントデリゲートを作成し、それを <xref:System.Diagnostics.Process.OutputDataReceived> イベントに関連付けます。 イベントハンドラーは、リダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームからテキスト行を受信し、テキストを書式設定して、後で例のコンソールウィンドウに表示される出力文字列に保存します。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスによって割り当てられたメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用される仮想メモリページングファイル内のメモリの現在のサイズをバイト単位で表します。 オペレーティングシステムは、仮想メモリページングファイルと物理メモリを使用して、各プロセスの仮想アドレス空間を管理します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリのページングファイルに転送できます。 プロセスのオペレーティングシステムによって使用されているメモリのサイズを取得するには、<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> プロパティを使用します。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ページファイル Bytes**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動し、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値によって返される値は、プロセスによって使用されるページング可能なシステムメモリの現在のサイズ (バイト単位) を表します。 システムメモリはオペレーティングシステムによって使用される物理メモリであり、ページングされたプールと非ページプールに分かれています。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリのページングファイルに転送できます。 プロセスによって使用されるアプリケーションメモリのサイズを取得するには、<xref:System.Diagnostics.Process.PagedMemorySize64%2A> プロパティを使用します。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**Pool Bytes (ページバイト数)** パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスによって割り当てられた、仮想メモリ ページング ファイルに書き込むことができたメモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値によって返される値は、プロセスが開始してから使用した仮想メモリページングファイル内のメモリの最大サイズをバイト単位で表します。 オペレーティングシステムは、仮想メモリページングファイルと物理メモリを使用して、各プロセスの仮想アドレス空間を管理します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリのページングファイルに転送できます。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ページファイルバイトピーク**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた仮想メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスが開始してから使用した仮想メモリの最大サイズをバイト単位で表します。 オペレーティングシステムは、物理メモリに読み込まれたページか、ディスク上の仮想メモリページングファイルに格納されているページに、各プロセスの仮想アドレス空間をマップします。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**仮想バイトピーク**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのピーク ワーキング セット サイズをバイト単位で取得します。</summary>
        <value>関連づけられたプロセスが一度に要求した物理メモリのバイト単位での最大容量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリを含む、プロセスによって実行されるすべての命令を含むページが含まれます。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される物理メモリの最大量をバイト数として取得します。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた物理メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスが開始してから使用されるワーキングセットメモリの最大サイズをバイト単位で表します。 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリからの指示を含め、プロセスが実行するすべての命令を含むページが含まれます。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ワーキングセットのピーク時**のパフォーマンスカウンターと同じです。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メイン ウィンドウのフォーカス時に、オペレーティング システムによって関連付けられたプロセスの優先順位を一時的に上げるかどうかを示す値を取得または設定します。</summary>
        <value>待機状態から抜けたときにプロセスの優先順位を動的に上げる場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 優先度クラスに動的優先順位列挙値 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>、<xref:System.Diagnostics.ProcessPriorityClass.High>、または <xref:System.Diagnostics.ProcessPriorityClass.RealTime>) のいずれかがあるプロセスでスレッドが実行されると、待機状態から除外されたときに、スレッドの優先順位が一時的にブーストされます。 この操作により、他のプロセスが現在のスレッドの処理を中断するのを防ぐことができます。 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 設定は、プロセスによって作成されたすべての既存のスレッドとスレッドに影響します。 通常の動作を復元するには、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> プロパティを `false`に設定します。  
  
> [!NOTE]
>  優先順位を高くすると、重要なオペレーティングシステムやネットワーク機能からリソースがドレインされ、他のオペレーティングシステムのタスクに関する問題が発生する可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースから priority boost 情報を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの全体的な優先順位カテゴリを取得または設定します。</summary>
        <value>プロセスの <see cref="P:System.Diagnostics.Process.BasePriority" /> を計算するときに使用する、関連付けられたプロセスの優先順位カテゴリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス優先度クラスは、スレッドの優先度レベルの範囲を含みます。 プロセスで実行されている優先順位が異なるスレッドは、プロセスの優先度クラスと比較して実行されます。 Win32 では、クラスごとに7つの基本優先度レベルを持つ4つの優先度クラスが使用されます。 これらのプロセス優先度クラスは <xref:System.Diagnostics.ProcessPriorityClass> 列挙にキャプチャされます。これにより、プロセスの優先順位を <xref:System.Diagnostics.ProcessPriorityClass.Idle>、<xref:System.Diagnostics.ProcessPriorityClass.Normal>、<xref:System.Diagnostics.ProcessPriorityClass.High>、<xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>、<xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>、または <xref:System.Diagnostics.ProcessPriorityClass.RealTime>に設定できます。 プロセッサにアクセスするためにプロセスを事前に進める必要がある場合、オペレーティングシステムによって基本優先度レベルを変更することができます。 また、待機状態から除外されたスレッドの優先度レベルを一時的に上げるように <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> を設定することもできます。 プロセスが待機状態に戻ると、優先順位がリセットされます。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> プロパティを使用すると、プロセスに割り当てられている開始の優先順位を表示できます。 ただし、読み取り専用であるため、<xref:System.Diagnostics.Process.BasePriority%2A> プロパティを使用してプロセスの優先順位を設定することはできません。 優先順位を変更するには、<xref:System.Diagnostics.Process.PriorityClass%2A> プロパティを使用します。このプロパティは、プロセスの全体的な優先順位カテゴリを取得または設定します。  
  
 システムモニタを使用して、優先度クラスを表示することはできません。 次の表は、<xref:System.Diagnostics.Process.BasePriority%2A> と <xref:System.Diagnostics.Process.PriorityClass%2A> の値の関係を示しています。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセスのリソースからプロセス優先度情報を設定できないか、取得できませんでした。  
  
 - または -  
  
 プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列挙体で定義されている有効な値が使用されていないため、優先度クラスを設定できません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないバイト数。</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるメモリの現在のサイズ (バイト単位) を表し、他のプロセスと共有することはできません。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**Private Bytes**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの特権プロセッサ時間を取得します。</summary>
        <value>プロセスが、オペレーティング システム コア内でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの名前を取得します。</summary>
        <value>システムで使用する、ユーザーがプロセスを識別するための名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> プロパティは、Outlook などの実行可能ファイル名を保持します。この名前には、.exe 拡張子やパスは含まれません。 これは、同じ実行可能ファイルに関連付けられているすべてのプロセスを取得して操作する場合に役立ちます。  
  
> [!NOTE]
>  [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] のオペレーティングシステムでは、プロセスモジュール情報を取得できない場合、<xref:System.Diagnostics.Process.ProcessName%2A> プロパティは15文字に切り捨てられることがあります。  
  
 <xref:System.Diagnostics.Process.GetProcessesByName%2A>を呼び出して、実行可能ファイル名を渡して、指定されたコンピューター上で実行されているすべてのインスタンスを含む配列を取得できます。 たとえば、この配列を使用して、実行可能ファイルの実行中のすべてのインスタンスをシャットダウンすることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスに ID がないか、<see cref="T:System.Diagnostics.Process" /> に関連付けられているプロセスがありません。  
  
- または - 
関連付けられたプロセスが終了しました。</exception>
        <exception cref="T:System.NotSupportedException">プロセスはこのコンピューター上のものではありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスでのスレッドの実行をスケジュールできるプロセッサを取得または設定します。</summary>
        <value>関連付けられたプロセスのスレッドを実行できるプロセッサを示すビットマスク。 既定値は、コンピューターのプロセッサ数によって異なります。 既定値は 2 <sup>n</sup> -1 です。ここで、n はプロセッサ数です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 以降では、プロセス内のスレッドはプロセッサからプロセッサに移行でき、各移行でプロセッサキャッシュが再読み込みされます。 システム負荷が高い場合、特定のスレッドを実行するプロセッサを指定すると、プロセッサキャッシュを再読み込みする回数を減らすことでパフォーマンスを向上させることができます。 プロセッサとスレッド間の関連付けは、プロセッサ関係と呼ばれます。  
  
 各プロセッサは、1つのビットとして表現されます。 ビット0はプロセッサ1、ビット1はプロセッサ2、などのようになります。 ビットを値1に設定すると、対応するプロセッサがスレッド割り当てに対して選択されます。 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 値を0に設定すると、オペレーティングシステムのスケジュールアルゴリズムによってスレッドのアフィニティが設定されます。 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 値が0以外の値に設定されている場合、値は、選択対象のプロセッサを指定するビットマスクとして解釈されます。  
  
 次の表は、8プロセッサシステムの <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 値の選択を示しています。  
  
|ビットマップ|バイナリ値|対象のプロセッサ|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1および2|  
|0x0007|00000000 00000111|1、2、3|  
|0x0009|00000000 00001001|1および4|  
|0x007F|00000000 01111111|1、2、3、4、5、6、7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセスのリソースから <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 情報を設定できないか、取得できませんでした。  
  
- または - 
プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できませんでした。  
  
- または - 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス コンポーネントにキャッシュされている関連付けられたプロセスに関するすべての情報を破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Refresh%2A> が呼び出された後、各プロパティに関する情報の最初の要求によって、プロセスコンポーネントは、関連付けられているプロセスから新しい値を取得します。  
  
 <xref:System.Diagnostics.Process> コンポーネントがプロセスリソースに関連付けられている場合、<xref:System.Diagnostics.Process> のプロパティ値は、関連付けられているプロセスの状態に従って直ちに設定されます。 関連付けられたプロセスに関する情報が後で変更された場合、これらの変更は <xref:System.Diagnostics.Process> コンポーネントのキャッシュされた値に反映されません。 <xref:System.Diagnostics.Process> コンポーネントは、プロセスリソースが関連付けられているときのスナップショットです。 関連付けられたプロセスの現在の値を表示するには、<xref:System.Diagnostics.Process.Refresh%2A> メソッドを呼び出します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を2秒間隔で最大10秒間取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのユーザー インターフェイスが応答するかどうかを示す値を取得します。</summary>
        <value>関連付けられたプロセスのユーザー インターフェイスがシステムに応答する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスにユーザーインターフェイスがある場合、<xref:System.Diagnostics.Process.Responding%2A> プロパティはユーザーインターフェイスに連絡して、プロセスがユーザー入力に応答しているかどうかを判断します。 インターフェイスがすぐに応答しない場合、<xref:System.Diagnostics.Process.Responding%2A> プロパティは `false`を返します。 関連付けられたプロセスのインターフェイスが応答を停止したかどうかを判断するには、このプロパティを使用します。  
  
 プロセスに <xref:System.Diagnostics.Process.MainWindowHandle%2A>がない場合、このプロパティは `true`を返します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Responding" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスへのネイティブ ハンドルを取得します。</summary>
        <value>このプロセスへのネイティブ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、呼び出し元のコンポーネントがプロセスを開始した場合にのみ使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのターミナル サービス セッション識別子を取得します。</summary>
        <value>関連付けられたプロセスのターミナル サービス セッション識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> プロパティは、アプリケーションが現在実行されているセッションを識別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">このプロセスに関連付けられているセッションはありません。</exception>
        <exception cref="T:System.InvalidOperationException">このセッション識別子に関連付けられているプロセスはありません。  
  
 - または -  
  
 関連付けられたプロセスが、このコンピューター上にありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのエラー出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準エラー ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> がテキストを標準エラーストリームに書き込む場合、そのテキストは通常、コンソールに表示されます。 <xref:System.Diagnostics.Process.StandardError%2A> ストリームをリダイレクトすることにより、プロセスのエラー出力を操作または非表示にすることができます。 たとえば、テキストをフィルター処理したり、異なる形式を設定したり、コンソールと指定したログファイルの両方に出力を書き込むことができます。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.StandardError%2A>を使用するには、<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> を `false`に設定し、<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> を `true`に設定する必要があります。 それ以外の場合、<xref:System.Diagnostics.Process.StandardError%2A> ストリームからの読み取りでは、例外がスローされます。  
  
 リダイレクトされた <xref:System.Diagnostics.Process.StandardError%2A> ストリームは、同期的または非同期的に読み取ることができます。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>、<xref:System.IO.StreamReader.ReadToEnd%2A> などのメソッドは、プロセスのエラー出力ストリームに対して同期読み取り操作を実行します。 これらの同期読み取り操作は、関連付けられた <xref:System.Diagnostics.Process> が <xref:System.Diagnostics.Process.StandardError%2A> ストリームに書き込むか、ストリームを閉じるまで完了しません。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> は、<xref:System.Diagnostics.Process.StandardError%2A> ストリームで非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 同期読み取り操作では、<xref:System.Diagnostics.Process.StandardError%2A> ストリームから読み取った呼び出し元と、そのストリームに書き込む子プロセスとの間に依存関係が生じます。 これらの依存関係によって、デッドロック状態が発生する可能性があります。 呼び出し元が子プロセスのリダイレクトされたストリームから読み取る場合は、子に依存します。 呼び出し元は、読み取り操作で、子がストリームに書き込むか、ストリームを閉じるまで待機します。 子プロセスは、リダイレクトされたストリームを埋めるために十分なデータを書き込むときに、親に依存します。 子プロセスは、親が完全なストリームから読み取るか、ストリームを閉じるまで、次の書き込み操作で待機します。 デッドロック状態は、呼び出し元と子プロセスが操作を完了するために互いに待機し、どちらも続行できない場合に発生します。 呼び出し元と子プロセスの間の依存関係を評価することによって、デッドロックを回避できます。  

このセクションの最後の2つの例では、<xref:System.Diagnostics.Process.Start%2A> メソッドを使用して、 *Write500Lines*という名前の実行可能ファイルを起動します。 次の例には、ソースコードが含まれています。

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

次の例は、リダイレクトされたエラーストリームから読み取り、子プロセスが終了するまで待機する方法を示しています。 `p.WaitForExit`する前に `p.StandardError.ReadToEnd` を呼び出すことによって、デッドロック状態を回避します。 デッドロック状態が発生するのは、親プロセスが `p.StandardError.ReadToEnd` 前に `p.WaitForExit` を呼び出し、子プロセスが、リダイレクトされたストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスが終了するまで無期限に待機します。 子プロセスは、親が完全な <xref:System.Diagnostics.Process.StandardError%2A> ストリームから読み取るのを無期限に待機します。   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

標準出力と標準エラーストリームの両方からすべてのテキストを読み取ると、同様の問題が発生します。 次の例では、両方のストリームに対して読み取り操作を実行します。 <xref:System.Diagnostics.Process.StandardError%2A> ストリームで非同期の読み取り操作を実行することによって、デッドロック状態を回避します。 デッドロック状態が発生するのは、親プロセスが `p.StandardOutput.ReadToEnd` 続けて `p.StandardError.ReadToEnd` を呼び出し、子プロセスがそのエラーストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスが <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームを閉じるまで無期限に待機します。 子プロセスは、親が完全な <xref:System.Diagnostics.Process.StandardError%2A> ストリームから読み取るのを無期限に待機します。  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

非同期の読み取り操作を使用すると、これらの依存関係とデッドロックの可能性を回避できます。 または、2つのスレッドを作成し、各ストリームの出力を個別のスレッドで読み取ることによって、デッドロック状態を回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 <xref:System.Diagnostics.Process> のリダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームでのすべての読み取り操作は同じモードである必要があります。 たとえば、<xref:System.Diagnostics.Process.StandardError%2A> ストリームで <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことによって <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> に従わないでください。その逆も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> を呼び出し、<xref:System.Diagnostics.Process.StandardError%2A> ストリームの <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことができます。  
  
   
  
## Examples  
 次の例では、ユーザーが指定した引数と共に `net use` コマンドを使用して、ネットワークリソースをマップします。 次に、net コマンドの標準エラーストリームを読み取り、コンソールに書き込みます。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの入力の書き込みに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準入力ストリームの書き込みに使用できる <see cref="T:System.IO.StreamWriter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> は、標準入力ストリーム (通常はキーボード) から入力テキストを読み取ることができます。 <xref:System.Diagnostics.Process.StandardInput%2A> ストリームをリダイレクトすることにより、プログラムで入力を指定できます。 たとえば、キーボード入力を使用する代わりに、指定されたファイルの内容または別のアプリケーションからの出力のテキストを指定できます。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.StandardInput%2A>を使用するには、<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> を `false`に設定し、<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> を `true`に設定する必要があります。 それ以外の場合、<xref:System.Diagnostics.Process.StandardInput%2A> ストリームへの書き込みでは、例外がスローされます。  
  
   
  
## Examples  
 次の例は、プロセスの <xref:System.Diagnostics.Process.StandardInput%2A> ストリームをリダイレクトする方法を示しています。 この例では、リダイレクトされた入力を使用して `sort` コマンドを開始します。 次に、ユーザーにテキストを求めるプロンプトが表示され、リダイレクトされた <xref:System.Diagnostics.Process.StandardInput%2A> ストリームを使用して `sort` プロセスに渡されます。 `sort` の結果は、コンソールでユーザーに表示されます。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> が <see langword="false" /> に設定されているため、<see cref="P:System.Diagnostics.Process.StandardInput" /> ストリームが定義されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのテキスト出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準出力ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> が標準ストリームにテキストを書き込む場合、そのテキストは通常、コンソールに表示されます。 <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームをリダイレクトすることにより、プロセスの出力を操作または非表示にすることができます。 たとえば、テキストをフィルター処理したり、異なる形式を設定したり、コンソールと指定したログファイルの両方に出力を書き込むことができます。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.StandardOutput%2A>を使用するには、<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> を `false`に設定し、<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> を `true`に設定する必要があります。 それ以外の場合、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームからの読み取りでは、例外がスローされます。  
  
 リダイレクトされた <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームは、同期的または非同期的に読み取ることができます。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>、<xref:System.IO.StreamReader.ReadToEnd%2A> などのメソッドは、プロセスの出力ストリームに対して同期読み取り操作を実行します。 これらの同期読み取り操作は、関連付けられた <xref:System.Diagnostics.Process> が <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームに書き込むか、ストリームを閉じるまで完了しません。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> は、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームで非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 同期読み取り操作では、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームから読み取った呼び出し元と、そのストリームに書き込む子プロセスとの間に依存関係が生じます。 これらの依存関係によって、デッドロック状態が発生する可能性があります。 呼び出し元が子プロセスのリダイレクトされたストリームから読み取る場合は、子に依存します。 呼び出し元は、読み取り操作で、子がストリームに書き込むか、ストリームを閉じるまで待機します。 子プロセスは、リダイレクトされたストリームを埋めるために十分なデータを書き込むときに、親に依存します。 子プロセスは、親が完全なストリームから読み取るか、ストリームを閉じるまで、次の書き込み操作で待機します。 デッドロック状態は、呼び出し元と子プロセスが操作を完了するために互いに待機し、どちらも続行できない場合に発生します。 呼び出し元と子プロセスの間の依存関係を評価することによって、デッドロックを回避できます。  

このセクションの最後の2つの例では、<xref:System.Diagnostics.Process.Start%2A> メソッドを使用して、 *Write500Lines*という名前の実行可能ファイルを起動します。 次の例には、ソースコードが含まれています。

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

次の例は、リダイレクトされたストリームから読み取り、子プロセスが終了するまで待機する方法を示しています。 この例では、`p.WaitForExit`する前に `p.StandardOutput.ReadToEnd` を呼び出すことによって、デッドロック状態を回避します。 デッドロック状態が発生するのは、親プロセスが `p.StandardOutput.ReadToEnd` 前に `p.WaitForExit` を呼び出し、子プロセスが、リダイレクトされたストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスが終了するまで無期限に待機します。 子プロセスは、親が完全な <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームから読み取るのを無期限に待機します。  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

標準出力と標準エラーストリームの両方からすべてのテキストを読み取ると、同様の問題が発生します。 次の例では、両方のストリームに対して読み取り操作を実行します。 <xref:System.Diagnostics.Process.StandardError%2A> ストリームで非同期の読み取り操作を実行することによって、デッドロック状態を回避します。 デッドロック状態が発生するのは、親プロセスが `p.StandardOutput.ReadToEnd` 続けて `p.StandardError.ReadToEnd` を呼び出し、子プロセスがそのエラーストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスが <xref:System.Diagnostics.Process.StandardOutput%2A> ストリームを閉じるまで無期限に待機します。 子プロセスは、親が完全な <xref:System.Diagnostics.Process.StandardError%2A> ストリームから読み取るのを無期限に待機します。   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 非同期の読み取り操作を使用すると、これらの依存関係とデッドロックの可能性を回避できます。 または、2つのスレッドを作成し、各ストリームの出力を個別のスレッドで読み取ることによって、デッドロック状態を回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 <xref:System.Diagnostics.Process> のリダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームでのすべての読み取り操作は同じモードである必要があります。 たとえば、<xref:System.Diagnostics.Process.StandardOutput%2A> ストリームで <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことによって <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> に従わないでください。その逆も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> を呼び出し、<xref:System.Diagnostics.Process.StandardError%2A> ストリームの <xref:System.IO.StreamReader.ReadLine%2A> を呼び出すことができます。  
  
   
  
## Examples  
 次の例では、ipconfig コマンドを実行し、その標準出力を例のコンソールウィンドウにリダイレクトします。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>プロセス リソースを起動し、<see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> プロパティで指定されたプロセス リソースを起動 (または再利用) し、コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースが起動された場合は <see langword="true" />。新しいプロセス リソースが起動されなかった場合は <see langword="false" /> (既存のプロセスを再利用した場合など)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、プロセスリソースを起動し、現在の <xref:System.Diagnostics.Process> コンポーネントに関連付けます。 戻り値 `true` は、新しいプロセスリソースが開始されたことを示します。 <xref:System.Diagnostics.Process.StartInfo%2A> プロパティの <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> メンバーによって指定されたプロセスリソースが既にコンピューター上で実行されている場合、追加のプロセスリソースは起動されません。 代わりに、実行中のプロセスリソースが再利用され、`false` が返されます。  
  
 ClickOnce アプリケーションを起動するには、最初にアプリケーションをインストールした場所 (Web アドレスなど) を指定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
> [!NOTE]
>  Visual Studio を使用している場合、<xref:System.Diagnostics.Process.Start%2A> メソッドのこのオーバーロードは、<xref:System.Diagnostics.Process> コンポーネントをデザイナーにドラッグした後にコードに挿入したものです。 [`Properties`] ウィンドウを使用して [`StartInfo`] カテゴリを展開し、適切な値を `FileName` プロパティに書き込みます。 変更内容がフォームの `InitializeComponent` プロシージャに表示されます。  
  
 <xref:System.Diagnostics.Process.Start%2A> のこのオーバーロードは、`static` メソッドではありません。 <xref:System.Diagnostics.Process> クラスのインスタンスから呼び出す必要があります。 <xref:System.Diagnostics.Process.Start%2A>を呼び出す前に、最初にこの <xref:System.Diagnostics.Process> インスタンスの <xref:System.Diagnostics.Process.StartInfo%2A> プロパティ情報を指定する必要があります。これは、開始するプロセスリソースを決定するためにその情報が使用されるためです。  
  
 <xref:System.Diagnostics.Process.Start%2A> メソッドの他のオーバーロードは、`static` メンバーです。 メソッドのオーバーロードを呼び出す前に、<xref:System.Diagnostics.Process> コンポーネントのインスタンスを作成する必要はありません。 代わりに、<xref:System.Diagnostics.Process> クラス自体に対して <xref:System.Diagnostics.Process.Start%2A> を呼び出すことができ、プロセスが開始された場合は新しい <xref:System.Diagnostics.Process> コンポーネントが作成されます。 または、プロセスが再利用された場合は `null` が返されます。 Process リソースは、<xref:System.Diagnostics.Process.Start%2A> メソッドによって返される新しい <xref:System.Diagnostics.Process> コンポーネントに自動的に関連付けられます。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> メンバーを使用すると、Windows `Start` メニューの [`Run`] ダイアログボックスの機能を複製できます。 コマンドラインに入力できるものは、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティに適切な値を設定することによって開始できます。 設定する必要がある唯一の <xref:System.Diagnostics.Process.StartInfo%2A> プロパティは、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティです。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティは実行可能ファイルである必要はありません。 拡張子がシステムにインストールされているアプリケーションに関連付けられている任意のファイルの種類を指定できます。 たとえば、メモ帳などのテキストファイルがエディターに関連付けられている場合は、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティに拡張子 .txt を付けることができます。また、Microsoft Word などのワードプロセッシングツールで .doc ファイルに関連付けられている場合は、.doc 拡張子を付けることができます。  
  
 コマンドラインでは、特定の種類のファイルに対して実行するアクションを指定できます。 たとえば、ドキュメントを印刷したり、テキストファイルを編集したりできます。 これらのアクションは、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティの <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> メンバーを使用して指定します。 その他の種類のファイルについては、[`Run`] ダイアログボックスでファイルを起動するときに、コマンドライン引数を指定できます。 たとえば、ブラウザーを <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>として指定した場合は、URL を引数として渡すことができます。 これらの引数は、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティの <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> メンバーで指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET の Web ページまたはサーバーコントロールで <xref:System.Diagnostics.Process.Start%2A> メソッドを使用すると、新しいプロセスはアクセス許可が制限された Web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 <xref:System.Diagnostics.Process.Start%2A> を使用してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは、その <xref:System.Diagnostics.Process.HasExited%2A> プロパティを使用して確認できます。  
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 プロセスコンポーネントの <xref:System.Diagnostics.Process.StartInfo%2A> プロパティに <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> が `true` 場合は、`main()` メソッドで属性 `[STAThread]` を設定して、アプリケーションにスレッドモデルが設定されていることを確認してください。 それ以外の場合は、マネージスレッドが `unknown` 状態になるか、`MTA` 状態になることがあります。後者の場合は、`true`中 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> と競合します。 一部のメソッドでは、アパートメントの状態を `unknown`しないようにする必要があります。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッドが検出されると、既定では `MTA`になり、設定されたアパートメント状態は変更できません。 ただし、`MTA` を使用すると、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、<xref:System.Diagnostics.Process> クラスのインスタンスを使用してプロセスを開始します。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> にファイル名が指定されませんでした。

- または -

<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティの <see cref="P:System.Diagnostics.Process.StartInfo" /> メンバーは <see langword="true" /> ですが、 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> は <see langword="true" />です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">ファイル名やコマンド ライン引数など、プロセスの起動に使用する情報が格納されている <see cref="T:System.Diagnostics.ProcessStartInfo" />。</param>
        <summary>プロセス起動情報 (起動するプロセスのファイル名など) が格納されているパラメーターで指定されたプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、<xref:System.Diagnostics.ProcessStartInfo> インスタンスを指定することによってプロセスリソースを開始します。 オーバーロードによって、リソースが新しい <xref:System.Diagnostics.Process> オブジェクトに関連付けられます。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始されず `null` が返されます。  
  
 このオーバーロードを使用すると、最初に新しい <xref:System.Diagnostics.Process> インスタンスを作成せずにプロセスを開始できます。 このオーバーロードを <xref:System.Diagnostics.ProcessStartInfo> パラメーターと共に使用することは、新しい <xref:System.Diagnostics.Process> インスタンスを作成し、その <xref:System.Diagnostics.Process.StartInfo%2A> プロパティを設定し、<xref:System.Diagnostics.Process> インスタンスの <xref:System.Diagnostics.Process.Start%2A> を呼び出すための明示的な手順の代替手段です。  
  
 パラメーターとして <xref:System.Diagnostics.ProcessStartInfo> インスタンスを使用すると、プロセスを開始するために呼び出しに渡される内容を最も制御して <xref:System.Diagnostics.Process.Start%2A> を呼び出すことができます。 ファイル名またはファイル名と引数だけを渡す必要がある場合は、新しい <xref:System.Diagnostics.ProcessStartInfo> インスタンスを作成する必要はありませんが、これはオプションです。 設定する必要がある唯一の <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> プロパティは、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティです。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティは、実行可能ファイルを表す必要はありません。 拡張子がシステムにインストールされているアプリケーションに関連付けられている任意のファイルの種類を指定できます。 たとえば、メモ帳などのテキストファイルがエディターに関連付けられている場合は、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティに拡張子 .txt を付けることができます。また、Microsoft Word などのワードプロセッシングツールで .doc ファイルに関連付けられている場合は、.doc 拡張子を付けることができます。  
  
 ClickOnce アプリケーションを起動するには、最初にアプリケーションをインストールした場所 (Web アドレスなど) を指定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> インスタンスの <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> プロパティと <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> プロパティが設定されている場合、アンマネージ `CreateProcessWithLogonW` 関数が呼び出されます。これにより、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> プロパティ値が `true` か、<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> プロパティ値が <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>場合でも、新しいウィンドウでプロセスが開始されます。 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> プロパティが `null`の場合、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> プロパティは UPN 形式 (*ユーザー*@*DNS_domain_name*である必要があります。   
  
 他のオーバーロードとは異なり、パラメーターを持たない <xref:System.Diagnostics.Process.Start%2A> のオーバーロードは、`static` のメンバーではありません。 <xref:System.Diagnostics.Process> インスタンスを既に作成し、開始情報 (ファイル名を含む) を指定し、プロセスリソースを起動して既存の <xref:System.Diagnostics.Process> インスタンスに関連付ける場合は、そのオーバーロードを使用します。 既存のコンポーネントのプロセスを開始するのではなく、新しい <xref:System.Diagnostics.Process> コンポーネントを作成する場合は、`static` のオーバーロードのいずれかを使用します。 このオーバーロードとパラメーターを持たないオーバーロードの両方で、<xref:System.Diagnostics.ProcessStartInfo> インスタンスを使用してプロセスリソースの開始情報を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET の Web ページまたはサーバーコントロールで <xref:System.Diagnostics.Process.Start%2A> メソッドを使用すると、新しいプロセスはアクセス許可が制限された Web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 <xref:System.Diagnostics.Process.Start%2A> を使用してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは、その <xref:System.Diagnostics.Process.HasExited%2A> プロパティを使用して確認できます。  
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 `startInfo` パラメーターに <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> が `true` 場合は、`main()` メソッドで属性 `[STAThread]` を設定して、アプリケーションにスレッドモデルを設定していることを確認します。 それ以外の場合は、マネージスレッドが `unknown` 状態になるか、`MTA` 状態になることがあります。後者の場合は、`true`中 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> と競合します。 一部のメソッドでは、アパートメントの状態を `unknown`しないようにする必要があります。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッドが検出されると、既定では `MTA`になり、設定されたアパートメント状態は変更できません。 ただし、`MTA` を使用すると、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、まず Internet Explorer のインスタンスを生成し、ブラウザーにお気に入りフォルダーの内容を表示します。 その後、Internet Explorer の他のインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動しているときに最小化されたウィンドウで Internet Explorer を起動します。  
  
 このメソッドの他の使用例については、<xref:System.Diagnostics.ProcessStartInfo> クラスの個々のプロパティを参照してください。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティにファイル名が指定されませんでした。  
  
- または - 
<paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティも <see langword="true" /> です。  
  
- または - 
<paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> プロパティは <see langword="null" /> でも空でもないか、または <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> プロパティは <see langword="null" /> ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startInfo" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  

- または - 
<paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティに指定されたファイルを見つけることができませんでした。
          
- または - 
引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行する文書またはアプリケーション ファイルの名前。</param>
        <summary>文書またはアプリケーション ファイルの名前を指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、ファイル名を指定してプロセスリソースを開始します。 オーバーロードによって、リソースが新しい <xref:System.Diagnostics.Process> オブジェクトに関連付けられます。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始されず `null` が返されます。  
  
 このオーバーロードを使用すると、最初に新しい <xref:System.Diagnostics.Process> インスタンスを作成せずにプロセスを開始できます。 オーバーロードは、新しい <xref:System.Diagnostics.Process> インスタンスを作成し、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティの <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> メンバーを設定し、<xref:System.Diagnostics.Process> インスタンスの <xref:System.Diagnostics.Process.Start%2A> を呼び出すための明示的な手順の代わりに使用されます。  
  
 ClickOnce アプリケーションを起動するには、アプリケーションを最初にインストールした場所 (Web アドレスなど) に `fileName` パラメーターを設定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
 ファイル名を指定してプロセスを開始することは、Windows の [`Start`] メニューの [`Run`] ダイアログボックスに情報を入力することと似ています。 このため、ファイル名は実行可能ファイルを表す必要はありません。 これは、システムにインストールされているアプリケーションに拡張機能が関連付けられている任意のファイルの種類にすることができます。 たとえば、メモ帳などのテキストファイルがエディターに関連付けられている場合、ファイル名の拡張子は .txt にすることができます。また、Microsoft Word などのワードプロセッシングツールを使用して .doc ファイルに関連付けられている場合は、.doc を使用することもできます。 同様に、[`Run`] ダイアログボックスが .exe 拡張子の有無にかかわらず実行可能ファイル名を受け入れるようにするのと同様に、`fileName` パラメーターの .exe 拡張子は省略可能です。 たとえば、`fileName` パラメーターを "Notepad.exe" または "Notepad" に設定できます。  
  
 このオーバーロードでは、プロセスのコマンドライン引数は許可されません。 プロセスに対して1つ以上のコマンドライン引数を指定する必要がある場合は、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> または <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> オーバーロードを使用します。  
  
 他のオーバーロードとは異なり、パラメーターを持たない <xref:System.Diagnostics.Process.Start%2A> のオーバーロードは、`static` のメンバーではありません。 <xref:System.Diagnostics.Process> インスタンスを既に作成し、開始情報 (ファイル名を含む) を指定し、プロセスリソースを起動して既存の <xref:System.Diagnostics.Process> インスタンスに関連付ける場合は、そのオーバーロードを使用します。 既存のコンポーネントのプロセスを開始するのではなく、新しい <xref:System.Diagnostics.Process> コンポーネントを作成する場合は、`static` のオーバーロードのいずれかを使用します。 このオーバーロードと、パラメーターを持たないオーバーロードの両方で、開始するプロセスリソースのファイル名を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET の Web ページまたはサーバーコントロールで <xref:System.Diagnostics.Process.Start%2A> メソッドを使用すると、新しいプロセスはアクセス許可が制限された Web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 <xref:System.Diagnostics.Process.Start%2A> を使用してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは、その <xref:System.Diagnostics.Process.HasExited%2A> プロパティを使用して確認できます。  
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 プロセスコンポーネントの <xref:System.Diagnostics.Process.StartInfo%2A> プロパティに <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> が `true` 場合は、`main()` メソッドで属性 `[STAThread]` を設定して、アプリケーションにスレッドモデルが設定されていることを確認してください。 それ以外の場合は、マネージスレッドが `unknown` 状態になるか、`MTA` 状態になることがあります。後者の場合は、`true`中 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> と競合します。 一部のメソッドでは、アパートメントの状態を `unknown`しないようにする必要があります。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッドが検出されると、既定では `MTA`になり、設定されたアパートメント状態は変更できません。 ただし、`MTA` を使用すると、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、まず Internet Explorer のインスタンスを生成し、ブラウザーにお気に入りフォルダーの内容を表示します。 その後、Internet Explorer の他のインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動しているときに最小化されたウィンドウで Internet Explorer を起動します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。

- または -

<paramref name="fileName" /> で指定したファイルが見つかりませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>アプリケーションの名前とコマンド ライン引数のセットを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイル名とコマンドライン引数を指定してプロセスリソースを開始するには、このオーバーロードを使用します。 オーバーロードによって、リソースが新しい <xref:System.Diagnostics.Process> オブジェクトに関連付けられます。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始されず `null` が返されます。  
  
 このオーバーロードを使用すると、最初に新しい <xref:System.Diagnostics.Process> インスタンスを作成せずにプロセスを開始できます。 オーバーロードは、新しい <xref:System.Diagnostics.Process> インスタンスを作成し、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティの <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> と <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> メンバーを設定し、<xref:System.Diagnostics.Process.Start%2A> インスタンスの <xref:System.Diagnostics.Process> を呼び出すための明示的な手順の代わりに使用されます。  
  
 ファイル名と引数を指定してプロセスを開始することは、Windows `Start` メニューの [`Run`] ダイアログボックスでファイル名とコマンドライン引数を入力することと似ています。 このため、ファイル名は実行可能ファイルを表す必要はありません。 これは、システムにインストールされているアプリケーションに拡張機能が関連付けられている任意のファイルの種類にすることができます。 たとえば、メモ帳などのテキストファイルがエディターに関連付けられている場合、ファイル名の拡張子は .txt にすることができます。また、Microsoft Word などのワードプロセッシングツールを使用して .doc ファイルに関連付けられている場合は、.doc を使用することもできます。 同様に、[`Run`] ダイアログボックスが .exe 拡張子の有無にかかわらず実行可能ファイル名を受け入れるようにするのと同様に、`fileName` パラメーターの .exe 拡張子は省略可能です。 たとえば、`fileName` パラメーターを "Notepad.exe" または "Notepad" に設定できます。 `fileName` パラメーターが実行可能ファイルを表す場合、`arguments` パラメーターは `Notepad.exe myfile.txt`内のテキストファイルなど、操作対象のファイルを表す場合があります。 `fileName` パラメーターがコマンド (.cmd) ファイルを表す場合、`arguments` パラメーターには、コマンドウィンドウを終了するか、完了後に残すかを指定する "`/c`" または "`/k`" の引数を含める必要があります。  
  
 他のオーバーロードとは異なり、パラメーターを持たない <xref:System.Diagnostics.Process.Start%2A> のオーバーロードは、`static` のメンバーではありません。 <xref:System.Diagnostics.Process> インスタンスを既に作成し、開始情報 (ファイル名を含む) を指定し、プロセスリソースを起動して既存の <xref:System.Diagnostics.Process> インスタンスに関連付ける場合は、そのオーバーロードを使用します。 既存のコンポーネントのプロセスを開始するのではなく、新しい <xref:System.Diagnostics.Process> コンポーネントを作成する場合は、`static` のオーバーロードのいずれかを使用します。 このオーバーロードと、パラメーターを持たないオーバーロードの両方で、開始するプロセスリソースのファイル名と渡すコマンドライン引数を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET の Web ページまたはサーバーコントロールで <xref:System.Diagnostics.Process.Start%2A> メソッドを使用すると、新しいプロセスはアクセス許可が制限された Web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 <xref:System.Diagnostics.Process.Start%2A> を使用してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは、その <xref:System.Diagnostics.Process.HasExited%2A> プロパティを使用して確認できます。 
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 プロセスコンポーネントの <xref:System.Diagnostics.Process.StartInfo%2A> プロパティに <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> が `true` 場合は、`main()` メソッドで属性 `[STAThread]` を設定して、アプリケーションにスレッドモデルが設定されていることを確認してください。 それ以外の場合は、マネージスレッドが `unknown` 状態になるか、`MTA` 状態になることがあります。後者の場合は、`true`中 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> と競合します。 一部のメソッドでは、アパートメントの状態を `unknown`しないようにする必要があります。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッドが検出されると、既定では `MTA`になり、設定されたアパートメント状態は変更できません。 ただし、`MTA` を使用すると、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、まず Internet Explorer のインスタンスを生成し、ブラウザーにお気に入りフォルダーの内容を表示します。 その後、Internet Explorer の他のインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動しているときに最小化されたウィンドウで Internet Explorer を起動します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="fileName" /> パラメーターまたは <paramref name="arguments" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  

- または -

<paramref name="fileName" /> で指定したファイルが見つかりませんでした。
  
- または - 
引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="userName">プロセスの開始時に使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスの開始時に使用するドメイン。</param>
        <summary>アプリケーションの名前、ユーザー名、パスワード、ドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、ファイル名、ユーザー名、パスワード、およびドメインを指定することにより、新しいプロセスとそのプライマリスレッドを作成します。 新しいプロセスは、指定された実行可能ファイルを、指定した資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティコンテキストで実行します。  
  
> [!NOTE]
>  実行可能ファイルがリモートドライブにある場合は、リンクされたドライブ文字ではなく、uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始されず `null` が返されます。  
  
 このオーバーロードを使用すると、最初に新しい <xref:System.Diagnostics.Process> インスタンスを作成せずにプロセスを開始できます。 オーバーロードは、新しい <xref:System.Diagnostics.Process> インスタンスを作成するための明示的な手順の代わりに、<xref:System.Diagnostics.ProcessStartInfo.Domain%2A> プロパティの <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および <xref:System.Diagnostics.Process.StartInfo%2A> の各プロパティを設定し、<xref:System.Diagnostics.Process.Start%2A> インスタンスの <xref:System.Diagnostics.Process> を呼び出します。  
  
 同様に、[ファイル名を指定して**実行**] ダイアログボックスが .exe 拡張子の有無にかかわらず、実行可能ファイル名を受け入れる場合と同じように、.exe 拡張子は `fileName` パラメーターで省略可能です。 たとえば、`fileName` パラメーターを "Notepad.exe" または "Notepad" に設定できます。 `fileName` パラメーターが実行可能ファイルを表す場合、`arguments` パラメーターは `Notepad.exe myfile.txt`内のテキストファイルなど、操作対象のファイルを表す場合があります。  
  
> [!NOTE]
>  ファイル名は、`userName`、`password`、および `domain` パラメーターを持つ <xref:System.Diagnostics.Process.Start%2A> オーバーロード内の実行可能ファイルを表す必要があります。  
  
 <xref:System.Diagnostics.Process.Start%2A> を使用してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは、その <xref:System.Diagnostics.Process.HasExited%2A> プロパティを使用して確認できます。 
  
   
  
## Examples  
 次のコード例では、このオーバーロードを使用して実行可能ファイルを起動し、実行不可能なファイルに関連付けられているアプリケーションを起動しようとしたときに <xref:System.ComponentModel.Win32Exception> をスローする方法を示します。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。

- または -

<paramref name="fileName" /> で指定したファイルが見つかりませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメンバーは Linux または macOS (.NET Core のみ) ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <param name="userName">プロセスの開始時に使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスの開始時に使用するドメイン。</param>
        <summary>アプリケーションの名前、コマンド ライン引数のセット、ユーザー名、パスワード、およびドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、ファイル名、コマンドライン引数、ユーザー名、パスワード、およびドメインを指定することにより、新しいプロセスとそのプライマリスレッドを作成します。 新しいプロセスは、指定された実行可能ファイルを、指定した資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティコンテキストで実行します。  
  
> [!NOTE]
>  実行可能ファイルがリモートドライブにある場合は、リンクされたドライブ文字ではなく、uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始されず `null` が返されます。  
  
 このオーバーロードを使用すると、最初に新しい <xref:System.Diagnostics.Process> インスタンスを作成せずにプロセスを開始できます。 オーバーロードは、新しい <xref:System.Diagnostics.Process> インスタンスを作成するための明示的な手順の代わりに、<xref:System.Diagnostics.ProcessStartInfo.Password%2A>プロパティの <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>、および <xref:System.Diagnostics.Process.StartInfo%2A> の各プロパティを設定し、<xref:System.Diagnostics.Process.Start%2A> インスタンスの <xref:System.Diagnostics.Process> を呼び出します。  
  
 同様に、[ファイル名を指定して**実行**] ダイアログボックスが .exe 拡張子の有無にかかわらず、実行可能ファイル名を受け入れる場合と同じように、.exe 拡張子は `fileName` パラメーターで省略可能です。 たとえば、`fileName` パラメーターを "Notepad.exe" または "Notepad" に設定できます。 `fileName` パラメーターが実行可能ファイルを表す場合、`arguments` パラメーターは `Notepad.exe myfile.txt`内のテキストファイルなど、操作対象のファイルを表す場合があります。  
  
> [!NOTE]
>  ファイル名は、`userName`、`password`、および `domain` パラメーターを持つ <xref:System.Diagnostics.Process.Start%2A> オーバーロード内の実行可能ファイルを表す必要があります。  
  
 <xref:System.Diagnostics.Process.Start%2A> を使用してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> または <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは、その <xref:System.Diagnostics.Process.HasExited%2A> プロパティを使用して確認できます。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  

- または -

<paramref name="fileName" /> で指定したファイルが見つかりませんでした。
  
- または - 
引数の長さと関連ファイルへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメンバーは Linux または macOS (.NET Core のみ) ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> の <see cref="M:System.Diagnostics.Process.Start" /> メソッドに渡すプロパティを取得または設定します。</summary>
        <value>プロセスを起動するときに使用するデータを表す <see cref="T:System.Diagnostics.ProcessStartInfo" />。 これらの引数には、プロセスの起動時に使用する実行可能ファイルまたは文書の名前があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> は、プロセスを開始するために使用するパラメーターのセットを表します。 <xref:System.Diagnostics.Process.Start%2A> を呼び出すと、開始するプロセスを指定するために <xref:System.Diagnostics.Process.StartInfo%2A> が使用されます。 設定が必要な <xref:System.Diagnostics.Process.StartInfo%2A> メンバーは、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティだけです。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> のプロパティを指定してプロセスを開始することは、Windows の **[スタート]** メニューの **[実行]** ダイアログボックスに情報を入力することと似ています。 したがって、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティは実行可能ファイルを表す必要はありません。 これは、システムにインストールされているアプリケーションに拡張機能が関連付けられている任意のファイルの種類にすることができます。 たとえば、メモ帳などのテキストファイルがエディターに関連付けられている場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> には .txt 拡張子を付けることができます。また、Microsoft Word などのワードプロセッシングツールで .doc ファイルに関連付けられている場合は、.doc を使用できます。 同様に、[ファイル名を指定して**実行**] ダイアログボックスが .exe 拡張子の有無にかかわらず、実行可能ファイル名を受け入れる場合と同じように、.exe 拡張子は <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> メンバーでは省略可能です。 たとえば、"Notepad.exe" または "Notepad" のいずれかに <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティを設定できます。  
  
 ClickOnce アプリケーションを起動するには、最初にアプリケーションをインストールした場所 (Web アドレスなど) に <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティを設定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
 ファイル名に、.doc ファイルなどの実行不可能なファイルが含まれている場合は、ファイルに対して実行するアクションを指定する動詞を含めることができます。 たとえば、.doc 拡張子で終わるファイルの <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> を "Print" に設定できます。 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> プロパティの値を手動で入力した場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティで指定されたファイル名に拡張子を付ける必要はありません。 ただし、<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> プロパティを使用して、使用可能な動詞を特定する場合は、拡張機能を含める必要があります。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> プロパティで指定されたパラメーターは、プロセスで <xref:System.Diagnostics.Process.Start%2A> メソッドを呼び出す時間まで変更できます。 プロセスを開始した後、<xref:System.Diagnostics.Process.StartInfo%2A> 値を変更しても、関連付けられているプロセスには影響しません。 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> プロパティと <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> プロパティを設定して <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> メソッドを呼び出すと、アンマネージ `CreateProcessWithLogonW` 関数が呼び出されます。これにより、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> プロパティ値が `true` か、<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> プロパティ値が <xref:System.Diagnostics.ProcessWindowStyle.Hidden>場合でも、新しいウィンドウでプロセスが開始されます。  
  
 <xref:System.Diagnostics.Process.Start%2A> メソッドによって返された <xref:System.Diagnostics.Process> オブジェクトの <xref:System.Diagnostics.Process.StartInfo%2A> プロパティにのみアクセスする必要があります。 たとえば、<xref:System.Diagnostics.Process.GetProcesses%2A>によって返された <xref:System.Diagnostics.Process> オブジェクトの <xref:System.Diagnostics.Process.StartInfo%2A> プロパティにアクセスすることはできません。 それ以外の場合、.NET Core では、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティによって <xref:System.InvalidOperationException> がスローされ .NET Framework で、ダミー <xref:System.Diagnostics.ProcessStartInfo> オブジェクトが返されます。
  
 プロセスが開始されると、ファイル名は、(読み取り専用) <xref:System.Diagnostics.Process.MainModule%2A> プロパティを設定するファイルになります。 プロセスの開始後にプロセスに関連付けられている実行可能ファイルを取得する場合は、<xref:System.Diagnostics.Process.MainModule%2A> プロパティを使用します。 関連付けられたプロセスが開始されていない <xref:System.Diagnostics.Process> インスタンスの実行可能ファイルを設定する場合は、<xref:System.Diagnostics.Process.StartInfo%2A> プロパティの <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> メンバーを使用します。 <xref:System.Diagnostics.Process.StartInfo%2A> プロパティのメンバーは、プロセスの <xref:System.Diagnostics.Process.Start%2A> メソッドに渡される引数であるため、関連付けられたプロセスの開始後に <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> プロパティを変更しても、<xref:System.Diagnostics.Process.MainModule%2A> プロパティはリセットされません。 これらのプロパティは、関連付けられたプロセスを初期化するためにのみ使用されます。  
  
   
  
## Examples  
 次の例では、実行するファイル、それに対して実行されるアクション、およびユーザーインターフェイスを表示する必要があるかどうかを <xref:System.Diagnostics.Process.StartInfo%2A> に設定します。 その他の例については、<xref:System.Diagnostics.ProcessStartInfo> クラスのプロパティのリファレンスページを参照してください。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.Process.StartInfo" /> を指定する値は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Diagnostics.Process.Start" /> メソッドはプロセスを開始するために使用されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが起動された時刻を取得します。</summary>
        <value>プロセスが起動された時刻を示すオブジェクト。 プロセスが実行中でない場合は、例外がスローされます。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.StartTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
 - または -  
  
 プロセスは開始されていません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Windows 関数の呼び出しでエラーが発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセス終了イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>プロセスの <see cref="E:System.Diagnostics.Process.Exited" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> が `null`場合、<xref:System.Diagnostics.Process.Exited> イベントを処理するメソッドは、システムスレッドプールからのスレッドで呼び出されます。 システムスレッドプールの詳細については、「<xref:System.Threading.ThreadPool>」を参照してください。  
  
 <xref:System.Diagnostics.Process.Exited> イベントが、<xref:System.Windows.Forms.Button>などのビジュアル Windows フォームコンポーネントによって処理されると、システムスレッドプールを介してコンポーネントにアクセスできない場合や、例外が発生する場合があります。 これを回避するには、<xref:System.Diagnostics.Process.SynchronizingObject%2A> を Windows フォームコンポーネントに設定します。これにより、<xref:System.Diagnostics.Process.Exited> イベントを処理するメソッドが、コンポーネントが作成されたのと同じスレッドで呼び出されます。  
  
 <xref:System.Diagnostics.Process> が Windows フォームデザイナーの [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 内で使用されている場合、<xref:System.Diagnostics.Process.SynchronizingObject%2A> は、<xref:System.Diagnostics.Process>を含むコントロールに自動的に設定されます。 たとえば、`Form1` (<xref:System.Windows.Forms.Form>から継承) のデザイナーに <xref:System.Diagnostics.Process> を配置すると、<xref:System.Diagnostics.Process> の <xref:System.Diagnostics.Process.SynchronizingObject%2A> プロパティが `Form1`のインスタンスに設定されます。  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 通常、このプロパティは、コンポーネントがコントロールまたはフォーム内に配置されるときに設定されます。これは、コンポーネントが特定のスレッドにバインドされるためです。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスで実行されているスレッドのセットを取得します。</summary>
        <value>関連付けられたプロセスで現在実行中のオペレーティング システム スレッドを表す <see cref="T:System.Diagnostics.ProcessThread" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、プロセス内のコードを実行します。 各プロセスは、1つのスレッド (プライマリスレッド) で開始されます。 どのスレッドでも新しいスレッドを作成できます。 プロセス内のスレッドは、プロセスのアドレス空間を共有します。  
  
 現在のプロセスに関連付けられているすべてのスレッドを取得するには、<xref:System.Diagnostics.ProcessThread> を使用します。 プライマリスレッドは、配列内のインデックス0の位置にあるとは限りません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">プロセスに <see cref="P:System.Diagnostics.Process.Id" /> がないか、<see cref="T:System.Diagnostics.Process" /> インスタンスに関連付けられているプロセスがありません。  
  
- または - 
関連付けられたプロセスが終了しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス名の書式指定は文字列にします。親コンポーネント型があれば、この型と組み合わせます。</summary>
        <returns>ベース コンポーネントの <see cref="M:System.Object.ToString" /> の戻り値と組み合わせた <see cref="P:System.Diagnostics.Process.ProcessName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの合計プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが CPU を使用した合計時間を示す <see cref="T:System.TimeSpan" />。 この値は、<see cref="P:System.Diagnostics.Process.UserProcessorTime" /> と <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> の合計です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスのユーザー プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが、プロセスのアプリケーション部分の内部 (オペレーティング システム コアの外部) でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの仮想メモリのサイズ (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用される仮想メモリの現在のサイズ (バイト単位) を表します。 オペレーティングシステムは、物理メモリに読み込まれたページか、ディスク上の仮想メモリページングファイルに格納されているページに、各プロセスの仮想アドレス空間をマップします。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**仮想 Bytes**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>関連付けられたプロセスが終了するまで待機する時間を設定し、指定した時間が経過するかプロセスが終了するまで現在のスレッドの実行をブロックします。 現在のスレッドがブロックされないようにする場合は、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを使用します。  
  
コード例については、<see cref="P:System.Diagnostics.Process.StandardError" /> および <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティのリファレンス ページを参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスが終了するまで無期限に待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> は、関連付けられたプロセスが終了するまで、現在のスレッドを待機させます。  これは、プロセスで他のすべてのメソッドが呼び出された後に呼び出される必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドは <xref:System.Diagnostics.Process> コンポーネントに対して、プロセスおよびイベントハンドラーが終了するのを無期限に待機するように指示します。 これにより、アプリケーションが応答を停止する可能性があります。 たとえば、ユーザーインターフェイスを持つプロセスに対して <xref:System.Diagnostics.Process.CloseMainWindow%2A> を呼び出すと、そのプロセスがメッセージループに入ることがないように記述されている場合、関連付けられているプロセスを終了するためのオペレーティングシステムへの要求が処理されないことがあります。  
  
> [!NOTE]
>  [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以前のバージョンでは、<xref:System.Diagnostics.Process.WaitForExit> のオーバーロードは、無制限ではなく <xref:System.Int32.MaxValue> ミリ秒 (約24日間) を待機していました。 また、以前のバージョンでは、フル <xref:System.Int32.MaxValue> 時間に達した場合に、イベントハンドラーが終了するのを待機していませんでした。  
  
 このオーバーロードは、リダイレクトされた標準出力の非同期イベントの処理など、すべての処理が完了したことを保証します。 標準出力が非同期イベントハンドラーにリダイレクトされた場合は、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> のオーバーロードを呼び出した後に、このオーバーロードを使用する必要があります。  
  
 関連付けられたプロセスが終了すると (つまり、通常または異常終了によって操作システムによってシャットダウンされた場合)、システムはプロセスに関する管理情報を格納し、<xref:System.Diagnostics.Process.WaitForExit>を呼び出したコンポーネントに戻ります。 <xref:System.Diagnostics.Process> コンポーネントは、終了したプロセスに <xref:System.Diagnostics.Process.Handle%2A> を使用して、<xref:System.Diagnostics.Process.ExitTime%2A>を含む情報にアクセスできます。  
  
 関連付けられたプロセスが終了したため、コンポーネントの [<xref:System.Diagnostics.Process.Handle%2A>] プロパティは既存のプロセスリソースを参照しなくなります。 代わりに、ハンドルは、プロセスリソースに関するオペレーティングシステムの情報にアクセスするためにのみ使用できます。 システムは、<xref:System.Diagnostics.Process> コンポーネントによって解放されていないプロセスを終了するハンドルを認識しているため、<xref:System.Diagnostics.Process> コンポーネントがリソースを明確に解放するまで、<xref:System.Diagnostics.Process.ExitTime%2A> と <xref:System.Diagnostics.Process.Handle%2A> の情報をメモリに保持します。 このため、<xref:System.Diagnostics.Process> インスタンスの <xref:System.Diagnostics.Process.Start%2A> を呼び出すたびに、関連付けられているプロセスが終了し、それに関する管理情報が不要になったときに <xref:System.Diagnostics.Process.Close%2A> を呼び出します。 <xref:System.Diagnostics.Process.Close%2A> は、終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 <xref:System.Diagnostics.Process.StandardError%2A> プロパティのリファレンスページの「解説」セクションを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
- または - 
リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスが終了するまで待機する時間。単位はミリ秒です。 最大値は、32 ビット整数で表現できる最大値で、オペレーティング システムに対して無限大で表現される値です。</param>
        <summary>関連付けられたプロセスが終了するまで、最大で指定したミリ秒間待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <returns>関連付けられたプロセスが終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> は、関連付けられたプロセスが終了するまで、現在のスレッドを待機させます。 これは、プロセスで他のすべてのメソッドが呼び出された後に呼び出される必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドは、プロセスが終了するまでの時間を待機するように <xref:System.Diagnostics.Process> コンポーネントに指示します。 終了要求が拒否されたために、関連付けられたプロセスが間隔の終了によって終了しない場合は、呼び出し元のプロシージャに `false` が返されます。 `milliseconds`には <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> を指定でき、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> は <xref:System.Diagnostics.Process.WaitForExit> のオーバーロードと同じように動作します。 メソッドに 0 (ゼロ) を渡すと、プロセスが既に終了している場合にのみ `true` が返されます。それ以外の場合は、直ちに `false`を返します。  
  
> [!NOTE]
>  [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以前のバージョンでは、`milliseconds` が-1 の場合、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> オーバーロードは無制限ではなく <xref:System.Int32.MaxValue> ミリ秒 (約24日) 待機します。  
  
 標準出力が非同期イベントハンドラーにリダイレクトされている場合、このメソッドから制御が戻ったときに出力処理が完了していない可能性があります。 非同期イベント処理が完了したことを確認するには、このオーバーロードから `true` を受け取った後にパラメーターを取らない <xref:System.Diagnostics.Process.WaitForExit> オーバーロードを呼び出します。 Windows フォームアプリケーションで <xref:System.Diagnostics.Process.Exited> イベントが正しく処理されるようにするには、<xref:System.Diagnostics.Process.SynchronizingObject%2A> プロパティを設定します。  
  
 関連付けられたプロセスが終了すると (が正常終了または異常終了によってオペレーティングシステムによってシャットダウンされます)、システムはプロセスに関する管理情報を格納し、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>を呼び出したコンポーネントに戻ります。 <xref:System.Diagnostics.Process> コンポーネントは、終了したプロセスに <xref:System.Diagnostics.Process.Handle%2A> を使用して、<xref:System.Diagnostics.Process.ExitTime%2A>を含む情報にアクセスできます。  
  
 関連付けられたプロセスが終了したため、コンポーネントの [<xref:System.Diagnostics.Process.Handle%2A>] プロパティは既存のプロセスリソースを参照しなくなります。 代わりに、ハンドルは、プロセスリソースに関するオペレーティングシステムの情報にアクセスするためにのみ使用できます。 システムは、<xref:System.Diagnostics.Process> コンポーネントによって解放されていないプロセスを終了するハンドルを認識しているため、<xref:System.Diagnostics.Process> コンポーネントがリソースを明確に解放するまで、<xref:System.Diagnostics.Process.ExitTime%2A> と <xref:System.Diagnostics.Process.Handle%2A> の情報をメモリに保持します。 このため、<xref:System.Diagnostics.Process> インスタンスの <xref:System.Diagnostics.Process.Start%2A> を呼び出すたびに、関連付けられているプロセスが終了し、それに関する管理情報が不要になったときに <xref:System.Diagnostics.Process.Close%2A> を呼び出します。 <xref:System.Diagnostics.Process.Close%2A> は、終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 <xref:System.Diagnostics.Process.ExitCode%2A> プロパティのコード例を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
- または - 
リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを無期限に待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForInputIdle> を使用すると、メッセージループがアイドル状態に戻ってくるまでアプリケーションの処理を強制的に実行できます。 ユーザーインターフェイスを持つプロセスが実行されている場合、オペレーティングシステムによって Windows メッセージがプロセスに送信されるたびに、そのメッセージループが実行されます。 次に、プロセスはメッセージループに戻ります。 プロセスは、メッセージループ内のメッセージを待機しているときにアイドル状態になっていると言います。 この状態は、アプリケーションがそのウィンドウと通信する前に、アプリケーションがメインウィンドウの作成を完了するまで待機する必要がある場合などに便利です。  
  
 プロセスにメッセージループがない場合、<xref:System.Diagnostics.Process.WaitForInputIdle> は <xref:System.InvalidOperationException>をスローします。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> のオーバーロードは、メッセージループ内のプロセスがアイドル状態になるまで無制限に待機するように <xref:System.Diagnostics.Process> コンポーネントに指示します。 この命令により、アプリケーションが応答を停止する可能性があります。 たとえば、プロセスが記述されている場合は、コード片 `while(true)`のように、常にメッセージループを直ちに終了します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
- または - 
不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
- または - 
プロセスは既に終了しています。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスがアイドル状態になるまでの待機時間をミリ秒単位で指定する、1 ～ <see cref="F:System.Int32.MaxValue" /> の値。 値 0 の場合はすぐに制御が戻され、値 -1 の場合は無期限に待機することを示します。</param>
        <summary>関連付けられたプロセスがアイドル状態になるまで、最大で指定したミリ秒間、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> を使用すると、メッセージループがアイドル状態に戻ってくるまでアプリケーションの処理を強制的に実行できます。 ユーザーインターフェイスを持つプロセスが実行されている場合、オペレーティングシステムによって Windows メッセージがプロセスに送信されるたびに、そのメッセージループが実行されます。 次に、プロセスはメッセージループに戻ります。 プロセスは、メッセージループ内のメッセージを待機しているときにアイドル状態になっていると言います。 この状態は、アプリケーションがそのウィンドウと通信する前に、アプリケーションがメインウィンドウの作成を完了するまで待機する必要がある場合などに便利です。  
  
 プロセスにメッセージループがない場合、<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> は <xref:System.InvalidOperationException>をスローします。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> のオーバーロードは、メッセージループでプロセスがアイドル状態になるまでの時間を待機するように <xref:System.Diagnostics.Process> コンポーネントに指示します。 ループがまだメッセージを処理しているために、関連付けられたプロセスが間隔の最後までアイドル状態にならない場合は、呼び出し元のプロシージャに `false` が返されます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
- または - 
不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
- または - 
プロセスは既に終了しています。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの物理メモリ使用量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが使用している物理メモリの合計容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるワーキングセットメモリの現在のサイズ (バイト単位) を表します。 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリを含む、プロセスによって実行されるすべての命令を含むページが含まれます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるワーキングセットメモリの現在のサイズ (バイト単位) を表します。 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリの指示を含む、プロセスが実行するすべての命令を含むページが含まれます。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ワーキングセット**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼の場合。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
