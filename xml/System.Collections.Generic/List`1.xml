<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="121f9bd369e34c3878ed38488cef7292a5e2c0f0" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75151654" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">リスト内の要素の型。</typeparam>
    <summary>インデックスを使用してアクセスできる、厳密に型指定されたオブジェクトのリストを表します。 リストの検索、並べ替え、および操作のためのメソッドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> クラスは、<xref:System.Collections.ArrayList> クラスに相当する汎用です。 必要に応じてサイズが動的に増加する配列を使用して、<xref:System.Collections.Generic.IList%601> ジェネリックインターフェイスを実装します。  
  
 <xref:System.Collections.Generic.List%601.Add%2A> または <xref:System.Collections.Generic.List%601.AddRange%2A> メソッドを使用して、<xref:System.Collections.Generic.List%601> に項目を追加できます。  
  
 <xref:System.Collections.Generic.List%601> クラスは、等値比較子と順序比較子の両方を使用します。  
  
-   <xref:System.Collections.Generic.List%601.Contains%2A>、<xref:System.Collections.Generic.List%601.IndexOf%2A>、<xref:System.Collections.Generic.List%601.LastIndexOf%2A>、<xref:System.Collections.Generic.Dictionary%602.Remove%2A> などのメソッドでは、リスト要素の等値比較子が使用されます。 `T` 型の既定の等値比較子は、次のように決定されます。 型 `T` が <xref:System.IEquatable%601> ジェネリックインターフェイスを実装している場合、等値比較子はそのインターフェイスの <xref:System.IEquatable%601.Equals%28%600%29> メソッドです。それ以外の場合、既定の等値比較子は <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>になります。  
  
-   <xref:System.Collections.Generic.List%601.BinarySearch%2A> や <xref:System.Collections.Generic.List%601.Sort%2A> などのメソッドは、リスト要素の順序比較子を使用します。 `T` 型の既定の比較子は、次のように決定されます。  型 `T` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装している場合、既定の比較子はそのインターフェイスの <xref:System.IComparable%601.CompareTo%28%600%29> メソッドです。それ以外の場合、型 `T` が非ジェネリック <xref:System.IComparable> インターフェイスを実装する場合、既定の比較子はそのインターフェイスの <xref:System.IComparable.CompareTo%28System.Object%29> メソッドになります。 型 `T` がどちらのインターフェイスも実装しない場合、既定の比較子は存在せず、比較子または比較デリゲートを明示的に指定する必要があります。  
  
 <xref:System.Collections.Generic.List%601> の並べ替えは保証されていません。  <xref:System.Collections.Generic.List%601> を並べ替える必要がある操作 (<xref:System.Collections.Generic.List%601.BinarySearch%2A>など) を実行する前に、<xref:System.Collections.Generic.List%601> を並べ替える必要があります。  
  
 このコレクションの要素には、整数インデックスを使用してアクセスできます。  このコレクションのインデックスは0から始まります。  
  
 **.NET Framework のみ:** 非常に大きな <xref:System.Collections.Generic.List%601> オブジェクトの場合、 [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)構成要素の `enabled` 属性を実行時環境の `true` に設定することによって、64ビットシステム上の最大容量を20億の要素に増やすことができます。  
  
 <xref:System.Collections.Generic.List%601> は、参照型の有効な値として `null` を受け入れ、重複する要素を許可します。  
  
 <xref:System.Collections.Generic.List%601> クラスの変更できないバージョンについては、「<xref:System.Collections.Immutable.ImmutableList%601>」を参照してください。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.Collections.Generic.List%601> または <xref:System.Collections.ArrayList> クラスを使用するかどうかを決定する際には、どちらも同様の機能を備えているため、<xref:System.Collections.Generic.List%601> クラスはほとんどの場合にパフォーマンスが向上し、タイプセーフであることに注意してください。 参照型が <xref:System.Collections.Generic.List%601> クラスの型 `T` に使用されている場合、2つのクラスの動作は同じになります。 ただし、型 `T`に値型を使用する場合は、実装とボックス化の問題を考慮する必要があります。  
  
 型 `T`に値型が使用されている場合、コンパイラはその値型に対して特別な <xref:System.Collections.Generic.List%601> クラスの実装を生成します。 つまり、要素を使用する前に、<xref:System.Collections.Generic.List%601> オブジェクトのリスト要素をボックス化する必要はありません。また、約500のリスト要素が作成された後は、ボックス化されたリスト要素ではなく、ボックス化されたメモリがクラス実装の生成に使用されたメモリよりも大きくなります。  
  
 <xref:System.IEquatable%601> ジェネリックインターフェイスを実装 `T` 型に使用される値型を特定するようにします。 それ以外の場合、<xref:System.Collections.Generic.List%601.Contains%2A> などのメソッドは、影響を受けるリスト要素を示す <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドを呼び出す必要があります。 値の型が <xref:System.IComparable> インターフェイスを実装していて、ソースコードを所有している場合は、<xref:System.IComparable%601> ジェネリックインターフェイスを実装して、<xref:System.Collections.Generic.List%601.BinarySearch%2A> および <xref:System.Collections.Generic.List%601.Sort%2A> メソッドがリスト要素のボックス化を回避できるようにします。 ソースコードを所有していない場合は、<xref:System.Collections.Generic.IComparer%601> オブジェクトを <xref:System.Collections.Generic.List%601.BinarySearch%2A> メソッドと <xref:System.Collections.Generic.List%601.Sort%2A> メソッドに渡します。  
  
 これは、<xref:System.Collections.ArrayList> クラスを使用したり、厳密に型指定されたラッパーコレクションを自分で記述したりする代わりに、<xref:System.Collections.Generic.List%601> クラスの型固有の実装を使用する利点になります。 その理由は、実装では .NET Framework が既に行っていることを実行する必要があり、共通言語ランタイムは Microsoft 中間言語コードとメタデータを共有できるため、実装はできません。  
  
## <a name="f-considerations"></a>F#上  
 <xref:System.Collections.Generic.List%601> クラスは、コードでF#はあまり使用されません。 代わりに、変更できないシングルリンクリストである[リスト](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d)を使用するのが一般的です。 リストF#は、順序付けられた変更できない一連の値を提供し、関数形式の開発での使用がサポートされています。 からF#使用する場合、<xref:System.Collections.Generic.List%601> クラスは通常、リストとの名前のF#競合を避けるために、 [collections.resizearray\<t >](https://msdn.microsoft.com/library/ee353447.aspx)型略称によって参照されます。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例では、<xref:System.Collections.Generic.List%601>に単純なビジネスオブジェクトを追加、削除、および挿入する方法を示します。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 次の例は、string 型の <xref:System.Collections.Generic.List%601> ジェネリッククラスのいくつかのプロパティとメソッドを示しています。 (複合型の <xref:System.Collections.Generic.List%601> の例については、「<xref:System.Collections.Generic.List%601.Contains%2A> メソッド」を参照してください)。  
  
 パラメーターなしのコンストラクターは、既定の容量を持つ文字列のリストを作成するために使用されます。 <xref:System.Collections.Generic.List%601.Capacity%2A> プロパティが表示され、<xref:System.Collections.Generic.List%601.Add%2A> メソッドを使用して複数の項目を追加します。 項目が一覧表示され、[<xref:System.Collections.Generic.List%601.Capacity%2A>] プロパティが <xref:System.Collections.Generic.List%601.Count%2A> プロパティと共に再び表示され、必要に応じて容量が増加したことが示されます。  
  
 <xref:System.Collections.Generic.List%601.Contains%2A> メソッドを使用して、リスト内の項目の存在をテストし、<xref:System.Collections.Generic.List%601.Insert%2A> メソッドを使用してリストの中央に新しい項目を挿入します。リストの内容が再び表示されます。  
  
 既定の <xref:System.Collections.Generic.List%601.Item%2A> プロパティ (のC#インデクサー) を使用して項目を取得し、<xref:System.Collections.Generic.List%601.Remove%2A> メソッドを使用して、前に追加した重複項目の最初のインスタンスを削除して、内容を再度表示します。 <xref:System.Collections.Generic.List%601.Remove%2A> メソッドは、最初に見つかったインスタンスを常に削除します。  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを使用して、カウントに一致する容量を減らし、<xref:System.Collections.Generic.List%601.Capacity%2A> と <xref:System.Collections.Generic.List%601.Count%2A> のプロパティを表示します。 未使用の容量が合計容量の10% 未満の場合、一覧のサイズは変更されませんでした。  
  
 最後に、<xref:System.Collections.Generic.List%601.Clear%2A> メソッドを使用してリストからすべての項目が削除され、<xref:System.Collections.Generic.List%601.Capacity%2A> と <xref:System.Collections.Generic.List%601.Count%2A> のプロパティが表示されます。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (Visual Basic では<see langword="Shared" />) なこの型のメンバーはスレッド セーフです インスタンス メンバーについては、スレッド セーフであることの保証はありません。  
  
<see cref="T:System.Collections.Generic.List`1" />に対して複数の読み取り操作を実行するのは安全ですが、読み取り中にコレクションが変更された場合に問題が発生する可能性があります。 スレッドセーフを確保するには、読み取りまたは書き込み操作中にコレクションをロックします。 読み取りと書き込みのために複数のスレッドがコレクションにアクセスできるようにするには、独自の同期を実装する必要があります。 組み込み同期を使用したコレクションについては、<see cref="N:System.Collections.Concurrent" /> 名前空間のクラスを参照してください。 本質的にスレッドセーフな代替方法については、<see cref="T:System.Collections.Immutable.ImmutableList`1" /> クラスを参照してください。</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">反復子 (C# および Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>空で、既定の初期量を備えた、<see cref="T:System.Collections.Generic.List`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> の容量は、<xref:System.Collections.Generic.List%601> が保持できる要素の数です。 要素が <xref:System.Collections.Generic.List%601>に追加されると、内部配列を再割り当てすることで、必要に応じて容量が自動的に増加します。  
  
 コレクションのサイズを推定できる場合は、<xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> コンストラクターを使用して初期容量を指定することで、<xref:System.Collections.Generic.List%601>に要素を追加するときに、さまざまなサイズ変更操作を実行する必要がなくなります。  
  
 容量は、<xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを呼び出すか、<xref:System.Collections.Generic.List%601.Capacity%2A> プロパティを明示的に設定することによって減らすことができます。 容量を減らしてメモリを再割り当てし、<xref:System.Collections.Generic.List%601>内のすべての要素をコピーします。  
  
 このコンストラクターは O (1) 操作です。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例は、<xref:System.Collections.Generic.List%601> ジェネリッククラスのパラメーターなしのコンストラクターを示しています。 パラメーターなしのコンストラクターは、<xref:System.Collections.Generic.List%601.Capacity%2A> プロパティを表示することによって示されているように、既定の容量を使用してリストを作成します。  
  
 この例では、項目を追加、挿入、および削除し、これらの方法によって容量がどのように変化するかを示します。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">新しいリストに要素がコピーされたコレクション。</param>
        <summary>指定したコレクションからコピーした要素を格納し、コピーされる要素の数を格納できるだけの容量を備えた、<see cref="T:System.Collections.Generic.List`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素は、コレクションの列挙子によって読み取られた順序で <xref:System.Collections.Generic.List%601> にコピーされます。  
  
 このコンストラクターは O (*n*) 操作です。ここで、 *n*は `collection`内の要素の数です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.%23ctor%2A> コンストラクターと、範囲に作用する <xref:System.Collections.Generic.List%601> クラスのさまざまなメソッドを示しています。 文字列の配列が作成されてコンストラクターに渡され、リストに配列の要素が設定されます。 次に、[<xref:System.Collections.Generic.List%601.Capacity%2A>] プロパティが表示され、初期容量が入力要素を保持するために必要な値であることが示されます。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">新しいリストに格納できる要素の数。</param>
        <summary>空で、指定した初期量を備えた、<see cref="T:System.Collections.Generic.List`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> の容量は、<xref:System.Collections.Generic.List%601> が保持できる要素の数です。 要素が <xref:System.Collections.Generic.List%601>に追加されると、内部配列を再割り当てすることで、必要に応じて容量が自動的に増加します。  
  
 コレクションのサイズを推定できる場合は、初期容量を指定すると、<xref:System.Collections.Generic.List%601>に要素を追加するときに、さまざまなサイズ変更操作を実行する必要がなくなります。  
  
 容量は、<xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを呼び出すか、<xref:System.Collections.Generic.List%601.Capacity%2A> プロパティを明示的に設定することによって減らすことができます。 容量を減らしてメモリを再割り当てし、<xref:System.Collections.Generic.List%601>内のすべての要素をコピーします。  
  
 このコンストラクターは O (*n*) 操作です。ここで、 *n*は `capacity`です。  
  
   
  
## Examples  
 <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> コンストラクターの例を次に示します。 容量が4の文字列の <xref:System.Collections.Generic.List%601> が作成されます。これは、リストの最終的なサイズが厳密に4であることがわかっているためです。 このリストには4つの文字列が入力され、読み取り専用のコピーは <xref:System.Collections.Generic.List%601.AsReadOnly%2A> メソッドを使用して作成されます。  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> の末尾に追加するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> の末尾にオブジェクトを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、参照型の有効な値として `null` を受け入れ、重複する要素を許可します。  
  
 <xref:System.Collections.Generic.List%601.Count%2A> 既に <xref:System.Collections.Generic.List%601.Capacity%2A>に等しい場合は、内部配列が自動的に再割り当てされ、既存の要素が新しい配列にコピーされてから、新しい要素が追加されるまで、<xref:System.Collections.Generic.List%601> の容量が増加します。  
  
 <xref:System.Collections.Generic.List%601.Count%2A> が <xref:System.Collections.Generic.List%601.Capacity%2A>より小さい場合、このメソッドは O (1) 操作になります。 新しい要素に対応するために容量を増やす必要がある場合、このメソッドは O (*n*) 操作になります。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例では、<xref:System.Collections.Generic.List%601>に単純なビジネスオブジェクトを追加、削除、および挿入する方法を示します。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 次の例は、<xref:System.Collections.Generic.List%601.Add%2A> メソッドを含む <xref:System.Collections.Generic.List%601> ジェネリッククラスのいくつかのプロパティとメソッドを示しています。 0の容量を持つ文字列のリストを作成するには、パラメーターなしのコンストラクターを使用します。 <xref:System.Collections.Generic.List%601.Capacity%2A> プロパティが表示され、<xref:System.Collections.Generic.List%601.Add%2A> メソッドを使用して複数の項目を追加します。 項目が一覧表示され、[<xref:System.Collections.Generic.List%601.Capacity%2A>] プロパティが <xref:System.Collections.Generic.List%601.Count%2A> プロパティと共に再び表示され、必要に応じて容量が増加したことが示されます。  
  
 他のプロパティおよびメソッドを使用して、リストの要素を検索、挿入、および削除し、最後に一覧をクリアします。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><see cref="T:System.Collections.Generic.List`1" /> の末尾に要素が追加されるコレクション。 コレクション自体を <see langword="null" /> にすることはできませんが、型 <see langword="null" /> が参照型の場合、コレクションに格納する要素は <paramref name="T" /> であってもかまいません。</param>
        <summary>指定したコレクションの要素を <see cref="T:System.Collections.Generic.List`1" /> の末尾に追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コレクション内の要素の順序は、<xref:System.Collections.Generic.List%601>に保持されます。  
  
 新しい <xref:System.Collections.Generic.List%601.Count%2A> (現在の <xref:System.Collections.Generic.List%601.Count%2A> とコレクションのサイズの合計) が <xref:System.Collections.Generic.List%601.Capacity%2A>を超える場合、新しい要素を格納するために内部配列が自動的に再割り当てされ、新しい要素が追加される前に既存の要素が新しい配列にコピーされて、<xref:System.Collections.Generic.List%601> の容量が増加します。  
  
 <xref:System.Collections.Generic.List%601> が、<xref:System.Collections.Generic.List%601.Capacity%2A>を増やさずに新しい要素に対応できる場合、このメソッドは O (*n*) 操作になります。ここで、 *n*は追加する要素の数です。 新しい要素に合わせて容量を増やす必要がある場合、このメソッドは O (*n* + *m*) 操作になります。ここで、 *n*は加算する要素の数で、 *m*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.AddRange%2A> メソッドと、範囲に作用する <xref:System.Collections.Generic.List%601> クラスのその他のさまざまなメソッドを示しています。 文字列の配列が作成されてコンストラクターに渡され、リストに配列の要素が設定されます。 <xref:System.Collections.Generic.List%601.AddRange%2A> メソッドが呼び出され、その引数としてリストが使用されます。 結果として、リストの現在の要素がリストの最後に追加され、すべての要素が複製されます。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のコレクションの読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパーを返します。</summary>
        <returns>現在の <see cref="T:System.Collections.Generic.List`1" /> をラップする読み取り専用のラッパーとして動作するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> オブジェクトが変更されないようにするには、このラッパーを通じてのみ公開します。 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> オブジェクトは、コレクションを変更するメソッドを公開しません。 ただし、基になる <xref:System.Collections.Generic.List%601> オブジェクトに変更が加えられた場合、読み取り専用コレクションにはそれらの変更が反映されます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 <xref:System.Collections.Generic.List%601.AsReadOnly%2A>メソッドの例を次に示します。 容量が4の文字列の <xref:System.Collections.Generic.List%601> が作成されます。これは、リストの最終的なサイズが厳密に4であることがわかっているためです。 このリストには4つの文字列が入力され、<xref:System.Collections.Generic.List%601.AsReadOnly%2A> メソッドを使用して、元のリストをラップする読み取り専用 <xref:System.Collections.Generic.IList%601> ジェネリックインターフェイスの実装を取得します。  
  
 元のリストの要素は、<xref:System.Collections.Generic.List%601.Item%2A> プロパティ (のC#インデクサー) を使用して "Coelophysis" に設定され、読み取り専用リストの内容が、元のリストの単なるラッパーであることを示すために再び表示されます。  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ サーチ アルゴリズムを使用して、並べ替えられた <see cref="T:System.Collections.Generic.List`1" /> 内の特定の要素またはその一部を検索します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>既定の比較子を使用して、並べ替えられた要素の <see cref="T:System.Collections.Generic.List`1" /> 全体を検索し、その要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="item" /> が見つかった場合は、並べ替えられた <see cref="T:System.Collections.Generic.List`1" /> 内の <paramref name="item" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="item" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.Collections.Generic.List`1.Count" /> のビットごとの補数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、型 `T` の既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> を使用して、リスト要素の順序を決定します。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> プロパティは、型 `T` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装し、その実装を使用するかどうかを確認します (使用可能な場合)。  それ以外の場合は、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 型 `T` が <xref:System.IComparable> インターフェイスを実装しているかどうかを確認します。  型 `T` がどちらのインターフェイスも実装していない場合、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> は <xref:System.InvalidOperationException>をスローします。  
  
 <xref:System.Collections.Generic.List%601> は、比較子の実装に従って既に並べ替えられている必要があります。それ以外の場合、結果は正しくありません。  
  
 `null` を任意の参照型と比較することはできますが、<xref:System.IComparable%601> ジェネリックインターフェイスを使用する場合は例外を生成しません。 並べ替えを行う場合、`null` は他のオブジェクトより小さいと見なされます。  
  
 <xref:System.Collections.Generic.List%601> に同じ値を持つ複数の要素が含まれている場合、メソッドは、1つの出現箇所だけを返します。最初の要素とは限りません。  
  
 <xref:System.Collections.Generic.List%601> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算 (~) をこの負の整数に適用すると、検索値よりも大きい最初の要素のインデックスを取得できます。 <xref:System.Collections.Generic.List%601>に値を挿入する場合、並べ替え順序を維持するために、このインデックスを挿入ポイントとして使用する必要があります。  
  
 このメソッドは O (log *n*) 操作です。ここで、 *n*は範囲内の要素の数です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.Sort> メソッドのオーバーロードと、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> メソッドのオーバーロードを示しています。 文字列の <xref:System.Collections.Generic.List%601> が作成され、特定の順序ではなく4つの文字列が設定されます。 一覧が表示され、並べ替えられて、もう一度表示されます。  
  
 次に、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> メソッドのオーバーロードを使用して、リストに含まれていない2つの文字列を検索し、<xref:System.Collections.Generic.List%601.Insert%2A> メソッドを使用してそれらの文字列を挿入します。 文字列がリストに含まれていないため、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> メソッドの戻り値は、各ケースで負の値になります。 ビットごとの補数 (およびでC#は ~ 演算子) C++を取得すると、この負の数値の `Xor`-1 Visual Basic) によって、検索文字列よりも大きいリスト内の最初の要素のインデックスが生成されます。この位置に挿入すると、並べ替え順序が保持されます。 2番目の検索文字列がリスト内のどの要素よりも大きいため、挿入位置がリストの末尾にあります。  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">既定の比較関数 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスまたは <see cref="T:System.IComparable" /> 型の <paramref name="T" /> インターフェイスの実装を見つけることができません。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
または 
 既定の比較子 <see langword="null" /> を使用する場合は <see cref="P:System.Collections.Generic.Comparer`1.Default" />。</param>
        <summary>指定した比較子を使用して、並べ替えられた要素の <see cref="T:System.Collections.Generic.List`1" /> 全体を検索し、その要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="item" /> が見つかった場合は、並べ替えられた <see cref="T:System.Collections.Generic.List`1" /> 内の <paramref name="item" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="item" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.Collections.Generic.List`1.Count" /> のビットごとの補数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較子は、要素の比較方法をカスタマイズします。 たとえば、<xref:System.Collections.CaseInsensitiveComparer> インスタンスを比較子として使用して、大文字と小文字を区別しない文字列検索を実行できます。  
  
 `comparer` が指定されている場合、指定された <xref:System.Collections.Generic.IComparer%601> 実装を使用して、<xref:System.Collections.Generic.List%601> の要素が指定された値と比較されます。  
  
 `comparer` が `null`場合、既定の比較 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 子は、型 `T` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装し、その実装を使用できる場合にその実装を使用するかどうかをチェックします。  それ以外の場合は、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 型 `T` が <xref:System.IComparable> インターフェイスを実装しているかどうかを確認します。  型 `T` がどちらのインターフェイスも実装していない場合、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> は <xref:System.InvalidOperationException>をスローします。  
  
 <xref:System.Collections.Generic.List%601> は、比較子の実装に従って既に並べ替えられている必要があります。それ以外の場合、結果は正しくありません。  
  
 `null` を任意の参照型と比較することはできますが、<xref:System.IComparable%601> ジェネリックインターフェイスを使用する場合は例外を生成しません。 並べ替えを行う場合、`null` は他のオブジェクトより小さいと見なされます。  
  
 <xref:System.Collections.Generic.List%601> に同じ値を持つ複数の要素が含まれている場合、メソッドは、1つの出現箇所だけを返します。最初の要素とは限りません。  
  
 <xref:System.Collections.Generic.List%601> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算 (~) をこの負の整数に適用すると、検索値よりも大きい最初の要素のインデックスを取得できます。 <xref:System.Collections.Generic.List%601>に値を挿入する場合、並べ替え順序を維持するために、このインデックスを挿入ポイントとして使用する必要があります。  
  
 このメソッドは O (log *n*) 操作です。ここで、 *n*は範囲内の要素の数です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードと、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを示しています。  
  
 この例では、DinoCompare という名前の文字列の代替比較子を定義しています。これC++は、`IComparer<string>` (`IComparer(Of String)` Visual Basic では `IComparer<String^>`、Visual) ジェネリックインターフェイスに実装されています。 比較子は次のように機能します。最初に、比較対照値が `null`に対してテストされ、null 参照が null 以外の値として処理されます。 次に、文字列の長さが比較され、長い方の文字列が大きいと見なされます。 3番目の長さが等しい場合は、通常の文字列比較が使用されます。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成され、特定の順序ではなく4つの文字列が設定されます。 一覧が表示され、代替比較子を使用して並べ替えられて、もう一度表示されます。  
  
 次に、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを使用して、リストに含まれていない複数の文字列を検索し、代替比較子を使用します。 <xref:System.Collections.Generic.List%601.Insert%2A> メソッドは、文字列を挿入するために使用されます。 これら2つのメソッドは `SearchAndInsert`という名前の関数に配置され、ビットごとの補数 (とビジュアルC# C++では ~ 演算子、は <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> で返された負の数の `Xor` は Visual Basic) を使用して、新しい文字列を挿入するためのインデックスとして使用します。  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、既定の比較関数 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> が <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスまたは <see cref="T:System.IComparable" /> 型の <paramref name="T" /> インターフェイスの実装を見つけることができません。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">検索範囲の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索する範囲の長さ。</param>
        <param name="item">検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> 実装。または、既定の比較子 <see langword="null" /> を使用する場合は <see cref="P:System.Collections.Generic.Comparer`1.Default" />。</param>
        <summary>指定した比較子を使用して、並べ替えられた要素の <see cref="T:System.Collections.Generic.List`1" /> の 1 つの要素の範囲を検索し、その要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="item" /> が見つかった場合は、並べ替えられた <see cref="T:System.Collections.Generic.List`1" /> 内の <paramref name="item" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="item" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.Collections.Generic.List`1.Count" /> のビットごとの補数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較子は、要素の比較方法をカスタマイズします。 たとえば、<xref:System.Collections.CaseInsensitiveComparer> インスタンスを比較子として使用して、大文字と小文字を区別しない文字列検索を実行できます。  
  
 `comparer` が指定されている場合、指定された <xref:System.Collections.Generic.IComparer%601> 実装を使用して、<xref:System.Collections.Generic.List%601> の要素が指定された値と比較されます。  
  
 `comparer` が `null`場合、既定の比較 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 子は、型 `T` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装し、その実装を使用できる場合にその実装を使用するかどうかをチェックします。  それ以外の場合は、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 型 `T` が <xref:System.IComparable> インターフェイスを実装しているかどうかを確認します。  型 `T` がどちらのインターフェイスも実装していない場合、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> は <xref:System.InvalidOperationException>をスローします。  
  
 <xref:System.Collections.Generic.List%601> は、比較子の実装に従って既に並べ替えられている必要があります。それ以外の場合、結果は正しくありません。  
  
 `null` を任意の参照型と比較することはできますが、<xref:System.IComparable%601> ジェネリックインターフェイスを使用する場合は例外を生成しません。 並べ替えを行う場合、`null` は他のオブジェクトより小さいと見なされます。  
  
 <xref:System.Collections.Generic.List%601> に同じ値を持つ複数の要素が含まれている場合、メソッドは、1つの出現箇所だけを返します。最初の要素とは限りません。  
  
 <xref:System.Collections.Generic.List%601> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算 (~) をこの負の整数に適用すると、検索値よりも大きい最初の要素のインデックスを取得できます。 <xref:System.Collections.Generic.List%601>に値を挿入する場合、並べ替え順序を維持するために、このインデックスを挿入ポイントとして使用する必要があります。  
  
 このメソッドは O (log *n*) 操作です。ここで、 *n*は範囲内の要素の数です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードと、<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを示しています。  
  
 この例では、DinoCompare という名前の文字列の代替比較子を定義しています。これC++は、`IComparer<string>` (`IComparer(Of String)` Visual Basic では `IComparer<String^>`、Visual) ジェネリックインターフェイスに実装されています。 比較子は次のように機能します。最初に、比較対照値が `null`に対してテストされ、null 参照が null 以外の値として処理されます。 次に、文字列の長さが比較され、長い方の文字列が大きいと見なされます。 3番目の長さが等しい場合は、通常の文字列比較が使用されます。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成され、5つの herbivorous 恐竜と3つの carnivorous 恐竜の名前が設定されます。 2つのグループのそれぞれで、名前は特定の並べ替え順序ではありません。 一覧が表示され、herbivores の範囲が代替比較子を使用して並べ替えられ、一覧が再び表示されます。  
  
 次に、<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを使用して、"Brachiosaurus" の herbivores の範囲だけを検索します。 文字列が見つかりません。ビットごとの補数 (とのC#場合は ~ 演算子C++、とビジュアルの場合は-1 Visual Basic) は、<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドによって返された負の数値の `Xor`、新しい文字列を挿入するためのインデックスとして使用されます。  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="count" /> は <see cref="T:System.Collections.Generic.List`1" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、既定の比較関数 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> が <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスまたは <see cref="T:System.IComparable" /> 型の <paramref name="T" /> インターフェイスの実装を見つけることができません。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内部データ構造体がサイズ変更せずに格納できる要素の合計数を取得または設定します。</summary>
        <value>サイズ変更が必要となるまでに <see cref="T:System.Collections.Generic.List`1" /> に格納できる要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> は、サイズ変更が必要になる前に <xref:System.Collections.Generic.List%601> が格納できる要素の数であり、<xref:System.Collections.Generic.List%601.Count%2A> は実際に <xref:System.Collections.Generic.List%601>内にある要素の数です。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> は、常に <xref:System.Collections.Generic.List%601.Count%2A>以上です。 要素の追加中に <xref:System.Collections.Generic.List%601.Count%2A> が <xref:System.Collections.Generic.List%601.Capacity%2A> を超えた場合は、古い要素をコピーして新しい要素を追加する前に、内部配列が自動的に再割り当てされ、容量が増加します。  
  
 容量がカウントよりも大幅に大きく、<xref:System.Collections.Generic.List%601>によって使用されるメモリを減らす必要がある場合は、<xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを呼び出すか、<xref:System.Collections.Generic.List%601.Capacity%2A> プロパティを明示的に小さい値に設定することにより、容量を減らすことができます。 <xref:System.Collections.Generic.List%601.Capacity%2A> の値が明示的に設定されている場合、内部配列も指定された容量に合わせて再割り当てされ、すべての要素がコピーされます。  
  
 このプロパティの値の取得は O (1) 操作です。プロパティを設定すると、O (*n*) 操作になります。 *n*は新しい容量です。  
  
   
   
## Examples  
 
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例は、単純なビジネスオブジェクトを含む <xref:System.Collections.Generic.List%601> の容量と数を確認する方法と、<xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法を使用して追加容量を削除する方法を示しています。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 次の例では、リストの有効期間におけるいくつかのポイントの <xref:System.Collections.Generic.List%601.Capacity%2A> プロパティを示します。 値が0の文字列のリストを作成するには、パラメーターなしのコンストラクターを使用します。これを示すために <xref:System.Collections.Generic.List%601.Capacity%2A> プロパティが表示されます。 <xref:System.Collections.Generic.List%601.Add%2A> メソッドを使用して複数の項目を追加すると、項目が一覧表示され、<xref:System.Collections.Generic.List%601.Count%2A> プロパティと共に <xref:System.Collections.Generic.List%601.Capacity%2A> プロパティが再び表示され、必要に応じて容量が増加したことが示されます。  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを使用してカウントに一致する容量を減らすと、<xref:System.Collections.Generic.List%601.Capacity%2A> プロパティが再び表示されます。 最後に、<xref:System.Collections.Generic.List%601.Clear%2A> メソッドを使用してリストからすべての項目が削除され、<xref:System.Collections.Generic.List%601.Capacity%2A> と <xref:System.Collections.Generic.List%601.Count%2A> のプロパティが再び表示されます。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> は <see cref="P:System.Collections.Generic.List`1.Count" /> より小さい値に設定します。</exception>
        <exception cref="T:System.OutOfMemoryException">システムで使用可能なメモリが不足しています。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> からすべての要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> が0に設定され、コレクションの要素から他のオブジェクトへの参照も解放されます。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> は変更されません。 <xref:System.Collections.Generic.List%601>の容量をリセットするには、<xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを呼び出すか、<xref:System.Collections.Generic.List%601.Capacity%2A> プロパティを直接設定します。 容量を減らしてメモリを再割り当てし、<xref:System.Collections.Generic.List%601>内のすべての要素をコピーします。 空の <xref:System.Collections.Generic.List%601> をトリミングすると、<xref:System.Collections.Generic.List%601> の容量が既定の容量に設定されます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 次の例は、<xref:System.Collections.Generic.List%601.Clear%2A> メソッドと、<xref:System.Collections.Generic.List%601> ジェネリッククラスのその他のさまざまなプロパティとメソッドを示しています。 <xref:System.Collections.Generic.List%601.Clear%2A> メソッドはプログラムの最後に使用され、リストからすべての項目が削除され、<xref:System.Collections.Generic.List%601.Capacity%2A> と <xref:System.Collections.Generic.List%601.Count%2A> のプロパティが表示されます。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>ある要素が <see cref="T:System.Collections.Generic.List`1" /> 内に存在するかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="item" /> に存在する場合は <see cref="T:System.Collections.Generic.List`1" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、既定の等値比較子を使用して等しいかどうかを判断します。これは、`T` (リスト内の値の型) の <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> メソッドのオブジェクトの実装によって定義されます。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.IEquatable%601.Equals%2A>を実装する単純なビジネスオブジェクトを含む <xref:System.Collections.Generic.List%601> の <xref:System.Collections.Generic.List%601.Contains%2A> および <xref:System.Collections.Generic.List%601.Exists%2A> メソッドを示しています。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 次の例には、`Cube`型の複合オブジェクトの一覧が含まれています。 `Cube` クラスは、2つのキューブが等しいと見なされるように、<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> メソッドを実装します。 この例では、<xref:System.Collections.Generic.List%601.Contains%2A> メソッドは、指定されたディメンションを持つキューブが既にコレクション内にあるため、`true`を返します。  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">変換後の配列要素の型。</typeparam>
        <param name="converter">各要素の型を変換するための <see cref="T:System.Converter`2" /> デリゲート。</param>
        <summary>現在の <see cref="T:System.Collections.Generic.List`1" /> の要素を別の型に変換し、変換された要素が格納されたリストを返します。</summary>
        <returns>現在の <see cref="T:System.Collections.Generic.List`1" /> の要素の型を変換した後の <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> は、オブジェクトを対象の型に変換するメソッドへのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Converter%602> デリゲートに個別に渡され、変換された要素は新しい <xref:System.Collections.Generic.List%601>に保存されます。  
  
 現在の <xref:System.Collections.Generic.List%601> は変更されません。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例では、<xref:System.Drawing.PointF> 構造体を <xref:System.Drawing.Point> 構造体に変換する `PointFToPoint` という名前のメソッドを定義します。 次に、<xref:System.Drawing.PointF> 構造体の <xref:System.Collections.Generic.List%601> を作成し、Visual Basic メソッドを表す `Converter\<PointF, Point>` デリゲート (`PointFToPoint` で`Converter(Of PointF, Point)`) を作成し、そのデリゲートを <xref:System.Collections.Generic.List%601.ConvertAll%2A> メソッドに渡します。 <xref:System.Collections.Generic.List%601.ConvertAll%2A> メソッドは、入力リストの各要素を `PointFToPoint` メソッドに渡し、変換された要素を <xref:System.Drawing.Point> 構造体の新しいリストに格納します。 両方のリストが表示されます。  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> またはその一部を配列にコピーします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> から要素がコピーされる 1 次元の <see cref="T:System.Collections.Generic.List`1" />。 <see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体を互換性のある 1 次元の配列にコピーします。コピー操作は、コピー先の配列の先頭から始まります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.Array.Copy%2A?displayProperty=nameWithType> を使用して要素をコピーします。  
  
 要素は、列挙子が <xref:System.Collections.Generic.List%601>を反復処理するのと同じ順序で <xref:System.Array> にコピーされます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.CopyTo%2A> メソッドの3つのオーバーロードすべてを示しています。 文字列の <xref:System.Collections.Generic.List%601> が作成され、5つの文字列が設定されます。 空の文字列配列15個の要素が作成され、<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> メソッドのオーバーロードを使用して、配列の最初の要素を開始位置として、リストのすべての要素が配列にコピーされます。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> メソッドのオーバーロードを使用して、リストのすべての要素を配列インデックス6から始まる配列にコピーします (インデックス5は空のまま)。 最後に、<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して、インデックス2から始まる3つの要素をリストから配列インデックス12で始まる配列にコピーします (インデックス11を空のままにします)。 配列の内容が表示されます。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">コピー元の <see cref="T:System.Collections.Generic.List`1" /> の要素数が、コピー先 <paramref name="array" /> に含めることができる要素数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> から要素がコピーされる 1 次元の <see cref="T:System.Collections.Generic.List`1" />。 <see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーを開始する <paramref name="array" /> の 0 から始まるインデックス。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体を、互換性のある 1 次元配列の、指定したインデックスから始まる位置にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.Array.Copy%2A?displayProperty=nameWithType> を使用して要素をコピーします。  
  
 要素は、列挙子が <xref:System.Collections.Generic.List%601>を反復処理するのと同じ順序で <xref:System.Array> にコピーされます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.CopyTo%2A> メソッドの3つのオーバーロードすべてを示しています。 文字列の <xref:System.Collections.Generic.List%601> が作成され、5つの文字列が設定されます。 空の文字列配列15個の要素が作成され、<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> メソッドのオーバーロードを使用して、配列の最初の要素を開始位置として、リストのすべての要素が配列にコピーされます。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> メソッドのオーバーロードを使用して、リストのすべての要素を配列インデックス6から始まる配列にコピーします (インデックス5は空のまま)。 最後に、<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して、インデックス2から始まる3つの要素をリストから配列インデックス12で始まる配列にコピーします (インデックス11を空のままにします)。 配列の内容が表示されます。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">コピー元の <see cref="T:System.Collections.Generic.List`1" /> の要素数が、コピー先 <paramref name="arrayIndex" /> の <paramref name="array" /> から最後までの使用可能領域を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">コピーを開始するコピー元の <see cref="T:System.Collections.Generic.List`1" /> 内の、0 から始まるインデックス番号。</param>
        <param name="array"><see cref="T:System.Array" /> から要素がコピーされる 1 次元の <see cref="T:System.Collections.Generic.List`1" />。 <see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーを開始する <paramref name="array" /> の 0 から始まるインデックス。</param>
        <param name="count">コピーする要素の数。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> のうちある範囲の要素を、互換性のある 1 次元の配列にコピーします。コピー操作は、コピー先の配列の指定したインデックスから始まります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.Array.Copy%2A?displayProperty=nameWithType> を使用して要素をコピーします。  
  
 要素は、列挙子が <xref:System.Collections.Generic.List%601>を反復処理するのと同じ順序で <xref:System.Array> にコピーされます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は `count`です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.CopyTo%2A> メソッドの3つのオーバーロードすべてを示しています。 文字列の <xref:System.Collections.Generic.List%601> が作成され、5つの文字列が設定されます。 空の文字列配列15個の要素が作成され、<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> メソッドのオーバーロードを使用して、配列の最初の要素を開始位置として、リストのすべての要素が配列にコピーされます。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> メソッドのオーバーロードを使用して、リストのすべての要素を配列インデックス6から始まる配列にコピーします (インデックス5は空のまま)。 最後に、<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して、インデックス2から始まる3つの要素をリストから配列インデックス12で始まる配列にコピーします (インデックス11を空のままにします)。 配列の内容が表示されます。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="arrayIndex" /> が 0 未満です。  
  
または 
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> がコピー元の <see cref="P:System.Collections.Generic.List`1.Count" /> の <see cref="T:System.Collections.Generic.List`1" /> 以上です。  
  
または 
コピー元の <paramref name="index" /> の <see cref="T:System.Collections.Generic.List`1" /> から最後までの要素数が、コピー先の <paramref name="arrayIndex" /> の <paramref name="array" /> から最後までの使用可能な領域を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> に格納されている要素の数を取得します。</summary>
        <value><see cref="T:System.Collections.Generic.List`1" /> に格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> は、サイズ変更が必要になる前に <xref:System.Collections.Generic.List%601> が格納できる要素の数です。 <xref:System.Collections.Generic.List%601.Count%2A> は、実際に <xref:System.Collections.Generic.List%601>内にある要素の数です。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> は、常に <xref:System.Collections.Generic.List%601.Count%2A>以上です。 要素の追加中に <xref:System.Collections.Generic.List%601.Count%2A> が <xref:System.Collections.Generic.List%601.Capacity%2A> を超えた場合は、古い要素をコピーして新しい要素を追加する前に、内部配列が自動的に再割り当てされ、容量が増加します。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例は、単純なビジネスオブジェクトを含む <xref:System.Collections.Generic.List%601> の容量と数を確認する方法と、<xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法を使用して追加容量を削除する方法を示しています。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 次の例では、リストの有効期間中のさまざまなポイントでの <xref:System.Collections.Generic.List%601.Count%2A> プロパティの値を示します。 リストが作成され、その要素が表示されると、<xref:System.Collections.Generic.List%601.Capacity%2A> と <xref:System.Collections.Generic.List%601.Count%2A> のプロパティが表示されます。 これらのプロパティは、<xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドが呼び出された後、およびリストの内容がクリアされた後に再び表示されます。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> に、指定された述語によって定義された条件と一致する要素が含まれているかどうかを判断します。</summary>
        <returns>指定された述語によって定義された条件と一致する要素が少なくとも 1 つ、<see langword="true" /> に含まれる場合は、<see cref="T:System.Collections.Generic.List`1" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、個別に <xref:System.Predicate%601> デリゲートに渡され、一致が見つかったときに処理が停止されます。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.IEquatable%601.Equals%2A>を実装する単純なビジネスオブジェクトを含む <xref:System.Collections.Generic.List%601> の <xref:System.Collections.Generic.List%601.Contains%2A> および <xref:System.Collections.Generic.List%601.Exists%2A> メソッドを示しています。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 次の例は、<xref:System.Collections.Generic.List%601.Exists%2A> メソッドと、<xref:System.Predicate%601> 汎用デリゲートを使用する他のいくつかのメソッドを示しています。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、この例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドを定義しています。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>、<xref:System.Collections.Generic.List%601.FindLast%2A>、および <xref:System.Collections.Generic.List%601.FindAll%2A> メソッドを使用して、検索述語メソッドを使用してリストを検索し、<xref:System.Collections.Generic.List%601.RemoveAll%2A> メソッドを使用して、"saurus" で終わるすべてのエントリを削除します。  
  
 最後に、<xref:System.Collections.Generic.List%601.Exists%2A> メソッドが呼び出されます。 最初からリストを走査し、各要素を順番に `EndsWithSaurus` メソッドに渡します。 検索は停止し、メソッドは、`EndsWithSaurus` メソッドが任意の要素に対して `true` を返す場合に `true` を返します。 <xref:System.Collections.Generic.List%601.Exists%2A> メソッドは、このようなすべての要素が削除されているため、`false` を返します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary>指定された述語によって定義された条件と一致する要素を検索し、<see cref="T:System.Collections.Generic.List`1" /> 全体の中で最もインデックス番号の小さい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最初の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡されます。 <xref:System.Collections.Generic.List%601>では、最初の要素から最後の要素まで順に移動します。  一致が見つかった場合、処理は停止されます。  
  
> [!IMPORTANT]
>  値型を含むリストを検索する場合は、型の既定値が検索述語を満たしていないことを確認してください。 それ以外の場合は、一致が検出されなかったことを示す既定値と、その型の既定値を持つリスト要素を区別する方法はありません。 既定値が検索述語を満たす場合は、代わりに <xref:System.Collections.Generic.List%601.FindIndex%2A> メソッドを使用します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、単純な複合オブジェクトを含む <xref:System.Collections.Generic.List%601> の <xref:System.Collections.Generic.List%601.Find%2A> メソッドを示しています。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 次の例は、<xref:System.Collections.Generic.List%601> クラスの find メソッドを示しています。 <xref:System.Collections.Generic.List%601> クラスの例には、[サンプル XML ファイル (Books (LINQ to XML))](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)のデータを使用して、クラス `Book`の `book` オブジェクトが含まれています。 この例の `FillList` メソッドでは、 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)を使用して、XML から `book` オブジェクトのプロパティ値を解析します。  
  
 次の表では、find メソッドに用意されている例について説明します。  
  
|メソッド|例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|`IDToFind` 述語デリゲートを使用して、ID で書籍を検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、`Genre` プロパティが "Computer" であるすべての書籍を検索します。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|`PubBefore2001` 述語デリゲートを使用して、2001より前の発行日を持つ、コレクション内の最後のブックを検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最後のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半にある最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半で最後のコンピューターブックのインデックスを検索します。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary>指定された述語によって定義された条件と一致するすべての要素を取得します。</summary>
        <returns>指定した述語によって定義される条件に一致する要素が見つかった場合は、そのすべての要素を格納する <see cref="T:System.Collections.Generic.List`1" />。それ以外の場合は、空の <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡され、条件に一致する要素は返された <xref:System.Collections.Generic.List%601>に保存されます。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601> クラスの find メソッドを示しています。 <xref:System.Collections.Generic.List%601> クラスの例には、[サンプル XML ファイル (Books (LINQ to XML))](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)のデータを使用して、クラス `Book`の `book` オブジェクトが含まれています。 この例の `FillList` メソッドでは、 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)を使用して、XML から `book` オブジェクトのプロパティ値を解析します。  
  
 次の表では、find メソッドに用意されている例について説明します。  
  
|メソッド|例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|`IDToFind` 述語デリゲートを使用して、ID で書籍を検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、`Genre` プロパティが "Computer" であるすべての書籍を検索します。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|`PubBefore2001` 述語デリゲートを使用して、2001より前の発行日を持つ、コレクション内の最後のブックを検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最後のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半にある最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半で最後のコンピューターブックのインデックスを検索します。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> またはその一部分から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。 このメソッドは、条件に一致する項目が見つからなかった場合に -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、最初の要素から最後の要素まで順に検索されます。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡されます。 デリゲートには、次のシグネチャがあります。  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例では、`Name` と `Id`の2つのフィールドを持つ `Employee` クラスを定義します。 また、`EmployeeSearch` クラスコンストラクターに指定された部分文字列で `Employee.Name` フィールドを開始するかどうかを示す単一のメソッド `StartsWith`を持つ `EmployeeSearch` クラスも定義します。 このメソッドのシグネチャに注意してください  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 <xref:System.Collections.Generic.List%601.FindIndex%2A> メソッドに渡すことができるデリゲートのシグネチャに対応します。 この例では、`List<Employee>` オブジェクトをインスタンス化し、そのオブジェクトに多数の `Employee` オブジェクトを追加した後、<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> メソッドを2回呼び出して、`Name` フィールドが "J" で始まる最初の `Employee` オブジェクトに対して最初に呼び出され、次に `Employee` フィールドが "Ju" で始まる最初の `Name` オブジェクトに対して2回目に呼び出されます。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> の指定したインデックスから最後の要素までの範囲内で、指定した述語にで定義される条件に一致する要素を検索し、最初に見つかった 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、`startIndex` から最後の要素までの順に検索されます。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡されます。 デリゲートには、次のシグネチャがあります。  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 演算です。ここで、 *n*は、<xref:System.Collections.Generic.List%601>の `startIndex` から最後までの要素の数です。  
  
   
  
## Examples  
 次の例では、`Name` と `Id`の2つのフィールドを持つ `Employee` クラスを定義します。 また、`EmployeeSearch` クラスコンストラクターに指定された部分文字列で `Employee.Name` フィールドを開始するかどうかを示す単一のメソッド `StartsWith`を持つ `EmployeeSearch` クラスも定義します。 このメソッドのシグネチャに注意してください  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 <xref:System.Collections.Generic.List%601.FindIndex%2A> メソッドに渡すことができるデリゲートのシグネチャに対応します。 この例では、`List<Employee>` オブジェクトをインスタンス化し、そのオブジェクトに多数の `Employee` オブジェクトを追加した後、<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> メソッドを2回呼び出して、5番目のメンバー (つまり、インデックス4のメンバー) からコレクションを検索します。 最初に、`Name` フィールドが "J" で始まる最初の `Employee` オブジェクトを検索します。2回目は、`Name` フィールドが "Ju" で始まる最初の `Employee` オブジェクトを検索します。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> のうち、指定したインデックスから始まり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は `startIndex` から順に検索され、`startIndex` プラス `count`-1 (`count` が0を超える場合) が終わります。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡されます。 デリゲートには、次のシグネチャがあります。  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は `count`です。  
  
   
  
## Examples  
 次の例では、`Name` と `Id`の2つのフィールドを持つ `Employee` クラスを定義します。 また、`EmployeeSearch` クラスコンストラクターに指定された部分文字列で `Employee.Name` フィールドを開始するかどうかを示す単一のメソッド `StartsWith`を持つ `EmployeeSearch` クラスも定義します。 このメソッドのシグネチャに注意してください  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 <xref:System.Collections.Generic.List%601.FindIndex%2A> メソッドに渡すことができるデリゲートのシグネチャに対応します。 この例では、`List<Employee>` オブジェクトをインスタンス化し、そのオブジェクトに多数の `Employee` オブジェクトを追加した後、<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> メソッドを2回呼び出して、コレクション全体 (つまり、インデックス0からインデックス <xref:System.Collections.Generic.List%601.Count%2A>-1 のメンバー) を検索します。 最初に、`Name` フィールドが "J" で始まる最初の `Employee` オブジェクトを検索します。2回目は、`Name` フィールドが "Ju" で始まる最初の `Employee` オブジェクトを検索します。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> が 0 未満です。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> が <see cref="T:System.Collections.Generic.List`1" /> 内の正しいセクションを指定していません。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Collections.Generic.List`1" /> 全体を対象に検索し、最もインデックス番号の大きい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最後の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡され、<xref:System.Collections.Generic.List%601>の前に移動します。最後の要素から始まり、最初の要素で終わります。  一致が見つかった場合、処理は停止されます。  
  
> [!IMPORTANT]
>  値型を含むリストを検索する場合は、型の既定値が検索述語を満たしていないことを確認してください。 それ以外の場合は、一致が検出されなかったことを示す既定値と、その型の既定値を持つリスト要素を区別する方法はありません。 既定値が検索述語を満たす場合は、代わりに <xref:System.Collections.Generic.List%601.FindLastIndex%2A> メソッドを使用します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601> クラスの find メソッドを示しています。 <xref:System.Collections.Generic.List%601> クラスの例には、[サンプル XML ファイル (Books (LINQ to XML))](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)のデータを使用して、クラス `Book`の `book` オブジェクトが含まれています。 この例の `FillList` メソッドでは、 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)を使用して、XML から `book` オブジェクトのプロパティ値を解析します。  
  
 次の表では、find メソッドに用意されている例について説明します。  
  
|メソッド|例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|`IDToFind` 述語デリゲートを使用して、ID で書籍を検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、`Genre` プロパティが "Computer" であるすべての書籍を検索します。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|`PubBefore2001` 述語デリゲートを使用して、2001より前の発行日を持つ、コレクション内の最後のブックを検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最後のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半にある最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半で最後のコンピューターブックのインデックスを検索します。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> またはその一部分から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、最後の要素から後方に検索され、最初の要素で終了します。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡されます。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601> クラスの find メソッドを示しています。 <xref:System.Collections.Generic.List%601> クラスの例には、[サンプル XML ファイル (Books (LINQ to XML))](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)のデータを使用して、クラス `Book`の `book` オブジェクトが含まれています。 この例の `FillList` メソッドでは、 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)を使用して、XML から `book` オブジェクトのプロパティ値を解析します。  
  
 次の表では、find メソッドに用意されている例について説明します。  
  
|メソッド|例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|`IDToFind` 述語デリゲートを使用して、ID で書籍を検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、`Genre` プロパティが "Computer" であるすべての書籍を検索します。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|`PubBefore2001` 述語デリゲートを使用して、2001より前の発行日を持つ、コレクション内の最後のブックを検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最後のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半にある最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半で最後のコンピューターブックのインデックスを検索します。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> のうち、先頭の要素から指定したインデックスまでの範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は `startIndex` から後方に検索され、最初の要素で終了します。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡されます。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 演算です。ここで、 *n*は、`startIndex`する <xref:System.Collections.Generic.List%601> の先頭からの要素の数です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> の指定したインデックスで終わる指定した要素数の範囲内で、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、`startIndex` から後方に検索され、`count` が0よりも大きい場合は `startIndex` からマイナス `count` になります。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Predicate%601> デリゲートに個別に渡されます。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は `count`です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601> クラスの find メソッドを示しています。 <xref:System.Collections.Generic.List%601> クラスの例には、[サンプル XML ファイル (Books (LINQ to XML))](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)のデータを使用して、クラス `Book`の `book` オブジェクトが含まれています。 この例の `FillList` メソッドでは、 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)を使用して、XML から `book` オブジェクトのプロパティ値を解析します。  
  
 次の表では、find メソッドに用意されている例について説明します。  
  
|メソッド|例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|`IDToFind` 述語デリゲートを使用して、ID で書籍を検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、`Genre` プロパティが "Computer" であるすべての書籍を検索します。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|`PubBefore2001` 述語デリゲートを使用して、2001より前の発行日を持つ、コレクション内の最後のブックを検索します。<br /><br /> C#例では、匿名デリゲートを使用します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、最後のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半にある最初のコンピューターブックのインデックスを検索します。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|`FindComputer` 述語デリゲートを使用して、コレクションの後半で最後のコンピューターブックのインデックスを検索します。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> が 0 未満です。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> が <see cref="T:System.Collections.Generic.List`1" /> 内の正しいセクションを指定していません。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><see cref="T:System.Action`1" /> の各要素に対して実行する <see cref="T:System.Collections.Generic.List`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> の各要素に対して、指定された処理を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> は、渡されたオブジェクトに対してアクションを実行するメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、<xref:System.Action%601> デリゲートに個別に渡されます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 <xref:System.Action%601> デリゲートの本体で基になるコレクションを変更することはサポートされていないため、未定義の動作が発生します。  
  
   
  
## Examples  
 次の例では、<xref:System.Action%601> デリゲートを使用して、<xref:System.Collections.Generic.List%601> オブジェクトの内容を出力する方法を示します。 この例では、`Print` メソッドを使用して、リストの内容をコンソールに表示します。  
  
> [!NOTE]
>  `Print` メソッドを使用して内容を表示することにC#加え、この例では、[匿名メソッド](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)を使用して結果をコンソールに表示する方法を示します。  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">コレクションの要素が変更されています。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> を反復処理する列挙子を返します。</summary>
        <returns><see cref="T:System.Collections.Generic.List`1.Enumerator" /> の <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  C# 言語の `foreach` ステートメント (C++ では `for each`、Visual Basic では `For Each`) では、列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初、列挙子はコレクションの先頭の要素の前に位置付けられます。 この位置では、<xref:System.Collections.Generic.List%601.Enumerator.Current%2A> プロパティは定義されていません。 そのため、<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.Generic.List%601.Enumerator.Current%2A> メソッドを呼び出し、列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> プロパティは、<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> が呼び出されるまで、同じオブジェクトを返します。 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> は、<xref:System.Collections.Generic.List%601.Enumerator.Current%2A> を次の要素に設定します。  
  
 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> がコレクションの末尾を通過した場合、列挙子がコレクション内の最後の要素の後に配置され、<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> は `false` を返します。 列挙子がこの位置にある場合、後続の <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 呼び出しも `false` を返します。 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> の最後の呼び出しが `false`を返した場合、<xref:System.Collections.Generic.List%601.Enumerator.Current%2A> は定義されていません。 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 列挙子は、コレクションが変更されない限り有効です。 要素の追加、変更、削除などの変更がコレクションに対して行われた場合、列挙子はなりに無効になり、次に <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> または <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> を呼び出すと <xref:System.InvalidOperationException>がスローされます。  
  
 列挙子はコレクションに排他アクセスできないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するために、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、O(1) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">範囲が開始する位置の、0 から始まる <see cref="T:System.Collections.Generic.List`1" /> のインデックス番号。</param>
        <param name="count">範囲内の要素の数。</param>
        <summary>コピー元の <see cref="T:System.Collections.Generic.List`1" /> 内の、ある範囲の要素の簡易コピーを作成します。</summary>
        <returns>コピー元の <see cref="T:System.Collections.Generic.List`1" /> 内の、ある範囲の要素の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照型のコレクションの簡易コピー、またはそのコレクションのサブセットには、コレクションの要素への参照のみが含まれます。 オブジェクト自体はコピーされません。 新しいリスト内の参照は、元のリスト内の参照と同じオブジェクトを指します。  
  
 値型のコレクションの簡易コピー、またはそのコレクションのサブセットには、コレクションの要素が含まれます。 ただし、コレクションの要素に他のオブジェクトへの参照が含まれている場合、それらのオブジェクトはコピーされません。 新しいコレクションの要素内の参照は、元のコレクションの要素内の参照と同じオブジェクトを指します。  
  
 これに対し、コレクションの詳細コピーでは、要素と、要素によって直接的または間接的に参照されるすべての要素がコピーされます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は `count`です。  
  
   
  
## Examples  
 次の例は、範囲に作用する <xref:System.Collections.Generic.List%601> クラスの <xref:System.Collections.Generic.List%601.GetRange%2A> メソッドとその他のメソッドを示しています。 この例の最後では、<xref:System.Collections.Generic.List%601.GetRange%2A> メソッドを使用して、インデックス位置2から始まる3つの項目をリストから取得します。 結果の <xref:System.Collections.Generic.List%601>に対して <xref:System.Collections.Generic.List%601.ToArray%2A> メソッドが呼び出され、3つの要素の配列が作成されます。 配列の要素が表示されます。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="count" /> は <see cref="T:System.Collections.Generic.List`1" /> において要素の有効な範囲を表していません。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体またはその一部において、最初に値が出現した位置のインデックス番号 (0 から始まる) を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体から指定したオブジェクトを検索し、最初に見つかったオブジェクトのインデックス (0 から始まる) を返します。</summary>
        <returns><paramref name="item" /> 全体を対象に <see cref="T:System.Collections.Generic.List`1" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素の 0 から始まるインデックス番号、それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、最初の要素から最後の要素まで順に検索されます。  
  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.IndexOf%2A> メソッドの3つのオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回表示される文字列の <xref:System.Collections.Generic.List%601> が作成されます。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> メソッドオーバーロードは、先頭からリストを検索し、最初に見つかった文字列を検索します。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> メソッドオーバーロードを使用して、インデックス位置3で始まるリストを検索し、リストの末尾まで進み、2番目に出現する文字列を検索します。 最後に、<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して2つのエントリの範囲を検索します。インデックスの位置2から開始します。検索文字列のインスタンスがこの範囲内に存在しないため、-1 が返されます。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <param name="index">検索の開始位置を示す 0 から始まるインデックス。 空のリストでは 0 (ゼロ) は有効です。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> のうち指定したインデックスから最後の要素までの要素範囲の中から、指定したオブジェクトを検索し、最初に出現する位置の 0 から始まるインデックス番号を返します。</summary>
        <returns><paramref name="item" /> から最後の要素までの <see cref="T:System.Collections.Generic.List`1" /> 内の要素の範囲内で <paramref name="index" /> が見つかった場合は、最初に見つかった位置の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、`index` から最後の要素までの順に検索されます。  
  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 演算です。ここで、 *n*は、<xref:System.Collections.Generic.List%601>の `index` から最後までの要素の数です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.IndexOf%2A> メソッドの3つのオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回表示される文字列の <xref:System.Collections.Generic.List%601> が作成されます。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> メソッドオーバーロードは、先頭からリストを検索し、最初に見つかった文字列を検索します。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> メソッドオーバーロードを使用して、インデックス位置3で始まるリストを検索し、リストの末尾まで進み、2番目に出現する文字列を検索します。 最後に、<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して2つのエントリの範囲を検索します。インデックスの位置2から開始します。検索文字列のインスタンスがこの範囲内に存在しないため、-1 が返されます。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <param name="index">検索の開始位置を示す 0 から始まるインデックス。 空のリストでは 0 (ゼロ) は有効です。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したインデックスから始まり、指定した数の要素が含まれる <see cref="T:System.Collections.Generic.List`1" /> の要素範囲内で、指定したオブジェクトを検索し、最初に出現する位置の 0 から始まるインデックス番号を返します。</summary>
        <returns><paramref name="item" /> から始まって <see cref="T:System.Collections.Generic.List`1" /> 個の要素を格納する <paramref name="index" /> 内の要素の範囲内で <paramref name="count" /> が見つかった場合は、最初に見つかった位置の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は `index` から順に検索され、`index` プラス `count`-1 (`count` が0を超える場合) が終わります。  
  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は `count`です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.IndexOf%2A> メソッドの3つのオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回表示される文字列の <xref:System.Collections.Generic.List%601> が作成されます。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> メソッドオーバーロードは、先頭からリストを検索し、最初に見つかった文字列を検索します。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> メソッドオーバーロードを使用して、インデックス位置3で始まるリストを検索し、リストの末尾まで進み、2番目に出現する文字列を検索します。 最後に、<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して2つのエントリの範囲を検索します。インデックスの位置2から開始します。検索文字列のインスタンスがこの範囲内に存在しないため、-1 が返されます。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> が 0 未満です。  
  
または 
 <paramref name="index" /> および <paramref name="count" /> が <see cref="T:System.Collections.Generic.List`1" /> 内の正しいセクションを指定していません。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index"><paramref name="item" /> を挿入する位置の、0 から始まるインデックス。</param>
        <param name="item">挿入するオブジェクトです。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 内の指定したインデックスの位置に要素を挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、参照型の有効な値として `null` を受け入れ、重複する要素を許可します。  
  
 <xref:System.Collections.Generic.List%601.Count%2A> 既に <xref:System.Collections.Generic.List%601.Capacity%2A>に等しい場合は、内部配列が自動的に再割り当てされ、既存の要素が新しい配列にコピーされてから、新しい要素が追加されるまで、<xref:System.Collections.Generic.List%601> の容量が増加します。  
  
 `index` が <xref:System.Collections.Generic.List%601.Count%2A>に等しい場合、`item` は <xref:System.Collections.Generic.List%601>の最後に追加されます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例では、<xref:System.Collections.Generic.List%601>に単純なビジネスオブジェクトを追加、削除、および挿入する方法を示します。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 次の例では、<xref:System.Collections.Generic.List%601.Insert%2A> メソッドと、<xref:System.Collections.Generic.List%601> ジェネリッククラスのその他のさまざまなプロパティとメソッドについて説明します。 リストが作成されると、要素が追加されます。 <xref:System.Collections.Generic.List%601.Insert%2A> メソッドを使用して、リストの中央に項目を挿入します。 挿入された項目は重複しており、後で <xref:System.Collections.Generic.List%601.Remove%2A> メソッドを使用して削除されます。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="index" /> が <see cref="P:System.Collections.Generic.List`1.Count" /> より大きくなっています。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">新しい要素を挿入する位置の 0 から始まるインデックス。</param>
        <param name="collection"><see cref="T:System.Collections.Generic.List`1" /> に要素を挿入するコレクション。 コレクション自体を <see langword="null" /> にすることはできませんが、型 <see langword="null" /> が参照型の場合、コレクションに格納する要素は <paramref name="T" /> であってもかまいません。</param>
        <summary>コレクションの要素を <see cref="T:System.Collections.Generic.List`1" /> 内の指定したインデックスの位置に挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、参照型の有効な値として `null` を受け入れ、重複する要素を許可します。  
  
 新しい <xref:System.Collections.Generic.List%601.Count%2A> (現在の <xref:System.Collections.Generic.List%601.Count%2A> とコレクションのサイズの合計) が <xref:System.Collections.Generic.List%601.Capacity%2A>を超える場合、新しい要素を格納するために内部配列が自動的に再割り当てされ、新しい要素が追加される前に既存の要素が新しい配列にコピーされて、<xref:System.Collections.Generic.List%601> の容量が増加します。  
  
 `index` が <xref:System.Collections.Generic.List%601.Count%2A>に等しい場合は <xref:System.Collections.Generic.List%601>の末尾に要素が追加されます。  
  
 コレクション内の要素の順序は、<xref:System.Collections.Generic.List%601>に保持されます。  
  
 このメソッドは O (*n* * *m*) 演算です。ここで、 *n*は加算する要素の数で、 *m*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例では、範囲に作用する <xref:System.Collections.Generic.List%601> クラスの <xref:System.Collections.Generic.List%601.InsertRange%2A> メソッドとその他のさまざまなメソッドを示します。 リストが作成され、複数の平和的植物の恐竜の名前が設定された後、<xref:System.Collections.Generic.List%601.InsertRange%2A> メソッドを使用して、3つの ferocious の恐竜の配列をリストに挿入します。この一覧は、インデックス位置3から始まります。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="index" /> が <see cref="P:System.Collections.Generic.List`1.Count" /> より大きくなっています。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得または設定する要素の、0 から始まるインデックス番号。</param>
        <summary>指定したインデックスにある要素を取得または設定します。</summary>
        <value>指定したインデックス位置にある要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、参照型の有効な値として `null` を受け入れ、重複する要素を許可します。  
  
 このプロパティでは、`myCollection[index]` という構文を使用して、コレクション内の特定の要素にアクセスできます。  
  
 このプロパティの値の取得は O (1) 操作です。プロパティの設定は、O (1) 操作でもあります。  
  
   
  
## Examples  
 このセクションの例では、<xref:System.Collections.Generic.List%601.Item%2A> プロパティ (のC#インデクサー) と、<xref:System.Collections.Generic.List%601> ジェネリッククラスのその他のさまざまなプロパティとメソッドについて説明します。 <xref:System.Collections.Generic.List%601.Add%2A> メソッドを使用してリストを作成して設定すると、要素が取得され、<xref:System.Collections.Generic.List%601.Item%2A> プロパティを使用して表示されます。 (<xref:System.Collections.Generic.List%601.Item%2A> プロパティを使用してリスト要素の値を設定する例については、「<xref:System.Collections.Generic.List%601.AsReadOnly%2A>」を参照してください)。  
  
> [!NOTE]
>  Visual Basic、 C#、およびC++にはすべて、名前を使用せずに <xref:System.Collections.Generic.List%601.Item%2A> プロパティにアクセスするための構文があります。 代わりに、<xref:System.Collections.Generic.List%601> を含む変数が配列であるかのように使用されます。  
  
 このC#言語では、<xref:System.Collections.Generic.List%601.Item%2A> プロパティを実装する代わりに、 [`this`](~/docs/csharp/language-reference/keywords/this.md)キーワードを使用してインデクサーを定義します。 Visual Basic は、<xref:System.Collections.Generic.List%601.Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="index" /> が <see cref="P:System.Collections.Generic.List`1.Count" /> 以上になっています。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体またはその一部において、最後に値が出現した位置のインデックス番号 (0 から始まる) を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体から指定したオブジェクトを検索し、最後に見つかったオブジェクトのインデックス (0 から始まる) を返します。</summary>
        <returns><paramref name="item" /> が見つかった場合は、<see cref="T:System.Collections.Generic.List`1" /> 全体で最後に見つかった位置のインデックス番号 (0 から始まる)。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、最後の要素から後方に検索され、最初の要素で終了します。  
  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.LastIndexOf%2A> メソッドの3つのオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回表示される文字列の <xref:System.Collections.Generic.List%601> が作成されます。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> メソッドオーバーロードは、末尾からリスト全体を検索し、2番目に出現する文字列を検索します。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> メソッドのオーバーロードを使用して、リストをインデックス位置3で後方に検索し、リストの先頭まで続行します。これにより、リスト内で最初に出現する文字列が検索されます。 最後に、<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して4つのエントリの範囲を検索します。このとき、インデックス位置4から後方に拡張します (つまり、場所4、3、2、および1の項目を検索します)。検索文字列のインスタンスがこの範囲内に存在しないため、この検索では-1 が返されます。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <param name="index">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> のうち、最初の要素から指定したインデックスまでの要素範囲の中で、指定したオブジェクトを検索し、最後に出現する位置の 0 から始まるインデックス番号を返します。</summary>
        <returns>最初の要素から <paramref name="item" /> までの <see cref="T:System.Collections.Generic.List`1" /> 内の要素の範囲内で <paramref name="index" /> が見つかった場合は、最後に見つかった位置の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は `index` から後方に検索され、最初の要素で終了します。  
  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 演算です。ここで、 *n*は、`index`する <xref:System.Collections.Generic.List%601> の先頭からの要素の数です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.LastIndexOf%2A> メソッドの3つのオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回表示される文字列の <xref:System.Collections.Generic.List%601> が作成されます。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> メソッドオーバーロードは、末尾からリスト全体を検索し、2番目に出現する文字列を検索します。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> メソッドのオーバーロードを使用して、リストをインデックス位置3で後方に検索し、リストの先頭まで続行します。これにより、リスト内で最初に出現する文字列が検索されます。 最後に、<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して4つのエントリの範囲を検索します。このとき、インデックス位置4から後方に拡張します (つまり、場所4、3、2、および1の項目を検索します)。検索文字列のインスタンスがこの範囲内に存在しないため、この検索では-1 が返されます。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <param name="index">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> のうち、指定した要素数が含まれ、指定したインデックスの位置で終了する要素範囲の中で、指定したオブジェクトを検索し、最後に出現する位置の 0 から始まるインデックス番号を返します。</summary>
        <returns><paramref name="item" /> 個の要素を格納し、<see cref="T:System.Collections.Generic.List`1" /> の位置で終了する <paramref name="count" /> 内の要素の範囲内で <paramref name="index" /> が見つかった場合は、最後に見つかった位置の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> は、`index` から後方に検索され、`count` が0よりも大きい場合は `index` からマイナス `count` になります。  
  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は `count`です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.LastIndexOf%2A> メソッドの3つのオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回表示される文字列の <xref:System.Collections.Generic.List%601> が作成されます。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> メソッドオーバーロードは、末尾からリスト全体を検索し、2番目に出現する文字列を検索します。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> メソッドのオーバーロードを使用して、リストをインデックス位置3で後方に検索し、リストの先頭まで続行します。これにより、リスト内で最初に出現する文字列が検索されます。 最後に、<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して4つのエントリの範囲を検索します。このとき、インデックス位置4から後方に拡張します (つまり、場所4、3、2、および1の項目を検索します)。検索文字列のインスタンスがこの範囲内に存在しないため、この検索では-1 が返されます。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は <see cref="T:System.Collections.Generic.List`1" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> が 0 未満です。  
  
または 
 <paramref name="index" /> および <paramref name="count" /> が <see cref="T:System.Collections.Generic.List`1" /> 内の正しいセクションを指定していません。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" /> から削除するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>特定のオブジェクトが <see cref="T:System.Collections.Generic.List`1" /> 内にあるときに、最初に出現したものを削除します。</summary>
        <returns><see langword="true" /> が正常に削除された場合は <paramref name="item" />。それ以外の場合は <see langword="false" />。  このメソッドは、<see langword="false" /> が <paramref name="item" /> に見つからなかった場合にも <see cref="T:System.Collections.Generic.List`1" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型 `T` が <xref:System.IEquatable%601> ジェネリックインターフェイスを実装している場合、等値比較子はそのインターフェイスの <xref:System.IEquatable%601.Equals%2A> メソッドです。それ以外の場合、既定の等値比較子は <xref:System.Object.Equals%2A?displayProperty=nameWithType>になります。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例では、<xref:System.Collections.Generic.List%601>に単純なビジネスオブジェクトを追加、削除、および挿入する方法を示します。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 <xref:System.Collections.Generic.List%601.Remove%2A> メソッドの例を次に示します。 <xref:System.Collections.Generic.List%601> ジェネリッククラスのいくつかのプロパティとメソッドを使用して、リストを追加、挿入、および検索します。 これらの操作の後に、一覧に重複が含まれています。 <xref:System.Collections.Generic.List%601.Remove%2A> メソッドを使用して、重複する項目の最初のインスタンスを削除すると、内容が表示されます。 <xref:System.Collections.Generic.List%601.Remove%2A> メソッドは、最初に見つかったインスタンスを常に削除します。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">削除する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary>指定した述語により定義される条件に一致するすべての要素を削除します。</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" /> から削除される要素の数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、個別に <xref:System.Predicate%601> デリゲートに渡され、条件に一致する要素は <xref:System.Collections.Generic.List%601>から削除されます。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.RemoveAll%2A> メソッドと、<xref:System.Predicate%601> 汎用デリゲートを使用する他のいくつかのメソッドを示しています。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、この例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドを定義しています。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>、<xref:System.Collections.Generic.List%601.FindLast%2A>、および <xref:System.Collections.Generic.List%601.FindAll%2A> メソッドを使用して、検索述語メソッドを使用してリストを検索します。  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> メソッドは、"saurus" で終わるすべてのエントリを削除するために使用されます。 最初からリストを走査し、各要素を順番に `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが `true`を返した場合、要素は削除されます。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 最後に、<xref:System.Collections.Generic.List%601.Exists%2A> メソッドは、"saurus" で終わる文字列がリストにないことを確認します。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素の 0 から始まるインデックス。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> の指定したインデックスにある要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.RemoveAt%2A> を呼び出して項目を削除すると、リスト内の残りの項目の番号が変更され、削除された項目が置き換えられます。 たとえば、インデックス3の項目を削除すると、インデックス4の項目が3つの位置に移動します。 また、リスト内の項目の数 (<xref:System.Collections.Generic.List%601.Count%2A> プロパティによって表されます) が1ずつ減少します。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は (<xref:System.Collections.Generic.List%601.Count%2A> - `index`) です。  
  
   
  
## Examples  
 次の例では、<xref:System.Collections.Generic.List%601>に単純なビジネスオブジェクトを追加、削除、および挿入する方法を示します。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="index" /> が <see cref="P:System.Collections.Generic.List`1.Count" /> 以上になっています。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素の範囲の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">削除する要素の数を指定します。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> から要素の範囲を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> これらの項目は削除され、その後に続くすべての要素は、`count`によってインデックスが小さくなります。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.RemoveRange%2A> メソッドと、範囲に作用する <xref:System.Collections.Generic.List%601> クラスのその他のさまざまなメソッドを示しています。 リストを作成して変更した後、<xref:System.Collections.Generic.List%601.RemoveRange%2A> メソッドを使用して、インデックス位置2から始まる2つの要素をリストから削除します。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="count" /> は <see cref="T:System.Collections.Generic.List`1" /> において要素の有効な範囲を表していません。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> またはその一部の要素の順序を反転させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 全体の要素の順序を反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Array.Reverse%2A?displayProperty=nameWithType> を使用して要素の順序を逆にします。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.Reverse%2A> メソッドの両方のオーバーロードを示しています。 この例では、文字列の <xref:System.Collections.Generic.List%601> を作成し、6つの文字列を追加します。 <xref:System.Collections.Generic.List%601.Reverse> メソッドのオーバーロードを使用してリストを反転した後、<xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用してリストの中間を反転します。これは、要素1から始まり、4つの要素から構成されます。  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">反転させる範囲の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">反転させる範囲内にある要素の数。</param>
        <summary>指定した範囲の要素の順序を反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Array.Reverse%2A?displayProperty=nameWithType> を使用して要素の順序を逆にします。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.Reverse%2A> メソッドの両方のオーバーロードを示しています。 この例では、文字列の <xref:System.Collections.Generic.List%601> を作成し、6つの文字列を追加します。 <xref:System.Collections.Generic.List%601.Reverse> メソッドのオーバーロードを使用してリストを反転した後、<xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用してリストの中間を反転します。これは、要素1から始まり、4つの要素から構成されます。  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="count" /> は <see cref="T:System.Collections.Generic.List`1" /> において要素の有効な範囲を表していません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> の指定した実装または既定の実装を使用するか、リストの要素を比較する指定した <see cref="T:System.Collections.Generic.IComparer`1" /> デリゲートを使用して、<see cref="T:System.Comparison`1" /> の要素または要素の一部を並べ替えます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定の比較子を使用して、<see cref="T:System.Collections.Generic.List`1" /> 全体内の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、型 `T` の既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> を使用して、リスト要素の順序を決定します。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> プロパティは、型 `T` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装し、その実装を使用するかどうかを確認します (使用可能な場合)。  それ以外の場合は、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 型 `T` が <xref:System.IComparable> インターフェイスを実装しているかどうかを確認します。  型 `T` がどちらのインターフェイスも実装していない場合、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> は <xref:System.InvalidOperationException>をスローします。  
  
 このメソッドは <xref:System.Array.Sort%2A?displayProperty=nameWithType> メソッドを使用し、次のように introspective sort を適用します。  
  
-   パーティションサイズが16要素以下の場合は、挿入並べ替えアルゴリズムが使用されます。  
  
-   パーティションの数が2つのログ*n*( *n*は入力配列の範囲) を超えている場合、heapsort アルゴリズムが使用されます。  
  
-   それ以外の場合は、クイックソートアルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 平均して、このメソッドは O (*n* log *n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。最悪のケースでは、O (*n*<sup>2</sup>) 操作です。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]
 
 次の例では、`List<String>` オブジェクトにいくつかの名前を追加し、並べ替えられていない順序で一覧を表示し、<xref:System.Collections.Generic.List%601.Sort%2A> メソッドを呼び出して、並べ替えられたリストを表示します。  
  
 [!code-csharp-interactive[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 次のコードは、単純なビジネスオブジェクトでの <xref:System.Collections.Generic.List%601.Sort> と <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> メソッドのオーバーロードを示しています。 <xref:System.Collections.Generic.List%601.Sort> メソッドを呼び出すと、パーツ型の既定の比較子が使用され、<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> メソッドは匿名メソッドを使用して実装されます。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 次の例は、<xref:System.Collections.Generic.List%601.Sort> メソッドのオーバーロードと、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> メソッドのオーバーロードを示しています。 文字列の <xref:System.Collections.Generic.List%601> が作成され、特定の順序ではなく4つの文字列が設定されます。 一覧が表示され、並べ替えられて、もう一度表示されます。  
  
 次に、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> メソッドのオーバーロードを使用して、リストに含まれていない2つの文字列を検索し、<xref:System.Collections.Generic.List%601.Insert%2A> メソッドを使用してそれらの文字列を挿入します。 文字列がリストに含まれていないため、<xref:System.Collections.Generic.List%601.BinarySearch%2A> メソッドの戻り値は、各ケースで負の値になります。 ビットごとの補数 (およびでC#は ~ 演算子) C++を取得すると、この負の数値の `Xor`-1 Visual Basic) によって、検索文字列よりも大きいリスト内の最初の要素のインデックスが生成されます。この位置に挿入すると、並べ替え順序が保持されます。 2番目の検索文字列がリスト内のどの要素よりも大きいため、挿入位置がリストの末尾にあります。  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">既定の比較関数 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスまたは <see cref="T:System.IComparable" /> 型の <paramref name="T" /> インターフェイスの実装を見つけることができません。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> 実装。または、既定の比較子 <see langword="null" /> を使用する場合は <see cref="P:System.Collections.Generic.Comparer`1.Default" />。</param>
        <summary>指定した比較子を使用して、<see cref="T:System.Collections.Generic.List`1" /> 全体内の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparer` が指定されている場合、<xref:System.Collections.Generic.List%601> の要素は、指定された <xref:System.Collections.Generic.IComparer%601> 実装を使用して並べ替えられます。  
  
 `comparer` が `null`場合、既定の比較 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 子は、型 `T` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装し、その実装を使用できる場合にその実装を使用するかどうかをチェックします。  それ以外の場合は、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 型 `T` が <xref:System.IComparable> インターフェイスを実装しているかどうかを確認します。  型 `T` がどちらのインターフェイスも実装していない場合、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> は <xref:System.InvalidOperationException>をスローします。  
  
 このメソッドは <xref:System.Array.Sort%2A?displayProperty=nameWithType> メソッドを使用し、次のように introspective sort を適用します。  
  
-   パーティションサイズが16要素以下の場合は、挿入並べ替えアルゴリズムが使用されます。  
  
-   パーティションの数が2つのログ*n*( *n*は入力配列の範囲) を超えている場合、heapsort アルゴリズムが使用されます。  
  
-   それ以外の場合は、クイックソートアルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 平均して、このメソッドは O (*n* log *n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。最悪のケースでは、O (*n*<sup>2</sup>) 操作です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードと、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを示しています。  
  
 この例では、DinoCompare という名前の文字列の代替比較子を定義しています。これC++は、`IComparer<string>` (`IComparer(Of String)` Visual Basic では `IComparer<String^>`、Visual) ジェネリックインターフェイスに実装されています。 比較子は次のように機能します。最初に、比較対照値が `null`に対してテストされ、null 参照が null 以外の値として処理されます。 次に、文字列の長さが比較され、長い方の文字列が大きいと見なされます。 3番目の長さが等しい場合は、通常の文字列比較が使用されます。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成され、特定の順序ではなく4つの文字列が設定されます。 一覧が表示され、代替比較子を使用して並べ替えられて、もう一度表示されます。  
  
 次に、<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを使用して、リストに含まれていない複数の文字列を検索し、代替比較子を使用します。 <xref:System.Collections.Generic.List%601.Insert%2A> メソッドは、文字列を挿入するために使用されます。 これら2つのメソッドは `SearchAndInsert`という名前の関数に配置され、ビットごとの補数 (とビジュアルC# C++では ~ 演算子、は <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> で返された負の数の `Xor` は Visual Basic) を使用して、新しい文字列を挿入するためのインデックスとして使用します。  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、既定の比較関数 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> が <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスまたは <see cref="T:System.IComparable" /> 型の <paramref name="T" /> インターフェイスの実装を見つけることができません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">要素を比較する場合に使用する <see cref="T:System.Comparison`1" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.List`1" /> を使用して、<see cref="T:System.Comparison`1" /> 全体内の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparison` が指定されている場合、<xref:System.Collections.Generic.List%601> の要素は、デリゲートによって表されるメソッドを使用して並べ替えられます。  
  
 `comparison` が `null`場合は、<xref:System.ArgumentNullException> がスローされます。  
  
 このメソッドは <xref:System.Array.Sort%2A?displayProperty=nameWithType>を使用します。これにより、次のように introspective sort が適用されます。  
  
-   パーティションサイズが16要素以下の場合は、挿入並べ替えアルゴリズムが使用されます。  
  
-   パーティションの数が2つのログ*n*( *n*は入力配列の範囲) を超えている場合、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、クイックソートアルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 平均して、このメソッドは O (*n* log *n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。最悪のケースでは、O (*n*<sup>2</sup>) 操作です。  
  
   
  
## Examples  
 次のコードは、単純なビジネスオブジェクトでの <xref:System.Collections.Generic.List%601.Sort%2A> と <xref:System.Collections.Generic.List%601.Sort%2A> メソッドのオーバーロードを示しています。 <xref:System.Collections.Generic.List%601.Sort%2A> メソッドを呼び出すと、パート型の既定の比較子が使用され、<xref:System.Collections.Generic.List%601.Sort%2A> メソッドは匿名メソッドを使用して実装されます。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 次の例は、<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> メソッドのオーバーロードを示しています。  
  
 この例では、`CompareDinosByLength`という名前の文字列に対して、別の比較メソッドを定義しています。 このメソッドは次のように機能します。最初に、比較対照値が `null`に対してテストされ、null 参照が null 以外の値として処理されます。 次に、文字列の長さが比較され、長い方の文字列が大きいと見なされます。 3番目の長さが等しい場合は、通常の文字列比較が使用されます。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成され、特定の順序ではなく4つの文字列が設定されます。 この一覧には、空の文字列と null 参照も含まれています。 リストが表示され、`CompareDinosByLength` メソッドを表す <xref:System.Comparison%601> 汎用デリゲートを使用して並べ替えられて、もう一度表示されます。  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparison" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">並べ替える範囲の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">並べ替える範囲の長さ。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> 実装。または、既定の比較子 <see langword="null" /> を使用する場合は <see cref="P:System.Collections.Generic.Comparer`1.Default" />。</param>
        <summary>指定した比較子を使用して、<see cref="T:System.Collections.Generic.List`1" /> 内の要素の範囲内の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparer` が指定されている場合、<xref:System.Collections.Generic.List%601> の要素は、指定された <xref:System.Collections.Generic.IComparer%601> 実装を使用して並べ替えられます。  
  
 `comparer` が `null`場合、既定の比較 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 子は、型 `T` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装し、その実装を使用できる場合にその実装を使用するかどうかをチェックします。  それ以外の場合は、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 型 `T` が <xref:System.IComparable> インターフェイスを実装しているかどうかを確認します。  型 `T` がどちらのインターフェイスも実装していない場合、<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> は <xref:System.InvalidOperationException>をスローします。  
  
 このメソッドは <xref:System.Array.Sort%2A?displayProperty=nameWithType>を使用します。これにより、次のように introspective sort が適用されます。  
  
-   パーティションサイズが16要素以下の場合は、挿入並べ替えアルゴリズムが使用されます。  
  
-   パーティションの数が2つのログ*n*( *n*は入力配列の範囲) を超えている場合、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、クイックソートアルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 平均して、このメソッドは O (*n* log *n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。最悪のケースでは、O (*n*<sup>2</sup>) 操作です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードと、<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを示しています。  
  
 この例では、DinoCompare という名前の文字列の代替比較子を定義しています。これC++は、`IComparer<string>` (`IComparer(Of String)` Visual Basic では `IComparer<String^>`、Visual) ジェネリックインターフェイスに実装されています。 比較子は次のように機能します。最初に、比較対照値が `null`に対してテストされ、null 参照が null 以外の値として処理されます。 次に、文字列の長さが比較され、長い方の文字列が大きいと見なされます。 3番目の長さが等しい場合は、通常の文字列比較が使用されます。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成され、5つの herbivorous 恐竜と3つの carnivorous 恐竜の名前が設定されます。 2つのグループのそれぞれで、名前は特定の並べ替え順序ではありません。 一覧が表示され、herbivores の範囲が代替比較子を使用して並べ替えられ、一覧が再び表示されます。  
  
 次に、<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドのオーバーロードを使用して、"Brachiosaurus" の herbivores の範囲だけを検索します。 文字列が見つかりません。ビットごとの補数 (とのC#場合は ~ 演算子C++、とビジュアルの場合は-1 Visual Basic) は、<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> メソッドによって返された負の数値の `Xor`、新しい文字列を挿入するためのインデックスとして使用されます。  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が 0 未満です。  
  
または 
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="count" /> は <see cref="T:System.Collections.Generic.List`1" /> において有効な範囲を指定していません。  
  
または 
<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、既定の比較関数 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> が <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスまたは <see cref="T:System.IComparable" /> 型の <paramref name="T" /> インターフェイスの実装を見つけることができません。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">カルチャの影響を受けないコレクションの操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.ICollection`1" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が読み取り専用である場合は <see cref="T:System.Collections.Generic.ICollection`1" />。それ以外の場合は <see langword="false" />。  <see cref="T:System.Collections.Generic.List`1" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取り専用のコレクションでは、コレクション作成後に要素の追加、削除、または変更はできません。  
  
 読み取り専用のコレクションは、単純にコレクションを変更できないようにするラッパーを含むコレクションです。したがって、基になるコレクションに変更が加えられた場合、読み取り専用コレクションにはこれらの変更が反映されます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを繰り返し処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  C# 言語の `foreach` ステートメント (C++ では `for each`、Visual Basic では `For Each`) では、列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初、列挙子はコレクションの先頭の要素の前に位置付けられます。 この位置では、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> プロパティは定義されていません。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> メソッドを呼び出し、列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> プロパティは、<xref:System.Collections.IEnumerator.MoveNext%2A> が呼び出されるまで、同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を次の要素に設定します。  
  
 <xref:System.Collections.IEnumerator.MoveNext%2A> がコレクションの末尾を通過した場合、列挙子がコレクション内の最後の要素の後に配置され、<xref:System.Collections.IEnumerator.MoveNext%2A> は `false` を返します。 列挙子がこの位置にある場合、後続の <xref:System.Collections.IEnumerator.MoveNext%2A> 呼び出しも `false` を返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> の最後の呼び出しが `false`を返した場合、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> は定義されていません。 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 列挙子は、コレクションが変更されない限り有効です。 要素の追加、変更、削除などの変更がコレクションに対して行われた場合、列挙子はなりに無効になり、次に <xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> を呼び出すと <xref:System.InvalidOperationException>がスローされます。  
  
 列挙子はコレクションに排他アクセスできないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するために、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、O(1) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> から要素がコピーされる 1 次元の <see cref="T:System.Collections.ICollection" />。 <see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーを開始する <paramref name="array" /> の 0 から始まるインデックス。</param>
        <summary><see cref="T:System.Collections.ICollection" /> の要素を <see cref="T:System.Array" /> にコピーします。<see cref="T:System.Array" /> の特定のインデックスからコピーが開始されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  ソース <xref:System.Collections.ICollection> の型を変換先の `array`の型に自動的にキャストできない場合、<xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> の非ジェネリック実装は <xref:System.InvalidCastException>をスローしますが、ジェネリック実装では <xref:System.ArgumentException>がスローされます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> が多次元です。  
  
または 
 <paramref name="array" /> には、0 から始まるインデックス番号がありません。  
  
または 
コピー元の <see cref="T:System.Collections.ICollection" /> の要素数が、コピー先 <paramref name="arrayIndex" /> の <paramref name="array" /> から最後までの使用可能領域を超えています。  
  
または 
コピー元の <see cref="T:System.Collections.ICollection" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ICollection" /> へのアクセスが同期されている (スレッド セーフである) かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> へのアクセスが同期されている (スレッド セーフである) 場合は <see cref="T:System.Collections.ICollection" />。それ以外の場合は <see langword="false" />。  <see cref="T:System.Collections.Generic.List`1" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間のコレクションの既定の実装は同期されません。  
  
 コレクションの列挙処理は、本質的にスレッドセーフな処理ではありません。  列挙が書き込みアクセスによって競合するまれなケースとして、列挙全体の間にコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> は、<xref:System.Collections.ICollection>へのアクセスを同期するために使用できるオブジェクトを返します。 同期は、コレクションにアクセスする前にすべてのスレッドがこのオブジェクトをロックする場合にのみ有効です。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value><see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクト。  <see cref="T:System.Collections.Generic.List`1" /> の既定の実装では、このプロパティは常に現在のインスタンスを返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間のコレクションの既定の実装は同期されません。  
  
 コレクションの列挙処理は、本質的にスレッドセーフな処理ではありません。  列挙処理でスレッド セーフを確保するために、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> は、<xref:System.Collections.ICollection>へのアクセスを同期するために使用できるオブジェクトを返します。 同期は、コレクションにアクセスする前にすべてのスレッドがこのオブジェクトをロックする場合にのみ有効です。 次のコードは、、 C# C++、および Visual Basic の <xref:System.Collections.ICollection.SyncRoot%2A> プロパティの使用方法を示しています。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを繰り返し処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  C# 言語の `foreach` ステートメント (C++ では `for each`、Visual Basic では `For Each`) では、列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初、列挙子はコレクションの先頭の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> プロパティは定義されていません。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> メソッドを呼び出し、列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> プロパティは、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまで、同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 <xref:System.Collections.IEnumerator.MoveNext%2A> がコレクションの末尾を通過した場合、列挙子がコレクション内の最後の要素の後に配置され、<xref:System.Collections.IEnumerator.MoveNext%2A> は `false` を返します。 列挙子がこの位置にある場合、後続の <xref:System.Collections.IEnumerator.MoveNext%2A> 呼び出しも `false` を返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> の最後の呼び出しが `false`を返した場合、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。 <xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 列挙子は、コレクションが変更されない限り有効です。 要素の追加、変更、削除などの変更がコレクションに対して行われた場合、列挙子はなりに無効になり、次に <xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> を呼び出すと <xref:System.InvalidOperationException>がスローされます。  
  
 列挙子はコレクションに排他アクセスできないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するために、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、O(1) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" /> に追加する <see cref="T:System.Collections.IList" />。</param>
        <summary><see cref="T:System.Collections.IList" /> に項目を追加します。</summary>
        <returns>新しい要素が挿入された位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> が <xref:System.Collections.Generic.List%601.Capacity%2A>より小さい場合、このメソッドは O (1) 操作になります。 新しい要素に対応するために容量を増やす必要がある場合、このメソッドは O (*n*) 操作になります。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> は <see cref="T:System.Collections.IList" /> に割り当てることのできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" /> 内で検索される <see cref="T:System.Collections.IList" />。</param>
        <summary><see cref="T:System.Collections.IList" /> に特定の値が格納されているかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="item" /> に存在する場合は <see cref="T:System.Collections.IList" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.IList" /> 内で検索するオブジェクト。</param>
        <summary><see cref="T:System.Collections.IList" /> 内の特定の項目のインデックスを確認します。</summary>
        <returns>リストに存在する場合は <paramref name="item" /> のインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> は <see cref="T:System.Collections.IList" /> に割り当てることのできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><paramref name="item" /> を挿入する位置の、0 から始まるインデックス。</param>
        <param name="item"><see cref="T:System.Collections.IList" /> に挿入するオブジェクト。</param>
        <summary>指定したインデックスの <see cref="T:System.Collections.IList" /> に項目を挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` が <xref:System.Collections.IList> 内の項目数に等しければ、`item` が末尾に追加されます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> は <see cref="T:System.Collections.IList" /> に割り当てることのできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.IList" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が固定サイズの場合は <see cref="T:System.Collections.IList" />。それ以外の場合は <see langword="false" />。  <see cref="T:System.Collections.Generic.List`1" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 固定サイズのコレクションでは、コレクションの作成後に要素の追加または削除はできませんが、既存の要素の変更はできます。  
  
 固定サイズのコレクションは、要素の追加と削除を防ぐラッパーを持つ単純なコレクションです。したがって、要素の追加や削除など、基になるコレクションに変更が加えられた場合、固定サイズのコレクションにはこれらの変更が反映されます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.IList" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が読み取り専用である場合は <see cref="T:System.Collections.IList" />。それ以外の場合は <see langword="false" />。  <see cref="T:System.Collections.Generic.List`1" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取り専用のコレクションでは、コレクション作成後に要素の追加、削除、または変更はできません。  
  
 読み取り専用のコレクションは、単純にコレクションを変更できないようにするラッパーを含むコレクションです。したがって、基になるコレクションに変更が加えられた場合、読み取り専用コレクションにはこれらの変更が反映されます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得または設定する要素の、0 から始まるインデックス番号。</param>
        <summary>指定したインデックスにある要素を取得または設定します。</summary>
        <value>指定したインデックス位置にある要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このC#言語では、<xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> プロパティを実装する代わりに、 [this](~/docs/csharp/language-reference/keywords/this.md)キーワードを使用してインデクサーを定義します。 Visual Basic は、<xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 このプロパティの値の取得は O (1) 操作です。プロパティの設定は、O (1) 操作でもあります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">プロパティが設定されていて、<paramref name="value" /> が <see cref="T:System.Collections.IList" /> に割り当てることのできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.IList" /> から削除するオブジェクト。</param>
        <summary>特定のオブジェクトが <see cref="T:System.Collections.IList" /> 内にあるときに、最初に出現したものを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、リスト内の値の型 `T`に <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 既定の等値比較子を使用して、等しいかどうかを判断します。  
  
 このメソッドは、線形検索を実行します。したがって、このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> は <see cref="T:System.Collections.IList" /> に割り当てることのできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> の要素を新しい配列にコピーします。</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" /> の要素のコピーを格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素は <xref:System.Array.Copy%2A?displayProperty=nameWithType>を使用してコピーされます。これは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、範囲に作用する <xref:System.Collections.Generic.List%601> クラスの <xref:System.Collections.Generic.List%601.ToArray%2A> メソッドとその他のメソッドを示しています。 この例の最後では、<xref:System.Collections.Generic.List%601.GetRange%2A> メソッドを使用して、インデックス位置2から始まる3つの項目をリストから取得します。 結果の <xref:System.Collections.Generic.List%601>に対して <xref:System.Collections.Generic.List%601.ToArray%2A> メソッドが呼び出され、3つの要素の配列が作成されます。 配列の要素が表示されます。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 内にある実際の要素数がしきい値未満の場合は、容量をその数に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コレクションに新しい要素が追加されない場合は、このメソッドを使用してコレクションのメモリオーバーヘッドを最小限に抑えることができます。 ただし、大きな <xref:System.Collections.Generic.List%601> の再割り当てとコピーにかかるコストはかなり大きくなる可能性があるため、<xref:System.Collections.Generic.List%601.TrimExcess%2A> の方法では、リストの容量が90% を超える場合は何も行われません。 これにより、比較的小さな増加に対して大きな再割り当てコストが発生することを回避できます。  
  
> [!NOTE]
>  現在のしきい値である90% は、今後のリリースで変更される可能性があります。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
 <xref:System.Collections.Generic.List%601> を初期状態にリセットするには、<xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを呼び出す前に <xref:System.Collections.Generic.List%601.Clear%2A> メソッドを呼び出します。 空の <xref:System.Collections.Generic.List%601> をトリミングすると、<xref:System.Collections.Generic.List%601> の容量が既定の容量に設定されます。  
  
 容量は、<xref:System.Collections.Generic.List%601.Capacity%2A> プロパティを使用して設定することもできます。  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 次の例は、単純なビジネスオブジェクトを含む <xref:System.Collections.Generic.List%601> の容量と数を確認する方法と、<xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法を使用して追加容量を削除する方法を示しています。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A>メソッドの例を次に示します。 <xref:System.Collections.Generic.List%601> クラスのいくつかのプロパティとメソッドを使用して、文字列のリストの項目を追加、挿入、および削除します。 その後、<xref:System.Collections.Generic.List%601.TrimExcess%2A> メソッドを使用して、カウントに一致する容量を減らし、<xref:System.Collections.Generic.List%601.Capacity%2A> と <xref:System.Collections.Generic.List%601.Count%2A> のプロパティを表示します。 未使用の容量が合計容量の10% 未満の場合、一覧のサイズは変更されませんでした。 最後に、リストの内容が消去されます。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 内のすべての要素が、指定した述語によって定義される条件に一致するかどうかを調べます。</summary>
        <returns><see langword="true" /> 内のすべての要素が、指定した述語によって定義される条件に一致する場合は <see cref="T:System.Collections.Generic.List`1" />。それ以外の場合は <see langword="false" />。 リストに要素がない場合、戻り値は <see langword="true" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  現在の <xref:System.Collections.Generic.List%601> の要素は、個別に <xref:System.Predicate%601> デリゲートに渡され、デリゲートが任意の要素に対して `false` を返すと処理が停止されます。 要素は順番に処理され、すべての呼び出しが1つのスレッドで行われます。  
  
 このメソッドは O (*n*) 操作です。ここで、 *n*は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## Examples  
 次の例は、<xref:System.Collections.Generic.List%601.TrueForAll%2A> メソッドと、<xref:System.Predicate%601> 汎用デリゲートを使用する他のいくつかのメソッドを示しています。  
  
 文字列の <xref:System.Collections.Generic.List%601> が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、この例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドを定義しています。  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A> メソッドは、最初からリストを走査し、各要素を順番に `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが `false`を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
