<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b9c41852a3767d8cfd83dfdccb6a15000d1459b9" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83937558" /></Metadata><TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ResourceManager extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <TypeSignature Language="F#" Value="type ResourceManager = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Resources.ResourceManager" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Resources.ResourceManager" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-1.0;netstandard-1.1;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netcore-3.1;netcore-1.0;netcore-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;net-5.0">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>実行時にカルチャ固有のリソースにアクセスする便利な手段を提供するリソース マネージャーを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.Resources.ResourceManager> クラスは、アセンブリに埋め込まれているバイナリ .resources ファイル、または、スタンドアロンの .resources ファイルからリソースを取得します。 アプリがローカライズされ、ローカライズされたリソースが[サテライト アセンブリ](/dotnet/framework/resources/creating-satellite-assemblies-for-desktop-apps)に配置されているなら、アプリは、カルチャ固有のリソースを検索し、ローカライズされたリソースが存在しない場合は、リソース フォールバックを提供します。また、リソースのシリアル化をサポートします。

 デスクトップ アプリや [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでのリソース作成および管理の詳細については、次のセクションを参照してください。

-   [デスクトップアプリ](#desktop)

    -   [リソースの作成](#creating_resources)

    -   [ResourceManager オブジェクトのインスタンス化](#instantiating)

    -   [ResourceManager とカルチャ固有のリソース](#CultureSpecific)

    -   [リソースの取得](#retrieving)

    -   [MissingManifestResourceException と MissingSatelliteAssemblyException の例外の処理](#exception)

    -   [リソースのバージョン管理](#versioning)

    -   [\<satelliteassemblies> 構成ファイルのノード](#config)

-   [Windows ストアアプリ](#ws)

<a name="desktop"></a>
## <a name="desktop-apps"></a>デスクトップアプリ
 デスクトップ アプリの場合、<xref:System.Resources.ResourceManager> クラスは、バイナリ リソース (.resources) ファイルからリソースを取得します。 通常は、言語コンパイラか[アセンブリ リンカー (AL.exe)](/dotnet/framework/tools/al-exe-assembly-linker) がアセンブリにこれらのリソース ファイルを埋め込みます。 <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> メソッドを呼び出すことによって、<xref:System.Resources.ResourceManager> オブジェクトを使用して、アセンブリに埋め込まれていない .resources ファイルからリソースを直接取得できます。

> [!CAUTION]
>  ASP.NET アプリでスタンドアロン .resources ファイルを使用すると、XCOPY による配置が中断されます。<xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドによって明示的に解放されるまで、リソースがロックされたままになるためです。 ASP.NET アプリでリソースを配置する場合は、サテライト アセンブリに .resources ファイルをコンパイルする必要があります。

 リソース ベースのアプリでは、1 つの .resources ファイルは既定のカルチャのリソースを含んでいます。そのリソースは、カルチャ固有のリソースが見つからない場合に使用されます。 たとえば、アプリの既定のカルチャが英語 (en) の場合は、英語 (米国) (en-US) やフランス語 (フランス) (fr-FR) などの、特定のカルチャに対してローカライズされたリソースが見つからないときに、英語の言語リソースが使用されます。 通常は、既定のカルチャのリソースはメイン アプリ アセンブリに埋め込まれ、他のローカライズされたリソースはサテライト アセンブリに埋め込まれます。 サテライト アセンブリはリソースのみを含みます。 サテライト アセンブリは、メイン アセンブリと同じルート ファイル名と、resources.dll の拡張子を持ちます。 アプリのアセンブリがグローバル アセンブリ キャッシュに登録されていない場合は、サテライト アセンブリは、アセンブリのカルチャに対応する名前を持つ、アプリのサブディレクトリに格納されます。

<a name="creating_resources"></a>
### <a name="creating-resources"></a>リソースの作成
 リソース ベースのアプリを開発する際は、テキスト ファイル (.txt か .restext 拡張子を持つファイル) または XML ファイル (.resx 拡張子を持つファイル) にリソース情報を格納します。 それから[リソース ファイル ジェネレーター (Resgen.exe)](/dotnet/framework/tools/resgen-exe-resource-file-generator) を使用して、テキスト ファイルまたは XML ファイルをコンパイルし、バイナリ .resources ファイルを作成します。 C# や Visual Basic コンパイラにおける `/resources` のようなコンパイラ オプションを使用して、作成した .resources ファイルを実行可能ファイルまたはライブラリに埋め込むことができます。または、アセンブリ リンカー (Al.exe) を使用して、サテライト アセンブリに埋め込むことができます。 Visual Studio プロジェクトに .resx ファイルを含めると、Visual Studio はビルド プロセスの一部として、既定のリソースとローカライズされたリソースのコンパイルおよび埋め込みを自動的に処理します。

 理想的には、アプリがサポートするすべての言語か、少なくとも各言語で意味をなすサブセットに対して、リソースを作成してください。 バイナリ .resources ファイルの名前は、*basename*.*cultureName*.resources の名前付け規則に従います。ここで *basename* は、必要な詳細のレベルに応じて、アプリの名前またはクラスの名前になります。 *cultureName* を判断するには、<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> プロパティを使用します。 アプリの既定のカルチャのリソースには、*basename*.resources の名前をつけてください。

 たとえば、ベースの名前に MyResources を持つリソース ファイルにいくつかのリソースが含まれているアセンブリを想定します。 これらのリソース ファイルは、日本 (日本語) のカルチャには MyResources.ja-JP.resources、ドイツのカルチャには MyResources.de.resources、簡体中国語のカルチャには MyResources.zh-CHS.resources、フランス語 (ベルギー) のカルチャには MyResources.fr-BE.resources、などの名前を持つ必要があります。 既定のリソース ファイルは MyResources.resources の名前を持つ必要があります。 通常は、カルチャ固有のリソース ファイルは、カルチャごとにサテライト アセンブリにパッケージ化されます。 既定のリソース ファイルは、アプリのメイン アセンブリに埋め込まれる必要があります。

 [アセンブリリンカー](/dotnet/framework/tools/al-exe-assembly-linker)では、リソースをプライベートとしてマークすることができますが、他のアセンブリからアクセスできるようにするには、常にパブリックとしてマークする必要があります。 (サテライト アセンブリはコードを含まないため、プライベートとしてマークされたリソースは、どんな方法を使ってもアプリで使用できません。)

 リソースの作成、パッケージ化、および、配置の詳細については、[リソース ファイルの作成](/dotnet/framework/resources/creating-resource-files-for-desktop-apps)、[サテライト アセンブリの作成](/dotnet/framework/resources/creating-satellite-assemblies-for-desktop-apps)、[リソースのパッケージ化と配置](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)の記事を参照してください。

<a name="instantiating"></a>
### <a name="instantiating-a-resourcemanager-object"></a>ResourceManager オブジェクトのインスタンス化
 埋め込まれた .resources ファイルからリソースを取得する <xref:System.Resources.ResourceManager> オブジェクトのインスタンス化は、それのクラス コンストラクターのオーバーロードの 1 つを呼び出すことによって行います。 これは、<xref:System.Resources.ResourceManager> オブジェクトを、特定の .resources ファイルや、サテライト アセンブリにあり関連するローカライズされた .resources ファイルとを密に結びつけます。

 最もよく呼び出されるコンストラクターは次の 2 つです。

-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> は、指定した 2 つの情報に基づいてリソースを検索します。それらは .resources ファイルのベース名と、既定の .resources ファイルが存在するアセンブリです。 ベース名は、.resources ファイルの名前空間とルート名を含み、それのカルチャや拡張子を含みません。 コマンド ラインからコンパイルされた .resources ファイルは、通常は名前空間の名前を含みませんが、Visual Studio 環境で作成した .resources ファイルはそれを含むことに注意してください。 たとえば、リソース ファイルの名前が MyCompany.StringResources.resources であり、`Example.Main` という名前の静的メソッドから <xref:System.Resources.ResourceManager> コンストラクターを呼び出す場合、次のコードが .resources ファイルからリソースを取得できる <xref:System.Resources.ResourceManager> オブジェクトをインスタンス化します。

     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]

-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> は、型オブジェクトからの情報に基づいて、サテライト アセンブリにあるリソースを検索します。 型の完全修飾名は、ファイル名の拡張子を含まない .resources ファイルのベース名に対応します。 Visual Studio リソース デザイナーを使用して作成されたデスクトップ アプリでは、Visual Studio は .resources ファイルのルート名と同じ完全修飾名を持つラッパー クラスを作成します。 たとえば、リソース ファイルの名前が MyCompany.StringResources.resources であり、`MyCompany.StringResources` という名前のラッパー クラスがある場合、次のコードが .resources ファイルからリソースを取得できる <xref:System.Resources.ResourceManager> オブジェクトをインスタンス化します。

     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]

 適切なリソースが見つからない場合、コンストラクターの呼び出しは有効な <xref:System.Resources.ResourceManager> オブジェクトを作成します。 ただし、リソースを取得しようとすると、<xref:System.Resources.MissingManifestResourceException> 例外がスローされます。 例外に対処する方法については、この記事で後述する [MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理](#exception)を参照してください。

 次の例は、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化する方法を示しています。 それには ShowTime.exe という名前の実行可能ファイルのソース コードが含まれています。 また、次に示す `TimeHeader` という唯一の文字列リソースを含む、Strings.txt という名前のテキスト ファイルも含まれます。

```
TimeHeader=The current time is
```

 バッチ ファイルを使用して、リソース ファイルを生成し、実行可能ファイルに埋め込むことができます。 C# コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。

```

resgen strings.txt
csc ShowTime.cs /resource:strings.resources

```

 Visual Basic コンパイラでは、次のバッチファイルを使用できます。

```

resgen strings.txt
vbc ShowTime.vb /resource:strings.resources

```

 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]

<a name="CultureSpecific"></a>
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager とカルチャ固有のリソース
 [リソースのパッケージ化と配置](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)の記事で説明したように、ローカライズされたアプリはリソースを配置する必要があります。 アセンブリが正しく構成されているなら、リソース マネージャーは、現在のスレッドの <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティに基づいて、どのリソースを取得するかを決定します。 (そのプロパティは現在のスレッドの UI カルチャを返します。) たとえば、メイン アセンブリに既定の英語の言語リソースがあり、2 つのサテライト アセンブリにフランス語とロシア語の言語リソースがあるようにアプリがコンパイルされていて、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティが fr-FR に設定されている場合、リソース マネージャーはフランス語のリソースを取得します。

 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティは明示的または暗黙的に設定できます。 それを設定する方法によって、<xref:System.Resources.ResourceManager> オブジェクトがカルチャに基づいてリソースを取得する方法が決定されます。

-   明示的に <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティに特定のカルチャを設定する場合、リソース マネージャーは常に、ユーザーのブラウザーまたはオペレーティング システムの言語に関係なく、そのカルチャのリソースを取得します。 既定の英語の言語リソースと、英語 (米国)、フランス語 (フランス)、およびロシア語 (ロシア) のリソースを含む 3 つのサテライト アセンブリとともにコンパイルされているアプリを考えます。 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティが fr-FR に設定されている場合、たとえユーザーのオペレーティング システムの言語がフランス語ではないとしても、<xref:System.Resources.ResourceManager> オブジェクトは常にフランス語 (フランス) のリソースを取得します。 プロパティを明示的に設定する前に、これが目的の動作であることを確認してください。

     ASP.NET アプリでは、サーバーの設定が受信したクライアント要求と一致しない可能性があるため、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティを明示的に設定する必要があります。 ASP.NET アプリは <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティをユーザーのブラウザーが受け入れ可能な言語に明示的に設定できます。

     <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティを明示的に設定することによって、そのスレッドの現在の UI カルチャが定義されます。 これは、アプリの他のスレッドの現在の UI カルチャには影響しません。

-   <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 静的プロパティに UI カルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを割り当てることで、アプリ ドメイン内のすべてのスレッドの UI カルチャを設定できます。

-   現在の UI カルチャを明示的に設定せず、現在のアプリ ドメインに既定のカルチャを定義しない場合、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティは Windows の `GetUserDefaultUILanguage` 関数によって暗黙的に設定されます。 この関数は Multilingual User Interface (MUI) によって提供されます。MUI は、ユーザーが既定の言語を設定できるようにします。 UI 言語がユーザーによって設定されていない場合、その既定値はシステムによってインストールされた言語になります。これはオペレーティング システムのリソースの言語です。

 次の単純な "Hello world" の例では、現在の UI カルチャを明示的に設定します。 これには、英語 (米国) (en-US)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の 3 つのカルチャのリソースが含まれています。 en-US のリソースは、Greetings.txt という名前のテキスト ファイルに含まれています。

```
HelloString=Hello world!
```

 fr-FR のリソースは、Greetings.fr-FR.txt という名前のテキスト ファイルに含まれています。

```
HelloString=Salut tout le monde!
```

 ru-RU のリソースは、Greetings.ru-RU.txt という名前のテキスト ファイルに含まれています。

```
HelloString=Всем привет!
```

 次に、この例のソース コード (Visual Basic バージョンの Example.vb または C# バージョンの Example.cs) を示します。

 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]

 この例をコンパイルするには、次のコマンドを含むバッチ (.bat) ファイルを作成し、コマンド プロンプトからそれを実行します。 C# を使用している場合は、`vbc` の代わりに `csc` を指定し、`Example.vb` の代わりに `Example.cs` を指定します。

```
resgen Greetings.txt
vbc Example.vb /resource:Greetings.resources

resgen Greetings.fr-FR.txt
Md fr-FR
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll

resgen Greetings.ru-RU.txt
Md ru-RU
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll
```

<a name="retrieving"></a>
### <a name="retrieving-resources"></a>リソースの取得
 特定のリソースにアクセスするには、<xref:System.Resources.ResourceManager.GetObject%28System.String%29> と <xref:System.Resources.ResourceManager.GetString%28System.String%29> メソッドを呼び出します。 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> メソッドを呼び出して、文字列以外のリソースをバイト配列として取得することもできます。 既定では、リソースがローカライズされているアプリでは、これらのメソッドは、呼び出しを行ったスレッドの現在の UI カルチャによって決定されるカルチャのリソースを返します。 スレッドの現在の UI カルチャを定義する方法の詳細については、前のセクションの [ResourceManager とカルチャ固有のリソース](#CultureSpecific)を参照してください。 リソース マネージャーが現在のスレッドの UI カルチャのリソースを見つけられない場合は、フォールバック プロセスを使用して、指定したリソースを取得します。 リソース マネージャーがローカライズされたリソースを何も見つけられない場合は、既定のカルチャのリソースを使用します。 リソース フォールバック規則の詳細については、[リソースのパッケージ化と配置](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)の記事内の「リソース フォールバック プロセス」セクションを参照してください。

> [!NOTE]
>  <xref:System.Resources.ResourceManager> クラスのコンストラクターで指定された .resources ファイルが見つからない場合、リソースを取得しようとすると、<xref:System.Resources.MissingManifestResourceException> または <xref:System.Resources.MissingSatelliteAssemblyException> 例外がスローされます。 例外に対処する方法については、この記事で後述する [MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理](#exception)を参照してください。

 次の例では、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを使用して、カルチャ固有のリソースを取得します。 これは、英語 (en)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の .txt ファイルからコンパイルされたリソースで構成されます。 例では、現在のカルチャと現在の UI カルチャを、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に変更します。 それから、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを呼び出して、ローカライズされた文字列を取得します。この文字列は現在の日付と月と一緒に表示されます。 現在の UI カルチャがスウェーデン語 (スウェーデン) である場合を除き、適切なローカライズされた文字列が出力に表示されることに注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは代わりに既定のカルチャである英語のリソースを使用します。

 例には、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 それぞれには `DateStart` という名前の唯一の文字列リソースがあります。

|カルチャ|ファイル名|リソース名|リソースの値|
|-------------|---------------|-------------------|--------------------|
|ja-JP|DateStrings.txt|`DateStart`|Today is|
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui、c' est le|
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|

 次に、この例のソース コード (Visual Basic バージョンの ShowDate.vb または C# バージョンの ShowDate.cs) を示します。

 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]

 この例をコンパイルするには、次のコマンドを含むバッチ ファイルを作成し、コマンド プロンプトからそれを実行します。 C# を使用している場合は、`vbc` の代わりに `csc` を指定し、`showdate.vb` の代わりに `showdate.cs` を指定します。

```

resgen DateStrings.txt
vbc showdate.vb /resource:DateStrings.resources

md fr-FR
resgen DateStrings.fr-FR.txt
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources

md ru-RU
resgen DateStrings.ru-RU.txt
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources

```

 現在の UI カルチャ以外の特定のカルチャのリソースを取得する方法は 2 つあります。

-   <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>、<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>、または<xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを呼び出して、指定したカルチャのリソースを取得できます。 ローカライズされたリソースが見つからない場合、リソース マネージャーはリソース フォールバック プロセスを使用して、適切なリソースを見つけます。

-   <xref:System.Resources.ResourceManager.GetResourceSet%2A> メソッドを呼び出して、特定のカルチャのリソースを表す <xref:System.Resources.ResourceSet> オブジェクトを取得できます。 メソッドの呼び出しでは、ローカライズされたリソースが見つからない場合に、親カルチャのリソース マネージャーのプローブを作成するかどうかや、単純に既定のカルチャのリソースにフォールバックするかどうかを指定できます。 その後、<xref:System.Resources.ResourceSet> のメソッドを使用して、(そのカルチャに向けてローカライズされた) リソースに名前でアクセスしたり、または、セット内のリソースを列挙したりできます。

<a name="exception"></a>
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>MissingManifestResourceException と MissingSatelliteAssemblyException の例外の処理
 特定のリソースを取得しようとしても、リソース マネージャーがそのリソースを見つけられないときに、既定のカルチャが定義されていないか、または既定のカルチャのリソースが見つからない場合、リソース マネージャーは、メイン アセンブリにリソースを探しているなら、<xref:System.Resources.MissingManifestResourceException> 例外をスローし、サテライト アセンブリにリソースを探しているなら、<xref:System.Resources.MissingSatelliteAssemblyException> 例外をスローします。 例外がスローされるのは、<xref:System.Resources.ResourceManager.GetString%2A> や <xref:System.Resources.ResourceManager.GetObject%2A> などのリソース取得メソッドを呼び出すときであり、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化するときではないことに注意してください。

 この例外は、通常、次のような状況でスローされます。

-   適切なリソース ファイルまたはサテライト アセンブリが存在しません。 リソース マネージャーによって、アプリの既定のリソースがメイン アプリ アセンブリに埋め込まれていることが期待される場合に、それらが存在しません。 <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性によって、アプリの既定のリソースがサテライト アセンブリに存在することが指示されている場合に、そのアセンブリが見つかりません。 アプリをコンパイルするときに、リソースがメイン アセンブリに埋め込まれているか、あるいは必要なサテライト アセンブリが生成され、適切な名前がついていることを確認します。 その名前は *appName*.resources.dll の形式をとる必要があります。また、含まれているリソースのカルチャに基づいて名前をつけたディレクトリに配置する必要があります。

-   アプリに既定のカルチャ、あるいはニュートラル カルチャがありません。 ソース コード ファイルまたはプロジェクトの情報ファイル (Visual Basic アプリでは AssemblyInfo.vb、C# アプリでは AssemblyInfo.cs) に <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性を追加します。

-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> コンストラクターの `baseName` パラメーターに .resources ファイルの名前が指定されていません。 名前には、リソース ファイルの完全修飾名前空間を含める必要がありますが、そのファイル名拡張子は不要です。 通常、Visual Studio で作成されるリソース ファイルは名前空間の名前を含みますが、コマンド プロンプトで作成されコンパイルされたリソース ファイルはそれを含みません。 次のユーティリティをコンパイルして実行すると、埋め込まれた .resources ファイルの名前を判断できます。 これは、メイン アセンブリまたはサテライト アセンブリの名前をコマンド ライン パラメーターとして指定するコンソール アプリです。 これは、リソース マネージャーがリソースを正しく特定できるように、`baseName` パラメーターに指定するべき文字列を表示します。

     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]

 アプリケーションの現在のカルチャを明示的に変更する場合、リソース マネージャーは <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティではなく <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティの値に基づいてリソース セットを取得することも覚えておいてください。 通常は、一方の値を変更するなら、もう一方も変更する必要があります。

<a name="versioning"></a>
### <a name="resource-versioning"></a>リソースのバージョン管理
 アプリの既定のリソースを含むメイン アセンブリは、アプリのサテライト アセンブリから切り離されているため、サテライト アセンブリを再配置せずに、メイン アセンブリの新しいバージョンをリリースできます。 既存のサテライト アセンブリを使用し、メイン アセンブリの新しいバージョンと一緒にそれらを再配置しないようにリソース マネージャーに指示するためには、<xref:System.Resources.SatelliteContractVersionAttribute> 属性を使用します。

 サテライト アセンブリのバージョン管理サポートの詳細については、[リソースの取得](/dotnet/framework/resources/retrieving-resources-in-desktop-apps)の記事を参照してください。

<a name="config"></a>
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies> 構成ファイルのノード
 Web サイト (HREF .exe ファイル) から展開と実行がされる実行可能ファイルの場合、<xref:System.Resources.ResourceManager> オブジェクトは Web 経由でサテライト アセンブリのプローブを作成する可能性があり、アプリのパフォーマンスが低下することがあります。 パフォーマンスの問題を排除するために、アプリと一緒に配置したサテライト アセンブリへのプローブを制限できます。 これを行うには、アプリの構成ファイル内に `<satelliteassemblies>` ノードを作成し、アプリの特定のカルチャのセットを配置したことと、<xref:System.Resources.ResourceManager> オブジェクトがそのノードに示されていないカルチャのプローブを作成するべきではないことを指定します。

> [!NOTE]
>  `<satelliteassemblies>` ノードの作成より推奨される方法は、[ClickOnce 配置マニフェスト](/visualstudio/deployment/clickonce-deployment-manifest)の機能を使用することです。

 アプリの構成ファイルで、次のようなセクションを作成します。

```
<?xml version ="1.0"?>
<configuration>
    <satelliteassemblies>
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">
            <culture>cultureName1</culture>
            <culture>cultureName2</culture>
            <culture>cultureName3</culture>
        </assembly>
    </satelliteassemblies>
</configuration>
```

 この構成情報は次のように編集します。

-   配置するメイン アセンブリごとに `<assembly>` ノードを 1 つ以上指定し、各ノードで完全修飾アセンブリ名を指定します。 *MainAssemblyName* の場所にメイン アセンブリの名前を指定し、メイン アセンブリに対応する `Version`、`PublicKeyToken`、および `Culture` 属性の値を指定します。

     `Version` 属性には、アセンブリのバージョン番号を指定します。 たとえば、アセンブリの最初のリリースでは、バージョン番号は 1.0.0.0 になるでしょう。

     `PublicKeyToken` 属性には、厳密な名前でアセンブリに署名していない場合は、キーワード `null` を指定し、アセンブリに署名した場合は、公開キー トークンを指定します。

     `Culture` 属性には、メイン アセンブリを指定するためにキーワード `neutral` を指定し、<xref:System.Resources.ResourceManager> クラスが `<culture>` ノードに示されているカルチャに対してのみプローブを作成するようにします。

     完全修飾アセンブリ名の詳細については、[アセンブリ名](/dotnet/standard/assembly/names)の記事を参照してください。 厳密な名前付きアセンブリの詳細については、「[厳密な名前付きアセンブリの作成と使用](/dotnet/standard/assembly/create-use-strong-named)」を参照してください。

-   "fr-FR" などの特定のカルチャ名、または "fr" などのニュートラル カルチャ名を持つ `<culture>` ノードを 1 つ以上指定します。

 `<satelliteassemblies>` ノード下に示されていないアセンブリにリソースが必要な場合、<xref:System.Resources.ResourceManager> クラスは標準のプローブ規則を使用してカルチャにプローブを作成します。

<a name="ws"></a>
## <a name="win8_appname_long-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ

> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。

 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでは、<xref:System.Resources.ResourceManager> クラスはパッケージ リソース インデックス (PRI) ファイルからリソースを取得します。 単一の PRI ファイル (アプリケーション パッケージの PRI ファイル) には、既定のカルチャとすべてのローカライズされたリソースの両方が含まれています。 1 つ以上の XML リソース (.resw) 形式のリソース ファイルから PRI ファイルを作成するには、MakePRI ユーティリティを使用します。 Visual Studio プロジェクトに含まれているリソースは、Visual Studio が自動的に PRI ファイルの作成とパッケージ化のプロセスを処理します。 その後、.NET Framework の <xref:System.Resources.ResourceManager> クラスを使用して、アプリやライブラリのリソースにアクセスできます。

 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでは、デスクトップ アプリの場合と同じ方法で <xref:System.Resources.ResourceManager> オブジェクトのインスタンスを作成できます。

 それから、<xref:System.Resources.ResourceManager.GetString%28System.String%29> メソッドに取得するリソースの名前を渡すことによって、特定のカルチャのリソースにアクセスすることができます。 既定では、このメソッドは、呼び出しを行ったスレッドの現在の UI カルチャによって決定されるカルチャのリソースを返します。 リソースの名前と、取得するリソースのカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドに渡すことによって、特定のカルチャのリソースも取得できます。 現在の UI カルチャまたは指定したカルチャのリソースが見つからない場合、リソース マネージャーは UI 言語フォールバック リストを使用して、適切なリソースを見つけます。



## Examples
 次の例では、明示的なカルチャおよび暗黙的な現在の UI カルチャを使用して、メイン アセンブリとサテライト アセンブリから文字列リソースを取得する方法を示します。 詳細については、[サテライト アセンブリの作成](/dotnet/framework/resources/creating-satellite-assemblies-for-desktop-apps)の記事内の「グローバル アセンブリ キャッシュにインストールされていないサテライト アセンブリのディレクトリの場所」セクションを参照してください。

 この例を実行するには、

1.  アプリ ディレクトリで、次のリソース文字列を含む rmc.txt という名前のファイルを作成します。

    ```

    day=Friday
    year=2006
    holiday="Cinco de Mayo"

    ```

2.  次のように、[リソース ファイル ジェネレーター](/dotnet/framework/tools/resgen-exe-resource-file-generator) を使用して、入力ファイル rmc.txt からリソース ファイル rmc.resources を生成します。

    ```
    resgen rmc.txt
    ```

3.  アプリ ディレクトリのサブディレクトリを作成し、"es-MX" という名前をつけます。 これは、続く 3 つの手順で作成するサテライト アセンブリのカルチャ名です。

4.  次のリソース文字列を含む rmc.es-MX.txt という名前のファイルを es-MX のディレクトリに作成します。

    ```

    day=Viernes
    year=2006
    holiday="Cinco de Mayo"

    ```

5.  次のように、[リソース ファイル ジェネレーター](/dotnet/framework/tools/resgen-exe-resource-file-generator) を使用して、入力ファイル rmc.es-MX.txt からリソース ファイル rmc.es-MX.resources を生成します。

    ```
    resgen rmc.es-MX.txt
    ```

6.  この例のファイル名が rmc.vb または rmc.cs のどちらかであると仮定します。 下記のソース コードをファイルにコピーします。 それをコンパイルし、メイン アセンブリのリソース ファイルである rmc.resources を実行可能アセンブリに埋め込みます。 Visual Basic コンパイラを使用している場合、構文は次のようになります。

    ```
    vbc rmc.vb /resource:rmc.resources
    ```

     これは C# コンパイラの対応する構文です。

    ```
    csc /resource:rmc.resources rmc.cs
    ```

7.  [アセンブリ リンカー](/dotnet/framework/tools/al-exe-assembly-linker) を使用して、サテライト アセンブリを作成します。 アプリのベース名が rmc なら、サテライト アセンブリの名前は rmc.resources.dll である必要があります。 サテライト アセンブリは es-MX ディレクトリに作成する必要があります。 es-MX が現在のディレクトリの場合は、このコマンドを使用します。

    ```
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll
    ```

8.  rmc.exe を実行して、埋め込まれたリソース文字列の取得と表示を行います。

 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]

 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
    <related type="Article" href="/dotnet/framework/resources/">アプリケーション内のリソース</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>既定値を使用して <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このコンストラクターは、<xref:System.Resources.ResourceManager> クラスから派生した独自のクラスを記述する場合にのみ役立ちます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager resourceSource" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">リソース マネージャーが .resources ファイルを検索するために必要なすべての情報を取得する元となる種類。</param>
        <summary>指定した型オブジェクトの情報に基づいて、サテライト アセンブリでリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

## <a name="desktop-apps"></a>デスクトップアプリ
 デスクトップアプリでは、リソースマネージャーは `resourceSource` パラメーターを使用して、次のように特定のリソースファイルを読み込みます。

-   既定のカルチャのリソースがサテライトアセンブリに存在することを示すために <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性が使用されていない場合、リソースマネージャーは、既定のカルチャのリソースファイルが、`resourceSource` パラメーターで指定された型と同じアセンブリに存在するものと見なします。

-   リソースマネージャーでは、既定のリソースファイルの基本名が `resourceSource` パラメーターで指定された型と同じであることを前提としています。

-   リソースマネージャーは、既定の <xref:System.Resources.ResourceSet> クラスを使用して、リソースファイルを操作します。

 たとえば、MyCompany という名前の型が指定されている場合、リソースマネージャーは、MyType を定義するアセンブリで MyCompany という名前の .resources ファイルを検索します。

 Visual Studio では、リソースデザイナーは、既定のカルチャの .resources ファイルのC#基本名と同じ名前を持つ `internal` (では) または `Friend` (Visual Basic) クラスを定義するコードを自動的に生成します。 これにより、リソースの名前に対応する名前を持つ型オブジェクトを取得することによって、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化し、特定のリソースのセットと組み合わせることができます。これは、クラスがコンパイラから参照できる限り、リソースが必要であるためです。 たとえば、.resources ファイルに Resource1.resx という名前が付けられている場合、次のステートメントは、Resource1.resx という名前の .resources ファイルを管理するために <xref:System.Resources.ResourceManager> オブジェクトをインスタンス化します。

 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]

 Visual Studio を使用していない場合は、名前空間と名前が既定の .resources ファイルと同じであるメンバーを持たないクラスを作成できます。 具体的な例を次に示します。

## <a name="win8_appname_long-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ

> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。

 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリの場合、<xref:System.Resources.ResourceManager> は `resourceSource` パラメーターを使用して、アセンブリ、基本名、およびリソース項目をアプリのパッケージリソースインデックス (PRI) ファイル内に配置できる名前空間を推論します。 たとえば、`MyAssembly`で定義されている MyCompany という名前の型が指定されている場合、リソースマネージャーは、MyAssembly という名前のリソースセット識別子を検索し、そのリソースセット内でスコープ MyCompany MyType を検索します。 リソースマネージャーは、このスコープ内で、既定のコンテキスト (現在のカルチャ、現在のハイコントラストの設定など) の下にあるリソース項目を検索します。



## Examples
 次の例では、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> コンストラクターを使用して、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化します。 これは、英語 (en)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の .txt ファイルからコンパイルされたリソースで構成されます。 例では、現在のカルチャと現在の UI カルチャを、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に変更します。 次に、<xref:System.Resources.ResourceManager.GetString%28System.String%29> メソッドを呼び出して、ローカライズされた文字列を取得します。これにより、時刻に依存するあいさつ文が表示されます。

 この例では、次の表に示すように、3つのテキストベースのリソースファイルが必要です。 各ファイルには、`Morning`、`Afternoon`、および `Evening`という名前の文字列リソースが含まれています。

|カルチャ|ファイル名|リソース名|リソースの値|
|-------------|---------------|-------------------|--------------------|
|ja-JP|GreetingResources.txt|`Morning`|おはようございます|
|ja-JP|GreetingResources.txt|`Afternoon`|こんにちは|
|ja-JP|GreetingResources.txt|`Evening`|こんばんは|
|fr-FR|GreetingResources.fr|`Morning`|Bonjour|
|fr-FR|GreetingResources.fr|`Afternoon`|Bonjour|
|fr-FR|GreetingResources.fr|`Evening`|Bonsoir|
|ru-RU|GreetingResources.ru|`Morning`|Доброе утро|
|ru-RU|GreetingResources.ru|`Afternoon`|Добрый день|
|ru-RU|GreetingResources.ru|`Evening`|Добрый вечер|

 次のバッチファイルを使用して Visual Basic の例をコンパイルし、あいさつという名前の実行可能ファイルを作成できます。 でC#コンパイルするには、コンパイラ名を `vbc` から `csc` に変更し、ファイル拡張子を `.vb` から `.cs`に変更します。

```

resgen GreetingResources.txt
vbc Greet.vb /resource: GreetingResources.resources

md fr-FR
resgen GreetingResources.fr-FR.txt
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources

md ru-RU
resgen GreetingResources.ru-RU.txt
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources

```

 次に、この例のソース コード (Visual Basic バージョンの ShowDate.vb または C# バージョンの ShowDate.cs) を示します。

 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]

 ソースコードでは、`Example`という名前のアプリクラスを定義するだけでなく、リソースファイルの基本名と同じ名前の `GreetingResources`を持つ内部クラスを定義します。 これにより、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> コンストラクターを呼び出すことによって、<xref:System.Resources.ResourceManager> オブジェクトを正常にインスタンス化できるようになります。

 現在の UI カルチャがスウェーデン語 (スウェーデン) の場合を除き、出力には適切なローカライズされた文字列が表示されることに注意してください。この場合、英語の言語リソースが使用されます。 スウェーデン語の言語リソースは使用できないため、アプリは、代わりに <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性で定義されている既定のカルチャのリソースを使用します。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceSource" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseName As String, assembly As Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <summary>指定したアセンブリ内で指定したルート名を持つファイルに含まれているリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

## <a name="desktop-apps"></a>デスクトップアプリ
 デスクトップアプリでは、個々のカルチャ固有のリソースファイルがサテライトアセンブリに含まれている必要があり、既定のカルチャのリソースファイルはメインアセンブリに含まれている必要があります。 サテライトアセンブリは、そのアセンブリのマニフェストで指定された1つのカルチャのリソースを格納し、必要に応じて読み込まれることを前提としています。

> [!NOTE]
>  リソースをアセンブリから取得するのではなく、.resources ファイルから直接取得するには、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化するために、代わりに <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> メソッドを呼び出す必要があります。

 `baseName` によって識別されるリソースファイルが `assembly`に見つからない場合、メソッドは <xref:System.Resources.ResourceManager> オブジェクトをインスタンス化しますが、特定のリソースを取得しようとすると、通常は <xref:System.Resources.MissingManifestResourceException>例外がスローされます。 例外の原因の診断の詳細については、<xref:System.Resources.ResourceManager> クラスのトピックの「MissingManifestResourceException Exception の処理」セクションを参照してください。

## <a name="win8_appname_long-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ

> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。

 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでは、リソースマネージャーが `assembly` パラメーターの簡易名を使用して、アプリのパッケージリソースインデックス (PRI) ファイルで一致するリソースセットを検索します。 `baseName` パラメーターは、リソースセット内のリソース項目を検索するために使用されます。 たとえば、PortableLibrary1.Resource1.de のルート名は PortableLibrary1 になります。



## Examples
 次の例では、単純なローカライズされていない "Hello World" アプリを使用して、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> コンストラクターを示しています。 ExampleResources という名前のテキストファイルの内容を次に示します。 アプリがコンパイルされると、リソースはメインアプリケーションアセンブリに埋め込まれます。

```
Greeting=Hello
```

 テキストファイルをバイナリリソースファイルに変換するには、コマンドプロンプトで次のように[リソースファイルジェネレーター (resgen.exe)](/dotnet/framework/tools/resgen-exe-resource-file-generator)を使用します。

```
resgen ExampleResources.txt
```

 次の例では、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化し、ユーザーに名前の入力を求めるプロンプトを表示して、あいさつ文を表示する実行可能コードを示します。

 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]

 Visual Basic で次のコマンドを使用してコンパイルできます。

```
vbc Example.vb /resource:ExampleResources.resources
```

 または、でC#次のコマンドを使用します。

```
csc Example.cs /resource:ExampleResources.resources
```

 この例では、リソースファイルを含むアセンブリへの参照を取得します。そのためには、そのアセンブリで定義されC#ている型を `typeof` 関数 (では) または `GetType` (Visual Basic) 関数に渡し、<xref:System.Type.Assembly%2A?displayProperty=nameWithType> プロパティの値を取得します。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para>このコンストラクターは、システム指定の <see cref="T:System.Resources.ResourceSet" /> 実装を使用します。 カスタムリソースファイル形式を使用するには、<see cref="T:System.Resources.ResourceSet" /> クラスから派生し、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> メソッドと <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> メソッドをオーバーライドして、その型を <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" /> コンストラクターに渡す必要があります。 カスタム <see cref="T:System.Resources.ResourceSet" /> を使用すると、リソースキャッシュポリシーを制御したり、独自のリソースファイル形式をサポートしたりする場合に便利ですが、通常は必要ありません。</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseName As String, assembly As Assembly, usingResourceSet As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly * Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly, usingResourceSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>指定した <see cref="T:System.Resources.ResourceSet" /> クラスを使用して、指定したアセンブリ内で指定したルート名を持つファイルに含まれるリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 個々のカルチャ固有のリソースファイルはサテライトアセンブリに含まれている必要があり、既定のカルチャのリソースファイルはメインアセンブリに含まれている必要があります。 サテライトアセンブリは、そのアセンブリのマニフェストで指定された1つのカルチャのリソースを格納し、必要に応じて読み込まれることを前提としています。

> [!NOTE]
>  リソースをアセンブリから取得するのではなく、.resources ファイルから直接取得するには、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化するために、代わりに <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> メソッドを呼び出す必要があります。

 `baseName` によって識別されるリソースファイルが `assembly`に見つからない場合、メソッドは <xref:System.Resources.ResourceManager> オブジェクトをインスタンス化しますが、特定のリソースを取得しようとすると、通常は <xref:System.Resources.MissingManifestResourceException>例外がスローされます。 例外の原因の診断の詳細については、<xref:System.Resources.ResourceManager> クラスのトピックの「MissingManifestResourceException Exception の処理」セクションを参照してください。

> [!NOTE]
>  `usingResourceSet` パラメーターは、独自のリソース形式をサポートするために使用され、通常は `null`されます。 これは、<xref:System.Type> を受け取るコンストラクターとは異なります。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="usingResourceset" /> が <see cref="T:System.Resources.ResourceSet" /> の派生クラスではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>このコンストラクターを使用すると、<see cref="T:System.Resources.ResourceSet" /> の実装を指定できます。 特定の <see cref="T:System.Resources.ResourceSet" /> 実装を必要とせず、カスタムリソースファイル形式を使用する場合は、<see cref="T:System.Resources.ResourceSet" /> クラスから派生し、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> および <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> メソッドをオーバーライドして、その型をこのコンストラクターに渡す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseName : string" Usage="System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を取得します。</summary>
        <value><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.BaseName%2A> プロパティには、リソースファイルの完全修飾名前空間名とルートリソース名が反映されます。カルチャまたはファイル名の拡張子は含まれません。 たとえば、アプリの既定のリソースファイルに `SampleApps.StringResources.resources`という名前が付けられている場合、<xref:System.Resources.ResourceManager.BaseName%2A> プロパティの値は "SampleApps. StringResources" になります。 アプリの既定のリソースファイルの名前が `SampleApps.StringResources.en-US.resources` で、サテライトアセンブリに埋め込まれている場合、<xref:System.Resources.ResourceManager.BaseName%2A> プロパティの値は依然として "SampleApps. StringResources" になります。

> [!IMPORTANT]
>  コマンドラインからコンパイルされて埋め込まれるリソースファイルの <xref:System.Resources.ResourceManager.BaseName%2A> プロパティ値には、ファイルをコンパイルするときに明示的に含める必要がある場合を除き、名前空間の名前は含まれません。 一方、Visual Studio 環境内にコンパイルされて埋め込まれるリソースファイルの <xref:System.Resources.ResourceManager.BaseName%2A> プロパティ値には、通常、既定の名前空間名が含まれます。

 <xref:System.Resources.ResourceManager.BaseName%2A> プロパティ値は、<xref:System.Resources.ResourceManager> インスタンスをインスタンス化するときに、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> または <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> コンストラクターに渡される文字列と同じです。



## Examples
 次のユーティリティをコンパイルして実行すると、埋め込まれた .resources ファイルの名前を判断できます。 これは、メイン アセンブリまたはサテライト アセンブリの名前をコマンド ライン パラメーターとして指定するコンソール アプリです。 リソースマネージャーがリソースを正しく識別できるように、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> または <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> コンストラクターの `baseName` パラメーターとして指定する文字列が表示されます。

 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberSignature Language="F#" Value="val mutable BaseNameField : string" Usage="System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.BaseNameField> フィールドは、<xref:System.Resources.ResourceManager> クラスから派生した独自のクラスを記述する場合にのみ役立ちます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="static member CreateFileBasedResourceManager : string * string * Type -&gt; System.Resources.ResourceManager" Usage="System.Resources.ResourceManager.CreateFileBasedResourceManager (baseName, resourceDir, usingResourceSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="resourceDir" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="baseName">リソースのルート名。 たとえば、"MyResource.en-US.resources" というリソース ファイルのルート名は "MyResource" です。</param>
        <param name="resourceDir">リソースを検索するディレクトリの名前。 <paramref name="resourceDir" /> には、アプリケーション ディレクトリを基準とした相対パス、または絶対パスを指定できます。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>リソースのアセンブリ マニフェストではなく特定のディレクトリを検索する <see cref="T:System.Resources.ResourceManager" /> オブジェクトを返します。</summary>
        <returns>リソースのアセンブリ マニフェストの代わりに指定されたディレクトリを検索する、リソース マネージャーの新しいインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、アセンブリに埋め込まれていない .resources ファイルからリソースを取得するリソースマネージャーを返します。 この <xref:System.Resources.ResourceManager> オブジェクトを使用して、ASP.NET ページのリソースを読み込んだり、<xref:System.Resources.ResourceSet> の実装をテストしたりすることができます。  スタンドアロンの .resources ファイルからリソースを取得する例については、[リソースの取得](/dotnet/framework/resources/retrieving-resources-in-desktop-apps)に関する記事をご覧ください。

 このメソッドを使用すると、<xref:System.Resources.ResourceSet> の実装を指定できます。 特定の <xref:System.Resources.ResourceSet> 実装が不要でも、カスタムリソースファイル形式を使用する場合は、<xref:System.Resources.ResourceSet> クラスから派生させ、<xref:System.Resources.ResourceSet.GetDefaultReader%2A> および <xref:System.Resources.ResourceSet.GetDefaultWriter%2A> メソッドをオーバーライドして、その型をこのコンストラクターに渡す必要があります。

> [!CAUTION]
>  ASP.NET アプリでスタンドアロン .resources ファイルを使用すると、XCOPY による配置が中断されます。<xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドによって明示的に解放されるまで、リソースがロックされたままになるためです。 ASP.NET アプリを使用してリソースをデプロイする場合は、.resources ファイルをサテライトアセンブリにコンパイルします。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="resourceDir" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackLocation : System.Resources.UltimateResourceFallbackLocation with get, set" Usage="System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のフォールバック リソースの取得元の場所を取得または設定します。</summary>
        <value>リソース マネージャーがフォールバック リソースを検索できる場所を指定する列挙値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.FallbackLocation%2A> プロパティは、<xref:System.Resources.ResourceManager> クラスから派生した独自のクラスを記述する場合にのみ役立ちます。

 <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性を使用して、アプリケーションの既定のカルチャを検索する場所をリソースマネージャーに通知できます。これは、メインアセンブリ (既定値) またはサテライトアセンブリ内で行います。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">パッケージ化と配置 (リソースの)</related>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetNeutralResourcesLanguage : System.Reflection.Assembly -&gt; System.Globalization.CultureInfo" Usage="System.Resources.ResourceManager.GetNeutralResourcesLanguage a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="a">カルチャ固有の情報を返すアセンブリ。</param>
        <summary>指定したアセンブリで <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性の値を取得して、メイン アセンブリの既定のリソースのカルチャ固有の情報を返します。</summary>
        <returns>見つかった場合は <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性のカルチャ、それ以外の場合は、インバリアント カルチャ。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のカルチャの文字列以外の指定したリソースの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string -&gt; obj&#xA;override this.GetObject : string -&gt; obj" Usage="resourceManager.GetObject name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定した文字列以外のリソースの値を返します。</summary>
        <returns>呼び出し元の現在のカルチャ用にローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.GetObject%2A> メソッドは、文字列以外のリソースを取得するために使用されます。 これには、<xref:System.Int32> や <xref:System.Double>などのプリミティブデータ型、ビットマップ (<xref:System.Drawing.Bitmap?displayProperty=nameWithType> オブジェクトなど)、シリアル化されたカスタムオブジェクトなどの値が含まれます。 通常、返されるオブジェクトは、適切な型C#のオブジェクトにキャスト (では) または変換 (Visual Basic) する必要があります。

 返されたリソースは、現在のスレッドの UI カルチャにローカライズされます。これは、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティによって定義されます。 リソースがそのカルチャ用にローカライズされていない場合、リソースマネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、<xref:System.Resources.ResourceManager> は既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソースセットが見つからない場合、メソッドは <xref:System.Resources.MissingManifestResourceException> 例外をスローします。また、リソースセットがサテライトアセンブリに存在することが予想される場合は、<xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 リソースマネージャーが適切なリソースセットを読み込むことができても、`name`という名前のリソースが見つからない場合、メソッドは `null`を返します。

 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティは、リソースの名前と `name` の比較で大文字と小文字を区別しないか、大文字と小文字を区別するか (既定値) を決定します。

> [!CAUTION]
>  このメソッドは、一覧表示されているよりも多くの例外をスローすることがあります。 このような場合に発生する原因の1つとして、このメソッドが呼び出すメソッドが例外をスローすることが考えられます。  たとえば、サテライトアセンブリを配置またはインストールするときにエラーが発生した場合、またはユーザー定義型が逆シリアル化されたときにユーザー定義の例外がスローされた場合に、例外がスローされる可能性がある場合 <xref:System.Runtime.Serialization.SerializationException> は、<xref:System.IO.FileLoadException> 例外がスローされます。

## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項
 同じ `name` パラメーターを使用して <xref:System.Resources.ResourceManager.GetObject%2A> メソッドを複数回呼び出す場合は、メソッドに依存せずに、各呼び出しで同じオブジェクトへの参照を返すことはできません。 これは、<xref:System.Resources.ResourceManager.GetObject%2A> メソッドがキャッシュ内の既存のリソースオブジェクトへの参照を返すことができるため、またはリソースを再度読み込み、新しいリソースオブジェクトへの参照を返すことができるためです。



## Examples
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 この例には、`PersonTable`という名前の次の構造を定義する、UIElements.cs という名前のソースコードファイル (Visual Basic を使用している場合は UIElements .vb) が含まれています。 この構造体は、ローカライズされたテーブル列名を表示する一般的なテーブル表示ルーチンでの使用を目的としています。 `PersonTable` 構造体は、 <xref:System.SerializableAttribute> 属性でマークされています。

 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]

 CreateResources.cs (Visual Basic の場合は CreateResources.vb) という名前のファイルに入っている次のコードは、UIResources.resx という名前の XML リソース ファイルを作成します。このリソース ファイルには、テーブルのタイトルに加えて、英語にローカライズされたアプリに関する情報を含む `PersonTable` オブジェクトが格納されます。

 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]

 GetObject.cs (GetObject.vb) という名前のソース コード ファイルに含まれる次のコードは、リソースを取得し、コンソールに表示します。

 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]

 次のバッチ ファイルを実行することで、必要なリソース ファイルとアセンブリをビルドし、アプリケーションを実行することができます。 `/r` 構造体に関する情報にアクセスできるように、 `PersonTable` オプションを使用して Resgen.exe を指定し、UIElements.dll への参照を含める必要があります。 C# を使用している場合は、 `vbc` コンパイラ名を `csc`に置換し、 `.vb` 拡張子を `.cs`に置換します。

```

vbc /t:library UIElements.vb
vbc CreateResources.vb /r:UIElements.dll
CreateResources

resgen UIResources.resx  /r:UIElements.dll
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources

GetObject.exe

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるローカライズされたリソースのセットが見つからず、既定のカルチャ リソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">パッケージ化と配置 (リソースの)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetObject : string * System.Globalization.CultureInfo -&gt; obj" Usage="resourceManager.GetObject (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ対象のカルチャ。 リソースがこのカルチャにローカライズされていない場合、リソース マネージャーはフォールバック規則を使用して適切なリソースを探します。

この値が <see langword="null" /> の場合、<see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> プロパティを使用して <see cref="T:System.Globalization.CultureInfo" /> オブジェクトが取得されます。</param>
        <summary>指定されたカルチャ用にローカライズされている指定された文字列以外のリソースの値を取得します。</summary>
        <returns>指定されたカルチャに合わせてローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドは、文字列以外のリソースを取得するために使用されます。 これには、<xref:System.Int32> や <xref:System.Double>などのプリミティブデータ型、ビットマップ (<xref:System.Drawing.Bitmap?displayProperty=nameWithType> オブジェクトなど)、シリアル化されたカスタムオブジェクトなどの値が含まれます。 通常、返されるオブジェクトは、適切な型C#のオブジェクトにキャスト (では) または変換 (Visual Basic) する必要があります。

 返されるリソースは `culture`によって指定されるカルチャ、または `culture` が `null`場合に <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティで指定されるカルチャにローカライズされます。 リソースがそのカルチャ用にローカライズされていない場合、リソースマネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、リソースマネージャーは既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソースセットが見つからない場合、メソッドは <xref:System.Resources.MissingManifestResourceException> 例外をスローします。また、リソースセットがサテライトアセンブリに存在することが予想される場合は、<xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 リソースマネージャーが適切なリソースセットを読み込むことができても、`name`という名前のリソースが見つからない場合、メソッドは `null`を返します。

 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティは、リソースの名前と `name` の比較で大文字と小文字を区別しないか (既定)、大文字と小文字を区別するかを決定します。

> [!CAUTION]
>  このメソッドは、一覧表示されているよりも多くの例外をスローすることがあります。 このような場合に発生する原因の1つとして、このメソッドが呼び出すメソッドが例外をスローすることが考えられます。  たとえば、サテライトアセンブリを配置またはインストールするときにエラーが発生した場合、またはユーザー定義型が逆シリアル化されたときにユーザー定義の例外がスローされた場合に、例外がスローされる可能性がある場合 <xref:System.Runtime.Serialization.SerializationException> は、<xref:System.IO.FileLoadException> 例外がスローされます。

## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項
 同じ `name` パラメーターを使用して <xref:System.Resources.ResourceManager.GetObject%2A> メソッドを複数回呼び出す場合は、メソッドに依存せずに、各呼び出しで同じオブジェクトへの参照を返すことはできません。 これは、<xref:System.Resources.ResourceManager.GetObject%2A> メソッドがキャッシュ内の既存のリソースオブジェクトへの参照を返すことができるため、またはリソースを再度読み込み、新しいリソースオブジェクトへの参照を返すことができるためです。



## Examples
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 この例には、`Numbers`という名前の次の構造を定義する NumberInfo.cs (Visual Basic を使用する場合は数値) という名前のソースコードファイルが含まれています。 この構造は、英語以外の人の生徒が英語で10にカウントする、簡単な教育用アプリによって使用されることを意図しています。 `Numbers` クラスは <xref:System.SerializableAttribute> 属性でマークされていることに注意してください。

 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]

 CreateResources.cs という名前のファイル (Visual Basic の場合は Createresources.vb) の次のソースコードでは、既定の英語用の XML リソースファイルと、フランス語、ポルトガル語、およびロシア語の言語が作成されます。

 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]

 リソースは、現在の UI カルチャをフランス語 (フランス)、ポルトガル語 (ブラジル)、またはロシア語 (ロシア) に設定する次のアプリによって使用されます。 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> メソッドを呼び出して、ローカライズされた数値を含む `Numbers` オブジェクトを取得し、<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを呼び出して、英語の言語番号を含む `Numbers` オブジェクトを取得します。 次に、現在の UI カルチャと英語を使用して奇数の数値が表示されます。 ソースコードファイルには、ShowNumbers.cs (ShowNumbers .vb) という名前が付けられています。

 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]

 次のバッチファイルを使用すると、この例の Visual Basic バージョンをビルドして実行できます。 を使用してC#いる場合は、`vbc` を `csc`に置き換え、`.vb` 拡張機能を `.cs`に置き換えます。

```

vbc /t:library NumberInfo.vb

vbc CreateResources.vb /r:NumberInfo.dll
CreateResources

resgen NumberResources.resx /r:NumberInfo.dll

resgen NumberResources.fr.resx /r:Numberinfo.dll
Md fr
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll

resgen NumberResources.pt.resx  /r:Numberinfo.dll
Md pt
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll

resgen NumberResources.ru.resx /r:Numberinfo.dll
Md ru
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll

vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources
ShowNumbers.exe
```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ リソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" /> メソッドはスレッドセーフです。</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">パッケージ化と配置 (リソースの)</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceFileName : System.Globalization.CultureInfo -&gt; string&#xA;override this.GetResourceFileName : System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetResourceFileName culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture">リソース ファイル名を構築する対象のカルチャ オブジェクト。</param>
        <summary>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルの名前を生成します。</summary>
        <returns>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルに使用できる名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A> メソッドは、<xref:System.Resources.ResourceManager> クラスから派生した独自のクラスを記述する場合にのみ役立ちます。

 このメソッドは、インバリアントカルチャ以外のすべてのカルチャのファイル名の一部として、<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> プロパティを使用します。 このメソッドは、アセンブリのマニフェストを参照したりディスクにタッチしたりするのではなく、リソースファイル名 (<xref:System.Resources.ResourceReader> コンストラクターへの引き渡しに適しています) またはマニフェストリソース blob 名を構築するためにのみ使用されます。

 派生クラスは、このメソッドをオーバーライドして、"などの別の拡張機能を検索できます。ResX (リソースファイルに名前を付けるための完全に異なるスキーム)。 メソッドを使用して、サテライトアセンブリ内のリソースファイルの名前をカスタマイズしたり、サテライトアセンブリ自体の名前をカスタマイズしたりすることはできないことに注意してください。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="/dotnet/standard/globalization-localization/">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.GetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture">リソースが取得されるカルチャ。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットが見つからないときに、適切なリソースを読み込むためにリソース フォールバックを使用する場合は <see langword="true" />。リソース フォールバック プロセスをバイパスする場合は <see langword="false" />。</param>
        <summary>特定のカルチャのリソース セットを取得します。</summary>
        <returns>指定されたカルチャに設定されたリソース。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 返されるリソースセットは、指定されたカルチャにローカライズされているリソースを表します。 リソースがそのカルチャ用にローカライズされておらず、`tryParents` が `true`場合、<xref:System.Resources.ResourceManager.GetResourceSet%2A> はリソースフォールバックルールを使用して適切なリソースを読み込みます。 `tryParents` が `false`、カルチャ固有のリソースセットが見つからない場合、メソッドは `null`を返します。 リソースフォールバックの詳細については、リソースの[パッケージ化とデプロイ](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)に関する記事の「リソースフォールバックプロセス」セクションを参照してください。



## Examples
 次の例では、<xref:System.Resources.ResourceManager.GetResourceSet%2A> メソッドを呼び出して、フランス語 (フランス) カルチャのカルチャ固有のリソースを取得します。 次に、リソースセット内のすべてのリソースを列挙します。 これには、ShowNumbers という名前の実行可能ファイルのソースコードが含まれています。 また、数値の名前を含む次の2つのテキストファイルも含まれます。 1つ目の Number Resources .txt には、英語の 1 ~ 10 の数値の名前が含まれています。

```

one=one
two=two
three=three
four=four
five=five
six=six
seven=seven
eight=eight
nine=nine
ten=ten

```

 2番目の NumberResources.fr には、フランス語の 1 ~ 4 の数値の名前が含まれています。

```

one=un
two=deux
three=trois
four=quatre

```

 バッチファイルを使用してリソースファイルを生成し、その実行可能ファイルに英語のリソースファイルを埋め込み、フランス語の言語リソース用のサテライトアセンブリを作成できます。 Visual Basic コンパイラを使用して実行可能ファイルを生成するバッチファイルを次に示します。

```

resgen NumberResources.txt
vbc shownumbers.vb /resource:NumberResources.resources

md fr-FR
resgen NumberResources.fr-FR.txt
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources
```

 C#コンパイラでは、次のバッチファイルを使用できます。

```

resgen NumberResources.txt
csc shownumbers.cs /resource:NumberResources.resources

md fr-FR
resgen NumberResources.fr-FR.txt
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources

```

 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]

 `createIfNotExists` 引数の値を `false`に変更すると、Resource Manager によってフランス語の言語リソースがまだ読み込まれていないため、メソッドの呼び出しは `null`を返します。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents" /> が <see langword="true" /> で、使用できるリソースのセットが見つからず、既定のカルチャ リソースもありません。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="/dotnet/standard/globalization-localization/">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetSatelliteContractVersion : System.Reflection.Assembly -&gt; Version" Usage="System.Resources.ResourceManager.GetSatelliteContractVersion a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="a"><see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性を確認する対象のアセンブリ。</param>
        <summary>指定したアセンブリの <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性で指定されたバージョンを返します。</summary>
        <returns>指定したアセンブリのサテライト コントラクト バージョン。バージョンが見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 サテライトアセンブリのバージョン管理の詳細については、<xref:System.Resources.SatelliteContractVersionAttribute> リファレンスのトピックを参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">アセンブリの <paramref name="a" /> で見つかった <see cref="T:System.Version" /> が無効です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="a" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.GetStream%2A> メソッドは、<xref:System.IO.MemoryStream> オブジェクトとして格納されているリソースの名前を受け取り、<xref:System.Object> リソースの値を取得して、<xref:System.IO.UnmanagedMemoryStream> オブジェクトを返します。 この場合、バイトのストリームを直接操作してから、オブジェクトに変換する必要があります。 このメソッドは、主にパフォーマンス上の理由から役立ちます。明示的なオブジェクトではなくバイトストリームとしてリソースを取得すると、パフォーマンスが向上する場合があります。

 返されたリソースは、現在のスレッドの UI カルチャにローカライズされます。これは、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティによって定義されます。 リソースがそのカルチャ用にローカライズされていない場合、リソースマネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、<xref:System.Resources.ResourceManager> は既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソースセットが見つからない場合、メソッドは <xref:System.Resources.MissingManifestResourceException> 例外をスローします。また、リソースセットがサテライトアセンブリに存在することが予想される場合は、<xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 リソースマネージャーが適切なリソースセットを読み込むことができても、`name`という名前のリソースが見つからない場合、メソッドは `null`を返します。

 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティは、リソースの名前と `name` の比較で大文字と小文字を区別しないか (既定)、大文字と小文字を区別するかを決定します。



## Examples
 次の例では、 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> メソッドを使用して、アプリの開始スプラッシュ ウィンドウで使用されるビットマップを取得します。 CreateResources.cs (のC#場合) または createresources.vb (Visual Basic の場合) という名前のファイルからの次のソースコードでは、シリアル化されたイメージを含む AppResources という名前の .resx ファイルが生成されます。 この場合、画像は SplashScreen.jpg という名前のファイルから読み込まれます。ファイル名を変更して、独自の画像に置き換えることができます。

 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]

 GetStream.cs (のC#場合) または system.resources.resourcemanager.getstream (Visual Basic の場合) という名前のファイルの次のコードは、リソースを取得し、そのイメージを <xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType> コントロールに表示します。

 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]

 次のバッチ ファイルを使用すると、C# の例をビルドできます。 Visual Basic の場合は、 `csc` を `vbc`に変更し、さらにソース コード ファイルの拡張子を `.cs` から `.vb`に変更します。

```

csc CreateResources.cs
CreateResources

resgen AppResources.resx

csc GetStream.cs /resource:AppResources.resources

```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が <see cref="T:System.IO.MemoryStream" /> オブジェクトではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string * System.Globalization.CultureInfo -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <param name="culture">リソース検索に使用するカルチャを指定するオブジェクト。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドのカルチャが使用されます。</param>
        <summary>指定したカルチャを使用し、指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.GetStream%2A> メソッドは、<xref:System.IO.MemoryStream> オブジェクトとして格納されているリソースの名前を受け取り、<xref:System.Object> リソースの値を取得して、<xref:System.IO.UnmanagedMemoryStream> オブジェクトを返します。 この場合、バイトのストリームを直接操作してから、オブジェクトに変換する必要があります。 このメソッドは、主にパフォーマンス上の理由から役立ちます。明示的なオブジェクトではなくバイトストリームとしてリソースを取得すると、パフォーマンスが向上する場合があります。

 返されるリソースは `culture`によって指定されるカルチャ、または `culture` が `null`場合に <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティで指定されるカルチャにローカライズされます。 リソースがそのカルチャ用にローカライズされていない場合、リソースマネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、<xref:System.Resources.ResourceManager> は既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソースセットが見つからない場合、メソッドは <xref:System.Resources.MissingManifestResourceException> 例外をスローします。また、リソースセットがサテライトアセンブリに存在することが予想される場合は、<xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 リソースマネージャーが適切なリソースセットを読み込むことができても、`name`という名前のリソースが見つからない場合、メソッドは `null`を返します。

 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティは、リソースの名前と `name` の比較で大文字と小文字を区別しないか (既定)、大文字と小文字を区別するかを決定します。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が <see cref="T:System.IO.MemoryStream" /> オブジェクトではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したカルチャまたは現在の UI カルチャの指定した文字列リソースを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (string name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(string name) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (name As String) As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::String ^ name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GetString : string -&gt; string" Usage="resourceManager.GetString name" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetString : string -&gt; string&#xA;override this.GetString : string -&gt; string" Usage="resourceManager.GetString name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定されている文字列リソースの値を返します。</summary>
        <returns>呼び出し元の現在の UI カルチャのためにローカライズされたリソースの値、または、リソース セットで <see langword="null" /> が見つからない場合は <paramref name="name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

## <a name="desktop-apps"></a>デスクトップアプリ
 デスクトップアプリでは、返されるリソースは、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティで定義されているように、現在のスレッドの UI カルチャにローカライズされます。 リソースがローカライズされていない場合は、リソースの[パッケージ化とデプロイ](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)に関する記事の「リソースフォールバックプロセス」セクションに記載されている手順に従って、リソースをプローブします。 ローカライズされたリソースの使用可能なセットが見つからない場合、リソースマネージャーは既定のカルチャのリソースにフォールバックします。 リソースマネージャーが既定のカルチャのリソースセットを読み込むことができない場合、メソッドは <xref:System.Resources.MissingManifestResourceException> 例外をスローします。また、リソースセットがサテライトアセンブリに存在することが予想される場合は、<xref:System.Resources.MissingSatelliteAssemblyException> の例外です。 リソースマネージャーが適切なリソースセットを読み込むことができても、`name`という名前のリソースが見つからない場合、メソッドは `null`を返します。

 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティは、リソースの名前と `name` の比較で大文字と小文字を区別しないか (既定)、大文字と小文字を区別するかを決定します。

> [!CAUTION]
>  このメソッドは、一覧表示されているよりも多くの例外をスローすることがあります。 このような場合に発生する原因の1つとして、このメソッドが呼び出すメソッドが例外をスローすることが考えられます。  たとえば、サテライトアセンブリを配置またはインストールするときにエラーが発生した場合、またはユーザー定義型が逆シリアル化されたときにユーザー定義の例外がスローされた場合に、例外がスローされる可能性がある場合 <xref:System.Runtime.Serialization.SerializationException> は、<xref:System.IO.FileLoadException> 例外がスローされます。

## <a name="win8_appname_long-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ

> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。

 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでは、<xref:System.Resources.ResourceManager.GetString%28System.String%29> メソッドは、呼び出し元の現在の UI カルチャ設定にローカライズされた `name` 文字列リソースの値を返します。 カルチャの一覧は、オペレーティングシステムの優先する UI 言語の一覧から取得されます。 リソースマネージャーが `name`と一致しない場合、メソッドは `null`を返します。



## Examples
 次の例では、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを使用して、カルチャ固有のリソースを取得します。 これは、英語 (en)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の .txt ファイルからコンパイルされたリソースで構成されます。 例では、現在のカルチャと現在の UI カルチャを、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に変更します。 それから、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを呼び出して、ローカライズされた文字列を取得します。この文字列は現在の日付と月と一緒に表示されます。 現在の UI カルチャがスウェーデン語 (スウェーデン) である場合を除き、適切なローカライズされた文字列が出力に表示されることに注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは代わりに既定のカルチャである英語のリソースを使用します。 例には、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 それぞれには `DateStart` という名前の唯一の文字列リソースがあります。

|カルチャ|ファイル名|リソース名|リソースの値|
|-------------|---------------|-------------------|--------------------|
|ja-JP|DateStrings.txt|`DateStart`|Today is|
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui、c' est le|
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|

 このC#例をコンパイルするには、次のバッチファイルを使用します。 Visual Basic の場合は、 `csc` を `vbc`に変更し、さらにソース コード ファイルの拡張子を `.cs` から `.vb`に変更します。

```
resgen DateStrings.txt
csc showdate.cs /resource:DateStrings.resources

md fr-FR
resgen DateStrings.fr-FR.txt
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources

md ru-RU
resgen DateStrings.ru-RU.txt
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources
```

 例のソースコードを次に示します (Visual Basic バージョンの場合は ShowDate .vb、 C#バージョンの場合は ShowDate.cs)。

 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ用のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> メソッドはスレッドセーフです。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">パッケージ化と配置 (リソースの)</related>
        <related type="Article" href="/dotnet/framework/resources/retrieving-resources-in-desktop-apps">サテライトアセンブリ内のリソースの取得</related>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string * System.Globalization.CultureInfo -&gt; string&#xA;override this.GetString : string * System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetString (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ先のカルチャを表すオブジェクト。</param>
        <summary>指定したカルチャにローカライズされている文字列リソースの値を返します。</summary>
        <returns>指定されたカルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

## <a name="desktop-apps"></a>デスクトップアプリ
 デスクトップアプリで `culture` が `null`場合、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドは <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティから取得した現在の UI カルチャを使用します。

 返されるリソースは、`culture` パラメーターによって指定されたカルチャにローカライズされます。 リソースが `culture`にローカライズされていない場合、リソースの[パッケージ化と配置](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)に関するトピックの「リソースフォールバックプロセス」に記載されている手順に従って、リソースマネージャーがリソースをプローブします。 使用できるリソースのセットが見つからない場合、リソースマネージャーは既定のカルチャのリソースにフォールバックします。 リソースマネージャーが既定のカルチャのリソースセットを読み込むことができない場合、メソッドは <xref:System.Resources.MissingManifestResourceException> 例外をスローします。また、リソースセットがサテライトアセンブリに存在することが予想される場合は、<xref:System.Resources.MissingSatelliteAssemblyException> の例外です。 リソースマネージャーが適切なリソースセットを読み込むことができても、`name`という名前のリソースが見つからない場合、メソッドは `null`を返します。

 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティは、リソースの名前と `name` の比較で大文字と小文字を区別しないか (既定)、大文字と小文字を区別するかを決定します。

> [!CAUTION]
>  このメソッドは、一覧表示されているよりも多くの例外をスローすることがあります。 このような場合に発生する原因の1つとして、このメソッドが呼び出すメソッドが例外をスローすることが考えられます。  たとえば、サテライトアセンブリを配置またはインストールするときにエラーが発生した場合、またはユーザー定義型が逆シリアル化されたときにユーザー定義の例外がスローされた場合に、例外がスローされる可能性がある場合 <xref:System.Runtime.Serialization.SerializationException> は、<xref:System.IO.FileLoadException> 例外がスローされます。

## <a name="win8_appname_long-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ

> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。

 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでは、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドは、`culture` パラメーターによって指定されたカルチャにローカライズされた `name` 文字列リソースの値を返します。 リソースが `culture` カルチャ用にローカライズされていない場合、参照は [!INCLUDE[win8](~/includes/win8-md.md)] の言語フォールバックリスト全体を使用し、既定のカルチャを確認した後に停止します。 リソースマネージャーが `name`と一致しない場合、メソッドは `null`を返します。



## Examples
 次の例では、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを使用して、カルチャ固有のリソースを取得します。 この例の既定のカルチャは英語 (en) で、フランス語 (フランス) (fr-fr) カルチャおよびロシア語 (ロシア) (ru) カルチャ用のサテライトアセンブリが含まれています。 この例では、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>を呼び出す前に、現在のカルチャと現在の UI カルチャをロシア語 (ロシア) に変更します。 次に、<xref:System.Resources.ResourceManager.GetString%2A> メソッドと <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出し、フランス語 (フランス) とスウェーデン語 (スウェーデン) のカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを各メソッドに渡します。 この出力では、<xref:System.Resources.ResourceManager.GetString%2A> メソッドがフランス語の言語リソースを取得できるため、月の月と日、およびその前にある文字列がフランス語で表示されます。 ただし、スウェーデン語 (スウェーデン) カルチャが使用されている場合、月の月と日はスウェーデン語で表示されますが、その前にある文字列は英語で表されます。 これは、リソースマネージャーがローカライズされたスウェーデン語のリソースを見つけることができないため、代わりに既定の英語カルチャのリソースを返すためです。

 例には、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 それぞれには `DateStart` という名前の唯一の文字列リソースがあります。

|カルチャ|ファイル名|リソース名|リソースの値|
|-------------|---------------|-------------------|--------------------|
|ja-JP|DateStrings.txt|`DateStart`|Today is|
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui、c' est le|
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|

 次のバッチファイルを使用すると、Visual Basic の例をコンパイルできます。 でC#コンパイルするには、`vbc` を `csc`に変更し、ソースコードファイルの拡張子を `.vb` から `.cs`に変更します。

```
resgen DateStrings.txt
vbc showdate.vb /resource:DateStrings.resources

md fr-FR
resgen DateStrings.fr-FR.txt
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources

md ru-RU
resgen DateStrings.ru-RU.txt
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources
```

 例のソースコードを次に示します (Visual Basic バージョンの場合は ShowDate .vb、 C#バージョンの場合は ShowDate.cs)。

 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ用のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" /> メソッドはスレッドセーフです。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">パッケージ化と配置 (リソースの)</related>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderVersionNumber : int" Usage="System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> の現在の実装が解釈および作成できるリソース ファイル ヘッダーのバージョンを指定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreCase : bool with get, set" Usage="System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース マネージャーが <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> メソッドと <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> メソッドで大文字と小文字を区別しないリソースの検索を許可しているかどうかを示す値を取得または設定します。</summary>
        <value>リソースの検索時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティの値が `false`場合、"Resource" という名前のリソースは、"resource" という名前のリソースと同じではありません。 <xref:System.Resources.ResourceManager.IgnoreCase%2A> が `true`場合、"Resource" という名前のリソースは、"resource" という名前のリソースに相当します。 ただし、<xref:System.Resources.ResourceManager.IgnoreCase%2A> が `true`場合、<xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType> および <xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType> メソッドでは、インバリアントカルチャを使用して大文字と小文字を区別しない文字列比較が実行されることに注意してください。 この利点は、これらのメソッドによって実行される大文字と小文字を区別しない文字列比較の結果が、カルチャに関係なくすべてのコンピューターで同じであることです。 欠点は、結果がすべてのカルチャの大文字と小文字の規則と一致しないことです。

 たとえば、トルコ語のアルファベットには I という2つのバージョンがあります。1つはドット付きで、もう1つはドットを含んでいません。 トルコ語では、I (Unicode 0049) という文字は、異なる文字ı (Unicode 0131) の大文字版と見なされます。 I (Unicode 0069) という文字は、他の文字 i (Unicode 0130) の小文字バージョンと見なされます。 これらの大文字と小文字の規則に従って、i (Unicode 0069) と I (Unicode 0049) の文字を区別しない文字列比較は、カルチャ "tr-TR" (トルコ語ではトルコ語) で失敗します。 ただし、<xref:System.Resources.ResourceManager.IgnoreCase%2A> が `true`場合は、インバリアントカルチャの大文字と小文字の規則を使用することによって比較が行われるため、この比較は成功します。

> [!NOTE]
>  パフォーマンス上の理由から、リソース名には常に正しいケースを指定することをお勧めします。 <xref:System.Resources.ResourceManager.IgnoreCase%2A> を `true` に設定すると、ワーキングセットが大幅に増加し、パフォーマンスが大幅に低下する可能性があります。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.InternalGetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture">検索対象のカルチャ オブジェクト。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットを読み込むことができないときに、親 <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを確認する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース セットを検索するための実装を提供します。</summary>
        <returns>指定されたリソース セット。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">メイン アセンブリに .resources ファイルが含まれていませんが、これはリソースの検索に必要です。</exception>
        <exception cref="T:System.ExecutionEngineException">ランタイムで、内部エラーが発生しました。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException"><paramref name="culture" /> に関連付けられているサテライト アセンブリを配置できません。</exception>
        <block subset="none" type="overrides"><para>このメソッドは、リソースセットを検索するために必要なすべての作業を完了し、再帰的で再入可能にすることができます。 つまり、このメソッドは、アセンブリを読み込み、<see cref="E:System.AppDomain.AssemblyLoad" /> イベントをトリガーする可能性があります。このイベントは、完全に初期化されていない <see cref="T:System.Resources.ResourceManager" /> のオブジェクトにコールバックします。 余分なロックを避けるために、このメソッドはスレッドセーフではありません。 <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />、<see cref="M:System.Resources.ResourceManager.GetString(System.String)" />、および <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> の各メソッドでは、すべての必要な同期が実行されます。</para></block>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="/dotnet/standard/globalization-localization/">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable MagicNumber : int" Usage="System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース ファイルを識別するために使用する番号を保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 値は0xBEEFCACE に設定されます。 システムの既定のファイル形式の最初の4バイトには、リトルエンディアン形式の32ビット符号付き整数が含まれています (<xref:System.Text.Encoding>を参照してください)。

 <xref:System.Resources.ResourceManager.MagicNumber> が見つかった場合、その後に続くバイトは、<xref:System.Resources.ResourceManager> ヘッダーのバージョン番号になります。その後、このヘッダーを越えるためにスキップするバイト数を示す数字になります。 次の数値は、ヘッダーを作成した <xref:System.Resources.ResourceManager> のバージョンを示し、その後にバージョン固有の情報が表示されます。

 現在の実装のバージョン番号は1です。 次のバイトは、このファイルを読み取ることができる、<xref:System.Resources.IResourceReader>の名前を含む、長さを示すプレフィックスが付けられた文字列です。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberSignature Language="F#" Value="val mutable MainAssembly : System.Reflection.Assembly" Usage="System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソースを含むメイン アセンブリを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Resources.ResourceManager.MainAssembly> フィールドは、<xref:System.Resources.ResourceManager> クラスから派生した独自のクラスを記述する場合にのみ役立ちます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseAllResources : unit -&gt; unit&#xA;override this.ReleaseAllResources : unit -&gt; unit" Usage="resourceManager.ReleaseAllResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソース マネージャーに、すべての <see cref="M:System.Resources.ResourceSet.Close" /> オブジェクトの <see cref="T:System.Resources.ResourceSet" /> メソッドを呼び出し、すべてのリソースを解放するように指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、実行中のアプリのワーキングセットを圧縮します。 リソースマネージャーがリソースをもう一度検索して読み込む必要があるため、この <xref:System.Resources.ResourceManager> オブジェクトの今後のリソース参照は、最初の参照と同じようにコストが高くなります。 これは、新しい <xref:System.Resources.ResourceManager> オブジェクトの作成が適切な動作である、複雑なスレッド処理のシナリオで役に立ちます。

> [!NOTE]
>  .NET Framework バージョン2.0 以降、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドは <xref:System.Resources.ResourceManager.GetObject%2A>、<xref:System.Resources.ResourceManager.GetString%2A>、および <xref:System.Resources.ResourceManager.GetStream%2A> 操作に関してスレッドセーフではありません。 この変更の利点は、リソースにアクセスする複数のスレッドのパフォーマンスが向上することです。 ただし、1つのスレッドで <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドを呼び出しても、別のスレッドで同時にリソースを取得した場合、get 操作では <xref:System.ObjectDisposedException> の例外がスローされる可能性があります。

 また、このメソッドは、リソースマネージャーが完全にスコープ外になってガベージコレクションされるのを待たずに、現在のリソースマネージャーによって作成されたリソースのマネージインスタンスを決定的に解放する必要がある場合にも使用できます。

> [!NOTE]
>  このメソッドを呼び出すと、サテライトアセンブリはアンロードされません。 サテライトアセンブリをアンロードするには、<xref:System.AppDomain.Unload%2A> メソッドを使用します。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberSignature Language="F#" Value="val mutable ResourceSets : System.Collections.Hashtable" Usage="System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カルチャから <see cref="T:System.Collections.Hashtable" /> オブジェクトへの割り当てを返す <see cref="T:System.Resources.ResourceSet" /> を格納します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ResourceSetType : Type" Usage="System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型を取得します。</summary>
        <value><see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
