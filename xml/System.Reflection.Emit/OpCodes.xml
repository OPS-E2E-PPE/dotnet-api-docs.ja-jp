<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c96aa9e4ce2a7d98b19a6ef14e35b41284c5a5f1" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78693050" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Reflection.Primitives" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Reflection.Emit.ILGenerator" /> クラス メンバー (<see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> など) による出力に対する MSIL (Microsoft Intermediate Language) 命令のフィールド表現を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーオペコードの詳細については、共通言語基盤 (CLI) のドキュメント、特に「パーティション III: CIL 命令セット」と「パーティション II: メタデータの定義とセマンティクス」を参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
   
  
## Examples  
 次の例は、<xref:System.Reflection.Emit.ILGenerator> を使用して `OpCodes` を <xref:System.Reflection.Emit.MethodBuilder>に出力する動的メソッドを構築する方法を示しています。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を加算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|58|add|2つの数値を加算して、新しい数値を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`に追加されます。  
  
4.  結果がスタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されません (適切なオーバーフロー処理の場合は、<xref:System.Reflection.Emit.OpCodes.Add_Ovf>を参照してください)。  
  
 整数の加算は、飽和度ではなく、ラップします。 たとえば、`value1` が255に設定され、`value2` が1に設定されている8ビット整数と想定した場合、ラップされた結果は256ではなく0になります。  
  
 浮動小数点オーバーフローでは、`+inf` (`PositiveInfinity`) または `-inf` (`NegativeInfinity`) が返されます。  
  
 許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。 特定の型の組み合わせ (たとえば、`int32` と `float`、`int32` および `int64`) のエントリがない場合、これは無効な Microsoft 中間言語 (MSIL) であり、エラーが生成されます。  
  
|operand|value1 型|value2 型|結果の種類|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`add` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D6|ovf を追加します。|オーバーフローチェック付きの2つの符号付き整数値を追加します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` は、オーバーフローのチェック付きで `value2` に追加されます。  
  
4.  結果がスタックにプッシュされます。  
  
 結果が結果の型に表示されない場合、<xref:System.OverflowException> がスローされます。  
  
 この操作は、符号付き整数に対して実行できます。 浮動小数点値の場合は、<xref:System.Reflection.Emit.OpCodes.Add>を使用します。  
  
 許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。 特定の型の組み合わせ (たとえば、`int32` と `float`、`int32` および `int64`) のエントリがない場合、これは無効な MSIL (Microsoft 中間言語) 命令であり、エラーが生成されます。  
  
|operand|value1 型|value2 型|結果の種類|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`add.ovf` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|オーバーフローチェック付きの2つの符号なし整数値を追加します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` は、オーバーフローのチェック付きで `value2` に追加されます。  
  
4.  結果がスタックにプッシュされます。  
  
 結果が結果の型に表示されない場合、<xref:System.OverflowException> がスローされます。  
  
 この操作は、符号付き整数に対して実行できます。 浮動小数点値の場合は、<xref:System.Reflection.Emit.OpCodes.Add>を使用します。  
  
 許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。 特定の型の組み合わせ (たとえば、`int32` と `float`、`int32` および `int64`) のエントリがない場合、これは無効な MSIL (Microsoft 中間言語) 命令であり、エラーが生成されます。  
  
|operand|value1 型|value2 型|結果の種類|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`add.ovf.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値のビットごとの AND を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|命令|説明|  
|------------|-----------------|-----------------|  
|5F (|and|2つの整数値のビットごとの AND を決定します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value1` と `value2` がスタックからポップされます。2つの値のビットごとの AND が計算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `and` 命令は、スタックの上位2つの値のビットごとの AND を計算し、結果をスタックに残します。  
  
 `And` は、整数固有の演算です。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`and` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドの引数リストへのアンマネージ ポインターを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 00|arglist|現在のメソッドの引数リストハンドルを返します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `arglist` 命令は、現在のメソッドの引数リストを表す不透明なハンドル (型 `native int`のアンマネージポインター) を返します。 このハンドルは、現在のメソッドの有効期間中にのみ有効です。 ただし、現在のメソッドがコントロールのスレッド上にある限り、ハンドルを他のメソッドに渡すことができます。 `arglist` 命令は、可変個の引数を受け取るメソッド内でのみ実行できます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`arglist` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|2つの値が等しい場合は、オフセット `target` でターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`に等しい場合は、分岐操作が実行されます。  
  
 `beq` 命令は、`value1` が `value2`と等しい場合に、指定されたターゲット命令に制御を転送します。 効果は、`ceq` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 許容されるオペランドの型は、次のようにカプセル化されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。  
  
 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送は、この命令では実行できません (このような転送は厳しく制限されており、代わりに <xref:System.Reflection.Emit.OpCodes.Leave> 命令を使用する必要があります)。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`beq` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq. s `target`|オフセットでターゲット命令に分岐します (`target` 等しい場合)。短い形式|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`に等しい場合は、分岐操作が実行されます。  
  
 `beq.s` 命令は、`value1` が `value2`と等しい場合に、指定されたターゲット命令に制御を転送します。 効果は、`ceq` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 許容されるオペランドの型は、次のようにカプセル化されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。  
  
 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送は、この命令では実行できません (このような転送は厳しく制限されており、代わりに <xref:System.Reflection.Emit.OpCodes.Leave> 命令を使用する必要があります)。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`beq.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|最初の値が2番目の値以上の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以上の場合は、分岐操作が実行されます。  
  
 `bge` 命令は、`value1` が `value2`以上の場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt` 命令 (float の`clt.un`) の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bge` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge `target`|最初の値が2番目の値 (短い形式) 以上の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以上の場合は、分岐操作が実行されます。  
  
 `bge.s` 命令は、`value1` が `value2`以上の場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt` 命令 (float の`clt.un`) の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bge.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge `target`|最初の値が2番目の値 (符号なしの値) 以上の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以上の場合は、分岐操作が実行されます。  
  
 `bge.un` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`以上の場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt.un` 命令 (float の`clt`) の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bge.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge `target`|最初の値が2番目の値 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以上の場合は、分岐操作が実行されます。  
  
 `bge.un.s` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`以上の場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt.un` 命令 (float の`clt`) の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bge.un.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt `target`|最初の値が2番目の値よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より大きい場合は、分岐操作が実行されます。  
  
 `bgt` 命令は、`value1` が `value2`より大きい場合に、指定されたターゲット命令に制御を転送します。 効果は、`cgt` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bgt` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt `target`|最初の値が2番目の値 (短い形式) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より大きい場合は、分岐操作が実行されます。  
  
 `bgt.s` 命令は、`value1` が `value2`より大きい場合に、指定されたターゲット命令に制御を転送します。 効果は、`cgt` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bgt.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt `target`|最初の値が2番目の値 (符号なしの値) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より大きい場合は、分岐操作が実行されます。  
  
 `bgt.un` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`より大きい場合は、指定されたターゲット命令に制御を転送します。 効果は、`cgt.un` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bgt.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt `target`|最初の値が2番目の値 (符号なしの値) (短い形式) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より大きい場合は、分岐操作が実行されます。  
  
 `bgt.un.s` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`より大きい場合は、指定されたターゲット命令に制御を転送します。 効果は、`cgt.un` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bgt.un.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3E `<int32>`|`target`|最初の値が2番目の値以下の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以下の場合は、分岐操作が実行されます。  
  
 `ble` 命令は、`value1` が `value2`以下の場合に、指定されたターゲット命令に制御を転送します。 効果は、`cgt` 命令 (float の`cgt.un`) の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ble` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|31 `<int8>`|`target`|最初の値が2番目の値 (短い形式) 以下の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以下の場合は、分岐操作が実行されます。  
  
 `ble.s` 命令は、`value1` が `value2`以下の場合に、指定されたターゲット命令に制御を転送します。 効果は、`cgt` 命令 (float の場合は`cgt.un`) 命令の後に特定のターゲット命令への`brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ble.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|43 `<int32>`|`target` を解除します。|最初の値が2番目の値 (符号なしの値) 以下の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以下の場合は、分岐操作が実行されます。  
  
 `ble.un` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`以下である場合に、指定されたターゲット命令に制御を転送します。 効果は、`cgt.un` 命令 (float の`cgt`) の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ble.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|36 `<int8>`|`target` を解除します。|最初の値が2番目の値 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`以下の場合は、分岐操作が実行されます。  
  
 `ble.un.s` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`以下である場合に、指定されたターゲット命令に制御を転送します。 効果は、`cgt.un` 命令 (float の`cgt`) の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ble.un.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|最初の値が2番目の値より小さい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`未満の場合は、分岐操作が実行されます。  
  
 `blt` 命令は、`value1` が `value2`以下の場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`blt` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt `target`|最初の値が2番目の値 (短い形式) より小さい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`未満の場合は、分岐操作が実行されます。  
  
 `blt.s` 命令は、`value1` が `value2`より小さい場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`blt.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt `target`|最初の値が2番目の値 (符号なしの値) より小さい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`未満の場合は、分岐操作が実行されます。  
  
 `blt.un` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`未満の場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt.un` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`blt.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt. s `target`|最初の値が2番目の値 (符号なしの値) (短い形式) よりも小さい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`未満の場合は、分岐操作が実行されます。  
  
 `blt.un` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`未満の場合に、指定されたターゲット命令に制御を転送します。 効果は、`clt.un` 命令の後に特定のターゲット命令への `brtrue` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`blt.un.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne `target`|2つの符号なし整数値が等しくない場合 (符号なしの値)、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`と等しくない場合は、分岐操作が実行されます。  
  
 `bne.un` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`と等しくない場合に、指定されたターゲット命令に制御を転送します。 効果は、`ceq` 命令の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bne.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne `target`|2つの符号なし整数値が等しくない場合 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`と等しくない場合は、分岐操作が実行されます。  
  
 `bne.un` 命令は、符号なし整数または順序なし float 値を使用して比較した場合に、`value1` が `value2`と等しくない場合に、指定されたターゲット命令に制御を転送します。 効果は、`ceq` 命令の後に特定のターゲット命令への `brfalse` 分岐が実行されることと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`bne.un.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型をオブジェクト参照 (<see langword="O" /> 型) に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8C < `T` >|box `valTypeToken`|値の型 (`valTypeToken`で指定された型) を true オブジェクト参照に変換します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型がスタックにプッシュされます。  
  
2.  値の型がスタックからポップされます。`box` 操作が実行されます。  
  
3.  結果の "ボックス化された" 値型へのオブジェクト参照がスタックにプッシュされます。  
  
 値型には、共通言語基盤 (CLI) 内の2つの異なる表現があります。  
  
-   値型が別のオブジェクトまたはスタックに埋め込まれている場合に使用される ' 未加工 ' フォーム。  
  
-   ' ボックス化された ' フォーム。値型のデータは、独立したエンティティとして存在できるように、オブジェクトにラップ (ボックス化) されます。  
  
 `box` 命令は、' raw ' (ボックス化が解除された) 値型をオブジェクト参照 (型 `O`) に変換します。 これは、新しいオブジェクトを作成し、値型から新しく割り当てられたオブジェクトにデータをコピーすることで実現されます。 `valTypeToken` は、スタック上の値型の型を示すメタデータトークンです。  
  
 <xref:System.OutOfMemoryException> は、要求を満たすのに十分なメモリがない場合にスローされます。  
  
 クラスが見つからない場合、<xref:System.TypeLoadException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`box` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|指定されたオフセットでターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `br` 命令は、無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`br` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br. s `target`|指定されたオフセット (短い形式) でターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `br.s` 命令は、無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`br.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブレークポイントがトリップしたことをデバッガーに通知するように、共通言語基盤 (CLI) に通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|01|break|ブレークポイントに達したことをデバッガーに通知します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `break` 命令は、デバッグをサポートするためのものです。 これは、ブレークポイントがトリップしたことをデバッガーに通知するよう CLI に通知します。 インタープリターの状態に他の影響はありません。  
  
 `break` 命令には、ブレークポイントを使用してコードを修正し、周囲のコードへの影響を最小限に抑えることができる最小の命令サイズがあります。  
  
 `break` 命令は、デバッガーへのトラップ、何も行わない、またはセキュリティ例外を発生させることができます。 実際の動作は実装定義です。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`break` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="false" />、null 参照 (Visual Basic の場合は <see langword="Nothing" />)、または 0 の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|`false`場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` は、前の操作によってスタックにプッシュされます。  
  
2.  `value` がスタックからポップされます。`value` が `false`場合は `target`に分岐します。  
  
 `value` (型 `int32`、`int64`、オブジェクト参照 `O`、マネージポインター `&`、transient ポインター `*`、`native int`) が 0 (`false`) の場合、`brfalse` 命令 (およびそのエイリアス `brnull` と `brzero`) は、指定されたターゲット命令に制御を転送します。 `value` が0以外 (`true`) の場合、次の命令で実行が続行されます。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`brfalse` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="false" />、null 参照または 0 の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse `target`<br /><br /> brnull. s `target`<br /><br /> brzero s `target`|`false`、短い形式の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` は、前の操作によってスタックにプッシュされます。  
  
2.  `value` がスタックからポップされます。`value` が `false`場合は `target`に分岐します。  
  
 `value` (型 `int32`、`int64`、オブジェクト参照 `O`、マネージポインター `&`、transient ポインター `*`、`native int`) が 0 (`false`) の場合、`brfalse.s` 命令 (およびそのエイリアス `brnull` と `brzero`) は、指定されたターゲット命令に制御を転送します。 `value` が0以外 (`true`) の場合、次の命令で実行が続行されます。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`brfalse.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|0以外 (`true`) の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` は、前の操作によってスタックにプッシュされます。  
  
2.  `value` がスタックからポップされます。`value` が `true`場合は `target`に分岐します。  
  
 `brtrue` 命令は、`value` (型 `native int`) が0以外 (`true`) の場合に、指定されたターゲット命令に制御を転送します。 `value` がゼロ (`false`) の場合は、次の手順で実行が続行されます。  
  
 `value` がオブジェクト参照 (型 `O`) の場合、`brinst` (`brtrue`の別名) は、オブジェクトのインスタンスを表す場合 (たとえば、null オブジェクト参照ではない場合) に制御を転送します。 <xref:System.Reflection.Emit.OpCodes.Ldnull>を参照してください。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`brtrue` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue `target`<br /><br /> brinst. s `target`|0以外 (`true`)、短い形式の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` は、前の操作によってスタックにプッシュされます。  
  
2.  `value` がスタックからポップされます。`value` が `true`場合は `target`に分岐します。  
  
 `brtrue.s` 命令は、`value` (型 `native int`) が0以外 (`true`) の場合に、指定されたターゲット命令に制御を転送します。 `value` がゼロ (`false`) の場合は、次の手順で実行が続行されます。  
  
 `value` がオブジェクト参照 (型 `O`) の場合、`brinst` (`brtrue`の別名) は、オブジェクトのインスタンスを表す場合 (たとえば、null オブジェクト参照ではない場合) に制御を転送します。 <xref:System.Reflection.Emit.OpCodes.Ldnull>を参照してください。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`brtrue.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>渡されたメソッド記述子によって示されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|28 < `T` >|`methodDesc` を呼び出します|`methodDesc`で説明されているメソッドを呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `argN` を通じて `arg1` メソッド引数はスタックにプッシュされます。  
  
2.  `argN` を通じて `arg1` メソッド引数はスタックからポップされます。メソッドの呼び出しはこれらの引数を使用して実行され、制御はメソッド記述子によって参照されるメソッドに転送されます。 完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。  
  
3.  戻り値はスタックにプッシュされます。  
  
 `call` 命令は、命令と共に渡されたメソッド記述子によって示されるメソッドを呼び出します。 メソッド記述子は、呼び出すメソッドと、そのメソッドに渡されるスタックに配置された引数の数、型、および順序、および使用される呼び出し規約を示すメタデータトークンであり、 `call` 命令は、コントロールを転送する前に現在のメソッドの状態を解放する必要があることを指定するために、`tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックス命令の前に記述できます。 呼び出しが、元のメソッドよりも高い信頼のメソッドに制御を転送する場合、スタックフレームは解放されません。 代わりに、`tail` が指定されていないかのように実行が自動的に続行されます。 メタデータトークンは、呼び出しが静的メソッド、インスタンスメソッド、仮想メソッド、またはグローバル関数のいずれであるかを判断するために十分な情報を保持します。 これらのすべてのケースでは、宛先アドレスはメソッド記述子から完全に決定されます (これは、仮想メソッドを呼び出すための <xref:System.Reflection.Emit.OpCodes.Callvirt> 命令と比較します。宛先アドレスは、<xref:System.Reflection.Emit.OpCodes.Callvirt>の前にプッシュされたインスタンス参照のランタイム型にも依存します)。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。 次の3つの重要な特殊なケースがあります。  
  
 1. インスタンス (または仮想) メソッドの呼び出しでは、ユーザーに表示される引数の前に、そのインスタンス参照をプッシュする必要があります。 インスタンス参照を null 参照にすることはできません。 メタデータに格納されているシグネチャに、`this` ポインターのパラメーターリストのエントリが含まれていません。代わりに、ビットを使用して、メソッドが `this` ポインターを渡す必要があるかどうかを示します。  
  
 2. `call` (`callvirt`ではなく) を使用して仮想メソッドを呼び出すことは有効です。これは、メソッドが、呼び出されるオブジェクトから動的に指定されるのではなく、メソッドによって指定されたクラスを使用して解決されることを示します。  
  
 3. デリゲートの `Invoke` メソッドは、`call` または `callvirt` 命令を使用して呼び出すことができることに注意してください。  
  
 呼び出されたメソッドへのアクセスがシステムセキュリティによって付与されていない場合、<xref:System.Security.SecurityException> がスローされる可能性があります。 セキュリティチェックは、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に発生する可能性があります。  
  
> [!NOTE]
>  値型に対して System.object のメソッドを呼び出す場合は、`call` 命令を生成する代わりに、`callvirt` 命令と共に `constrained` プレフィックスを使用することを検討してください。 これにより、値型がメソッドをオーバーライドするかどうかによって異なる IL を生成する必要がなくなり、バージョン管理の問題が発生する可能性がなくなります。 インターフェイスメソッドを実装する値型のメソッドは `MethodImpl`を使用して変更できるため、値型に対してインターフェイスメソッドを呼び出すときは、`constrained` プレフィックスを使用することを検討してください。 これらの問題については、<xref:System.Reflection.Emit.OpCodes.Constrained> オペコードで詳細に説明されています。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`call` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCall%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> メソッドは `varargs` 呼び出し用に用意されています。 通常の呼び出しには、<xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し規則によって記述されている引数を使用して、評価スタックで (エントリ ポイントへのポインターとして) 指定されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|呼び出し規約によって記述された引数を使用して、が指すメソッドを呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `argN` を通じて `arg1` メソッド引数はスタックにプッシュされます。  
  
2.  メソッドのエントリポインターがスタックにプッシュされます。  
  
3.  メソッドの引数が `argN` を通じて `arg1`、メソッドのエントリポインターがスタックからポップされます。メソッドの呼び出しが実行されます。 完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。  
  
4.  戻り値はスタックにプッシュされます。  
  
 `calli` 命令は `argN`を通じて `arg1` 引数を使用してメソッドのエントリポインターを呼び出します。 これらの引数の型は、特定の呼び出し規則 (`callSiteDesc`) によって記述されます。 `calli` 命令は、コントロールを転送する前に現在のメソッドの状態を解放する必要があることを指定するために、`tail` プレフィックス (<xref:System.Reflection.Emit.OpCodes.Tailcall>) の直前にある場合があります。 呼び出しによって、元のメソッドより高い信頼のメソッドに制御が転送される場合、スタックフレームは解放されません。代わりに、`tail` が指定されていないかのように、実行は暗黙的に続行されます。  
  
 メソッドのエントリポインターは、(ターゲットコンピューターの) ネイティブコードへの特定のポインターと見なされます。このポインターは、呼び出し規約 (スタンドアロン署名の場合はメタデータトークン) で記述された引数を使用して、正規的に呼び出すことができます。 このようなポインターは、<xref:System.Reflection.Emit.OpCodes.Ldftn> または <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> 命令を使用して作成するか、ネイティブコードから渡すことができます。  
  
 呼び出し規約は動的にチェックされないため、指定された呼び出し規約をコピー先が実際に使用していない場合、`calli` 命令を使用するコードは正常に機能しません。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。 インスタンスまたは仮想メソッドの引数作成コードシーケンスは、ユーザーに表示される引数の前に、そのインスタンス参照 (null 参照ではない必要があります) をプッシュする必要があります。  
  
 呼び出されたメソッドへのアクセスがシステムセキュリティによって付与されていない場合、<xref:System.Security.SecurityException> がスローされる可能性があります。 セキュリティチェックは、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に発生する可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> メソッドを使用して、スタックで `calli` 命令を実行できます。 `calli` は、<xref:System.Reflection.Emit.ILGenerator.Emit%2A> クラスを使用して命令をスタックに直接配置するのではなく、以下のメソッドを通じて呼び出す必要があることに注意してください。  
  
-   マネージ呼び出し規約を使用して呼び出しを <xref:System.Reflection.Emit.ILGenerator.EmitCalli%28System.Reflection.Emit.OpCode%2CSystem.Reflection.CallingConventions%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> します。  
  
-   アンマネージ呼び出し規約を使用して呼び出しを <xref:System.Reflection.Emit.ILGenerator.EmitCalli%28System.Reflection.Emit.OpCode%2CSystem.Runtime.InteropServices.CallingConvention%2CSystem.Type%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト上で遅延バインディング メソッドを呼び出し、戻り値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|`obj`に関連付けられた特定のメソッドを呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `obj` スタックにプッシュされます。  
  
2.  `argN` を通じて `arg1` メソッド引数はスタックにプッシュされます。  
  
3.  メソッド引数が `argN` を通じて `arg1`、オブジェクト参照 `obj` がスタックからポップされます。メソッドの呼び出しは、これらの引数を使用して実行され、メソッドのメタデータトークンによって参照される `obj` のメソッドに制御が移ります。 完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。  
  
4.  戻り値はスタックにプッシュされます。  
  
 `callvirt` 命令は、オブジェクトに対して遅延バインディングメソッドを呼び出します。 つまり、メソッドは、メソッドポインターで参照できるコンパイル時のクラスではなく、`obj` のランタイム型に基づいて選択されます。 `Callvirt` を使用すると、仮想メソッドとインスタンスメソッドの両方を呼び出すことができます。 `callvirt` 命令は、コントロールを転送する前に現在のスタックフレームを解放する必要があることを指定するために、`tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックスの前に配置されている可能性があります。 呼び出しによって、元のメソッドよりも高い信頼のメソッドに制御が転送される場合、スタックフレームは解放されません。  
  
 メソッドメタデータトークンは、呼び出すメソッドの名前、クラス、および署名を提供します。 `obj` に関連付けられているクラスは、インスタンスとして使用されるクラスです。 クラスが、指定されたメソッド名とシグネチャに一致する非静的メソッドを定義している場合、このメソッドが呼び出されます。 それ以外の場合は、このクラスの基底クラスチェーンにあるすべてのクラスが順番にチェックインされます。 メソッドが見つからない場合、エラーになります。  
  
 `Callvirt` は、メソッドを呼び出す前に、オブジェクトと関連する引数を評価スタックからポップします。 メソッドに戻り値がある場合、メソッドの完了時にスタックにプッシュされます。 呼び出し先側では、`obj` パラメーターは引数0として、`arg1` 引数1などとしてアクセスされます。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。 (常に `callvirt`に必要な) インスタンス参照 `obj` は、ユーザーが参照できる任意の引数の前にプッシュする必要があります。 (メタデータトークンに含まれる) シグネチャには、このポインターのパラメーターリストにエントリが含まれていてはなりません。  
  
 <xref:System.Reflection.Emit.OpCodes.Call> 命令を使用して仮想メソッドを呼び出すこともできます。  
  
 指定された名前およびシグネチャを持つ非静的メソッドが `obj` またはその基本クラスに関連付けられているクラスに見つからなかった場合、<xref:System.MissingMethodException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 obj が null の場合、<xref:System.NullReferenceException> がスローされます。  
  
 呼び出されたメソッドへのアクセスがシステムセキュリティによって付与されていない場合、<xref:System.Security.SecurityException> がスローされます。 セキュリティチェックは、CIL が実行時ではなくネイティブコードに変換されたときに発生する可能性があります。  
  
> [!NOTE]
>  値型に対して System.object のメソッドを呼び出す場合は、`callvirt` 命令と共に `constrained` プレフィックスを使用することを検討してください。 これにより、値型がメソッドをオーバーライドするかどうかによって異なる IL を生成する必要がなくなり、バージョン管理の問題が発生する可能性がなくなります。 インターフェイスメソッドを実装する値型のメソッドは `MethodImpl`を使用して変更できるため、値型に対してインターフェイスメソッドを呼び出すときは、`constrained` プレフィックスを使用することを検討してください。 これらの問題については、<xref:System.Reflection.Emit.OpCodes.Constrained> オペコードで詳細に説明されています。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`callvirt` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCall%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したクラスへの参照により渡されたオブジェクトをキャストしようとします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|オブジェクトを `class`型の新しいオブジェクトにキャストします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされます。参照先のオブジェクトは、指定された `class`としてキャストされます。  
  
3.  成功すると、新しいオブジェクト参照がスタックにプッシュされます。  
  
 `castclass` 命令は、スタックの一番上にあるオブジェクト参照 (型 `O`) を指定されたクラスにキャストしようとします。 新しいクラスは、必要なクラスを示すメタデータトークンによって指定されます。 スタックの一番上にあるオブジェクトのクラスが新しいクラスを実装していない (新しいクラスがインターフェイスであると仮定している) 場合、新しいクラスの派生クラスではない場合、<xref:System.InvalidCastException> がスローされます。 オブジェクト参照が null 参照の場合、`castclass` は成功し、新しいオブジェクトが null 参照として返されます。  
  
 <xref:System.InvalidCastException> は、obj をクラスにキャストできない場合にスローされます。  
  
 クラスが見つからない場合、<xref:System.TypeLoadException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`castclass` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 2 つの値が等しい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 01|ceq|`value1` が `value2`に等しい場合は1をプッシュします。それ以外の場合は、0をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` は `value2`と比較されます。  
  
4.  `value1` が `value2`に等しい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 `ceq` 命令は、`value1` と `value2`を比較します。 `value1` が `value2`に等しい場合は、1 (型 `int32`) がスタックにプッシュされます。 それ以外の場合は、0 (型 `int32`) がスタックにプッシュされます。  
  
 浮動小数点数の場合、`ceq` は、数値が順序付けられていない場合は0を返します (または両方が NaN)。 無限値は、それ自体と同じです。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ceq` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 02|cgt|`value1` が `value2`より大きい場合は1をプッシュします。それ以外の場合は、0をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より大きいかどうかを `cgt` テストします。  
  
4.  `value1` が `value2`より大きい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 `cgt` 命令は、`value1` と `value2`を比較します。 `value1` が厳密に `value2`より大きい場合、`int32` 値1がスタックにプッシュされます。 それ以外の場合は、`int32` 値0がスタックにプッシュされます。  
  
-   浮動小数点数の場合、数値が順序付けられていない場合、`cgt` は0を返します (つまり、引数の一方または両方が NaN の場合)。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`cgt` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値または順序なしの値を比較します。 最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|`value1` が `value2`より大きい場合は1をプッシュします。それ以外の場合は、0 (符号なしの値) をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より大きいかどうかを `cgt.un` テストします。  
  
4.  `value1` が `value2`より大きい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 次のいずれかが `true` 場合は、`int32` 値1がスタックにプッシュされます。  
  
 浮動小数点数の場合、`value1` は `value2`に対して順序付けされません。  
  
 整数値の場合、`value1` は、符号なし数値として扱われる場合、厳密には `value2` より大きくなります。  
  
 それ以外の場合は、`int32` 値0がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`cgt.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値が有限数ではない場合は、<see cref="T:System.ArithmeticException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|C3|ckfinite|値が有限数でない場合は、<xref:System.ArithmeticException> をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。 
  
2.  `value` がスタックからポップされ、`ckfinite` 命令が実行されます。  
  
3.  例外がスローされない場合、`value` はスタックに戻されます。  
  
 `value` (浮動小数点数) が "not no number" 値 (NaN) または `+-` 無限大値の場合、`ckfinite instruction` は <xref:System.ArithmeticException> をスローします。 例外がスローされない場合、`Ckfinite` はスタックに値を残します。 `value` が浮動小数点数でない場合、実行は指定されません。  
  
 `value` が ' normal ' の数値ではない場合、<xref:System.ArithmeticException> がスローされます。  
  
 <xref:System.ArithmeticException> の特別な例外または派生クラスがより適切な場合は、例外ハンドラーに間違った値を渡します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ckfinite` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が 2 番目の値より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 04|clt|`value1` が `value2`未満の場合は1をプッシュします。それ以外の場合は、0をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。 

1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より小さいかどうかを `clt` テストします。  
  
4.  `value1` が `value2`未満の場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 `clt` 命令は、`value1` と `value2`を比較します。 `value1` が厳密に `value2`より小さい場合、`int32` 値1がスタックにプッシュされます。 それ以外の場合は、`int32` 値0がスタックにプッシュされます。  
  
-   浮動小数点数の場合、数値が順序付けられていない場合、`clt` は0を返します (つまり、引数の一方または両方が NaN の場合)。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`clt` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値または順序なしの値である <paramref name="value1" /> と <paramref name="value2" /> を比較します。 <paramref name="value1" /> が <paramref name="value2" /> より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|`value1` が `value2`未満の場合は1をプッシュします。それ以外の場合は、0 (符号なしの値) をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` が `value2`より小さいかどうかを `clt.un` テストします。  
  
4.  `value1` が `value2`未満の場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 `clt.un` 命令は、`value1` と `value2`を比較します。 次のいずれかに該当する場合は、`int32` 値1がスタックにプッシュされます。  
  
-   `value1` は、厳密には `value2` (`clt`の場合) よりも小さくなります。  
  
-   浮動小数点数の場合、`value1` は `value2`に対して順序付けされません。  
  
-   整数値の場合、`value1` は符号なしの数値と見なされると、厳密には `value2` より小さくなります。  
  
 それ以外の場合は、`int32` 値0がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`clt.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想メソッド呼び出しをする対象の型を制約します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|制約付き. `thisType`|型 `T`として制約されている型に対して仮想メソッドを呼び出します。|  
  
 `constrained` プレフィックスは、`callvirt` 命令でのみ許可されます。  
  
 この時点での MSIL スタックの状態は、次のようにする必要があります。  
  
1.  マネージポインター `ptr`がスタックにプッシュされます。 `ptr` の型は `thisType`するために、マネージポインター (`&`) である必要があります。 これは、プレフィックスのない `callvirt` 命令の場合とは異なり、`thisType`の参照を必要とすることに注意してください。  
  
2.  プレフィックスのない `callvirt` 命令と同様に、`argN` を通じて `arg1` メソッド引数はスタックにプッシュされます。  
  
 `constrained` プレフィックスは、`thisType` が値型と参照型のどちらであるかに関係なく、`callvirt` 命令を一貫した方法で作成できるように設計されています。  
  
 `callvirt` `method` 命令の先頭に `constrained` `thisType`がある場合、命令は次のように実行されます。  
  
-   `thisType` が (値型ではなく) 参照型の場合、`ptr` は逆参照され、`method`の `callvirt` への ' this ' ポインターとして渡されます。  
  
-   `thisType` が値型で、`thisType` が `method` を実装している場合、`call` によって `method` を実装するために、`ptr` は `method` `thisType`命令への ' this ' ポインターとして変更されずに渡されます。  
  
-   `thisType` が値型で `thisType` が `method` を実装していない場合、`ptr` は逆参照され、ボックス化されて、`callvirt` `method` 命令への ' this ' ポインターとして渡されます。  
  
 この最後のケースは、`method` が <xref:System.Object>、<xref:System.ValueType>、または <xref:System.Enum> で定義されていて、`thisType`によってオーバーライドされていない場合にのみ発生します。 この場合、ボックス化によって元のオブジェクトのコピーが作成されます。 ただし、<xref:System.Object>、<xref:System.ValueType>、および <xref:System.Enum> のいずれのメソッドもオブジェクトの状態を変更しないため、このファクトを検出することはできません。  
  
 `constrained` プレフィックスは、ジェネリックコードを作成する IL ジェネレーターをサポートしています。 通常、`callvirt` 命令は、値型では有効ではありません。 代わりに、IL コンパイラは、`ptr` の型および呼び出されるメソッドに応じて、コンパイル時に上記で説明した ' this ' 変換を効果的に実行する必要があります。 ただし `ptr` がコンパイル時に不明なジェネリック型である場合、コンパイル時にこの変換を行うことはできません。  
  
 `constrained` オペコードを使用すると、IL コンパイラは、`ptr` が値型または参照型のどちらであるかに関係なく、同じ方法で仮想関数を呼び出すことができます。 `thisType` がジェネリック型の変数であるケースを想定していますが、`constrained` プレフィックスは非ジェネリック型でも機能し、値型と参照型の区別を隠す言語で仮想呼び出しを生成する複雑さを軽減することができます。  
  
 `constrained` プレフィックスを使用すると、値の型に関する潜在的なバージョン管理の問題も回避されます。 `constrained` プレフィックスが使用されていない場合は、値型によって System.object のメソッドがオーバーライドされるかどうかに応じて、異なる IL を生成する必要があります。 たとえば、値型 `V` によってオブジェクトの ToString () メソッドがオーバーライドされる場合、`call` `V.ToString()` 命令が生成されます。そうでない場合は、`box` 命令と `callvirt` `Object.ToString()` 命令が出力されます。 前のケースでは、オーバーライドが後で削除された場合は、バージョン管理の問題が発生する可能性があります。後者の場合は、オーバーライドが後で追加されます。  
  
 `constrained` プレフィックスは、インターフェイスメソッドを実装する値型のメソッドを `MethodImpl`を使用して変更できるため、値型のインターフェイスメソッドの呼び出しにも使用できます。 `constrained` プレフィックスを使用しない場合、コンパイラはコンパイル時にバインドする値型のメソッドを強制的に選択します。 `constrained` プレフィックスを使用すると、コンパイル時ではなく、実行時にインターフェイスメソッドを実装するメソッドに MSIL をバインドできます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`constrained` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="native int" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D3|conv. i|`native int`に変換し、スタックで `native int` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.i` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.i` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int8" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|67|conv|`int8`に変換し、スタックで `int32` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.i1` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.i1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int16" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|68|i2|`int16`に変換し、スタックで `int32` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.i2` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.i2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|69|conv.i4|`int32`に変換し、スタックで `int32` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.i4` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.i4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int64" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6A|i8|`int64`に変換し、スタックで `int64` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.i8` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.i8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|(`native int`としてスタック上の) `native int` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|符号なしの値を `native int`としてスタック上の `native int` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|(`int32`としてスタック上の) `int8` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i1` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|符号なしの値を `int32`としてスタック上の `int8` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i1.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i1.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int16" /> に変換し、変換した値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|(`int32`としてスタック上の) `int16` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i2` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|符号なしの値を `int32`としてスタック上の `int16` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i2.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i2.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|(`int32`としてスタック上の) `int32` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i4` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|符号なしの値を `int32`としてスタック上の `int32` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i4.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i4.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|(`int64`としてスタック上の) `int64` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i8` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|符号なしの値を `int64`としてスタック上の `int64` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.i8.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.i8.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|(`native int`としてスタック上の) `unsigned native int` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|符号なしの値を `native int`としてスタック上の `unsigned native int` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.uvf.u.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|(`int32`としてスタック上の) `unsigned int8` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u1` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|符号なしの値を `int32`としてスタック上の `unsigned int8` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u1.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u1.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|(`int32`としてスタック上の) `unsigned int16` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u2` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|符号なしの値を `int32`としてスタック上の `unsigned int16` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u2.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u2.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|(`int32`としてスタック上の) `unsigned int32` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u4` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|符号なしの値を `int32`としてスタック上の `unsigned int32` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u4.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u4.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|(`int64`としてスタック上の) `unsigned int64` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u8` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|符号なしの値を `int64`としてスタック上の `unsigned int64` に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.ovf.u8.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されることに注意してください (`conv.ovf.i` または `conv.ovf.u` が使用されていない場合は、結果も `native int`)。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.ovf.u8.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の符号なし整数値を <see langword="float32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|76|conv.r.un|符号なし整数を浮動小数点型に変換し、スタックに `F` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.r.un` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される `result` は指定されません。 `conv.r.un` 操作は、スタックから整数を取得し、それを符号なしとして解釈し、整数を表す浮動小数点数に置き換えます。これが、有効桁数を失うことなく整数を表すのに十分な幅である場合は `float32`、それ以外の場合は `float64`です。  
  
 このフィールドを使用する場合、例外はスローされません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.r.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="float32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6B|conv.r4|`float32`に変換し、スタックで `F` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.r4` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.r4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="float64" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6C|conv.r8|`float64`に変換し、スタックで `F` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.r8` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.r8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned native int" /> に変換し、その値を <see langword="native int" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|E0|conv|`unsigned native int`に変換し、スタックで `native int` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.u` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.u` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D2|conv|`int8`に変換し、スタックで `int32` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.u1` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.u1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D1|conv. u2|`int16`に変換し、スタックで `int32` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.u2` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.u2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int32" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6D|u4|`unsigned int32`に変換し、スタックで `int32` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.u4` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.u4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int64" /> に変換し、その値を <see langword="int64" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6E|u8|`int64`に変換し、スタックで `int64` をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 `conv.u8` オペコードは、スタックの一番上の `value` をオペコードに指定された型に変換し、その値はスタックの一番上にそのまま残します。 4バイト未満の整数値は、評価スタックに読み込まれるときに `int32` に拡張されます (`conv.i` または `conv.u` が使用されていない場合は、結果も `native int`)。 浮動小数点値は `F` 型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から `float32`に変換する場合、有効桁数が失われる可能性があります。 `value` が大きすぎて `float32 (F)`に収まりきらない場合は、正の無限大 (`value` が正の場合) または負の無限大 (`value` が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果が `int32`よりも小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果の型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>」と「<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>」を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`conv.u8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソース アドレスから指定した数のバイトを宛先アドレスにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|メモリブロック間でデータをコピーします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  宛先アドレスはスタックにプッシュされます。  
  
2.  ソースアドレスはスタックにプッシュされます。  
  
3.  コピーするバイト数がスタックにプッシュされます。  
  
4.  バイト数、送信元アドレス、および宛先アドレスがスタックからポップされます。指定されたバイト数が、転送元アドレスから宛先アドレスにコピーされます。  
  
 `cpblk` 命令は、送信元アドレス (型 `*`、`native int`、または `&`) から宛先アドレス (`*`、`native int`、または `&`) に、バイトの数 (型 `unsigned int32`) をコピーします。 コピー元とコピー先の領域が重複する場合、`cpblk` の動作は指定されません。  
  
 `cpblk` は、送信元と送信先の両方がコンピューターの自然サイズに合わせて配置されていることを前提としています。 `cpblk` 命令の直前に `unaligned.<prefix>` 命令を指定して、変換元または変換先のどちらかが整列していないことを示すことができます。  
  
 `cpblk` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 無効なアドレスが検出されると <xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`cpblk` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にある値型をコピー先のオブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|ソースオブジェクトから変換先オブジェクトに値型をコピーします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  ターゲットオブジェクト参照がスタックにプッシュされます。  
  
2.  ソースオブジェクト参照がスタックにプッシュされます。  
  
3.  2つのオブジェクト参照がスタックからポップされます。ソースオブジェクトのアドレスの値の型が、コピー先のオブジェクトのアドレスにコピーされます。  
  
 ソースオブジェクトとターゲットオブジェクトの参照が、クラストークン `classTok` (`typeref` または `typedef`) によって表されるクラスのインスタンスへのポインターではない場合、または `classTok` が値型を表していない場合、`cpobj` の動作は指定されません。  
  
 無効なアドレスが検出されると <xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`cpobj` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値の除算を実行し、結果を浮動小数点値 (<see langword="F" /> 型) または商 (<see langword="int32" /> 型) として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5B|div|2つの値を除算して、商または浮動小数点の結果を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` は `value2`で除算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `result` = `value1` div value2 は次の条件を満たします。  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;、および:  
  
 sign (`result`) = +、sign (`value1`) = sign (`value2`)、または-、if sign (`value1`) ~ = sign (`value2`)  
  
 `div` 命令は、結果を計算してスタックにプッシュします。  
  
 整数除算は0方向に切り捨てられます。  
  
 有限数を0で除算すると、正しい符号付きの無限値が生成されます。  
  
 0をゼロまたは無限大で除算すると、NaN (非数) 値が生成されます。 任意の数を無限大で除算すると、ゼロ値が生成されます。  
  
 結果を結果の型で表すことができない場合、整数演算では <xref:System.ArithmeticException> がスローされます。 これは、`value1` が負の最大値で、`value2` が-1 の場合に発生する可能性があります。  
  
 `value2` が0の場合、整数演算は <xref:System.DivideByZeroException> をスローします。  
  
 Intel ベースのプラットフォームでは、コンピューティング時に <xref:System.OverflowException> がスローされることに注意してください (minint div-1)。 浮動小数点演算では、例外がスローされることはありません (代わりに Nan または無限大が生成されます)。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`div` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を除算し、結果 (<see langword="int32" />) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5C|div.un|2つの値を符号なしで除算して商を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` は `value2`で除算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `div.un` 命令は、符号なし整数として取得された `value2`で除算された `value1` を計算し、スタックに `result` をプッシュします。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`div.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値をコピーし、そのコピーを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|25|dup|スタックの一番上の値を複製します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` は、複製のためにスタックからポップされます。  
  
3.  `value` がスタックに戻されます。  
  
4.  重複する値がスタックにプッシュされます。  
  
 `dup` 命令は、スタックの最上位要素を複製し、2つの同じ値をその上に残します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`dup` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外の <see langword="filter" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|SEH 例外処理のフィルター句を終了します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` がスタックからポップされます。`endfilter` が実行され、制御が例外ハンドラーに転送されます。  
  
 `Value` (`int32` 型であり、特定の値のセットの1つである必要があります) は、フィルター句から返されます。 次のいずれかである必要があります。  
  
-   `exception_continue_search` (`value` = 0) を使用して、例外ハンドラーの検索を続行します。  
  
-   `exception_execute_handler` (`value` = 1) を使用して例外処理の2番目のフェーズを開始します。 finally ブロックは、このフィルター句に関連付けられているハンドラーが配置されるまで実行されます。 検出が完了すると、ハンドラーが実行されます。  
  
 その他の整数値は、指定されていない結果を生成します。  
  
 フィルターのエントリポイントは、メソッドの例外テーブルに示されているように、フィルターのコードブロックの最初の命令である必要があります。 `endfilter` 命令は、フィルターのコードブロックの最後の命令である必要があります (したがって、1つのフィルターブロックには1つの `endfilter` しか存在できません)。 `endfilter` 命令を実行すると、制御は CLI 例外処理機構に論理的に戻ります。  
  
 例外メカニズムを使用する場合を除き、コントロールをフィルターブロックに転送することはできません。 `throw` 命令を使用する場合や、最後の `endfilter` 命令を実行する場合を除き、コントロールをフィルターブロックの外に移すことはできません。 `filter` ブロック内に `try` ブロックを埋め込むことはできません。 例外が `filter` ブロック内でスローされると、その例外はインターセプトされ、値 0 (`exception_continue_search`) が返されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`endfilter` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外ブロックの <see langword="fault" /> 句または <see langword="finally" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|例外ブロックの `finally` または `fault` 句を終了します。|  
  
 この命令に対するスタック移行の動作はありません。  
  
 `Endfinally` と `endfault` は、例外ハンドラーが呼び出されるまでスタックアンワインドが続行されるように `finally` または `fault` 句の末尾に通知します。 `endfinally` または `endfault` 命令は、CLI 例外機構に制御を戻します。 次に、保護されたブロックが leave 命令で終了した場合に、チェーン内の次の `finally` 句を検索します。 例外を使用して保護されたブロックが終了した場合、CLI は次の `finally` または `fault`を検索するか、例外処理の最初のパス中に選択された例外ハンドラーを入力します。  
  
 `endfinally` 命令は、`finally` ブロック内で構文的にのみ表示される場合があります。 `endfilter` 命令とは異なり、ブロックが `endfinally` 命令で終了する必要はありません。また、必要に応じて、ブロック内に `endfinally` 命令をいくつでも指定できます。 これらの同じ制限は、`endfault` 命令と `fault` ブロックにも適用されます。  
  
 例外メカニズムを使用する場合を除き、コントロールを `finally` (または `fault`) ブロックに転送することはできません。 `throw` 命令を使用したり、`endfinally` (または `endfault`) 命令を実行したりする以外に、`finally` (または `fault`) ブロックから制御を転送することはできません。 特に、`finally` (または `fault`) ブロックを "フォールアウト" したり、`finally` (または `fault`) ブロック内で <xref:System.Reflection.Emit.OpCodes.Ret> または <xref:System.Reflection.Emit.OpCodes.Leave> 命令を実行したりすることはできません。  
  
 `endfault` と `endfinally` の命令はエイリアスであることに注意してください。これらは同じオペコードに対応します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードでは、`endfinally` (`endfault`) オペコード、および `ILGenerator` メソッド <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>を使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のアドレスの指定したメモリ ブロックを、指定のサイズと初期値に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 18|initblk|メモリブロック内の各場所を特定の値に設定します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  開始アドレスがスタックにプッシュされます。  
  
2.  初期化値がスタックにプッシュされます。  
  
3.  初期化するバイト数がスタックにプッシュされます。  
  
4.  バイト数、初期化値、および開始アドレスがスタックからポップされ、その値に従って初期化が実行されます。  
  
 `initblk` 命令は、指定されたアドレス (`native int`、`&`、または `*`) で始まるバイトの数 (`unsigned int32`) を初期化値 (型 `unsigned int8`) に設定します。 `initblk` は、開始アドレスがマシンの自然サイズにアラインされることを前提としています。  
  
 `initblk` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 無効なアドレスが検出されると <xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`initblk` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したアドレスにある値型の各フィールドを null 参照または適切なプリミティブ型の 0 に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|値型を初期化します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  初期化する値の型のアドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。指定されたアドレスの値の型は `typeTok`型として初期化されます。  
  
 `initobj` 命令は、プッシュされたアドレス (型 `native int`、`&`、または `*`) によって指定された値型の各フィールドを null 参照または適切なプリミティブ型の0に初期化します。 このメソッドが呼び出されると、インスタンスは、コンストラクターメソッドを呼び出すことができる状態になります。 `typeTok` が参照型である場合、この命令は `ldnull` の後に `stind.ref`が続く場合と同じ効果があります。  
  
 <xref:System.Reflection.Emit.OpCodes.Newobj>とは異なり、`initobj` はコンストラクターメソッドを呼び出しません。 `Initobj` は値型を初期化するためのものであり、`newobj` はオブジェクトの割り当てと初期化に使用されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`initobj` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照 (<see langword="O" /> 型) が特定のクラスのインスタンスかどうかをテストします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|オブジェクト参照が `class`のインスタンスであるかどうかをテストして、null 参照またはそのクラスまたはインターフェイスのインスタンスを返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照はスタックからポップされ、`class`で渡されるクラスのインスタンスであるかどうかをテストします。  
  
3.  結果 (オブジェクト参照または null 参照) がスタックにプッシュされます。  
  
 `Class` は、必要なクラスを示すメタデータトークンです。 スタックの一番上にあるオブジェクトのクラスが `class` を実装している場合 (`class` がインターフェイスである場合)、または `class` の派生クラスである場合 (`class` が通常のクラスの場合)、`class` が呼び出されたときとまったく同じように、結果がスタックにプッシュされます。<xref:System.Reflection.Emit.OpCodes.Castclass> それ以外の場合は、null 参照がスタックにプッシュされます。 オブジェクト参照自体が null 参照の場合、`isinst` も同様に null 参照を返します。  
  
 クラスが見つからない場合、<xref:System.TypeLoadException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`isinst` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドを終了し、指定したメソッドにジャンプします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|現在のメソッドを終了し、指定したメソッドにジャンプします。|  
  
 この命令に対するスタック移行の動作はありません。  
  
 `jmp` (ジャンプ) 命令は、`method`によって指定されたメソッドに制御を転送します。これは、メソッド参照のメタデータトークンです。 現在の引数は、転送先のメソッドに転送されます。  
  
 この命令の実行時には、評価スタックが空である必要があります。 呼び出し規約、宛先アドレスの引数の数と型は、現在のメソッドの引数と一致している必要があります。  
  
 `jmp` 命令は、`try`、`filter`、`catch`、または `finally` ブロックから制御を転送するためには使用できません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`jmp` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したインデックス値によって参照される引数をスタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|`index` の引数をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `index` の引数値はスタックにプッシュされます。  
  
 `ldarg` 命令は、`index`にインデックスが付けられた引数をプッシュします。引数のインデックスは0以降で、評価スタックになります。 `ldarg` 命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 可変長引数リストを受け取るプロシージャの場合、`ldarg` 命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます (詳細については、<xref:System.Reflection.Emit.OpCodes.Arglist> 命令を参照してください)。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarg` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|02|ldarg.0|引数0をスタックに読み込みます|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス0の引数値はスタックにプッシュされます。  
  
 `ldarg.0` 命令は、インデックス0で引数値を読み込むための効率的なエンコードです。  
  
 `ldarg.0` 命令は、0にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.0` 命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarg.0` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|03|ldarg|引数1をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス1の引数値がスタックにプッシュされます。  
  
 `ldarg.1` 命令は、インデックス1で引数値を読み込むための効率的なエンコードです。  
  
 `ldarg.1` 命令は、1にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.1` 命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarg.1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|04|ldarg|引数2をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス2の引数値がスタックにプッシュされます。  
  
 `ldarg.2` 命令は、インデックス2で引数値を読み込むための効率的なエンコードです。  
  
 `ldarg.2` 命令は、2にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.2` 命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarg.2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|05|ldarg|引数3をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス3の引数値がスタックにプッシュされます。  
  
 `ldarg.3` 命令は、インデックス3で引数値を読み込むための効率的なエンコードです。  
  
 `ldarg.3` 命令は、3にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.3` 命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarg.3` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した短い形式のインデックスによって参照される引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg `index`|`index` の引数をスタック (短い形式) に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `index` の引数値はスタックにプッシュされます。  
  
 `ldarg.s` 命令は、4 ~ 255 のインデックスが付けられた引数を読み込むための効率的なエンコーディングです。  
  
 `ldarg.s` 命令は、`index`にインデックスが付けられた引数をプッシュします。引数のインデックスは0以降で、評価スタックになります。 `ldarg.s` 命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 可変長引数リストを受け取るプロシージャの場合、`ldarg.s` 命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます (詳細については、<xref:System.Reflection.Emit.OpCodes.Arglist> 命令を参照してください)。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarg.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|`index`によってインデックス付けされた引数のアドレスを取得します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `index` によってインデックス付けされた引数の `addr` アドレスがスタックにプッシュされます。  
  
 `ldarga` 命令は `index`によってインデックス付けされた引数のアドレス (`*`型) をフェッチします。この場合、引数のインデックスは0以降になります。 アドレス `addr` は、常にターゲットコンピューター上の自然な境界に合わせて調整されます。  
  
 可変長の引数リストを受け取るプロシージャの場合、`ldarga` 命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 `ldarga` は、ref パラメーターを渡すために使用されます。 その他の場合は、<xref:System.Reflection.Emit.OpCodes.Ldarg> と <xref:System.Reflection.Emit.OpCodes.Starg> を使用する必要があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarga` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレス (短い形式) を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga `index`|`index`、短い形式でインデックス付けされた引数のアドレスを取得します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `index` によってインデックス付けされた引数の `addr` アドレスがスタックにプッシュされます。  
  
 `ldarga.s` (短い形式の `ldarga`) は、0 ~ 255 の引数番号に使用する必要があり、より効率的なエンコードです。  
  
 `ldarga.s` 命令は `index`によってインデックス付けされた引数のアドレス (`*`型) をフェッチします。この場合、引数のインデックスは0以降になります。 アドレス `addr` は、常にターゲットコンピューター上の自然な境界に合わせて調整されます。  
  
 可変長の引数リストを受け取るプロシージャの場合、`ldarga.s` 命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 `ldarga.s` は、ref パラメーターを渡すために使用されます。 その他の場合は、<xref:System.Reflection.Emit.OpCodes.Ldarg_S> と <xref:System.Reflection.Emit.OpCodes.Starg_S> を使用する必要があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldarga.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc i4 `num`|`num` 値をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `num` 値がスタックにプッシュされます。  
  
 整数-128 ~ 127、特に-1 ~ 8 の短いエンコーディングには、特別な短い (つまり、効率的な) エンコーディングがあることに注意してください。 すべての短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。 長いエンコーディングは、8バイトの整数、4および8バイトの浮動小数点数、および短い形式には適合しない4バイトの値に使用されます。 8バイトの整数定数をスタックにプッシュするには、3つの方法があります。  
  
 1. 32ビットを超える定数を表す必要がある場合は、<xref:System.Reflection.Emit.OpCodes.Ldc_I8> 命令を使用します。  
  
 2. <xref:System.Reflection.Emit.OpCodes.Ldc_I4> 命令の後に、9 ~ 32 ビットを必要とする定数の <xref:System.Reflection.Emit.OpCodes.Conv_I8> を使用します。  
  
 3. 8個以下のビットで表現できる定数については、短い形式の命令の後に <xref:System.Reflection.Emit.OpCodes.Conv_I8> を使用します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int32%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 0 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|0をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値0はスタックにプッシュされます。  
  
 これは、整数値0のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.0` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 1 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|1をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値1がスタックにプッシュされます。  
  
 これは、整数値1をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 2 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|2をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値2がスタックにプッシュされます。  
  
 これは、整数値2のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 3 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|3をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値3がスタックにプッシュされます。  
  
 これは、整数値3をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.3` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 4 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|4をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値4がスタックにプッシュされます。  
  
 これは、整数値4のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 5 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|ドル|ldc.i4.5|5をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値5がスタックにプッシュされます。  
  
 これは、整数値5をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.5` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 6 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|6をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値6がスタックにプッシュされます。  
  
 これは、整数値6のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.6` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 7 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|7をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値7がスタックにプッシュされます。  
  
 これは、整数値7のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.7` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 8 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|8をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値8がスタックにプッシュされます。  
  
 これは、整数値8をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 -1 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|-1 をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値-1 がスタックにプッシュされます。  
  
 これは、整数値-1 をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.m1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int8" /> 値を <see langword="int32" /> として評価スタックにプッシュします (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc i4 `num`|`num` を `int32`としてスタックにプッシュします (短い形式)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `num` 値がスタックにプッシュされます。  
  
 `ldc.i4.s` は、-128 から127への整数を評価スタックにプッシュするためのより効率的なエンコードです。  
  
次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i4.s` オペコードを使用できます。
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc `num`|`num` を `int64`としてスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `num` 値がスタックにプッシュされます。  
  
 このエンコーディングは、`int64` 値をスタックにプッシュします。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.i8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int64%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc. r4 `num`|`num` を `F`としてスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `num` 値がスタックにプッシュされます。  
  
 このエンコーディングは、`float32` 値をスタックにプッシュします。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.r4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Single%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc r8 `num`|`num` を `F`としてスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `num` 値がスタックにプッシュされます。  
  
 このエンコーディングは、`float64` 値をスタックにプッシュします。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldc.r8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Double%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの要素を命令で指定された型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|`index` の要素を型 `typeTok`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 戻り値の型は、命令で `typeTok` トークンによって指定されます。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`の上限を超えている場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="native int" /> 型の要素を <see langword="native int" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|97|ldelem.i|`index` `native int` 型の要素を、`native int`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.i` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.i` の戻り値は `native int`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.i` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|`index` に `int8` 型の要素を、`int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.i1` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.i1` の戻り値は `int8`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.i1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|`index` に `int16` 型の要素を、`int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.i2` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.i2` の戻り値は `int16`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.i2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|`index` に `int32` 型の要素を、`int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.i4` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.i4` の戻り値は `int32`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.i4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int64" /> 型の要素を <see langword="int64" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|`index` に `int64` 型の要素を、`int64`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.i8` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.i8` の戻り値は `int64`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.i8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="float32" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|`index` `float32` 型の要素を `F`型としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.r4` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.r4` の戻り値は `float32`です。  
  
 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.r4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="float64" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|`index` に型 `float64` を持つ要素を型 `F`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.r8` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.r8` の戻り値は `float64`です。  
  
 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.r8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスのオブジェクト参照を格納している要素を <see langword="O" /> 型 (オブジェクト参照) として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|`index` のオブジェクト参照を持つ要素を、型 `O`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.ref` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.ref` の戻り値は、型 `O` (オブジェクト参照) です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.ref` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|`index` に `unsigned int8` 型の要素を、`int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.u1` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.u1` の戻り値は `int8`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.u1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|インデックスの `unsigned int16` 型の要素を `int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.u2` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.u2` の戻り値は `int16`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.u2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|インデックスの `unsigned int32` 型の要素を `int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の `index` 位置に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 `ldelem.u4` 命令は、インデックス `index` (型 `native int`) を持つ要素の値を0から始まる1次元 `array` 配列に読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。  
  
 `ldelem.u4` の戻り値は `int32`です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 配列が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelem.u4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスにある配列要素のアドレスを <see langword="&amp;" /> 型 (マネージド ポインター) として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|`index` の配列要素のアドレスを型 `&` (マネージポインター) として評価スタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `array` スタックにプッシュされます。  
  
2.  インデックス値 `index` がスタックにプッシュされます。  
  
3.  `index` と `array` がスタックからポップされます。`array` の位置 `index` に格納されているアドレスが検索されます。  
  
4.  アドレスはスタックにプッシュされます。  
  
 `ldelema` は、オブジェクトの配列 (`class`型) の特定のインデックス位置にあるオブジェクトのアドレスを取得するために使用されます。 `ldelema` 命令は、0から始まる1次元 `array` 配列のインデックス `index` (型 `native int`) の値のアドレスを読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、そのため `O`型の値によって表されます。 この値は、命令で渡される `class` 型である必要があります。  
  
 `ldelema` の戻り値はマネージポインター (型 `&`) です。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldelema` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドの値を検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|指定したオブジェクトのフィールドの値をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 (またはポインター) がスタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクト内の指定されたフィールドの値が見つかりました。  
  
3.  フィールドに格納されている値がスタックにプッシュされます。  
  
 `ldfld` 命令は、オブジェクトにあるフィールドの値をスタックにプッシュします。 オブジェクトは、オブジェクト参照 (型 `O`)、マネージポインター (型 `&`)、アンマネージポインター (型 `native int`)、transient ポインター (型 `*`)、または値型のインスタンスとしてスタック上にある必要があります。 アンマネージポインターを使用することは、検証可能なコードでは許可されていません。 オブジェクトのフィールドは、フィールドメンバーを参照する必要があるメタデータトークンによって指定されます。 戻り値の型は、フィールドに関連付けられているものと同じです。 フィールドは、インスタンスフィールド (この場合は、オブジェクトを null 参照にすることはできません) または静的フィールドのいずれかになります。  
  
 `ldfld` 命令の前には、<xref:System.Reflection.Emit.OpCodes.Unaligned> と <xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックスのいずれかまたは両方を付けることができます。  
  
 オブジェクトが null で、フィールドが静的でない場合、<xref:System.NullReferenceException> がスローされます。  
  
 指定されたフィールドがメタデータ内に見つからない場合、<xref:System.MissingFieldException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldfld` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドのアドレスを検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|指定したオブジェクトの `field` のアドレスをスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 (またはポインター) がスタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクト内の指定されたフィールドのアドレスが見つかりました。  
  
3.  指定されたフィールドのアドレスがスタックにプッシュされます。  
  
 `ldflda` 命令は、オブジェクトにあるフィールドのアドレスをスタックにプッシュします。 オブジェクトは、オブジェクト参照 (型 `O`)、マネージポインター (型 `&`)、アンマネージポインター (型 `native int`)、transient ポインター (型 `*`)、または値型のインスタンスとしてスタック上にある必要があります。 アンマネージポインターを使用することは、検証可能なコードでは許可されていません。 オブジェクトのフィールドは、フィールドメンバーを参照する必要があるメタデータトークンによって指定されます。  
  
 オブジェクトがアンマネージポインターとしてスタックにプッシュされる場合を除き、`ldflda` によって返される値はマネージポインター (型 `&`) です。この場合、戻りアドレスもアンマネージポインター (型 `native int`) になります。  
  
 `ldflda` 命令の前には、<xref:System.Reflection.Emit.OpCodes.Unaligned> と <xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックスのいずれかまたは両方を付けることができます。  
  
 オブジェクトがアクセス元のアプリケーションドメイン内にない場合、<xref:System.InvalidOperationException> がスローされます。 アクセスしているアプリケーションドメインに含まれていないフィールドのアドレスを読み込むことができません。  
  
 オブジェクトが null で、フィールドが静的でない場合、<xref:System.NullReferenceException> がスローされます。  
  
 指定されたフィールドがメタデータ内に見つからない場合、<xref:System.MissingFieldException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldflda` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のメソッドを実装しているネイディブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|スタック上の `method` によって参照されるメソッドへのポインターをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  特定のメソッドへのアンマネージポインターがスタックにプッシュされます。  
  
 特定のメソッド (`method`) は、マネージメソッド (またはマネージコードからアンマネージコードに遷移するスタブ) を参照する場合、<xref:System.Reflection.Emit.OpCodes.Calli> 命令を使用して呼び出すことができます。  
  
 返される値は、CLR 呼び出し規約を使用してネイティブコードを指します。 このメソッドポインターは、アンマネージネイティブコードにコールバックルーチンとして渡すことはできません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldftn` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="native int" /> 型の値を <see langword="native int" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4D|ldind.i|アドレス `addr` の `native int` 値を `native int`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.i` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `native int` 値を `native int`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.i` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|46|ldind.i1|アドレス `addr` の `int8` 値を `int32`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。 
  
 `ldind.i1` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `int8` 値を `int32`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.i1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|48|ldind.i2|アドレス `addr` の `int16` 値を `int32`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.i2` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `int16` 値を `int32`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.i2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|アドレス `addr` の `int32` 値を `int32`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.i4` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `int32` 値を `int32`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.i4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|アドレス `addr` の `int64` 値を `int64`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.i8` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `int64` 値を `int64`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.i8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|アドレス `addr` の `float32` 値を `F`型としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.r4` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `float32` 値を、型 `F`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.r4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|アドレス `addr` の `float64` 値を `F`型としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.r8` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `float64` 値を `float64`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.r8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照を <see langword="O" /> 型 (オブジェクト参照) として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|50|ldind.ref|アドレス `addr` にあるオブジェクト参照を、型としてスタックに読み込み `O`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにあるオブジェクト参照がフェッチされます。  
  
3.  フェッチされた参照がスタックにプッシュされます。  
  
 `ldind.ref` 命令は、指定されたアドレス (型 `native int`、`&`、または *) をオブジェクト参照を `O`型としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.ref` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|47|ldind.u1|アドレス `addr` の `unsigned int8` 値を `int32`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.u1` 命令は、指定されたアドレス (型`native int`、`&`、または *) からの `unsigned int8` 値を `int32`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.u1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|49|ldind.u2|アドレス `addr` の `unsigned int16` 値を `int32`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.u2` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `unsigned int16` 値を `int32`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.u2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|アドレス `addr` の `unsigned int32` 値を `int32`としてスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 `ldind.u4` 命令は、指定されたアドレス (型 `native int`、`&`、または *) からの `unsigned int32` 値を `int32`としてスタックに間接的に読み込みます。  
  
 `ldind` のすべての手順は、対応する組み込み値クラスを指定する <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込まれるときに (`native int`ではなく) `int32` に拡張されることに注意してください。 浮動小数点値は、評価スタックに読み込まれるときに `F` 型に変換されます。  
  
 Microsoft 中間言語 (MSIL) が正しく記述されていると、ポインターの型と一貫性のある方法で `ldind` 命令が使用されるようになります。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要があります。または、<xref:System.NullReferenceException> が発生する可能性があります (「<xref:System.Reflection.Emit.OpCodes.Unaligned>」を参照してください)。 アドレスを返すすべての MSIL 命令 (<xref:System.Reflection.Emit.OpCodes.Ldloca> や <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 無効なアドレスが検出された場合、<xref:System.NullReferenceException> がスローされる可能性があります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldind.u4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス番号が 0 から始まる 1 次元配列の要素数を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8E|ldlen|配列の長さ (型 `natural unsigned int`) をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照がスタックにプッシュされます。  
  
2.  配列参照がスタックからポップされ、長さが計算されます。  
  
3.  長さはスタックにプッシュされます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 長さは `natural unsigned int`として返されます。  
  
 配列参照が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldlen` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|インデックス `index` のローカル変数をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数の値がスタックにプッシュされます。  
  
 `ldloc` 命令は、渡されたインデックスにあるローカル変数番号の内容を評価スタックにプッシュします。この場合、ローカル変数には0以降の番号が付けられます。 ローカル変数は、メソッドの initialize フラグが true の場合にのみ、メソッドに入る前に0に初期化されます。 65535 (2 ^ 16-1) ローカル変数を使用できます (0 ~ 65534)。 インデックス65535は有効ではありません。実装では、2バイトの整数を使用して、ローカルのインデックスと、特定のメソッドのローカルの合計数が追跡されるためです。 65535のインデックスが有効になっている場合は、このようなメソッドでローカルの数を追跡するために、より広い整数が必要になります。  
  
 `ldloc.0`、`ldloc.1`、`ldloc.2`、および `ldloc.3` の各手順では、最初の4つのローカル変数にアクセスするための効率的なエンコードが提供されます。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 「パーティション I」を参照してください。4バイトより小さいローカル変数は、スタックに読み込まれるときに `int32` 型に展開されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloc` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|06|ldloc.0|インデックス 0 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス0のローカル変数値はスタックにプッシュされます。  
  
 `ldloc.0` は、インデックス0のローカル変数へのアクセスを許可する <xref:System.Reflection.Emit.OpCodes.Ldloc>のための、特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloc.0` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|07|ldloc|インデックス 1 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス1のローカル変数値がスタックにプッシュされます。  
  
 `ldloc.1` は、インデックス1のローカル変数へのアクセスを許可する <xref:System.Reflection.Emit.OpCodes.Ldloc>に特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloc.1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|08|ldloc|インデックス 2 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス2のローカル変数値がスタックにプッシュされます。  
  
 `ldloc.2` は、インデックス2でローカル変数へのアクセスを許可する <xref:System.Reflection.Emit.OpCodes.Ldloc>のために特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloc.2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|09|ldloc|インデックス 3 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス3のローカル変数値がスタックにプッシュされます。  
  
 `ldloc.3` は、インデックス3でローカル変数へのアクセスを許可する <xref:System.Reflection.Emit.OpCodes.Ldloc>のために特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込まれるときに `int32` 型に拡張されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloc.3` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc `index`|インデックス `index` のローカル変数をスタック (短い形式) に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数の値がスタックにプッシュされます。  
  
 `ldloc.s` 命令は、渡されたインデックスにあるローカル変数番号の内容を評価スタックにプッシュします。この場合、ローカル変数には0以降の番号が付けられます。 メソッドの initialize フラグが true の場合は、メソッドに入る前にローカル変数が0に初期化されます。 短い形式では、256 (2 ^ 8) のローカル変数 (0-255) が使用できます。 `ldloc`よりも効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 「パーティション I」を参照してください。4バイトより小さいローカル変数は、スタックに読み込まれるときに `int32` 型に展開されます。 浮動小数点値は、ネイティブサイズ (型 `F`) に展開されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloc.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE OD < `unsigned int16` >|ldloca `index`|`index` のローカル変数のアドレスを評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数に格納されているアドレスがスタックにプッシュされます。  
  
 `ldloca` 命令は、渡されたインデックス位置にあるローカル変数番号のアドレスをスタックにプッシュします。ローカル変数には、0以降の番号が付けられます。 スタックにプッシュされた値は、<xref:System.Reflection.Emit.OpCodes.Ldind_I> や <xref:System.Reflection.Emit.OpCodes.Stind_I>などの命令で使用できるように、既に正しく調整されています。 結果は、遷移ポインター (型 `*`) になります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloca` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca `index`|`index` のローカル変数のアドレスを評価スタック (短い形式) に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数に格納されているアドレスがスタックにプッシュされます。  
  
 `ldloca.s` 命令は、渡されたインデックス位置にあるローカル変数番号のアドレスをスタックにプッシュします。ローカル変数には、0以降の番号が付けられます。 スタックにプッシュされた値は、<xref:System.Reflection.Emit.OpCodes.Ldind_I> や <xref:System.Reflection.Emit.OpCodes.Stind_I>などの命令で使用できるように、既に正しく調整されています。 結果は、遷移ポインター (型 `*`) になります。  
  
 `ldloca.s` 命令は、ローカル変数 0 ~ 255 で使用するための効率的なエンコードを提供します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldloca.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>null 参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|14|ldnull|null 参照をスタックにプッシュします|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  Null オブジェクト参照がスタックにプッシュされます。  
  
 `ldnull` は、null 参照 (型 `O`) をスタックにプッシュします。 これは、データを格納する前に、または非推奨になったときに、場所を初期化するために使用されます。  
  
 `ldnull` は、サイズに依存しない null 参照を提供します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldnull` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレスが指す値型オブジェクトを評価スタックの一番上にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|`class` 値の型のインスタンスをスタックにコピーします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型のオブジェクトのアドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされ、その特定のアドレスのインスタンスが検索されます。  
  
3.  そのアドレスに格納されているオブジェクトの値がスタックにプッシュされます。  
  
 `ldobj` 命令は、値型をパラメーターとして渡すために使用されます。  
  
 `ldobj` 命令は、`addrOfValObj` (型 `&`、`*`、または `native int`) が指す値をスタックの一番上にコピーします。 コピーされるバイト数は、クラスのサイズ (`class` パラメーターで指定) によって異なります。 `class` パラメーターは、値の型を表すメタデータトークンです。  
  
 `ldobj` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 クラスが見つからない場合、<xref:System.TypeLoadException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldobj` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|スタックに `field` の値をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  特定のフィールドの値がスタックにプッシュされます。  
  
 `ldsfld` 命令は、静的 (クラスのすべてのインスタンスで共有される) フィールドの値をスタックにプッシュします。 戻り値の型は、渡されたメタデータトークン `field`に関連付けられています。  
  
 `ldsfld` 命令は、<xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックスを持つことができます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldsfld` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドのアドレスを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|スタックに `field` のアドレスをプッシュします|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  特定のフィールドのアドレスがスタックにプッシュされます。  
  
 `ldsflda` 命令は、スタック上の静的 (クラスのすべてのインスタンス間で共有される) フィールドのアドレスをプッシュします。 メタデータトークン `field` が、メモリが管理されている型を参照している場合は、このアドレスを transient ポインター (型 `*`) として表すことができます。 それ以外の場合は、アンマネージポインター (型 `native int`) に対応します。 `field` は、割り当てられた相対仮想アドレス (それを含んでいる PE ファイルがメモリに読み込まれるベースアドレスからのフィールドのオフセット) を持つ静的グローバルであり、メモリが管理されていない場合があることに注意してください。  
  
 `ldsflda` 命令は、<xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックスを持つことができます。  
  
 メタデータ内にフィールドが見つからない場合、<xref:System.MissingFieldException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldsflda` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータに格納されているリテラル文字列への新しいオブジェクト参照をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|メタデータ文字列トークン `mdToken`の文字列オブジェクトをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  文字列へのオブジェクト参照がスタックにプッシュされます。  
  
 `ldstr` 命令は、オブジェクト参照 (型 `O`) を、メタデータに格納されている特定の文字列リテラルを表す新しい文字列オブジェクトにプッシュします。 `ldstr` 命令は、必要な量のメモリを割り当て、ファイルで使用されている形式の文字列リテラルを実行時に必要な文字列形式に変換するために必要な任意の形式変換を実行します。  
  
 共通言語基盤 (CLI) では、2つの `ldstr` 命令の結果、同じ文字シーケンスを持つ2つのメタデータトークンを参照すると、正確に同じ文字列オブジェクト ("文字列インターン" と呼ばれるプロセス) が返されることが保証されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldstr` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.String%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ トークンをそのランタイム表現に変換し、評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|メタデータトークンをそのランタイム表現に変換します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  渡されたトークンは `RuntimeHandle` に変換され、スタックにプッシュされます。  
  
 `ldtoken` 命令は、指定されたメタデータトークンの `RuntimeHandle` をプッシュします。 `RuntimeHandle` には、`fieldref/fielddef`、`methodref/methoddef`、または `typeref/typedef`を指定できます。  
  
 スタックにプッシュされた値は、システムクラスライブラリの `Reflection` メソッドの呼び出しで使用できます。  
  
 ランタイムハンドルの詳細については、<xref:System.RuntimeFieldHandle>、<xref:System.RuntimeTypeHandle>、および <xref:System.RuntimeMethodHandle>の各クラスを参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldtoken` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したオブジェクトに関連付けられた特定の仮想メソッドを実装しているネイティブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|オブジェクトの仮想メソッド `method` へのポインターをスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、(メタデータトークン `method`によって指定された) メソッドへのエントリポイントのアドレスが検索されます。  
  
3.  `method` へのポインターがスタックにプッシュされます。  
  
 `ldvirtftn` 命令によってスタックにプッシュされたアンマネージポインターは、マネージメソッド (またはマネージコードからアンマネージコードに遷移するスタブ) を参照する場合、<xref:System.Reflection.Emit.OpCodes.Calli> 命令を使用して呼び出すことができます。  
  
 アンマネージポインターは、CLR 呼び出し規約を使用してネイティブコードを指します。 このメソッドポインターは、アンマネージネイティブコードにコールバックルーチンとして渡すことはできません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ldvirtftn` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御を特定のターゲット命令に無条件で転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DD < `int32` >|`target` のままにする|コードの保護された領域を終了します。|  
  
 この命令にはスタック移行動作が指定されていません。  
  
 `leave` 命令は無条件で特定のターゲット命令に制御を転送します。これは、現在の命令の後に続く命令の先頭から4バイト符号付きオフセットとして表されます。  
  
 `leave` 命令は `br` 命令に似ていますが、`try`、`filter`、または `catch` ブロックを終了するために使用できますが、通常の分岐命令は、そのようなブロック内でのみ使用できます。 `leave` 命令によって、評価スタックが空になり、適切な周辺の `finally` ブロックが実行されます。  
  
 `leave` 命令を使用して `finally` ブロックを終了することはできません。 例外ハンドラーのコード生成を簡単にするために、catch ブロック内から `leave` 命令を使用して、関連付けられている `try` ブロック内の命令に制御を移すことができます。  
  
 命令にプレフィックスコードが1つ以上含まれている場合は、これらのプレフィックスの最初の部分にのみ制御を転送できます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`leave` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御をターゲット命令に無条件で転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DE < `int8` >|`target` のままにします|コードの保護された領域 (短い形式) を終了します。|  
  
 この命令にはスタック移行動作が指定されていません。  
  
 `leave.s` 命令は、渡されたターゲット命令に無条件で制御を転送します。これは、現在の命令の後に続く命令の先頭から1バイト符号付きオフセットとして表されます。  
  
 `leave.s` 命令は `br` 命令に似ていますが、`try`、`filter`、または `catch` ブロックを終了するために使用できますが、通常の分岐命令は、そのようなブロック内でのみ使用できます。 `leave.s` 命令によって、評価スタックが空になり、適切な周辺の `finally` ブロックが実行されます。  
  
 `leave.s` 命令を使用して `finally` ブロックを終了することはできません。 例外ハンドラーのコード生成を簡単にするために、catch ブロック内から `leave.s` 命令を使用して、関連付けられている `try` ブロック内の命令に制御を移すことができます。  
  
 命令にプレフィックスコードが1つ以上含まれている場合は、これらのプレフィックスの最初の部分にのみ制御を転送できます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`leave.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル動的メモリ プールから特定のバイト数を割り当て、最初に割り当てたバイトのアドレス (遷移ポインター、<see langword="*" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|ローカルヒープから領域を割り当てます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  割り当てられるバイト数はスタックにプッシュされます。  
  
2.  スタックからポップされたバイト数。サイズに対応するメモリ量は、ローカルヒープから割り当てられます。  
  
3.  割り当てられたメモリの最初のバイトへのポインターがスタックにプッシュされます。  
  
 `localloc` 命令は、ローカルの動的メモリプールから `size` (型 `natural unsigned int`) バイトを割り当て、最初に割り当てられたバイトのアドレス (遷移ポインター、型 `*`) を返します。 返されるメモリブロックは、メソッドの initialize フラグが `true`場合にのみ0に初期化されます。 現在のメソッドが <xref:System.Reflection.Emit.OpCodes.Ret>を実行すると、ローカルメモリプールを再利用できるようになります。  
  
 結果のアドレスは、`stind` 命令 (<xref:System.Reflection.Emit.OpCodes.Stind_I4>など) を使用してそこに格納し、`ldind` 命令 (<xref:System.Reflection.Emit.OpCodes.Ldind_I4>など) を使用して読み込むことができるように、配置されます。  
  
 `localloc` 命令は、`filter`、`catch`、`finally`、または `fault` ブロック内では実行できません。  
  
 <xref:System.StackOverflowException> は、要求を処理するためのメモリが不足している場合にスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`localloc` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型のインスタンスへの型指定された参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|`class` 型の型指定された参照をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  データへのポインターがスタックにプッシュされます。  
  
2.  ポインターがポップされ、`class`型の型指定された参照に変換されます。  
  
3.  型指定された参照がスタックにプッシュされます。  
  
 `mkrefany` 命令は、動的に型指定された参照を渡すことをサポートしています。 ポインターの型は `&`、`*`、または `native int`で、データの有効なアドレスを保持している必要があります。 `Class` は、ポインターによって参照されるデータの型を記述するクラストークンです。 `Mkrefany` は、型指定された参照をスタックにプッシュし、ポインターの不透明な記述子と `class`型を提供します。  
  
 型指定された参照に対して許可される有効な操作は、パラメーターとして型指定された参照を必要とするメソッドに渡すことだけです。 その後、呼び出し先は <xref:System.Reflection.Emit.OpCodes.Refanytype> と <xref:System.Reflection.Emit.OpCodes.Refanyval> 命令を使用して、それぞれ型 (クラス) とアドレスを取得できます。  
  
 `class` が見つからない場合、<xref:System.TypeLoadException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`mkrefany` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を乗算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5A|mul|スタックの2つの値を乗算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` は `value2`で乗算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `mul` 命令は `value2` によって `value1` を乗算し、結果をスタックにプッシュします。 整数演算では、オーバーフロー時に上位ビットが自動的に切り捨てられます。  
  
 オーバーフロー処理を使用した整数固有の乗算演算については、「<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>」を参照してください。  
  
 浮動小数点型の場合は 0 * 無限大 = NaN。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`mul` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D8|ovf|オーバーフローチェックを使用して、スタック上の2つの整数値を乗算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` には、オーバーフローチェック付きで `value2`が乗算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `mul.ovf` 命令は、整数 `value1` を整数 `value2` に乗算し、結果をスタックにプッシュします。 結果が結果の型に合わない場合は、例外がスローされます。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`mul.ovf` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|オーバーフローチェックを使用して、スタック上の2つの符号なしの値を乗算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value1` には、オーバーフローチェック付きで `value2`が乗算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `mul.ovf.un` 命令は、符号なし整数を符号なし `value2` 整数で `value1` 乗算し、結果をスタックにプッシュします。 結果が結果の型に合わない場合は、例外がスローされます。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`mul.ovf.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値を無効にし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|65|neg|スタックの現在の上にある値を否定します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  値はスタックからポップされ、否定されます。  
  
3.  結果がスタックにプッシュされます。  
  
 `neg` 命令は、値を否定し、結果をスタックの一番上にプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 整数値の否定は、標準の2の補数否定です。 特に、負の数 (正の値に対応する正の数値) を否定すると、最も負の数値が得られます。 このオーバーフローを検出するには、代わりに <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> 命令を使用します (つまり、0から減算します)。  
  
 浮動小数点数を否定することはできません。また、NaN を否定すると NaN が返されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`neg` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型の要素を持つ、インデックス番号が 0 から始まる新しい 1 次元配列へのオブジェクト参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8D< `T` >|newarr `etype`|`etype`型の要素を持つ新しい配列を作成します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列内の要素の数がスタックにプッシュされます。  
  
2.  要素の数がスタックからポップされ、配列が作成されます。  
  
3.  新しい配列へのオブジェクト参照がスタックにプッシュされます。  
  
 `newarr` 命令は、オブジェクト参照 (型 `O`) を、`etype` 型 (型を記述するメタデータトークン) の要素を持つ、新しい0から始まる1次元配列にプッシュします。 新しい配列内の要素の数は、`native int`として指定する必要があります。 有効な配列のインデックスの範囲は、0から最大で1を引いた数までです。  
  
 配列の要素は、値型を含む任意の型にすることができます。  
  
 0から始まる、数値の1次元配列は、適切な値の型 (<xref:System.Int32>など) を参照するメタデータトークンを使用して作成されます。 配列の要素は、適切な型の0に初期化されます。  
  
 0以外のベースの1次元配列と多次元配列は、`newarr`ではなく <xref:System.Reflection.Emit.OpCodes.Newobj> を使用して作成されます。 一般的には、.NET Framework の <xref:System.Array> クラスのメソッドを使用して作成されます。  
  
 <xref:System.OutOfMemoryException> は、要求を満たすのに十分なメモリがない場合にスローされます。  
  
 `numElems` が0未満の場合、<xref:System.OverflowException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`newarr` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいオブジェクトまたは値型の新しいインスタンスを作成し、オブジェクト参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|初期化されていないオブジェクトまたは値型を割り当て、コンストラクターメソッド `ctor`を呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `argn` を通じて `arg1` 引数は、順番にスタックにプッシュされます。  
  
2.  `arg1` を通じて `argn` 引数はスタックからポップされ、オブジェクトの作成のために `ctor` に渡されます。  
  
3.  新しいオブジェクトへの参照がスタックにプッシュされます。  
  
 `newobj` 命令は、新しいオブジェクトまたは値型の新しいインスタンスを作成します。 `Ctor` は、呼び出すコンストラクターの名前、クラス、およびシグネチャを示すメタデータトークン (コンストラクターとしてマークされる必要がある `methodref` または `methoddef`) です。  
  
 `newobj` 命令は、`ctor` に関連付けられたクラスの新しいインスタンスを割り当て、新しいインスタンス内のすべてのフィールドを 0 (適切な型の) または null 参照 (適切な場合) に初期化します。 次に、新しく作成されたインスタンスと共に、指定された引数を使用して `ctor` コンストラクターを呼び出します。 コンストラクターが呼び出されると、現在初期化されているオブジェクト参照 (型 `O`) がスタックにプッシュされます。  
  
 コンストラクターの観点からは、初期化されていないオブジェクトは引数0であり、newobj に渡される他の引数は順に続きます。  
  
 0から始まる、1次元の配列はすべて、`newobj`ではなく <xref:System.Reflection.Emit.OpCodes.Newarr>を使用して作成されます。 一方、他のすべての配列 (複数の次元、または1次元ではなく、0から始まる) は `newobj`を使用して作成されます。  
  
 値型は、通常、`newobj`を使用して作成されるわけではありません。 通常、これらは、`newarr` (0 から始まる、1次元配列の場合)、またはオブジェクトのフィールドとして、引数またはローカル変数として割り当てられます。 割り当てられると、<xref:System.Reflection.Emit.OpCodes.Initobj>を使用して初期化されます。 ただし、`newobj` 命令を使用して、スタック上に値型の新しいインスタンスを作成することができます。これは、引数として渡すことも、ローカルに格納することもできます。  
  
 <xref:System.OutOfMemoryException> は、要求を満たすのに十分なメモリがない場合にスローされます。  
  
 <xref:System.MissingMethodException> は、指定された名前、クラス、およびシグネチャを持つコンストラクターメソッド `ctor` が見つからない場合にスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`newobj` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.ConstructorInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペコードがパッチされている場合は、領域を補完します。 循環参照の処理を利用することはできますが、意味のある演算は実行されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|00|nop|動作を指定せずに操作を実行します。|  
  
 この命令には、スタック移行動作は定義されていません。  
  
 `nop` 操作では何も実行されません。 これは、オペコードにパッチが適用されている場合に領域を埋めることを目的としています。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`nop` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある整数値のビットごとの補数を計算し、結果を同じ型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|66|not|値のビットごとの補数を計算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value` がスタックにプッシュされます。  
  
2.  `value` はスタックからポップされ、ビットごとの補数が計算されます。  
  
3.  結果がスタックにプッシュされます。  
  
 `not` 命令は、整数値のビットごとの補数を計算し、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`not` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある 2 つの整数値のビットごとの補数を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|60|or|2つの整数値のビットごとの OR を計算し、整数を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` はスタックからポップされ、ビットごとの OR 演算が計算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `or` 命令は、スタックの一番上にある2つの値のビットごとの OR を計算し、結果をスタックにプッシュします。  
  
 `Or` は、整数固有の演算です。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`or` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|26|pop|スタックから上位の値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  最上位の値がスタックからポップされます。  
  
 `pop` 命令は、スタックから最上位の要素を削除します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`pop` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以降の配列アドレス演算で、実行時に型チェックを実行しないこと、および変更可能性が制限されたマネージド ポインターを返すことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1E|readonly.|後続の配列アドレス操作が実行時に型チェックを実行しないことと、制限された可能性が制限されたマネージポインターを返すことを指定します。|  
  
 このプレフィックスは、`ldelema` 命令の直前にのみ表示され、配列で特別な `Address` メソッドを呼び出すことができます。 後続の操作に対する影響は次のようになります。  
  
1.  実行時には、型チェック操作は実行されません。 通常、参照型の配列で使用する場合は、`ldelema` と `stelem` 命令に対して暗黙的な型チェックがあることに注意してください。 値クラスに対して実行時の型チェックが行われることはないため、`readonly` はそのような場合には何も行われません。  
  
2.  検証ツールは、アドレス操作の結果を、相互実行性が制限されたマネージポインターとして扱います。  
  
 ポインターは、値を変換できるかどうかを定義する型によって制御されるので、このポインターは、制限性が制限されていると言います。 パブリックフィールドまたは値を更新するメソッドを公開しない値クラスの場合、ポインターは読み取り専用になります (したがって、プレフィックスの名前)。 特に、プリミティブ型 (system.string など) を表すクラスは、ミューテーターを公開しないため、読み取り専用です。  
  
 この方法で制限されているマネージポインターは、次の方法でのみ使用できます。  
  
-   `ldfld`、`ldflda`、`stfld`、`call`、`constrained callvirt` の各命令の `object` パラメーターとして。  
  
-   `ldobj` 命令への `pointer` パラメーターとして、またはいずれかの `ldind` 命令。  
  
-   `cpobj` 命令の `source` パラメーターとして。  
  
 `stobj`、`initobj`、`mkrefany` 操作、または `stind` 命令を含む、許可されていないその他のすべての操作。  
  
 `readonly` プレフィックスの目的は、ジェネリックコードで配列から要素をフェッチするときに型チェックが行われないようにすることです。 たとえば、式 `arr[i].m()`、配列 `arr` の要素の型が、メソッド `m`を持つインターフェイスを持つように制約されたジェネリック型である場合、は次の MSIL にコンパイルされる可能性があります。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 `readonly` プレフィックスがない場合、`ldelema` 命令は、! 0 が参照型である場合に型チェックを実行します。 この型チェックは非効率的ですが、意味が正しくありません。 `ldelema` の型チェックは厳密に一致していますが、これは厳密なものではありません。 配列に型! 0 のサブクラスが保持されている場合、上記のコードは型チェックに失敗します。  
  
 配列要素のアドレスは、要素自体の代わりに、値型と参照型の両方に対して機能する `arr[i]` のハンドルを持つためにフェッチされます。したがって、`constrained callvirt` 命令に渡すことができます。  
  
 一般に、参照型の要素が配列に保持されている場合、実行時チェックをスキップすることは安全ではありません。 安全にするには、このポインターを使用して配列を変更しないようにする必要があります。 検証規則によってこのことが保証されます。 制限付きマネージポインターは、インスタンスメソッド呼び出しのオブジェクトとして渡すことができるため、厳密には値型の読み取り専用ではありませんが、値型にはタイプセーフの問題はありません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`readonly` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれている型トークンを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|型指定された参照に格納されている型トークンをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型参照がスタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップされ、対応する型トークンが取得されます。  
  
3.  型トークンがスタックにプッシュされます。  
  
 型指定された参照には、型トークンとオブジェクトインスタンスへのアドレスが含まれています。  
  
 `refanytype` 命令は、型指定された参照に埋め込まれている型トークンを取得します。 型指定された参照の作成の詳細については、<xref:System.Reflection.Emit.OpCodes.Mkrefany> の指示を参照してください。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`refanytype` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれているアドレス (<see langword="&amp;" /> 型) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|型指定された参照に格納されているアドレスをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型参照がスタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップされ、対応するアドレスが取得されます。  
  
3.  アドレスはスタックにプッシュされます。  
  
 型指定された参照には、型トークンとオブジェクトインスタンスへのアドレスが含まれています。  
  
 `refanyval` 命令は、型指定された参照に埋め込まれているアドレスを取得します。 スタックに指定された型指定された参照に埋め込まれた型は、`type` によって指定された型 (`typedef` または `typeref`) と一致する必要があります。 関連するコンテンツについては、<xref:System.Reflection.Emit.OpCodes.Mkrefany> 命令を参照してください。  
  
 <xref:System.InvalidCastException> は、`type` が型参照に格納されている型と同一でない場合にスローされます (この例では、`type` は、型指定された参照として構築された <xref:System.Reflection.Emit.OpCodes.Mkrefany> 命令に指定されたクラスです)。  
  
 `type` が見つからない場合、<xref:System.TypeLoadException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`refanyval` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5D|rem|`value2` によって `value1` を分割した剰余をスタックにプッシュします。|  
  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` はスタックからポップされ、`value1` `value2` `div` の残りは計算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `result` = `value1` `rem` `value2` は次の条件を満たしています。  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`)、および:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;、sign (`result`) = sign (`value1`)。ここで、`div` は0方向に切り捨てられる除算命令です。  
  
 `value2` がゼロの場合、または `value1` が無限大の場合、結果は NaN になります。 `value2` が無限である場合、結果は `value1` になります (`-infinity`の場合は否定されます)。  
  
 `value2` が0の場合、整数演算は <xref:System.DivideByZeroException> をスローします。  
  
 Intel ベースのプラットフォームでは、コンピューティング時に <xref:System.OverflowException> がスローされることに注意してください (minint `rem`-1)。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`rem` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5E|rem.un|符号なしの `value1` を符号なし `value2` によってスタックに分割した剰余をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` はスタックからポップされ、`value1` `value2` `div` の残りは計算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 `result` = `value1` `rem.un` `value2` は次の条件を満たしています。  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`)、および:  
  
 0 = `result` < `value2`。ここで `div.un` は符号なし除算命令です。  
  
 `rem.un` 命令は、`result` を計算してスタックにプッシュします。 `Rem.un` は引数を符号なし整数として扱い、<xref:System.Reflection.Emit.OpCodes.Rem> は符号付き整数として扱います。  
  
 浮動小数点数では `Rem.un` が指定されていません。  
  
 `value2` が0の場合、整数演算は <xref:System.DivideByZeroException> をスローします。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`rem.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドから戻り、呼び出し先の評価スタックから呼び出し元の評価スタックに戻り値 (存在する場合) をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2A>|ret|はメソッドからを返します。値を返す可能性があります。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  戻り値は、呼び出し先の評価スタックからポップされます。  
  
2.  手順 1. で取得した戻り値は、呼び出し元の評価スタックにプッシュされます。  
  
 呼び出し先の評価スタックに戻り値が存在しない場合、値は返されません (呼び出し先または呼び出し元のメソッドのスタック遷移動作はありません)。  
  
 現在のメソッドの戻り値の型によって、スタックの一番上からフェッチされ、現在のメソッドを呼び出したメソッドのスタックにコピーされる値の型が決まります。 返される値を除き、現在のメソッドの評価スタックは空である必要があります。  
  
 `ret` 命令を使用して、`try`、`filter`、`catch`、または `finally` ブロックから制御を移すことはできません。 `try` または `catch`内から、<xref:System.Reflection.Emit.OpCodes.Leave> 命令を、外側のすべての例外ブロックの外側にある `ret` 命令の出力先と共に使用します。 `filter` と `finally` のブロックは論理的には例外処理の一部であり、コードが埋め込まれているメソッドではないため、正しく生成された Microsoft 中間言語 (MSIL) 命令は `filter` または `finally`内からメソッドを返しません。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`ret` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外を再スローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1A|スロー|現在の例外を再スローします|  
  
 この命令には、スタック移行動作は定義されていません。  
  
 `rethrow` 命令は、`catch` ハンドラーの本体内でのみ許可されます。 このハンドラーでキャッチされたのと同じ例外をスローします。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`rethrow` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、0 を使用して左にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|62|shl|整数を左にシフトします (0 でシフト)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  シフトされるビットの量がスタックにプッシュされます。  
  
3.  シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ左にシフトされます。  
  
4.  結果がスタックにプッシュされます。  
  
 `shl` 命令は、指定されたビット数だけ左に値 (型 `int32`、`int64` または `native int`) をシフトします。 ビット数は `int32` または `native int`型の値です。 シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。  
  
 `Shl` は、各シフトの最下位位置にゼロビットを挿入します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`shl` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、符号を付けて右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|63|shr|整数を右にシフトします (符号でシフトします)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  シフトされるビットの量がスタックにプッシュされます。  
  
3.  シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ右にシフトされます。  
  
4.  結果がスタックにプッシュされます。  
  
 `shr.un` 命令は、指定されたビット数だけ右に値 (型 `int32`、`int64` または `native int`) をシフトします。 ビット数は `int32` または `native int`型の値です。 シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。  
  
 `Shr` は、各シフトの上位ビットをレプリケートし、`result`の元の値の符号を保持します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`shr` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値を指定したビット数だけ、0 を使用して右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|64|shr|整数を右にシフトします (0 でシフト)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  シフトされるビットの量がスタックにプッシュされます。  
  
3.  シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ右にシフトされます。  
  
4.  結果がスタックにプッシュされます。  
  
 `shr.un` 命令は、指定されたビット数だけ右に値 (型 `int32`、`int64` または `native int`) をシフトします。 ビット数は `int32`、`int64` または `native int`型の値です。 シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。  
  
 `Shr.un` は、各シフトの最上位位置にゼロビットを挿入します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`shr.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された値型のサイズ (バイト単位) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|値型のサイズをバイト単位で `unsigned int32`としてプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定した値の型 (`valType`) のサイズ (バイト単位) がスタックにプッシュされます。  
  
 `valType` は、値型、参照型、またはジェネリック型パラメーターを指定するメタデータトークン (`typeref` または `typedef`) である必要があります。  
  
 参照型の場合、返されるサイズは、対応する型の参照値のサイズ (32 ビットシステムでは4バイト) であり、参照値で参照されるオブジェクトに格納されているデータのサイズではありません。 ジェネリック型パラメーターは、それを定義する型またはメソッドの本体でのみ使用できます。 その型またはメソッドがインスタンス化されると、ジェネリック型パラメーターは値型または参照型に置き換えられます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`sizeof` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|スタックから上位の値をポップし、引数スロット `num`に格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  スタックの一番上にある値はポップされ、引数スロット `num`に配置されます。  
  
 `starg` 命令は、スタックから値をポップし、引数スロット `num`に配置します。 値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致している必要があります。  
  
 可変個引数リストを受け取るプロシージャの場合、`starg` 命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 4バイト未満の整数値を保持する引数にストアを実行すると、スタックから引数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`starg` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg `num`|スタックからトップ値をポップし、引数スロット `num`、短い形式で格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  スタックの一番上にある値はポップされ、引数スロット `num`に配置されます。  
  
 `starg.s` 命令は、スタックから値をポップし、引数スロット `num`に配置します。 値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致している必要があります。  
  
 `starg.s` 命令は、最初の256引数で使用するための効率的なエンコードを提供します。  
  
 可変個引数リストを受け取るプロシージャの場合、`starg.s` 命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 4バイト未満の整数値を保持する引数にストアを実行すると、スタックから引数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`starg.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの、命令で指定された型の値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|指定したインデックス位置にある配列要素を、スタックの `typeTok` 型の値に置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素に対するインデックス値 `index`がスタックにプッシュされます。  
  
3.  命令で指定された型の値がスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem` 命令は、1次元 `array` 配列内の指定された0から始まるインデックス位置にある要素の値を、の値に置き換えます。 この値には、命令で `typeTok` トークンによって指定された型があります。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="native int" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9B|stelem.i|指定したインデックス位置にある配列要素を、スタックの `native int` 値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.i` 命令は、1次元配列 `array` の要素 `index` の値を、スタックにプッシュされた `native int` 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.i` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int8" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|指定したインデックス位置にある配列要素を、スタックの `int8` 値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.i1` 命令は、1次元配列 `array` の要素 `index` の値を、スタックにプッシュされた `int8` 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.i1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int16" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|指定したインデックス位置にある配列要素を、スタックの `int16` 値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.i2` 命令は、1次元配列 `array` の要素 `index` の値を、スタックにプッシュされた `int16` 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.i2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int32" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|指定したインデックス位置にある配列要素を、スタックの `int32` 値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.i4` 命令は、1次元配列 `array` の要素 `index` の値を、スタックにプッシュされた `int32` 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.i4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int64" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|指定したインデックス位置にある配列要素を、スタックの `int64` 値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.i8` 命令は、1次元配列 `array` の要素 `index` の値を、スタックにプッシュされた `int64` 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.i8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="float32" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|指定したインデックス位置にある配列要素を、スタックの `float32` 値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.r4` 命令は、1次元配列 `array` の要素 `index` の値を、スタックにプッシュされた `float32` 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.r4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="float64" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|指定したインデックス位置にある配列要素を、スタックの `float64` 値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.r8` 命令は、1次元配列 `array` の要素 `index` の値を、スタックにプッシュされた `float64` 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.r8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素をオブジェクト参照値 (<see langword="O" /> 型) に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|指定したインデックス位置にある配列要素を、スタック上の `ref` 値 (型 `O`) で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照 `array`がスタックにプッシュされます。  
  
2.  `array` 内の要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 `stelem.ref` 命令は、1次元 `array` 配列内の指定されたインデックス位置にある要素の値を、スタックにプッシュされた `ref` (型 `O`) 値に置き換えます。  
  
 配列はオブジェクトであり、そのため `O`型の値によって表されます。 インデックスは `native int`型です。  
  
 `stelem.ref` は、値を配列要素に割り当てる前に、指定された値を `array` の要素型に暗黙的にキャストすることに注意してください。 検証されたコードの場合でも、このキャストは失敗する可能性があります。 したがって、`stelem.ref` 命令は <xref:System.InvalidCastException>をスローできます。 0から始まらない1次元配列、および多次元配列の場合、<xref:System.Array> クラスは <xref:System.Array.SetValue%2A> メソッドを提供します。  
  
 `array` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 <xref:System.IndexOutOfRangeException> は、`index` が負の場合、または `array`のバインドより大きい場合にスローされます。  
  
 `array` が必要な型の要素を保持していない場合、<xref:System.ArrayTypeMismatchException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stelem.ref` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照またはポインターのフィールドに格納された値を新しい値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|オブジェクトの `field` の値を新しい値に置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照またはポインターがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とオブジェクト参照/ポインターがスタックからポップされます。オブジェクトの `field` の値は、指定された値に置き換えられます。  
  
 `stfld` 命令は、オブジェクト (型 `O`) のフィールドの値、またはポインター (型 `native int`、`&`、または `*`) を指定された値で置き換えます。 `Field` は、フィールドメンバー参照を参照するメタデータトークンです。 `stfld` 命令は、<xref:System.Reflection.Emit.OpCodes.Unaligned> と <xref:System.Reflection.Emit.OpCodes.Volatile>のいずれかまたは両方のプレフィックスを持つことができます。  
  
 オブジェクト参照またはポインターが null 参照で、フィールドが静的でない場合、<xref:System.NullReferenceException> がスローされます。  
  
 メタデータに `field` が見つからない場合、<xref:System.MissingFieldException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換される場合にチェックされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stfld` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="native int" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DF|stind|指定されたアドレスに `native int` 値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.i` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) に `native int` 値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.i` 命令を使用する必要があります。 `stind.i` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.i` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int8" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|52|stind.i1|指定されたアドレスに `int8` 値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.i1` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) に `int8` 値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.i1` 命令を使用する必要があります。 `stind.i1` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.i1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int16" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|53|stind.i2|指定されたアドレスに `int16` 値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.i2` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) に `int16` 値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.2i` 命令を使用する必要があります。 `stind.i2` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.i2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int32" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|54|stind.i4|指定されたアドレスに `int32` 値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.i4` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) に `int32` 値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.i4` 命令を使用する必要があります。 `stind.i4` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.i4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int64" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|55|stind.i8|指定されたアドレスに `int64` 値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.i8` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) に `int64` 値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.i8` 命令を使用する必要があります。 `stind.i` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.i8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="float32" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|56|stind.r4|指定されたアドレスに `float32` 値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.r4` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) に `float32` 値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.r4` 命令を使用する必要があります。 `stind.r4` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.r4` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="float64" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|57|stind.r8|指定されたアドレスに `float64` 値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.r8` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) に `float64` 値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.r8` 命令を使用する必要があります。 `stind.r8` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.r8` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスにオブジェクト参照値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|51|stind.ref|指定されたアドレスにオブジェクト参照 (型 `O`) の値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 `stind.ref` 命令は、指定されたアドレス (型 `native int`、`*`、または `&`) にオブジェクト参照値を格納します。  
  
 型セーフ操作を行うには、ポインターの型と一貫性のある方法で `stind.ref` 命令を使用する必要があります。 `stind.ref` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 命令サフィックスによって暗黙的に指定された引数の型に対して `addr` が自然にアラインされていない場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stind.ref` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、指定したインデックスのローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|スタックから値をポップし、`index`ローカル変数に格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、ローカル変数 `index`に配置されます。  
  
 `stloc` 命令は、トップ値を評価スタックからポップし、ローカル変数 number `index`に移動します。ローカル変数には、0以降の番号が付けられます。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 Microsoft 中間言語 (MSIL) 命令を修正するには、`index` 有効なローカルインデックスである必要があります。 `stloc` 命令の場合、`index` は 0 ~ 65534 の範囲で指定する必要があります (具体的には65535が有効ではありません)。 65535を除外する理由は実用的であると考えられます。実装では、2バイトの整数を使用して、ローカルのインデックスと、特定のメソッドのローカルの合計数を追跡します。 65535のインデックスが有効になっている場合は、このようなメソッドでローカルの数を追跡するために、より広い整数が必要になります。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stloc` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 0 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0A|stloc|スタックからローカル変数0に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、0によってインデックスが作成されたローカル変数に配置されます。  
  
 `stloc.0` 命令は、トップ値を評価スタックからポップし、0でインデックス付けされたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.0` は、ローカル変数0に値を格納するための特に効率的なエンコードです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stloc.0` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 1 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0B|stloc|スタックからローカル変数1に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、1によってインデックスが作成されたローカル変数に配置されます。  
  
 `stloc.1` 命令は、トップ値を評価スタックからポップし、1でインデックス付けされたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.1` は、ローカル変数1に値を格納するための特に効率的なエンコードです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stloc.1` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 2 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0C|stloc|スタックからローカル変数2に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、2によってインデックスが作成されたローカル変数に格納されます。  
  
 `stloc.2` 命令は、トップ値を評価スタックからポップし、2でインデックスが作成されたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.2` は、ローカル変数2に値を格納するための特に効率的なエンコードです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stloc.2` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 3 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0D|stloc|スタックからローカル変数3に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、3によってインデックスが作成されたローカル変数に格納されます。  
  
 `stloc.3` 命令は、トップ値を評価スタックからポップし、3によってインデックスが作成されたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.3` は、ローカル変数3に値を格納するための特に効率的なエンコードです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stloc.3` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、<paramref name="index" /> のローカル変数リストに格納します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc `index`|スタックから値をポップし、ローカル変数 `index`、短い形式で格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、ローカル変数 `index`に配置されます。  
  
 `stloc.s` 命令は、トップ値を評価スタックからポップし、ローカル変数 number `index`に移動します。ローカル変数には、0以降の番号が付けられます。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.s` 命令は、ローカル変数 0 ~ 255 の効率的なエンコードを提供します。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型 `F`) から引数に関連付けられているサイズに丸められます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stloc.s` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックから提供されたメモリ アドレスに、指定した型の値をコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|`class` 型の値をスタックからメモリに格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  `class` 型の値型オブジェクトがスタックにプッシュされます。  
  
3.  オブジェクトとアドレスがスタックからポップされます。値型のオブジェクトはアドレスに格納されます。  
  
 `stobj` 命令は、アドレス (`native int`、`*`、または `&`) によって指定されたアドレスに、値型オブジェクトをコピーします。 コピーされるバイト数は、`class`によって表されるクラスのサイズによって異なります。これは、値型を表すメタデータトークンです。  
  
 `stobj` 命令の操作は、直前の <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> プレフィックス命令によって変更できます。  
  
 クラスが見つからない場合、<xref:System.TypeLoadException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stobj` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックの値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|`field` の値を指定された値に置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  値はスタックからポップされ、`field`に格納されます。  
  
 `stsfld` 命令は、静的フィールドの値をスタックの値に置き換えます。 `field` は、静的フィールドメンバーを参照する必要があるメタデータトークンです。  
  
 `stsfld` 命令にプレフィックスとして <xref:System.Reflection.Emit.OpCodes.Volatile>を付けることができます。  
  
 メタデータ内にフィールドが見つからない場合、<xref:System.MissingFieldException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`stsfld` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある値から別の値を減算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|59|sub|ある値を別の値から減算し、新しい数値を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value2` は `value1`から減算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されません (適切なオーバーフロー処理の場合は、<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>を参照してください)。  
  
 整数の減算は、によって飽和するのではなく、ラップします。 たとえば、8ビット整数を想定して `value1` が0に設定され、`value2` が1に設定されている場合、"ラップされた" 結果は255になります。  
  
 浮動小数点オーバーフローでは、`+inf` (`PositiveInfinity`) または `-inf` (`NegativeInfinity`) が返されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`sub` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある整数値を別の整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|オーディオ|ovf|オーバーフローチェックを使用して、ある整数値を別の整数値から減算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value2` は、オーバーフローのチェック付きで `value1` から減算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 この操作は、符号付き整数に対して実行されます。浮動小数点値の場合は、<xref:System.Reflection.Emit.OpCodes.Sub>を使用します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`sub.ovf` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある符号なし整数値を別の符号なし整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|オーバーフローチェックを使用して、1つの符号なし整数値を別の符号なし整数値から減算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` がスタックからポップされます。`value2` は、オーバーフローのチェック付きで `value1` から減算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 結果を結果の型で表すことができない場合、<xref:System.OverflowException> がスローされます。  
  
 この操作は、符号付き整数に対して実行されます。浮動小数点値の場合は、<xref:System.Reflection.Emit.OpCodes.Sub>を使用します。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`sub.ovf.un` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャンプ テーブルを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >...< `int32` >|スイッチ (`N`、`t1`、`t2`... `tN`)|`N` の値のいずれかにジャンプします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  値はスタックからポップされ、値によってインデックス付けされたオフセットの命令に実行が転送されます。このとき、値は `N`未満です。  
  
 `switch` 命令は、ジャンプテーブルを実装します。 命令の形式は、`N`ターゲットの数を表す `unsigned int32` であり、その後にジャンプターゲットを指定する int32 値 `N` ます。 これらのターゲットは、この `switch` 命令に続く命令の先頭からのオフセット (正または負) として表されます。  
  
 `switch` 命令は、値をスタックからポップし、符号なし整数として `N`に比較します。 Value が `N`未満の場合、実行は値でインデックス付けされたターゲットに転送されます。この場合、ターゲットは0から番号が付けられます (たとえば、0の値は最初のターゲットを、値1は2番目のターゲットを受け取ります)。 値が `N`以上の場合、実行は次の命令 (フォールスルー) で続行されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。  
  
 `try`、`catch`、`filter`、および `finally` ブロックとの間での転送の制御は、この命令では実行できません。 (このような転送は厳しく制限されており、代わりに leave 命令を使用する必要があります)。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`switch` オペコードを使用できます。 `Label[]` 引数は、32ビットオフセットを表すラベルの配列です。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%5B%5D%29?displayProperty=nameWithType>  
  
   
  
## Examples  
 次のコードサンプルは、<xref:System.Reflection.Emit.Label>の配列を使用して `Switch` オペコードを使用してジャンプテーブルを生成する方法を示しています。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際の呼び出し命令が実行される前に、現在のメソッドのスタック フレームが削除されるように、後置のメソッド呼び出し命令を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 14|テイ.|後続の呼び出しは、現在のメソッドを終了します|  
  
 この命令には、スタック移行動作は定義されていません。  
  
 `tail` prefix 命令は、<xref:System.Reflection.Emit.OpCodes.Call>、<xref:System.Reflection.Emit.OpCodes.Calli>、または <xref:System.Reflection.Emit.OpCodes.Callvirt> 命令の直前に配置する必要があります。 これは、呼び出し命令が実行される前に、現在のメソッドのスタックフレームを削除する必要があることを示します。 また、次の呼び出しから返される値も、現在のメソッドによって返される値であることを意味します。この呼び出しは、メソッド間のジャンプに変換できます。  
  
 スタックは、次の呼び出しによって転送される引数を除いて、空である必要があります。 呼び出し命令の後の命令は、ret である必要があります。したがって、有効なコードシーケンスは `tail. call` (または `calli` または `callvirt`) のみです。 Microsoft 中間言語 (MSIL) の正しい命令を `call` 命令に分岐することはできませんが、後続の <xref:System.Reflection.Emit.OpCodes.Ret>に分岐する場合があります。  
  
 コード id のセキュリティが損なわれる可能性があるため、信頼されていないコードから信頼されるコードに制御が転送されるときに、現在のフレームを破棄することはできません。 このため、.NET Framework セキュリティチェックによって、`tail` は無視され、標準の <xref:System.Reflection.Emit.OpCodes.Call> 命令が残されます。 同様に、呼び出しから制御が戻った後に同期された領域の終了が発生するようにするために、synchronized とマークされているメソッドを終了するために使用した場合、`tail` のプレフィックスは無視されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`tail` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Opcode オブジェクトのインスタンス。</param>
        <summary>提供されたオペコードが 1 バイト引数をとる場合は、true または false を返します。</summary>
        <returns><see langword="true" /> または <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、最適化されたコードで使用される "短い形式" の MSIL オペコードを見つけることができます。  
  
 `TakesSingleByteArgument` は、次の場合に <xref:System.Reflection.Emit.OpCode> インスタンスが1バイトの引数を受け取る場合に `true` を返します。  
  
-   オペコードは、バイトサイズのアドレスに対する分岐命令を実行します (たとえば、<xref:System.Reflection.Emit.OpCodes.Br_S> と <xref:System.Reflection.Emit.OpCodes.Bgt_S>)。  
  
-   オペコードは、バイト値をスタックにプッシュします (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   オペコードは、バイトサイズの "短い形式" (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloc_S> と <xref:System.Reflection.Emit.OpCodes.Stloc_S>) を使用して、変数または引数を参照します。  
  
 それ以外の場合は、 `false`を返します。  
  
 次の例では、`OpCodes` クラスに対してをリフレクションし、各 `OpCode` フィールドが1バイトの引数を受け取るかどうかをテストすることによって `TakesSingleByteArgument` を使用する方法を示します。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックにある例外オブジェクトをスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7A|throw|例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  (例外への) オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、例外がスローされます。  
  
 `throw` 命令は、現在スタックにある例外オブジェクト (型 `O`) をスローします。  
  
 オブジェクト参照が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`throw` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが、直後の <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> または <see langword="cpblk" /> の各命令の通常サイズに合わせて配置されていない可能性があることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|揃え. `alignment`|後続のポインター命令が整列していない可能性があることを示します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
 `Unaligned` は、スタック上のアドレス (アンマネージポインター、`native int`) が、直後の `ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`、または `cpblk` 命令の自然サイズに配置されていない可能性があることを指定します。 つまり、<xref:System.Reflection.Emit.OpCodes.Ldind_I4> 命令の場合、アドレスのアラインメントを4バイト境界にすることはできません。 `initblk` および `cpblk` の場合、既定のアラインメントはアーキテクチャに依存します (32 ビット Cpu では4バイト、64ビット Cpu では8バイト)。 コンパイル時に8バイトとして配置が認識されない場合、出力を32ビットワードサイズに制限しないコードジェネレーターでは、`unaligned` を使用する必要があります。  
  
 アラインメントの値は1、2、または4である必要があります。生成されたコードでは、アドレスがバイト、2バイト、または4バイトでアラインされていると想定する必要があります。 一時的なポインター (型 `*`) は常にアラインされることに注意してください。  
  
 `cpblk` 命令の配置では、論理的に2つの数値が必要になりますが (1 つはソース用、もう1つは変換先に対して)、低い数値のみが指定されている場合、パフォーマンスに顕著な影響はありません。  
  
 `unaligned` と `volatile` のプレフィックスは、どちらの順序でも組み合わせることができます。 これらは、`ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`、または `cpblk` 命令の直前に配置する必要があります。 <xref:System.Reflection.Emit.OpCodes.Ldsfld> と <xref:System.Reflection.Emit.OpCodes.Stsfld> の手順では、<xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックスのみを使用できます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`unaligned` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型のボックス化変換された形式をボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|79 < `T` >|`valType` のボックス解除|値型のデータを `obj`のボックス化された形式で抽出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照はスタックからポップされ、ボックス化が解除されて値型のポインターになります。  
  
3.  値型のポインターがスタックにプッシュされます。  
  
 値型には、共通言語基盤 (CLI) 内の2つの異なる表現があります。  
  
-   値型が別のオブジェクトに埋め込まれている場合に使用される ' 未加工 ' フォーム。  
  
-   ' ボックス化された ' フォーム。値型のデータは、独立したエンティティとして存在できるように、オブジェクトにラップ (ボックス化) されます。  
  
 `unbox` 命令は、オブジェクト参照 (型 `O`)、値型のボックス化された表現を、値型ポインター (マネージポインター、型 `&`) に、ボックス化されていない形式に変換します。 指定された値の型 (`valType`) は、ボックス化されたオブジェクト内に含まれる値型の型を示すメタデータトークンです。  
  
 オブジェクトで使用するために値型のコピーを作成するために必要な <xref:System.Reflection.Emit.OpCodes.Box>とは異なり、`unbox` では、オブジェクトから値型をコピーする必要はありません。 通常は、ボックス化されたオブジェクト内に既に存在する値の型のアドレスを計算するだけです。  
  
 オブジェクトが `valType`としてボックス化されていない場合、<xref:System.InvalidCastException> がスローされます。  
  
 オブジェクト参照が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 値の型 `valType` が見つからない場合、<xref:System.TypeLoadException> がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`unbox` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>命令で指定された型のボックス化変換された形式を、ボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A5 < `T` >|ボックス解除します。任意の `typeTok`|`obj`から、ボックス化された形式でデータを抽出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 `obj` スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、その命令で指定された型にボックス化解除されます。  
  
3.  結果として得られるオブジェクト参照または値型がスタックにプッシュされます。  
  
 値型のボックス化された形式に適用すると、`unbox.any` 命令によって `obj` (型 `O`) に含まれる値が抽出され、その後に `ldobj`が続く `unbox` と同じになります。  
  
 参照型に適用された場合、`unbox.any` 命令は `castclass` `typeTok`と同じ効果を持ちます。  
  
 オペランド `typeTok` がジェネリック型パラメーターである場合、ランタイムの動作は、そのジェネリック型パラメーターに指定されている型によって決まります。  
  
 <xref:System.InvalidCastException> は、`obj` がボックス化された型でない場合にスローされます。  
  
 `obj` が null 参照の場合、<xref:System.NullReferenceException> がスローされます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`unbox.any` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが揮発性である可能性があるため、この位置の読み取り結果をキャッシュできないこと、またはこの位置への複数の格納を中止できないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 13|やすい.|後続のポインター参照が volatile であることを示します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
 `volatile`。 アドレスが volatile アドレスである (つまり、現在実行されているスレッドの外部で参照できる) ことを指定します。また、その場所の読み取り結果をキャッシュできないか、またはその場所への複数のストアを抑制できないことを示します。 アクセスを `volatile` としてマークすると、その1つのアクセスのみに影響します。同じ場所への他のアクセスは、個別にマークする必要があります。 揮発性の場所へのアクセスは、アトミックに実行する必要はありません。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned> と `volatile` のプレフィックスは、どちらの順序でも組み合わせることができます。 これらは、`ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`、または `cpblk` 命令の直前に配置する必要があります。 <xref:System.Reflection.Emit.OpCodes.Ldsfld> と <xref:System.Reflection.Emit.OpCodes.Stsfld> の手順では、`volatile` プレフィックスのみを使用できます。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`volatile` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある 2 つの値のビットごとの XOR を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|61|xor|2つの整数値のビットごとの XOR を計算し、整数を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1` がスタックにプッシュされます。  
  
2.  `value2` がスタックにプッシュされます。  
  
3.  `value2` と `value1` はスタックからポップされ、ビットごとの XOR が計算されます。  
  
4.  `value2` と `value1` のビットごとの XOR がスタックにプッシュされます。  
  
 `xor` 命令は、スタックの上位2つの値のビットごとの XOR を計算し、結果をスタックに残します。  
  
 `Xor` は、整数固有の演算です。  
  
 次の <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドオーバーロードは、`xor` オペコードを使用できます。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
