<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4dec371eab23b9b51981b3e008c438d68e467356" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73347088" /></Metadata><TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <TypeSignature Language="F#" Value="type DataContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>LINQ to SQL フレームワークのメイン エントリ ポイントを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext> は、データベース接続にマップされているすべてのエンティティのソースです。 取得したすべてのエンティティに対して行った変更を追跡し、"id キャッシュ" を保持します。これにより、複数回取得したエンティティが同じオブジェクトインスタンスを使用して表されることが保証されます。  
  
 一般に、<xref:System.Data.Linq.DataContext> インスタンスは、1つの "作業単位" に対して最後に設計されていますが、アプリケーションではその用語を定義しています。 <xref:System.Data.Linq.DataContext> は軽量であり、作成にはコストがかかりません。 一般的な [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] アプリケーションは、メソッドスコープで <xref:System.Data.Linq.DataContext> インスタンスを作成するか、関連するデータベース操作の論理セットを表す有効期間の短いクラスのメンバーとして作成します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.Linq.DataContext" /> クラスの新しいインスタンスを初期化します。 接続文字列として、ADO.NET 接続文字列を使用できます。 SQL Server Express ファイルまたは SQL Server Compact Edition ファイルにファイル名を指定することもできます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] で使用される接続。</param>
        <summary>[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] で使用される接続を参照して、<see cref="T:System.Data.Linq.DataContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 閉じられた接続または接続文字列を指定すると、<xref:System.Data.Linq.DataContext> は必要に応じてデータベース接続を開き、閉じます。 一般に、<xref:System.Data.Linq.DataContext>で `Dispose` を呼び出す必要はありません。 開いている接続を指定した場合、<xref:System.Data.Linq.DataContext> によって閉じられることはありません。 そのため、開いている接続を使用して <xref:System.Data.Linq.DataContext> をインスタンス化しないでください。有効な理由がない限りです。 <xref:System.Transactions> のトランザクションでは、昇格を回避するために <xref:System.Data.Linq.DataContext> が接続を開いたり閉じたりすることはありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (connection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">.NET Framework によって使用される接続。</param>
        <param name="mapping">マッピングのためのソース。</param>
        <summary>接続およびマップ ソースを参照して、<see cref="T:System.Data.Linq.DataContext" /> クラスの新規のインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (fileOrServerOrConnection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">この引数には、次のいずれかを指定できます。 
SQL Server Express データベースを格納しているファイルの名前。  
  
データベースが存在するサーバーの名前。 この場合、ユーザーの既定のデータベースがプロバイダーで使用されます。  
  
完全な接続文字列。 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] はプロバイダーに渡すだけで、文字列は変更しません。</param>
        <param name="mapping">マッピングのためのソース。</param>
        <summary>ファイル ソースおよびマップ ソースを参照して、<see cref="T:System.Data.Linq.DataContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext fileOrServerOrConnection" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">この引数には、次のいずれかを指定できます。SQL Server Express データベースを格納しているファイルの名前。

データベースが存在するサーバーの名前。 この場合、ユーザーの既定のデータベースがプロバイダーで使用されます。  
  
完全な接続文字列。 LINQ to SQL はプロバイダーに渡すだけで、文字列は変更しません。</param>
        <param name="connectionString">この引数には、次のいずれかを指定できます。SQL Server Express データベースを格納しているファイルの名前。

データベースが存在するサーバーの名前。 この場合、ユーザーの既定のデータベースがプロバイダーで使用されます。  
  
完全な接続文字列。 LINQ to SQL はプロバイダーに渡すだけで、文字列は変更しません。</param>
        <summary>ファイル ソースを参照して、<see cref="T:System.Data.Linq.DataContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChangeConflicts : System.Data.Linq.ChangeConflictCollection" Usage="System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> が呼び出されたときにコンカレンシーの競合を発生させたオブジェクトのコレクションを取得します。</summary>
        <value>コンカレンシーの競合を引き起こしたオブジェクトのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の例は、競合情報を取得するためにコレクションを反復処理する方法を示しています。  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : int with get, set" Usage="System.Data.Linq.DataContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のタイムアウト期限ではクエリがタイムアウトする場合に、クエリのタイムアウト期限の値 (秒) を増やす整数値を取得または設定します。</summary>
        <value>既定のタイムアウト期間中にタイムアウトになる可能性があるクエリのタイムアウト期間 (秒単位) を増やす整数値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、生成されたコマンドを実行するために使用されるコマンドのタイムアウト (秒) を取得または設定します (`IDbCommands`)。 詳細については、「<xref:System.Data.IDbCommand.CommandTimeout%2A>」を参照してください。  
  
 このプロパティが設定されていない場合、クエリコマンドの実行には <xref:System.Data.IDbCommand.CommandTimeout%2A> の既定値が使用されます。 この既定値は、記憶域プロバイダーによって設定されます。 この値が0以外の値に設定されている場合、一部のプロバイダーで例外がスローされることがあります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Linq.DataContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フレームワークによって使用される接続を取得します。</summary>
        <value>フレームワークによって使用される接続。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、リレーショナル ADO.NET コードと相互運用することができます。  
  
 返された接続は、ユーザーによって明示的に開かれていない限り、閉じられます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="dataContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー上にデータベースを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データベースの名前は、次のアルゴリズムを使用して取得されます。  
  
1. 接続文字列でデータベースが識別されている場合は、その名前が使用されます。  
1. <xref:System.Data.Linq.Mapping.DatabaseAttribute> の属性が存在する場合、その <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> プロパティがデータベースの名前として使用されます。  
1. 接続文字列にデータベースタグがなく、厳密に型指定された <xref:System.Data.Linq.DataContext> が使用されている場合は、<xref:System.Data.Linq.DataContext> 継承するクラスと同じ名前のデータベースが作成されます。  
1. 弱く型指定された <xref:System.Data.Linq.DataContext> を使用すると、例外がスローされます。  
1. ファイル名を使用して <xref:System.Data.Linq.DataContext> が作成されている場合は、そのファイル名に対応するデータベースが作成されます。  
     
  
## Examples  
 次のコードは、一時データベースを設定して削除する方法を示しています。  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fb7f23c4-4572-4c38-9898-a287807d070c">方法 : データベースを動的に作成する (LINQ to SQL)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4ed76327-54a7-414b-82a9-7579bfcec04b">SQL と CLR の型マッピング (LINQ to SQL)</related>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodCallQuery : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="dataContext.CreateMethodCallQuery (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">返されるコレクション内の要素の型。</typeparam>
        <param name="instance">メソッド呼び出しのインスタンス (現在のオブジェクト)。</param>
        <param name="methodInfo">データベース メソッドに対応する .NET メソッドを識別する <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="parameters">コマンドに渡すパラメーターの配列。</param>
        <summary>指定した .NET メソッドに関連付けられているテーブル値データベース関数を実行します。</summary>
        <returns>データベース クエリによって返される結果値のコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> メソッドは、自動的に生成されたコードで使用され、データベース関数のプロキシとして機能します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="dataContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連するデータベースを開くことができるかどうかを判断します。</summary>
        <returns>指定したデータベースを開くことができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Data.Linq.DataContext.Connection%2A> プロパティの接続を使用して、関連付けられているデータベースを開こうとします。  
  
   
  
## Examples  
 次の例では、このメソッドを使用して、データベースが既に存在するかどうかを確認します。  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DeferredLoadingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>1 対多または 1 対 1 のリレーションシップを遅延読み込みするかどうかを示す値を取得または設定します。</summary>
        <value>遅延読み込みが有効の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コードがこれらのリレーションシップのいずれかにアクセスすると、リレーションシップが一対一の場合は null が返され、1対多の場合は空のコレクションが返されます。 リレーションシップは、<xref:System.Data.Linq.DataContext.LoadOptions%2A> プロパティを設定することによって、引き続き塗りつぶすことができます。  
  
 このプロパティの主なシナリオは、オブジェクトモデルの一部を抽出して、(たとえば、Web サービスに) 送信できるようにすることです。  
  
> [!NOTE]
>  クエリが実行された後にこのプロパティを `false` に設定すると、例外がスローされます。 詳細については、以下の「**有効なモード**」セクションを参照してください。  
  
## <a name="valid-modes"></a>有効なモード  
 遅延読み込みには、オブジェクトの追跡が必要です。 次の3つのモードのみが有効です。  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> は無視され、`false`れることが推論されます。 この動作は、読み取り専用の <xref:System.Data.Linq.DataContext>に対応しています。  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. この状況は、ユーザーが <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> ディレクティブを使用してオブジェクトグラフを読み込むための <xref:System.Data.Linq.DataContext> に対応していますが、遅延読み込みは有効になっていません。  
  
-   どちらも `true`に設定されます。 既定値です。  
  
 クエリの実行後にフラグを変更することはできません。 この <xref:System.Data.Linq.DataContext> を使用する最初のクエリの実行後に加えられた変更は、例外をスローします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="dataContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられているデータベースを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Data.Linq.DataContext.Connection%2A> プロパティの接続を使用して、削除するデータベースを識別します。  
  
   
  
## Examples  
 次の例では、一時的に作成されたデータベースを削除する方法を示します。  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.Linq.DataContext" /> クラスによって使用されているリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="dataContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.Linq.DataContext" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="dataContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>使用されるアンマネージ リソースを解放、<see cref="T:System.Data.Linq.DataContext" />クラスし、オプションでマネージ リソースも解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteCommand : string * obj[] -&gt; int" Usage="dataContext.ExecuteCommand (command, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">実行する SQL コマンド。</param>
        <param name="parameters">コマンドに渡すパラメーターの配列。 以下の動作に注意してください。 
配列内のオブジェクトの数が、コマンド文字列で特定された最大数より小さい場合、例外がスローされます。  
  
配列にコマンド文字列で参照されないオブジェクトが含まれている場合、例外はスローされません。  
  
パラメーターのいずれかが null の場合、<see langword="DBNull.Value" /> に変換されます。</param>
        <summary>データベース上で SQL コマンドを直接実行します。</summary>
        <returns>コマンドの実行によって変更された行の数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この方法は、特定のシナリオに対して [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] が適切に提供しない場合のパススルーメカニズムです。  
  
 コマンドの構文は、ADO.NET `DataCommand`の作成に使用される構文とほぼ同じです。 唯一の違いは、パラメーターの指定方法です。 具体的には、パラメーターを中かっこ ({...}) で囲んで指定し、0から開始して列挙します。 パラメーターは、parameters 配列内の同じ番号を持つオブジェクトに関連付けられています。  
  
 `ExecuteQuery` と `ExecuteCommand` では、パラメーターの置換に可変数の引数を指定できます。 たとえば、ExecuteQuery\<TResult > を呼び出すときに、パラメーターを指定できます。  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 もう1つの例を次に示します。  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 次の例では、接続を開き、sql `UPDATE` コマンドを SQL エンジンに渡します。  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicDelete : obj -&gt; unit" Usage="dataContext.ExecuteDynamicDelete entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">削除するエンティティ。</param>
        <summary>[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] に削除操作のための動的 SQL の生成と実行を行うタスクを再度代行させるために、削除用のオーバーライド メソッド内部で実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下を参照してください。<xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicInsert : obj -&gt; unit" Usage="dataContext.ExecuteDynamicInsert entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">挿入するエンティティ。</param>
        <summary>[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] に挿入操作のための動的 SQL を生成し実行するタスクの処理を再度代行させるために、挿入用のオーバーライド メソッド内部で実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の点に注意してください。  
  
-   メソッドには protected 修飾子があるため、その使用には <xref:System.Data.Linq.DataContext>のサブクラス化が必要です。  
  
-   この操作が <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 操作の内部で呼び出されない場合は、例外がスローされます。 これは、<xref:System.Data.Linq.DataContext.SubmitChanges%2A> 操作の範囲外のスタンドアロン操作として呼び出すためのものではありません。 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 自体は、オーバーライドメソッドが実装されており、前のメソッドがオーバーライドメソッド内で呼び出されることを意図している場合に、そのメソッドを呼び出します。  
  
-   開発者は、適切なエンティティを渡す必要があります。 実装は、渡されたエンティティが追跡されていることを確認します。 ただし、注文を維持したり、同じエンティティを2回渡したりするのは、開発者の責任です。  
  
-   開発者は、適切な動的 API を呼び出す必要があります。 たとえば、`Update` override メソッドでは、<xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> メソッドのみを呼び出すことができます。 呼び出した動的メソッドが対象の操作に一致するかどうかについて、[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] は、検出や検査は行いません。 該当しないメソッドが呼び出された場合 (たとえば、オブジェクトを更新するために <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> を呼び出す場合)、結果は未定義になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicUpdate : obj -&gt; unit" Usage="dataContext.ExecuteDynamicUpdate entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">更新するエンティティ。</param>
        <summary>[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] に更新操作のための動的 SQL の生成と実行を行うタスクの処理を再度代行させるために、更新用のオーバーライド メソッド内部で実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下を参照してください。<xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected internal System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteMethodCall : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Data.Linq.IExecuteResult" Usage="dataContext.ExecuteMethodCall (instance, methodInfo, parameters)" />
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">メソッド呼び出しのインスタンス (現在のオブジェクト)。</param>
        <param name="methodInfo">データベース メソッドに対応する .NET メソッドを識別します。</param>
        <param name="parameters">コマンドに渡すパラメーターの配列。</param>
        <summary>指定した .NET メソッドに関連付けられているストアド データベース プロシージャまたはスカラー関数を実行します。</summary>
        <returns>指定したメソッドを実行した結果 (戻り値と出力パラメーター)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> メソッドは、自動的に生成されたコードで使用され、データベース関数のプロキシとして機能します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : Type * string * obj[] -&gt; System.Collections.IEnumerable" Usage="dataContext.ExecuteQuery (elementType, query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">返される <see cref="T:System.Collections.Generic.IEnumerable`1" /> の型。  
  
オブジェクト内のフィールドまたはプロパティに対して、クエリの結果内の列の一致を行うアルゴリズムは、以下のように動作します。 
フィールドまたはプロパティが特定の列名に割り当てられている場合は、その列名が結果セットに存在する必要があります。  
  
フィールドまたはプロパティが割り当てられていない場合は、フィールドまたはプロパティと同じ名前の列が結果セットに存在する必要があります。  
  
比較では、まず大文字と小文字が区別されます。 一致するものが見つからない場合は、大文字と小文字を区別せずに以降の検索が実行されます。  
  
このクエリは、以下の条件がすべて当てはまる場合、(遅延読み込みされる場合を除いて) オブジェクトの追跡されるフィールドおよびプロパティをすべて返す必要があります。 
 <c>T</c> が、<see cref="T:System.Data.Linq.DataContext" /> によって明示的に追跡されるエンティティである場合。  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> は <see langword="true" />です。  
  
そのエンティティに主キーがある場合。  
  
それ以外の場合は、例外がスローされます。</param>
        <param name="query">実行する SQL クエリ。</param>
        <param name="parameters">コマンドに渡すパラメーターの配列。 以下の動作に注意してください。 
配列内のオブジェクトの数が、コマンド文字列で特定された最大数より小さい場合、例外がスローされます。  
  
配列にコマンド文字列で参照されないオブジェクトが含まれている場合、例外はスローされません。  
  
パラメーターが <see langword="null" /> の場合は、<see langword="DBNull.Value" /> に変換されます。</param>
        <summary>データベース上で SQL クエリを直接実行します。</summary>
        <returns>クエリによって返されるオブジェクトの <see cref="T:System.Collections.Generic.IEnumerable`1" /> コレクション。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;TResult&gt;(string query, object[] parameters) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result&gt;" Usage="dataContext.ExecuteQuery (query, parameters)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result (requires 'Result : (new : unit -&gt; 'Result))&gt; (requires 'Result : (new : unit -&gt; 'Result))" Usage="dataContext.ExecuteQuery (query, parameters)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">返されるコレクション内の要素の型。</typeparam>
        <param name="query">実行する SQL クエリ。</param>
        <param name="parameters">コマンドに渡すパラメーターの配列。 以下の動作に注意してください。 
配列内のオブジェクトの数が、コマンド文字列で特定された最大数より小さい場合、例外がスローされます。  
  
配列にコマンド文字列で参照されないオブジェクトが含まれている場合、例外はスローされません。  
  
パラメーターが null の場合は、<see langword="DBNull.Value" /> に変換されます。</param>
        <summary>データベース上で SQL クエリを直接実行して、オブジェクトを返します。</summary>
        <returns>クエリによって返されるオブジェクトのコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] が特定のシナリオに対してを提供しない場合のパススルーメカニズムです。  
  
 クエリの結果の列をオブジェクトのフィールドおよびプロパティに一致させるためのアルゴリズムは、次のようになります。  
  
-   フィールドまたはプロパティが特定の列名に割り当てられている場合は、その列名が結果セットに存在する必要があります。  
  
-   フィールドまたはプロパティが割り当てられていない場合は、フィールドまたはプロパティと同じ名前の列が結果セットに存在する必要があります。  
  
-   比較は、最初に大文字と小文字を区別する一致を検索することによって行われます。 このような一致が見つからない場合は、大文字と小文字を区別せずに検索が行われます。  
  
-   次のすべての条件に該当する場合、クエリはオブジェクトの追跡されたすべてのフィールドとプロパティを返す必要があります。  
  
    -   `<T>` が <xref:System.Data.Linq.DataContext>によって明示的に追跡されるエンティティである場合は。  
  
    -   ObjectTrackingEnabled は true です。  
  
    -   そのエンティティに主キーがある場合。  
  
     それ以外の場合は、例外がスローされます。  
  
-   それ以外の場合、クエリは、オブジェクトの追跡されたフィールドおよびプロパティのサブセットのみを取得できます。  
  
 次C#のスニペットは、このメソッドの1つの使用方法を示しています。  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberSignature Language="F#" Value="member this.GetChangeSet : unit -&gt; System.Data.Linq.ChangeSet" Usage="dataContext.GetChangeSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.Linq.DataContext" /> で追跡される変更されたオブジェクトを取得します。</summary>
        <returns>オブジェクトのセットが、3 つの読み取り専用のコレクションとして返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の点に注意してください。  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> には、通常は <xref:System.Data.Linq.DataContext.SubmitChanges%2A>時に実行される挿入操作や削除操作の推定など、副作用が生じる可能性があります。 たとえば、次の操作で使用されるオブジェクトでは、次の一覧に対応する推論操作を作成できます。  
  
    -   <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>に <xref:System.Data.Linq.EntitySet%601.Add%2A> します。  
  
    -   null への割り当てを <xref:System.Data.Linq.EntityRef%601> しています (<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>の <xref:System.Data.Linq.EntitySet%601.Remove%2A> が原因である可能性があります。  
  
-   Set は、foreign key 制約に従って並べ替えられない場合があります。  
  
-   データベースで生成された値 (たとえば、主キーと外部キーの値、タイムスタンプなど) は使用できません。 このような情報には、データベースコマンドの実行と、取得した情報の伝達 (主キーからの外部キーなど) が必要です。  
  
-   変更されたオブジェクトのセットは、呼び出し時に計算されます。 後で <xref:System.Data.Linq.DataContext.SubmitChanges%2A> を呼び出すと、追加の変更が加えられた場合に異なるセットが生成される可能性があります。  
  
 変更が行われなかった場合の出力は次のようになります。  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetCommand : System.Linq.IQueryable -&gt; System.Data.Common.DbCommand" Usage="dataContext.GetCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">SQL コマンド情報を取得するクエリ。</param>
        <summary>[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] によって生成される SQL コマンドの情報を取得します。</summary>
        <returns>要求したコマンド情報オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは get アクセス操作子であり、<xref:System.Data.Linq.DataContext> の状態には影響しません。  
  
 次の点に注意してください。  
  
-   引数は null 以外である必要があります。 それ以外の場合は、null 引数の例外がスローされます。  
  
-   変換できないクエリに対して [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] クエリの実行中にスローされる通常のクエリ変換例外。  
  
-   最初のクエリコマンドのみが返されます。 具体的には、一括読み込み (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) に使用される追加のコマンドは含まれません。  
  
-   <xref:System.Data.Linq.DataContext> は、ユーザーがコマンドで何を実行しているかを追跡しません。 たとえば、返されたコマンドの実行結果は追跡されず、<xref:System.Data.Linq.DataContext> 状態には影響しません。  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetIDbCommand : System.Linq.IQueryable -&gt; System.Data.IDbCommand" Usage="dataContext.GetIDbCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTable : Type -&gt; System.Data.Linq.ITable" Usage="dataContext.GetTable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">返されるオブジェクトの型。</param>
        <summary><paramref name="type" /> パラメーターで定義される型のオブジェクトのコレクションを返します。</summary>
        <returns><paramref name="type" /> パラメーターで定義されたオブジェクトのコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、<xref:System.Data.Linq.DataContext.GetTable%2A>の弱く型指定されたバージョンです。 クエリを動的に構築するのは比較的一般的な方法であるため、弱く型指定されたバージョンを用意することが重要です。 アプリケーションがリフレクションを使用して適切なジェネリックメソッドを呼び出すように強制するのは不便です。  
  
 特定の型のコレクションが存在しない場合は、例外がスローされます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberSignature Language="F#" Value="member this.GetTable : unit -&gt; System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="dataContext.GetTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">返されるオブジェクトの型。</typeparam>
        <summary><paramref name="TEntity" /> パラメーターで定義される型のオブジェクトのコレクションを返します。</summary>
        <returns><paramref name="TEntity" /> パラメーターで定義されたオブジェクトのコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、クエリを実行するための主なエントリポイントです。 厳密に型指定された <xref:System.Data.Linq.DataContext> が作成されると、新しい生成されるプロパティは、このメソッドの呼び出しをカプセル化します。 たとえば、`GetTable<Customer>`を返す `Customers` プロパティが生成されます。  
  
 特定の型のコレクションが存在しない場合は、例外がスローされます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LoadOptions : System.Data.Linq.DataLoadOptions with get, set" Usage="System.Data.Linq.DataContext.LoadOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Data.Linq.DataLoadOptions" /> に関連付けられた <see cref="T:System.Data.Linq.DataContext" /> を取得または設定します。</summary>
        <value>関連するデータのプリフェッチ読み込みのオプション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、遅延読み込みされたメンバーと関連コレクションのメンバーシップのプリフェッチ動作を定義するために使用されるオプションを取得または設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : System.IO.TextWriter with get, set" Usage="System.Data.Linq.DataContext.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>SQL クエリまたはコマンドの書き込み先を取得または設定します。</summary>
        <value>コマンドを書き込むために使用する <see cref="T:System.IO.TextReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コマンドのログ記録を無効にするには、このプロパティを `null` に設定します。  
  
   
  
## Examples  
 次の例では、生成された SQL をコンソールウィンドウに表示してから、クエリの結果を表示します。  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mapping : System.Data.Linq.Mapping.MetaModel" Usage="System.Data.Linq.DataContext.Mapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マッピングの基になる <see cref="T:System.Data.Linq.Mapping.MetaModel" /> を取得します。</summary>
        <value>データベース オブジェクトとドメイン オブジェクト間のマッピング。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectTrackingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトの追跡が有効かどうかを示す値を取得または設定します。</summary>
        <value>追跡が有効になっている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを `false` に設定すると、追跡する項目が少なくなるため、取得時のパフォーマンスが向上します。  
  
 例外がスローされます。  
  
-   クエリが実行された後に、プロパティが `false` に設定されている場合は。  
  
     詳細については、「<xref:System.Data.Linq.DataContext>」の有効なモードに関するセクションを参照してください。  
  
-   プロパティが `false` に設定されており、<xref:System.Data.Linq.DataContext.SubmitChanges%2A> が呼び出されている場合は。  
  
 <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> が `false`場合、<xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> は無視され、`false`として扱われます。 この場合、<xref:System.Data.Linq.DataContext> は読み取り専用です。  
  
 <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> が `true` の場合、<xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> は `false` です。 この場合、<xref:System.Data.Linq.DataContext> を使用すると、<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> ディレクティブを使用してオブジェクトグラフを読み込むことができますが、遅延読み込みは有効になりません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.QueryCacheEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データベース内のデータを使用してオブジェクトの状態を更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、オプティミスティック同時実行制御エラーの後で、項目を別の試行の状態にするために役立ちます。 オブジェクトのプリミティブフィールドとプロパティの状態を更新します。  
  
> [!NOTE]
>  オブジェクトが一対多のリレーションシップの "*多*" の側にある場合は、オブジェクトの外部キーが設定され、リレーションシップのもう一方の側のオブジェクトポインターが新しい値に設定されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">オプティミスティック コンカレンシーの競合の処理方法を指定する値。</param>
        <param name="entities">更新されるエンティティのコレクション。</param>
        <summary>指定したモードに従ってエンティティ オブジェクトのコレクションを更新します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj -&gt; unit" Usage="dataContext.Refresh (mode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">オプティミスティック コンカレンシーの競合の処理方法を指定する値。</param>
        <param name="entity">更新するオブジェクト。</param>
        <summary>指定したモードに従ってエンティティ オブジェクトを更新します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj[] -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">オプティミスティック コンカレンシーの競合の処理方法を指定する値。</param>
        <param name="entities">更新するエンティティ オブジェクトの配列。</param>
        <summary>指定したモードに従ってエンティティ オブジェクトの配列を更新します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>挿入、更新、または削除される変更されたオブジェクトのセットを計算し、該当するコマンドを実行してデータベースを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Insert、update、または delete に対して override メソッドが存在する場合、<xref:System.Data.Linq.DataContext.SubmitChanges%2A> は既定の [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] コマンドの代わりにこれらのメソッドを実行します。  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> はトランザクションを開始し、<xref:System.Data.Linq.DataContext.SubmitChanges%2A> の実行中に例外が発生した場合はロールバックします。 ただし、これによってメモリ内の変更がロールバックされることも、<xref:System.Data.Linq.DataContext>によって追跡されることもありません。これらの変更は、手動でロールバックする必要があります。 メモリ内の変更を破棄する場合は、<xref:System.Data.Linq.DataContext> の新しいインスタンスを使用して開始できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberSignature Language="F#" Value="member this.SubmitChanges : unit -&gt; unit" Usage="dataContext.SubmitChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>挿入、更新、または削除される変更されたオブジェクトのセットを計算し、該当するコマンドを実行してデータベースを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Insert、update、または delete に対して override メソッドが存在する場合、<xref:System.Data.Linq.DataContext.SubmitChanges%2A> は既定の [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] コマンドの代わりにこれらのメソッドを実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberSignature Language="F#" Value="abstract member SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit&#xA;override this.SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit" Usage="dataContext.SubmitChanges failureMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">送信が失敗したときに実行するアクション。 有効な引数は次のとおりです。 
 <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>取得したオブジェクトに対して行われた変更を、基になるデータベースに送信し、送信が失敗したときに実行するアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のエラーモードは <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>です。  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transaction : System.Data.Common.DbTransaction with get, set" Usage="System.Data.Linq.DataContext.Transaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>データベースにアクセスするために使用する [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] のローカル トランザクションを取得または設定します。</summary>
        <value>クエリおよびコマンドの実行中に <see cref="T:System.Data.Linq.DataContext" /> によって使用されるトランザクション オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの主要なシナリオは、リレーショナル [!INCLUDE[vstecado](~/includes/vstecado-md.md)] コードとの相互運用性です。 たとえば、独自の `Create`を記述する場合は、このプロパティを使用して /`Update`/`Delete` メソッドを使用して、ADO `Transaction` オブジェクトの `Command` プロパティを設定します。  
  
 次の点に注意してください。  
  
-   このプロパティが明示的に設定されていない場合、getter は null を返します。  
  
-   コードが <xref:System.Transactions.Transaction> コンテキストで実行されている場合、このプロパティを設定すると例外がスローされます。  
  
-   このプロパティが設定されていて、新しい <xref:System.Transactions.Transaction> が開かれている場合は、クエリまたは更新が実行されると例外がスローされます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既存の <see cref="T:System.Data.IDataReader" /> をオブジェクトに変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataReader> の各行は、<xref:System.Collections.Generic.IEnumerable%601>内のオブジェクトに変換されます。  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 説明: このメソッドは、既存の <xref:System.Data.Common.DbDataReader> をオブジェクトに変換するために使用されます。 <xref:System.Data.Common.DbDataReader> の各行は、<xref:System.Collections.Generic.IEnumerable%601>内のオブジェクトに変換されます。  
  
 **ジェネリックパラメーター:**  
  
 `T`: 「<xref:System.Data.Linq.DataContext.ExecuteQuery%2A>」を参照してください。  
  
 **パラメータ**  
  
 `Query`: <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>の下にあるコマンドの説明を参照してください。  
  
 `Parameters`: <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>の下にあるパラメーターの説明を参照してください。  
  
 **戻り値の型:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: 変換によって返されるオブジェクトのコレクション。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Linq.IMultipleResults" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">変換される <see cref="T:System.Data.IDataReader" />。</param>
        <summary>既存の <see cref="T:System.Data.Common.DbDataReader" /> をオブジェクトに変換します。</summary>
        <returns>変換によって返されるオブジェクトのリスト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : Type * System.Data.Common.DbDataReader -&gt; System.Collections.IEnumerable" Usage="dataContext.Translate (elementType, reader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">返される <see cref="T:System.Collections.Generic.IEnumerable`1" /> の型。  
  
オブジェクト内のフィールドおよびプロパティに対して、結果内の列の一致を行うアルゴリズムは、以下のように動作します。 
フィールドまたはプロパティが特定の列名に割り当てられている場合は、その列名が結果セットに存在する必要があります。  
  
フィールドまたはプロパティが割り当てられていない場合は、フィールドまたはプロパティと同じ名前の列が結果セットに存在する必要があります。  
  
比較では、まず大文字と小文字が区別されます。 一致するものが見つからない場合は、大文字と小文字を区別せずに以降の検索が実行されます。  
  
このクエリは、以下の条件がすべて当てはまる場合、(遅延読み込みされる場合を除いて) オブジェクトの追跡されるフィールドおよびプロパティをすべて返す必要があります。 
 <c>T</c> が、<see cref="T:System.Data.Linq.DataContext" /> によって明示的に追跡されるエンティティである場合。  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> は <see langword="true" />です。  
  
そのエンティティに主キーがある場合。  
  
それ以外の場合は、例外がスローされます。</param>
        <param name="reader">変換される <see cref="T:System.Data.IDataReader" />。</param>
        <summary>既存の <see cref="T:System.Data.Common.DbDataReader" /> をオブジェクトに変換します。</summary>
        <returns>変換によって返されるオブジェクトのリスト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; seq&lt;'Result&gt;" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">返される <see cref="T:System.Collections.Generic.IEnumerable`1" /> の型。</typeparam>
        <param name="reader">変換される <see cref="T:System.Data.IDataReader" />。</param>
        <summary>既存の <see cref="T:System.Data.Common.DbDataReader" /> をオブジェクトに変換します。</summary>
        <returns>変換によって返されるオブジェクトのコレクション。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
