<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3af4fec8c7b89c7aec3e00fa41aa15a534df436c" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82505524" /></Metadata><TypeSignature Language="C#" Value="public abstract class CriticalHandle : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Implements IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type CriticalHandle = class&#xA;    interface IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type CriticalHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.InteropServices" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.0.20.0" To="System.Runtime.Handles" ToVersion="4.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;netstandard-1.3;netstandard-1.4" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.1.0.0" To="System.Runtime.Handles" ToVersion="4.0.0.0" FrameworkAlternate="netcore-1.0;netstandard-1.5;netstandard-1.6" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.1.1.0" To="System.Runtime.Handles" ToVersion="4.0.0.0" FrameworkAlternate="netcore-1.1" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.2.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.2.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.2.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3aaf9-101">ハンドル リソースのラッパー クラスを表します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-101">Represents a wrapper class for handle resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-102"><xref:System.Runtime.InteropServices.CriticalHandle> クラスは <xref:System.Runtime.InteropServices.SafeHandle> クラスに似ていますが、<xref:System.Runtime.InteropServices.SafeHandle> で参照カウントが実装されている点が異なります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-102">The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting.</span></span> <span data-ttu-id="3aaf9-103">必要な同期を自分でより効率的に行うには、<xref:System.Runtime.InteropServices.SafeHandle> ではなく <xref:System.Runtime.InteropServices.CriticalHandle> を使用します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-103">You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</span></span>  
  
 <span data-ttu-id="3aaf9-104"><xref:System.Runtime.InteropServices.CriticalHandle> クラスは参照カウントを実行しないため、ハンドルリサイクルのセキュリティ攻撃からの保護は提供されません。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-104">Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</span></span> <span data-ttu-id="3aaf9-105">参照カウントアルゴリズムは演算を暗黙的にシリアル化するため、一定量のスレッドセーフも失われます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-105">Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</span></span> <span data-ttu-id="3aaf9-106">ハンドルを使用している操作が別のスレッドで未処理のときに、<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> または <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> メソッドを呼び出した場合、または同時に2つのスレッドから <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> または <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> を呼び出した場合、結果は非決定的になります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-106">If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic.</span></span> <span data-ttu-id="3aaf9-107"><xref:System.Runtime.InteropServices.CriticalHandle> クラスでは、<xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> クラスによって提供される、保証された重大な終了処理が引き続き提供されます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-107">The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.CriticalHandle : nativeint -&gt; System.Runtime.InteropServices.CriticalHandle" Usage="new System.Runtime.InteropServices.CriticalHandle invalidHandleValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue"><span data-ttu-id="3aaf9-108">無効なハンドルの値 (通常は 0 または -1)。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-108">The value of an invalid handle (usually 0 or -1).</span></span></param>
        <summary><span data-ttu-id="3aaf9-109">指定した無効なハンドル値を使用して、<see cref="T:System.Runtime.InteropServices.CriticalHandle" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-109">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="3aaf9-110">派生クラスがアンマネージ コードのアクセス許可なしにアセンブリに存在しています。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-110">The derived class resides in an assembly without unmanaged code access permission.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="criticalHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3aaf9-111">リソースを解放するためのハンドルをマークします。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-111">Marks the handle for releasing and freeing resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-112"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドを呼び出すと、リソースを解放できます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-112">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="3aaf9-113"><xref:System.Runtime.InteropServices.SafeHandle> クラスとは異なり、これは常に、他のスレッドがこのハンドルを使用していることを示す参照カウントがないため、直ちに発生します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-113">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="3aaf9-114">そのため、<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> メソッドを安全に呼び出すには、同期機構を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-114">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method.</span></span> <span data-ttu-id="3aaf9-115"><xref:System.Runtime.InteropServices.CriticalHandle> クラスを使用するほとんどのクラスはファイナライザーを提供する必要はありませんが、これが必要になることがあります (たとえば、ファイルバッファーをフラッシュする場合や、データをメモリに書き戻す場合など)。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-115">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="3aaf9-116">この場合、クラスは、<xref:System.Runtime.InteropServices.CriticalHandle> クリティカルファイナライザーが実行される前に実行が保証されるファイナライザーを提供できます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-116">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="3aaf9-117"><xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトの使用が終了したら、<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-117">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="3aaf9-118"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> メソッドは、<xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトを使用できない状態のままにします。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-118">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="3aaf9-119">**メモ**<xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトへの最後の参照を解放する前に、常に <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> を呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-119">**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="3aaf9-120">そうしないと、ガベージ コレクターが <xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトの <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> メソッドを呼び出すまで、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-120">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3aaf9-121">リソースを解放するためのハンドルをマークします。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-121">Marks the handle for releasing and freeing resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="criticalHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3aaf9-122"><see cref="T:System.Runtime.InteropServices.CriticalHandle" /> で使用されるすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-122">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-123"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドを呼び出すと、リソースを解放できます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-123">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="3aaf9-124"><xref:System.Runtime.InteropServices.SafeHandle> クラスとは異なり、これは常に、他のスレッドがこのハンドルを使用していることを示す参照カウントがないため、直ちに発生します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-124">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="3aaf9-125">そのため、<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドを安全に呼び出すには、同期機構を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-125">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method.</span></span> <span data-ttu-id="3aaf9-126"><xref:System.Runtime.InteropServices.CriticalHandle> クラスを使用するほとんどのクラスはファイナライザーを提供する必要はありませんが、これが必要になることがあります (たとえば、ファイルバッファーをフラッシュする場合や、データをメモリに書き戻す場合など)。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-126">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="3aaf9-127">この場合、クラスは、<xref:System.Runtime.InteropServices.CriticalHandle> クリティカルファイナライザーが実行される前に実行が保証されるファイナライザーを提供できます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-127">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="3aaf9-128"><xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトの使用が終了したら、<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-128">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="3aaf9-129"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> メソッドは、<xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトを使用できない状態のままにします。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-129">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="3aaf9-130">**メモ**<xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトへの最後の参照を解放する前に、常に <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドを呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-130">**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="3aaf9-131">そうしないと、ガベージ コレクターが <xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトの <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> メソッドを呼び出すまで、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-131">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="criticalHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="3aaf9-132">通常の破棄操作を実行する場合は <see langword="true" />。ハンドルを終了する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-132"><see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span></span></param>
        <summary><span data-ttu-id="3aaf9-133">通常の破棄操作を実行するかどうかを指定して、<see cref="T:System.Runtime.InteropServices.CriticalHandle" /> クラスによって使用されているアンマネージ リソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-133">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-134">`disposing` パラメーターを `false`に設定して、<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドを明示的に呼び出すことは避けてください。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-134">You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="criticalHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3aaf9-135">ハンドルに関連付けられたすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-135">Frees all resources associated with the handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-136"><xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> メソッドは、<xref:System.Runtime.InteropServices.CriticalHandle> クラスのデストラクターです。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-136">The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class.</span></span> <span data-ttu-id="3aaf9-137">アプリケーションコードでは、このメソッドを直接呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-137">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3aaf9-138">ラップするハンドルを指定します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-138">Specifies the handle to be wrapped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-139">ハンドルを公開しないでください (つまり、派生クラスの外部)。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-139">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3aaf9-140">ハンドルが閉じているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-140">Gets a value indicating whether the handle is closed.</span></span></summary>
        <value><span data-ttu-id="3aaf9-141">ハンドルが閉じている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-141"><see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-142"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> メソッドは、<xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトのハンドルがネイティブリソースに関連付けられていないかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-142">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="3aaf9-143">これは、指定されたハンドルが常に無効と見なされるかどうかを計算する <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> プロパティの定義とは異なります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-143">This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="3aaf9-144"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> メソッドは、次の場合に `true` 値を返します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-144">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="3aaf9-145"><xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> メソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-145">The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="3aaf9-146"><xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドまたは <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> メソッドが呼び出されましたが、他のスレッドの <xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトへの参照がありません。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-146">The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3aaf9-147">派生クラスでオーバーライドされると、ハンドル値が無効かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-147">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span></span></summary>
        <value><span data-ttu-id="3aaf9-148">ハンドルが有効な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-148"><see langword="true" /> if the handle is valid; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-149">派生クラスは、<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> プロパティを実装する必要があります。これにより、重要な終了処理が必要かどうかを共通言語ランタイムが判断できるようになります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-149">Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="3aaf9-150">派生クラスは、サポートするハンドルの一般的な種類に適した実装を提供する必要があります (0 または-1 は無効です)。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-150">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="3aaf9-151">これらのクラスは、特定のセーフハンドル型に対してさらに派生させることができます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-151">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="3aaf9-152"><xref:System.Runtime.InteropServices.CriticalHandle> オブジェクトが基になるハンドルの使用を終了したかどうかを報告する <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> プロパティとは異なり、<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> プロパティは、指定されたハンドル値が常に無効と見なされるかどうかを計算します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-152">Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="3aaf9-153">したがって、<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> プロパティは常に、1つのハンドル値に対して同じ値を返します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-153">Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="criticalHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3aaf9-154">派生クラスでオーバーライドされると、ハンドルを解放するために必要なコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-154">When overridden in a derived class, executes the code required to free the handle.</span></span></summary>
        <returns><span data-ttu-id="3aaf9-155">ハンドルが正常に解放された場合は <see langword="true" />。深刻なエラーが発生した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-155"><see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span></span> <span data-ttu-id="3aaf9-156">この場合、<see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see> マネージド デバッグ アシスタントが生成されます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-156">In this case, it generates a <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see> Managed Debugging Assistant.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-157"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> メソッドは、適切な同期機構を使用して、<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> メソッドの呼び出しが1回だけ行われるようにすると、1回だけ呼び出されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-157">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made.</span></span> <span data-ttu-id="3aaf9-158"><xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> または <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> プロパティが `true`場合、<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> メソッドは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-158">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`.</span></span> <span data-ttu-id="3aaf9-159">このメソッドを <xref:System.Runtime.InteropServices.CriticalHandle> の派生クラスに実装して、ハンドルを解放するために必要なすべてのコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-159">Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="3aaf9-160"><xref:System.Runtime.InteropServices.CriticalHandle> の関数の1つはリソースリークの防止を保証することであるため、<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> の実装のコードは失敗しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-160">Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="3aaf9-161">ガベージコレクターは、同時にガベージコレクションされたオブジェクトに対して通常のファイナライザーが実行された後に <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> を呼び出し、リソースが呼び出しを行うことと、実行中に中断されないことを保証します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-161">The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</span></span> <span data-ttu-id="3aaf9-162">このメソッドは、インスタンスの構築時に制約された実行領域 (CER) として準備されます (静的な determinable 呼び出しグラフ内のすべてのメソッドと共に)。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-162">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="3aaf9-163">これによってスレッド中止割り込みが発生することはありませんが、オーバーライドされた <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> メソッドにエラーパスを導入しないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-163">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="3aaf9-164">特に、<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>から呼び出すメソッドに <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> 属性を適用します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-164">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="3aaf9-165">ほとんどの場合、このコードは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-165">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="3aaf9-166">また、単純なクリーンアップ (たとえば、ファイルハンドルで Windows API `CloseHandle` を呼び出す) では、単一のプラットフォーム呼び出しの戻り値を確認できます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-166">Additionally, for simple cleanup (for example, calling the Windows API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="3aaf9-167">複雑なクリーンアップでは、多くのプログラムロジックと多くのメソッド呼び出しがあり、その一部が失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-167">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="3aaf9-168">プログラムロジックにそれぞれのケースのフォールバックコードがあることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-168">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="3aaf9-169"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> メソッドが何らかの理由で `false` を返した場合、 [Releasehandlefailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)マネージデバッグアシスタントが生成されます。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-169">If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c"><span data-ttu-id="3aaf9-170">マネージデバッグアシスタントによる実行時エラーの診断</span><span class="sxs-lookup"><span data-stu-id="3aaf9-170">Diagnosing Run-time Errors with Managed Debugging Assistants</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51"><span data-ttu-id="3aaf9-171">ReleaseHandleFailed</span><span class="sxs-lookup"><span data-stu-id="3aaf9-171">ReleaseHandleFailed</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="criticalHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="3aaf9-172">使用する既存のハンドル。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-172">The pre-existing handle to use.</span></span></param>
        <summary><span data-ttu-id="3aaf9-173">ハンドルを指定した既存のハンドルに設定します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-173">Sets the handle to the specified pre-existing handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-174"><xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> メソッドは、既存のハンドルをサポートする必要がある場合にのみ使用します (たとえば、ハンドルが構造体で返された場合)。 .NET Framework COM 相互運用インフラストラクチャは、構造体のマーシャリングハンドルをサポートしていないためです。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-174">Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="criticalHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3aaf9-175">ハンドルを無効としてマークします。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-175">Marks a handle as invalid.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3aaf9-176">ハンドルが無効であることがわかっている場合にのみ <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> メソッドを呼び出し、そのようにマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-176">Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such.</span></span> <span data-ttu-id="3aaf9-177">この操作を行っても、<xref:System.Runtime.InteropServices.CriticalHandle.handle> フィールドの値は変更されません。ハンドルを無効としてマークするだけです。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-177">Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid.</span></span> <span data-ttu-id="3aaf9-178">このハンドルには、古くなった可能性のある値が含まれている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-178">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="3aaf9-179">この呼び出しの結果として、リソースの解放は行われません。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-179">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="3aaf9-180"><xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> メソッドと同様に、既存のハンドルをサポートする必要がある場合にのみ、<xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="3aaf9-180">As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
