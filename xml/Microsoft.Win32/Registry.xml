<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="074d550818e79a9ebb2757227e72df0cd562c0da" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77231539" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows レジストリのルート キーを表す <see cref="T:Microsoft.Win32.RegistryKey" /> オブジェクト、およびキー/値ペアにアクセスするための <see langword="static" /> メソッドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスは、Windows を実行しているコンピューターのレジストリに存在する標準のルートキーのセットを提供します。 レジストリは、アプリケーション、ユーザー、および既定のシステム設定に関する情報を格納するための記憶域機能です。 たとえば、アプリケーションは、アプリケーションの終了後に保存する必要がある情報を格納するためにレジストリを使用し、アプリケーションの再読み込み時に同じ情報にアクセスすることができます。 たとえば、色の設定、画面の位置、またはウィンドウのサイズを格納できます。 レジストリの別の場所に情報を保存することで、ユーザーごとにこのデータを制御できます。  
  
 `Registry` クラスによって公開される基本またはルート <xref:Microsoft.Win32.RegistryKey> インスタンスは、レジストリ内のサブキーと値の基本的なストレージ機構を表します。 レジストリはその存在に依存しているため、すべてのキーが読み取り専用です。 `Registry` によって公開されるキーは次のとおりです。  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 ユーザー設定に関する情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 ローカルコンピューターの構成情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 型 (およびクラス) とそのプロパティに関する情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.Users>  
 既定のユーザー構成に関する情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 ソフトウェアコンポーネントのパフォーマンス情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 では、ユーザー固有ではないハードウェア情報が保存されます。  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 動的データを格納します。  
  
 レジストリから情報を格納または取得するルートキーを特定したら、<xref:Microsoft.Win32.RegistryKey> クラスを使用して、サブキーを追加または削除したり、特定のキーの値を操作したりすることができます。  
  
 ハードウェアデバイスは、プラグアンドプレイインターフェイスを使用して、レジストリに情報を自動的に配置できます。 デバイスドライバーをインストールするためのソフトウェアでは、標準 Api に書き込むことによってレジストリに情報を配置できます。  
  
## <a name="static-methods-for-getting-and-setting-values"></a>値を取得および設定するための静的メソッド  
 .NET Framework バージョン2.0 では、<xref:Microsoft.Win32.Registry> クラスには、レジストリキーから値を設定および取得するための `static`<xref:Microsoft.Win32.Registry.GetValue%2A> および <xref:Microsoft.Win32.Registry.SetValue%2A> メソッドも含まれています。 これらのメソッドは、使用されるたびにレジストリキーを開いて閉じます。そのため、多数の値にアクセスするときに、これらのメソッドは、<xref:Microsoft.Win32.RegistryKey> クラスの同様のメソッドを実行しません。  
  
 <xref:Microsoft.Win32.RegistryKey> クラスには、レジストリキーの Windows アクセス制御セキュリティを設定したり、値のデータ型を取得する前にテストしたり、キーを削除したりできるメソッドも用意されています。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例は、ルートキーを示しています。2番目の例では、`static`<xref:Microsoft.Win32.Registry.GetValue%2A> メソッドと <xref:Microsoft.Win32.Registry.SetValue%2A> メソッドを示しています。  
  
 例 1  
  
 次のコード例は、HKEY_USERS キーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、`RegistryKey` で他の操作を使用してそのキーを操作できます。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 例 2  
  
 次のコード例では、複数のデータ型の値を例のキーに格納し、そのようなキーを作成して、値を取得して表示します。 この例では、既定の (名前のない) 名前と値のペアを格納して取得する方法と、名前と値のペアが存在しない場合に `defaultValue` を使用する方法を示します。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドキュメントの型 (またはクラス) と、これらの型に関連付けられるプロパティを定義します。 このフィールドには、Windows レジストリの基本キー HKEY_CLASSES_ROOT が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 従来のアプリケーションと OLE アプリケーションは、このキーの下に格納されているデータを使用します。 このキーは、DDE および OLE サポートの情報を格納することで、Windows 3.1 登録データベースとの下位互換性も提供します。 ファイルビューアーとユーザーインターフェイス拡張では、OLE クラス識別子がこのキーに格納され、処理サーバーはこのキーに登録されます。  
  
   
  
## Examples  
 次の例は、このキーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、<xref:Microsoft.Win32.RegistryKey> で他の操作を使用してそのキーを操作できます。  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>各ユーザーに共通のハードウェアに関する構成情報を格納します。 このフィールドには、Windows レジストリの基本キー HKEY_CURRENT_CONFIG が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは <xref:Microsoft.Win32.Registry.LocalMachine>内のサブキーにマップされます。  
  
 このメンバーを使用する例として、システムがネットワークに接続されているかどうかによって、データに異なるサーバー名を格納するアプリケーションがあります。  
  
   
  
## Examples  
 次の例は、このキーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、<xref:Microsoft.Win32.RegistryKey> で他の操作を使用してそのキーを操作できます。  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザー設定に関する情報が格納されます。 このフィールドには、Windows レジストリの基本キー HKEY_CURRENT_USER が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このキーに格納される情報には、環境変数の設定と、プログラムグループ、色、プリンター、ネットワーク接続、およびアプリケーションの設定に関するデータが含まれます。 このキーを使用すると、現在のユーザーの設定を簡単に設定できます。 このキーでは、ソフトウェアベンダーは、アプリケーション内で使用される現在のユーザー固有の設定を格納します。 たとえば、microsoft では、アプリケーションが使用するアプリケーションの HKEY_CURRENT_USER \Software\Microsoft キーを作成し、各アプリケーションで Microsoft キーの下に独自のサブキーを作成します。  
  
   
  
## Examples  
 次の例は、このキーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、<xref:Microsoft.Win32.RegistryKey> で他の操作を使用してそのキーを操作できます。  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的レジストリ データを格納します。 このフィールドには、Windows レジストリの基本キー HKEY_DYN_DATA が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 98/Windows Me レジストリは、(レジストリのディスクに格納されている) 静的データと動的データ (パフォーマンス統計などの頻繁な変更) の両方をサポートしています。 この動的データ領域は、仮想デバイスドライバー (Vxd) が、リモートおよびローカルで実行できる Win32 アプリケーションにリアルタイムのデータを提供できるようにするメカニズムです。 また、システムモニターは、リモートの Windows 98/Windows Me システムに関するパフォーマンスの統計情報を提供することもできます。  
  
 Vxd は、パフォーマンスデータに限定されません。 CPU を占有することなく、リング0からリング3に効率的に渡す必要があるすべてのデータを提供できます。 レジストリは、値 (または多くの値) を返す関数へのポインターを格納することによって、動的データをサポートします。 レジストリ呼び出しによって動的キーに関連付けられた値が照会されると、その関数が呼び出され、目的の値が返されます。  
  
> [!NOTE]
>  動的キーは、動的なレジストリデータを処理するために Microsoft Windows 95 で導入されました。 Windows 98/Windows Me でのみサポートされています。  
  
   
  
## Examples  
 次の例は、このキーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、<xref:Microsoft.Win32.RegistryKey> で他の操作を使用してそのキーを操作できます。 この例では、動的データが使用できない可能性があるため、または Windows 98/ME を実行していない可能性があるため、結果が返されないことに注意してください。 このキーを使用すると、他のシステムでエラーが発生する可能性があります。  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">そのオペレーティング システムは動的データをサポートしていません。つまり、それは Windows 98、Windows 98 Second Edition、または Windows Millennium Edition (Windows Me) ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">有効なレジストリ ルート ("HKEY_CURRENT_USER" など) から始まるキーの完全なレジストリ パス。</param>
        <param name="valueName">名前/値ペアの名前。</param>
        <param name="defaultValue"><paramref name="valueName" /> が存在しない場合に返す値。</param>
        <summary>指定したレジストリ キーに含まれる、指定した名前に関連付けられた値を取得します。 指定したキーに該当する名前が見つからない場合は、設定している既定値が返されます。指定したキーが存在しない場合は、<see langword="null" /> が返されます。</summary>
        <returns><see langword="null" /> で指定したサブキーが存在しない場合は、<paramref name="keyName" />。それ以外の場合は、<paramref name="valueName" /> に関連付けられた値。<paramref name="defaultValue" /> が見つからない場合は、<paramref name="valueName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列 `valueName` では、大文字と小文字は区別されません。  
  
> [!NOTE]
>  レジストリキーには、どの名前にも関連付けられていない1つの値を含めることができます。 この名前のない値がレジストリエディターに表示されると、名前の代わりに "(既定値)" という文字列が表示されます。 この名前のない値を取得するには、`valueName`に `null` または空の文字列 ("") を指定します。  
  
 有効なルート名は、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG、および HKEY_DYN_DATA です。 たとえば Visual Basic 文字列 "HKEY_CURRENT_USER \MyTestKey" は、HKEY_CURRENT_USER ルート内のサブキー "MyTestKey" のキーと値のペアにアクセスします。  
  
 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> メソッドが展開可能な文字列値 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) を取得すると、ローカル環境のデータを使用して環境文字列が拡張されます。 展開可能な文字列 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) ではなく、環境変数への展開可能な参照を含む値が文字列 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>) として格納されている場合、<xref:Microsoft.Win32.RegistryKey.GetValue%2A> では展開されません。 <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、このような文字列を取得した後に展開できます。  
  
> [!NOTE]
>  HKEY_PERFORMANCE_DATA からデータを取得するには、<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> メソッドではなく <xref:System.Diagnostics.PerformanceCounter> クラスを使用することをお勧めします。  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A> メソッドと <xref:Microsoft.Win32.Registry.SetValue%2A> メソッドは、使用されるたびにレジストリキーを開いて閉じます。そのため、多数の値にアクセスした場合は、<xref:Microsoft.Win32.RegistryKey> クラスのメソッドと同様に実行されません。  
  
 また <xref:Microsoft.Win32.RegistryKey> には、レジストリキーにアクセス制御リスト (ACL) を追加したり、値のデータ型を取得する前にテストしたり、キーを削除したりできるメソッドも用意されています。  
  
   
  
## Examples  
 次のコード例では、複数のデータ型の値を例のキーに格納し、そのようなキーを作成して、値を取得して表示します。 この例では、既定の (名前のない) 名前と値のペアを格納して取得する方法と、名前と値のペアが存在しない場合に `defaultValue` を使用する方法を示します。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">ユーザーに、レジストリ キーからの読み取りに必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">指定された値を格納する <see cref="T:Microsoft.Win32.RegistryKey" /> は、削除対象としてマークされています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> が有効なレジストリ ルートから始まっていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル コンピューターの構成データが格納されます。 このフィールドには、Windows レジストリの基本キー HKEY_LOCAL_MACHINE が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` には、次の5つのキーが含まれます。  
  
 ハードウェア  
 コンピューターの物理ハードウェア、デバイスドライバーがそのハードウェアを使用する方法、およびカーネルモードドライバーとユーザーモードコードをリンクするマッピングと関連データについて説明します。 このキーのすべてのデータは、システムが起動されるたびに再作成されます。 Description サブキーには、実際のコンピューターハードウェアが記述されています。 DeviceMap サブキーには、特定のクラスのドライバーに固有の形式のその他のデータが含まれています。 ResourceMap サブキーは、どのデバイスドライバがどのハードウェアリソースを要求するかを示します。 Windows NT 診断プログラム (Winmsdp .exe) は、読みやすい形式でコンテンツを報告できます。  
  
 SAM  
 ユーザーアカウントとグループアカウントのセキュリティ情報のディレクトリサービスデータベース、および Windows 2000 Server のドメイン (SAM は、ディレクトリサービスデータベースと呼ばれるセキュリティアカウントマネージャー) です。  
  
 セキュリティ  
 特定のユーザー権限などのローカルセキュリティポリシーが含まれます。 このキーは、Windows 2000 セキュリティサブシステムでのみ使用されます。  
  
 ソフトウェア  
 コンピューターごとのソフトウェアデータベース。 このキーには、ローカルコンピューターにインストールされているソフトウェアに関するデータと、その他の構成データのさまざまな項目が含まれます。  
  
 System  
 システムのスタートアップ、デバイスドライバーの読み込み、Windows 2000 サービス、およびオペレーティングシステムの動作を制御します。  
  
 規則により、<xref:Microsoft.Win32.Registry.CurrentUser> の下に類似データが存在し、<xref:Microsoft.Win32.Registry.LocalMachine>の下にある場合、<xref:Microsoft.Win32.Registry.CurrentUser> 内のデータが優先されます。 ただし、このキーの値は、レジストリ内のデータを (置き換えるのではなく) 拡張することもできます。 また、一部の項目 (デバイスドライバーの読み込みエントリなど) は、レジストリの外部で発生した場合は無意味です。  
  
   
  
## Examples  
 次の例は、このキーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、<xref:Microsoft.Win32.RegistryKey> で他の操作を使用してそのキーを操作できます。  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソフトウェア コンポーネントのパフォーマンス情報が含まれます。 このフィールドには、Windows レジストリの基本キー HKEY_PERFORMANCE_DATA が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各ソフトウェアコンポーネントは、オブジェクトのキー、インストールされたカウンターを作成し、実行中にカウンターデータを書き込みます。 <xref:Microsoft.Win32.RegistryKey> 関数を使用して、他のレジストリデータにアクセスする場合と同様に、このデータにアクセスできます。  
  
 レジストリを使用してパフォーマンスデータを収集する場合でも、データはレジストリデータベースに格納されません。 代わりに、このキーを使用してレジストリにアクセスすると、システムによって、適切なシステムオブジェクトマネージャーからデータが収集されます。  
  
 ローカルシステムからパフォーマンスデータを取得するには、<xref:Microsoft.Win32.RegistryKey.GetValue%2A> メソッドを使用して、レジストリの... を使用します。 最初の呼び出しでは、キーが開きます (最初にキーを明示的に開く必要はありません)。 ただし、パフォーマンスデータの取得が完了したら、<xref:Microsoft.Win32.RegistryKey.Close%2A> メソッドを使用してキーへのハンドルを閉じるようにしてください。 ユーザーは、パフォーマンスデータの使用中にソフトウェアコンポーネントをインストールまたは削除することはできません。  
  
 リモートシステムからパフォーマンスデータを取得するには、<xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> メソッドを使用する必要があります。この方法では、リモートシステムのコンピューター名と、を使用する必要があります。 この呼び出しは、リモートシステムのパフォーマンスデータを表すキーを取得します。 データを取得するには、このキーを使用して <xref:Microsoft.Win32.RegistryKey.GetValue%2A> を呼び出します。このキーは、レジストリの.......  
  
> [!NOTE]
>  Windows Server 2003 では、ユーザーがこの基本キーのサブキーにアクセスするには、少なくとも Performance Monitor Users グループに属している必要があります。  
  
   
  
## Examples  
 次の例は、このキーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、<xref:Microsoft.Win32.RegistryKey> で他の操作を使用してそのキーを操作できます。 この例では、パフォーマンスデータが存在しない可能性があるため、多くの場合、結果が返されないことに注意してください。  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>レジストリ キーに名前/値ペアの値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、複数のデータ型の値を例のキーに格納し、そのようなキーを作成して、値を取得して表示します。 この例では、既定の (名前のない) 名前と値のペアを格納して取得する方法と、名前と値のペアが存在しない場合に `defaultValue` を使用する方法を示します。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">有効なレジストリ ルート ("HKEY_CURRENT_USER" など) から始まるキーの完全なレジストリ パス。</param>
        <param name="valueName">名前/値ペアの名前。</param>
        <param name="value">格納される値。</param>
        <summary>指定したレジストリ キーに、指定した名前/値ペアを設定します。 指定したキーが存在しない場合は、キーが作成されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、`valueName` パラメーターは最大255文字に制限されなくなりました。ただし、`keyName` パラメーターには引き続き255文字の制限があります。  
  
 レジストリ内の各キーには多くの値を格納できるため、`valueName` パラメーターを使用して、設定する特定の値を指定する必要があります。  
  
> [!NOTE]
>  レジストリキーには、どの名前にも関連付けられていない1つの値を含めることができます。 この名前のない値がレジストリエディターに表示されると、名前の代わりに "(既定値)" という文字列が表示されます。 この名前のない値を設定するには、`valueName`に `null` または空の文字列 ("") を指定します。  
  
 キーに `valueName` が存在しない場合は、作成され、関連付けられている値は `value`に設定されます。  
  
 `keyName` が存在しないサブキーを指定した場合は、指定されたルートにサブキーが作成されます。 たとえば Visual Basic 文字列 "HKEY_CURRENT_USER \MyTestKey" では、HKEY_CURRENT_USER ルートにサブキー "MyTestKey" が作成されます。 "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" という文字列は、入れ子になったサブキー "MyTestKey"、"MyTestKey\Key2"、および "MyTestKey\Key2\Key3" を作成します。  
  
 有効なルート名には、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG、HKEY_DYN_DATA があります。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> メソッドは、レジストリキーを開き、値を設定して、呼び出されるたびにキーを閉じます。 多くの値を変更する必要がある場合は、<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法でパフォーマンスが向上する可能性があります。 <xref:Microsoft.Win32.RegistryKey> クラスには、レジストリキーにアクセス制御リスト (ACL) を追加したり、値のデータ型を取得する前にテストしたり、キーを削除したりできるメソッドも用意されています。  
  
 この <xref:Microsoft.Win32.Registry.SetValue%2A> のオーバーロードでは、64ビットの整数が文字列 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>) として格納されます。 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> 値として64ビット数値を格納するには、<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> メソッドオーバーロードを使用します。  
  
 <xref:Microsoft.Win32.Registry.SetValue%2A> のこのオーバーロードは、環境変数への展開可能な参照が含まれている場合でも、すべての文字列値を <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> オブジェクトとして格納します。 文字列値を展開可能な文字列 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) として保存するには、<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> メソッドオーバーロードを使用します。  
  
 このオーバーロードは、<xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>を使用して <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> メソッドのオーバーロードを呼び出すことと同じです。  
  
> [!NOTE]
>  Windows 98 および Windows Millennium Edition (Windows Me) では、レジストリは Unicode ではなく、すべての Unicode 文字がすべてのコードページで有効であるとは限りません。 現在のコードページに対して無効な Unicode 文字が、使用できる最適な一致に置き換えられます。 例外をスローすることはありません。  
  
   
  
## Examples  
 次のコード例では、複数のデータ型の値を例のキーに格納し、そのようなキーを作成して、値を取得して表示します。 この例では、既定の (名前のない) 名前と値のペアを格納して取得する方法と、名前と値のペアが存在しない場合に `defaultValue` を使用する方法を示します。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> が有効なレジストリ ルートから始まっていません。  
  
または 
 <paramref name="keyName" /> が許容される最大長 (255 文字) を超えています。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> が読み取り専用であるため、このキーに書き込むことはできません。たとえば、ルートレベル ノードの場合などです。</exception>
        <exception cref="T:System.Security.SecurityException">ユーザーに、レジストリ キーの作成または変更に必要なアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">有効なレジストリ ルート ("HKEY_CURRENT_USER" など) から始まるキーの完全なレジストリ パス。</param>
        <param name="valueName">名前/値ペアの名前。</param>
        <param name="value">格納される値。</param>
        <param name="valueKind">データを格納する際に使用するレジストリ データ型。</param>
        <summary>指定したレジストリ データ型を使用して、指定したレジストリ キーに名前/値ペアを設定します。 指定したキーが存在しない場合は、キーが作成されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、`valueName` パラメーターは最大255文字に制限されなくなりました。ただし、`keyName` パラメーターには255文字の制限があります。  
  
 レジストリ内の各キーには多くの値を格納できるため、`valueName` パラメーターを使用して、設定する特定の値を指定する必要があります。  
  
> [!NOTE]
>  レジストリキーには、どの名前にも関連付けられていない1つの値を含めることができます。 この名前のない値がレジストリエディターに表示されると、名前の代わりに "(既定値)" という文字列が表示されます。 この名前のない値を設定するには、`valueName`に `null` または空の文字列 ("") を指定します。  
  
 キーに `valueName` が存在しない場合は、作成され、関連付けられている値は `value`に設定されます。  
  
 `keyName` が存在しないサブキーを指定した場合は、指定されたルートにサブキーが作成されます。 たとえば Visual Basic 文字列 "HKEY_CURRENT_USER \MyTestKey" では、HKEY_CURRENT_USER ルートにサブキー "MyTestKey" が作成されます。 "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" という文字列は、入れ子になったサブキー "MyTestKey"、"MyTestKey\Key2"、および "MyTestKey\Key2\Key3" を作成します。  
  
 有効なルート名には、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG、HKEY_DYN_DATA があります。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> メソッドは、レジストリキーを開き、値を設定して、呼び出されるたびにキーを閉じます。 多くの値を変更する必要がある場合は、<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法でパフォーマンスが向上する可能性があります。 <xref:Microsoft.Win32.RegistryKey> クラスには、レジストリキーにアクセス制御リスト (ACL) を追加したり、値のデータ型を取得する前にテストしたり、キーを削除したりできるメソッドも用意されています。  
  
 指定した `value` の型が指定した `valueKind`と一致せず、データを変換できない場合は <xref:System.ArgumentException> がスローされます。 たとえば、<xref:System.Int64?displayProperty=nameWithType> を <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>として格納することができますが、その値が <xref:System.Int32?displayProperty=nameWithType>の最大値よりも小さい場合に限られます。 1つの文字列値を <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>として格納することはできません。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> または <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>にボックス化された値が渡された場合、変換はインバリアントカルチャを使用して行われます。  
  
> [!NOTE]
>  Windows 98 および Windows Millennium Edition (Windows Me) では、レジストリは Unicode ではなく、すべての Unicode 文字がすべてのコードページで有効であるとは限りません。 現在のコードページに対して無効な Unicode 文字が、使用できる最適な一致に置き換えられます。 例外をスローすることはありません。  
  
   
  
## Examples  
 次のコード例では、複数のデータ型の値を例のキーに格納し、そのようなキーを作成して、値を取得して表示します。 この例では、既定の (名前のない) 名前と値のペアを格納して取得する方法と、名前と値のペアが存在しない場合に `defaultValue` を使用する方法を示します。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> が有効なレジストリ ルートから始まっていません。  
  
または 
 <paramref name="keyName" /> が許容される最大長 (255 文字) を超えています。  
  
または 
<paramref name="value" /> の型が <paramref name="valueKind" /> で指定したレジストリ データ型と一致しなかったため、データを適切に変換できませんでした。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> が読み取り専用であるため、このキーに書き込むことはできません。ルートレベル ノードの場合や、書き込みアクセスが設定された状態でキーが開かれていない場合などです。</exception>
        <exception cref="T:System.Security.SecurityException">ユーザーに、レジストリ キーの作成または変更に必要なアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のユーザー構成に関する情報を格納します。 このフィールドには、Windows レジストリの基本キー HKEY_USERS が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このキーには、コンピューターの各ユーザーのブランチが含まれています。 既定の構成は、ローカルコンピューターの新しいユーザーに対して指定され、ユーザーが設定を変更していない場合は、既定の現在のユーザーに対して指定されます。 Windows 98/ME ではレジストリもサポートされているため、アプリケーションは Windows 2000 の場合と同じ方法でユーザー固有の情報にアクセスできます。 各ユーザーの情報は別のファイルに格納され、ローカルまたはネットワークサーバーに保存できます。 Windows 98/ME では、このファイルをユーザーの現在のシステムにコピーして、設定がユーザーとの間でコンピューター間を移動できるようにすることができます。  
  
   
  
## Examples  
 次の例は、このキーのサブキーを取得し、その名前を画面に出力する方法を示しています。 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> メソッドを使用して、対象となる特定のサブキーのインスタンスを作成します。 その後、<xref:Microsoft.Win32.RegistryKey> で他の操作を使用してそのキーを操作できます。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
