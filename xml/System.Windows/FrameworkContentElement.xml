<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4700f4556a8fa99e3cdd57ab8da777390b6879c5" /><Meta Name="ms.sourcegitcommit" Value="9058026d5788c19bed0a767fc52b40a1eac8ebfe" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/24/2019" /><Meta Name="ms.locfileid" Value="72849099" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1fb7d-101"><see cref="T:System.Windows.FrameworkContentElement" /> は、<see cref="T:System.Windows.ContentElement" /> 基底クラスの WPF フレームワーク レベルの実装および拡張です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-101"><see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span></span> <span data-ttu-id="1fb7d-102"><see cref="T:System.Windows.FrameworkContentElement" /> は、補足の入力 API (ツールヒントやコンテキスト メニューなど)、ストーリーボード、データ バインディング用のデータ コンテキスト、スタイルのサポート、および論理ツリーのヘルパー API に関するサポートを追加します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-102"><see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-103"><xref:System.Windows.FrameworkContentElement> は、まだ独自のレンダリング動作を定義していません。実際の <xref:System.Windows.FrameworkContentElement> クラスインスタンスをコードまたはマークアップでインスタンス化することは可能ですが、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] アプリケーション [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]には何も表示されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="1fb7d-104">レンダリングロジックは、コンテンツモデルの一部として <xref:System.Windows.FrameworkContentElement> 子要素を受け取るクラス、または <xref:System.Windows.FrameworkContentElement> 派生クラスで提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="1fb7d-105"><xref:System.Windows.FrameworkContentElement> は、<xref:System.Windows.FrameworkElement>と同じ Api の多くに意図的に似ています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same APIs as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="1fb7d-106"><xref:System.Windows.FrameworkElement> で見つかった Api には、同等の <xref:System.Windows.FrameworkContentElement> がないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-106">Note that certain APIs found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="1fb7d-107"><xref:System.Windows.FrameworkElement> Api のいくつかは、<xref:System.Windows.FrameworkContentElement>に関連しないジオメトリ表現やレイアウトなどの機能のために用意されています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-107">Several of the <xref:System.Windows.FrameworkElement> APIs are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="1fb7d-108">既存の <xref:System.Windows.FrameworkContentElement> 派生クラスの大部分は、<xref:System.Windows.Documents> 名前空間にあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="1fb7d-109">これらの派生クラスの多くは、フロードキュメントモデルの要素を実装しています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="1fb7d-110"><xref:System.Windows.Documents.Hyperlink> などの特定の派生クラスには、コントロールに似た機能がありますが、コントロールのような要素をフロードキュメントモデルに含めることができるように、<xref:System.Windows.FrameworkContentElement> から派生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-111"><see cref="T:System.Windows.FrameworkContentElement" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="1fb7d-112">追加される子要素。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-112">The child element to be added.</span></span></param>
        <summary><span data-ttu-id="1fb7d-113">指定した要素をこの要素の子として追加します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-113">Adds the provided element as a child of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-114">このメソッドは、論理ツリーが別のプロセスによって反復処理されている場合に、例外をスローすることがあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="1fb7d-115">ほとんどの <xref:System.Windows.FrameworkContentElement> 派生クラスは、コンテインメントを担当する専用コレクション (たとえば、<xref:System.Windows.Documents.Span> クラスの <xref:System.Windows.Documents.Span.Inlines%2A>、<xref:System.Windows.Documents.Section> クラスの <xref:System.Windows.Documents.Section.Blocks%2A>) を公開します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="1fb7d-116">通常、これらのクラスから派生する場合、論理ツリーを直接操作する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="1fb7d-117">コンテンツ要素の論理ツリーを使用すると、高度なシナリオとして、特殊化されたパーサー、または親の表示要素 (コンテンツホスト) として機能する特別な <xref:System.Windows.FrameworkElement> が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="1fb7d-118"><xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> と <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>の使用方法の詳細については、「 [WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-119">要素が初期化される前に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-119">Called before an element is initialized.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1fb7d-120">要素の読み込みプロセス中に要素が初期化される前に発生する必要がある特別な処理を提供するには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span></span>  
  
<span data-ttu-id="1fb7d-121">基本 (既定) の実装では初期化を追跡する内部フラグが設定されるため、実装では基本実装を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
<span data-ttu-id="1fb7d-122"><see cref="M:System.Windows.FrameworkContentElement.EndInit" />に達する前に同じ要素で <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> が複数回呼び出された場合、基本実装では例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1fb7d-123">指定したストーリーボードに含まれるアクションのシーケンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-123">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="1fb7d-124">開始するストーリーボード。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-124">The storyboard to begin.</span></span></param>
        <summary><span data-ttu-id="1fb7d-125">指定したストーリーボードに含まれるアクションのシーケンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-125">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-126">`isControllable`、パラメーターを使用しない署名、またはそのパラメーターが `false`指定されている場合、アニメーションに関連付けられているタイムラインクロックは、"塗りつぶし" 期間に達するとすぐに削除されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="1fb7d-127">このため、1回実行した後にアニメーションを再起動することはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="1fb7d-128">アニメーションの制御では、ストーリーボードにコード内のインスタンスとして名前を付けたり、アクセスしたりする必要があることにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="1fb7d-129">開始するストーリーボード。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-129">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="1fb7d-130">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙値。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span></span></param>
        <summary><span data-ttu-id="1fb7d-131">プロパティが既にアニメーション化されていた場合に行う処理を指定するオプションを使用して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-132">`isControllable`、パラメーターを使用しない署名、またはそのパラメーターが `false`指定されている場合、アニメーションに関連付けられているタイムラインクロックは、"塗りつぶし" 期間に達するとすぐに削除されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="1fb7d-133">このため、1回実行した後にアニメーションを再起動することはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="1fb7d-134">アニメーションの制御では、ストーリーボードにコード内のインスタンスとして名前を付けたり、アクセスしたりする必要があることにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="1fb7d-135">作成 HandoffBehavior の使用</span><span class="sxs-lookup"><span data-stu-id="1fb7d-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="1fb7d-136"><xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>を使用して <xref:System.Windows.Media.Animation.Storyboard>、<xref:System.Windows.Media.Animation.AnimationTimeline>、または <xref:System.Windows.Media.Animation.AnimationClock> をプロパティに適用すると、そのプロパティに以前関連付けられていたすべての <xref:System.Windows.Media.Animation.Clock> オブジェクトが引き続きシステムリソースを消費します。タイミングシステムは、クロックを自動的に削除しません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="1fb7d-137"><xref:System.Windows.Media.Animation.HandoffBehavior.Compose>を使用して多数のクロックを適用するときのパフォーマンスの問題を回避するには、アニメーション化されたプロパティから完成したクロックを削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="1fb7d-138">クロックを削除するには、いくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="1fb7d-139">プロパティからすべてのクロックを削除するには、アニメーション化されたオブジェクトの <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> または <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="1fb7d-140">最初のパラメーターとしてアニメーション化するプロパティを指定し、2番目のパラメーターとして `null` します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="1fb7d-141">これにより、プロパティからすべてのアニメーションクロックが削除されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="1fb7d-142">特定の <xref:System.Windows.Media.Animation.AnimationClock> をクロックの一覧から削除するには、<xref:System.Windows.Media.Animation.AnimationClock> の <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティを使用して <xref:System.Windows.Media.Animation.ClockController>を取得し、次に <xref:System.Windows.Media.Animation.ClockController.Remove%2A> の <xref:System.Windows.Media.Animation.ClockController>メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="1fb7d-143">これは通常、クロックの <xref:System.Windows.Media.Animation.Clock.Completed> イベントハンドラーで実行されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="1fb7d-144"><xref:System.Windows.Media.Animation.ClockController>によって制御できるのはルートクロックのみであることに注意してください。子クロックの <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="1fb7d-145">また、クロックの有効期間が無期限の場合は、<xref:System.Windows.Media.Animation.Clock.Completed> イベントが発生しないことにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="1fb7d-146">その場合、ユーザーは <xref:System.Windows.Media.Animation.ClockController.Remove%2A> を呼び出すタイミングを決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="1fb7d-147">これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="1fb7d-148">オブジェクトがガベージコレクションされると、そのクロックも切断され、ガベージコレクトされます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="1fb7d-149">クロックオブジェクトの詳細については、「[アニメーションとタイミングシステムの概要](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-149">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="1fb7d-150">開始するストーリーボード。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-150">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="1fb7d-151">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する、動作を表す列挙型の値。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span></span></param>
        <param name="isControllable"><span data-ttu-id="1fb7d-152">アニメーションを起動した後に、アニメーションを制御できるかどうか (一時停止できるかどうか) を宣言します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-152">Declares whether the animation is controllable (can be paused) after it is started.</span></span></param>
        <summary><span data-ttu-id="1fb7d-153">開始後のアニメーションの制御の状態を指定して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-154">`isControllable`、パラメーターを使用しない署名、またはそのパラメーターが `false`指定されている場合、アニメーションに関連付けられているタイムラインクロックは、"塗りつぶし" 期間に達するとすぐに削除されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="1fb7d-155">このため、1回実行した後にアニメーションを再起動することはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="1fb7d-156">アニメーションの制御では、ストーリーボードにコード内のインスタンスとして名前を付けたり、アクセスしたりする必要があることにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="1fb7d-157">作成 HandoffBehavior の使用</span><span class="sxs-lookup"><span data-stu-id="1fb7d-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="1fb7d-158"><xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>を使用して <xref:System.Windows.Media.Animation.Storyboard>、<xref:System.Windows.Media.Animation.AnimationTimeline>、または <xref:System.Windows.Media.Animation.AnimationClock> をプロパティに適用すると、そのプロパティに以前関連付けられていたすべての <xref:System.Windows.Media.Animation.Clock> オブジェクトが引き続きシステムリソースを消費します。タイミングシステムでは、これらのクロックは自動的に削除されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="1fb7d-159"><xref:System.Windows.Media.Animation.HandoffBehavior.Compose>を使用して多数のクロックを適用するときのパフォーマンスの問題を回避するには、アニメーション化されたプロパティから完成したクロックを削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="1fb7d-160">クロックを削除するには、いくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="1fb7d-161">プロパティからすべてのクロックを削除するには、アニメーション化されたオブジェクトの <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> または <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="1fb7d-162">最初のパラメーターとしてアニメーション化するプロパティを指定し、2番目のパラメーターとして `null` します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="1fb7d-163">これにより、プロパティからすべてのアニメーションクロックが削除されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="1fb7d-164">特定の <xref:System.Windows.Media.Animation.AnimationClock> をクロックの一覧から削除するには、<xref:System.Windows.Media.Animation.AnimationClock> の <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティを使用して <xref:System.Windows.Media.Animation.ClockController>を取得し、次に <xref:System.Windows.Media.Animation.ClockController.Remove%2A> の <xref:System.Windows.Media.Animation.ClockController>メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="1fb7d-165">これは通常、クロックの <xref:System.Windows.Media.Animation.Clock.Completed> イベントハンドラーで実行されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="1fb7d-166"><xref:System.Windows.Media.Animation.ClockController>によって制御できるのはルートクロックのみであることに注意してください。子クロックの <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="1fb7d-167">また、クロックの有効期間が無期限の場合は、<xref:System.Windows.Media.Animation.Clock.Completed> イベントが発生しないことにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="1fb7d-168">その場合、ユーザーは <xref:System.Windows.Media.Animation.ClockController.Remove%2A> を呼び出すタイミングを決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="1fb7d-169">これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="1fb7d-170">オブジェクトがガベージコレクションされると、そのクロックも切断され、ガベージコレクトされます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="1fb7d-171">クロックオブジェクトの詳細については、「[アニメーションとタイミングシステムの概要](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-171">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-172">要素に使用される <see cref="T:System.Windows.Data.BindingGroup" /> を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-173">要素に使用される <see cref="T:System.Windows.Data.BindingGroup" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-174"><xref:System.Windows.Data.BindingGroup> を使用すると、オブジェクトの複数のプロパティの値を検証できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="1fb7d-175">たとえば、ユーザーにアドレスを入力するように求めるメッセージが表示され、`Address`型のオブジェクトが設定されているとします。このオブジェクトには、`Street`、`City`、`ZipCode`、`Country`というプロパティがユーザーが指定した値と共に格納されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="1fb7d-176">このアプリケーションには、4つの <xref:System.Windows.Controls.TextBox> コントロールを含むパネルがあり、それぞれがオブジェクトのプロパティの1つにバインドされています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object's properties.</span></span> <span data-ttu-id="1fb7d-177"><xref:System.Windows.Data.BindingGroup> 内の <xref:System.Windows.Controls.ValidationRule> を使用して、`Address` オブジェクトを検証できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="1fb7d-178">たとえば、<xref:System.Windows.Controls.ValidationRule> は、住所の国/地域に対して郵便番号が有効であることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country/region of the address.</span></span>  
  
 <span data-ttu-id="1fb7d-179">子要素は、他の継承可能なプロパティと同様に、親要素から <xref:System.Windows.Data.BindingGroup> を継承します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-180">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-181">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="1fb7d-182">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-182">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-183"><see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-184">この要素が含まれているスクロール可能な領域内に、この要素を表示することを試みます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-185">このメソッドを呼び出すことにより、要素を含む任意の親のスクロール可能な領域で <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> を呼び出すことができます (親は <xref:System.Windows.FrameworkContentElement>ではなく <xref:System.Windows.FrameworkElement>である可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="1fb7d-186">この要素がスクロール可能な領域に含まれていない場合でも、イベントは発生しますが、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)"><span data-ttu-id="1fb7d-187">方法: ScrollViewer を作成する</span><span class="sxs-lookup"><span data-stu-id="1fb7d-187">How to: Create a ScrollViewer</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-188">この要素内から[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] によってコンテキスト メニューが要求された場合に常に表示されるコンテキスト メニュー要素を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-188">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-189">この要素が使用するコンテキスト メニュー。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-189">The context menu that this element uses.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-190">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-190">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-191">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-191">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="1fb7d-192">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-192">Metadata properties set to `true`</span></span>|<span data-ttu-id="1fb7d-193">なし</span><span class="sxs-lookup"><span data-stu-id="1fb7d-193">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-194">次の例では、<xref:System.Windows.Documents.Paragraph>に <xref:System.Windows.Controls.ContextMenu> を配置します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-194">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-195">要素のコンテキスト メニューが閉じる直前に発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-195">Occurs just before any context menu on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-196">コンテキストメニューを終了しないようにするには、イベントのハンドラーがそれを処理済みとしてマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-196">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="1fb7d-197">このイベントをスタイルの <xref:System.Windows.EventTrigger> として使用するには、基になるサービスイベント識別子を参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-197">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="1fb7d-198">(この使用方法が必要なのは、基になるサービスイベントを公開する <xref:System.Windows.FrameworkContentElement> のイベント実装が、トリガーで使用する <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> 識別子を正しくマップしていないためです)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-198">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="1fb7d-199">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-199">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-200">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-200">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="1fb7d-201">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-201">Routing strategy</span></span>|<span data-ttu-id="1fb7d-202">バブリング</span><span class="sxs-lookup"><span data-stu-id="1fb7d-202">Bubbling</span></span>|  
|<span data-ttu-id="1fb7d-203">Delegate</span><span class="sxs-lookup"><span data-stu-id="1fb7d-203">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-204">次の例では、`DisplayArea` (表示されていない) 名前付き領域の上にカーソルを変更するハンドラーを実装しています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-204">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="1fb7d-205">コメントヒントは <xref:System.Windows.UIElement> 使用されますが、実際には、`DisplayArea` が <xref:System.Windows.FrameworkContentElement>の場合、このサンプルは同じになります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-205">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-206"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> ([Routed Events Overview (ルーティング イベントの概要)](~/docs/framework/wpf/advanced/routed-events-overview.md)) を識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-206">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-207">イベント識別子オブジェクトは、ルーティングイベントが登録されたときに作成され (<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照)、クラスハンドラーを追加するために使用できます (「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-207">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="1fb7d-208">識別子オブジェクトには、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-208">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-209">要素のコンテキスト メニューが開くときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-209">Occurs when any context menu on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-210">コンテキストメニューを手動で開くには、イベントのハンドラーが関連するイベントを処理済みとしてマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-210">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="1fb7d-211">それ以外の場合は、[<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>] プロパティの既存の値を使用して、ショートカットメニューが自動的に開きます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-211">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="1fb7d-212">イベントを処理済みとしてマークすると、既定のアクションが実質的にキャンセルされます。また、<xref:System.Windows.FrameworkContentElement.ContextMenu%2A> プロパティの値をリセットし、新しい <xref:System.Windows.Controls.ContextMenu>を開くことができます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-212">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="1fb7d-213">ただし、タイミングの問題に注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-213">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="1fb7d-214">コンテキストメニューを <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> ハンドラーで完全に置き換えるには、最初のコンテキストメニューを null または空にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-214">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="1fb7d-215">または、イベントを処理し、新しいコンテキストメニューを手動で開く必要がある場合もあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-215">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="1fb7d-216">詳細については、「[方法: ContextMenuOpening イベント](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)を処理します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-216">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="1fb7d-217">このイベントをスタイルの <xref:System.Windows.EventTrigger> として使用するには、基になるサービスイベント識別子を参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-217">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="1fb7d-218">(この使用方法が必要なのは、基になるサービスイベントを公開する <xref:System.Windows.FrameworkContentElement> のイベント実装が、トリガーで使用する <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> 識別子を正しくマップしていないためです)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-218">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="1fb7d-219">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-219">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-220">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-220">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="1fb7d-221">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-221">Routing strategy</span></span>|<span data-ttu-id="1fb7d-222">バブリング</span><span class="sxs-lookup"><span data-stu-id="1fb7d-222">Bubbling</span></span>|  
|<span data-ttu-id="1fb7d-223">Delegate</span><span class="sxs-lookup"><span data-stu-id="1fb7d-223">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-224"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> ([Routed Events Overview (ルーティング イベントの概要)](~/docs/framework/wpf/advanced/routed-events-overview.md)) を識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-224">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-225">イベント識別子オブジェクトは、ルーティングイベントが登録されたときに作成され (<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照)、クラスハンドラーを追加するために使用できます (「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-225">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="1fb7d-226">識別子オブジェクトには、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-226">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-227"><see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-227">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-228">この要素上にマウス ポインターが置かれたときに表示されるカーソルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-228">Gets or sets the cursor that displays when the mouse pointer is over this element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-229">表示対象のカーソル。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-229">The cursor to display.</span></span> <span data-ttu-id="1fb7d-230">既定値はこの依存関係プロパティごとに <see langword="null" /> として定義されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-230">The default value is defined as <see langword="null" /> per this dependency property.</span></span> <span data-ttu-id="1fb7d-231">ただし、実行時における実用的な既定値は、さまざまな要因から取得されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-231">However, the practical default at run time will come from a variety of factors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-232">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]でこのプロパティを設定する場合、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] プロセッサは <xref:System.Windows.Input.Cursor> クラスの型変換に依存して文字列を評価します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-232">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="1fb7d-233">指定された文字列は、<xref:System.Windows.Input.CursorType> 値に評価される必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-233">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="1fb7d-234">詳細については、「<xref:System.Windows.Input.Cursor>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-234">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="1fb7d-235">このプロパティによって確立されたカーソルは、マウスポインターがこの要素の上にあるときに表示されるかどうかは、<xref:System.Windows.FrameworkContentElement.ForceCursor%2A> プロパティの値にも依存します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-235">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="1fb7d-236">また、アクティブなドラッグ、マウスのキャプチャ、コントロール内のテキスト編集モードなどのイベント関連の考慮事項は、このプロパティで指定した値よりも優先順位の高いカーソルにも影響します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-236">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="1fb7d-237">このプロパティを最終的な既定値に設定する動作を元に戻すには、再度 `null` に設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-237">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="1fb7d-238">`null` の既定値は、実際のカーソル値の決定がここで遅延され、他の場所から取得する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-238">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="1fb7d-239">任意のソースからプログラム的な値が指定されていない場合、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] アプリケーション上の既定のカーソルは矢印になります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-239">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="1fb7d-240">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] アプリケーションにマウスを移動するたびに、<xref:System.Windows.ContentElement.QueryCursor> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-240">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="1fb7d-241">イベントのバブルと、ルートにあるすべての要素には、イベントを処理し、このイベントの引数を使用してカーソルの値を設定する機会があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-241">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="1fb7d-242">その場合、<xref:System.Windows.FrameworkContentElement.ForceCursor%2A> が設定されていない限り、イベントが処理され、引数の値が変更されたという事実が、<xref:System.Windows.FrameworkContentElement.Cursor%2A> プロパティの値よりも優先されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-242">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="1fb7d-243">カスタムカーソルを作成しない場合は、通常、このプロパティを <xref:System.Windows.Input.Cursors> クラスの静的なプロパティ値に設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-243">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="1fb7d-244">部分信頼では、<xref:System.Windows.Input.Cursor> をカスタム値に設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-244">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="1fb7d-245">カスタムカーソルの詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-245">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-246">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-246">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-247">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-247">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="1fb7d-248">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-248">Metadata properties set to `true`</span></span>|<span data-ttu-id="1fb7d-249">なし</span><span class="sxs-lookup"><span data-stu-id="1fb7d-249">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-250">次の例では、カーソルをカスタム値に設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-250">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-251"><see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-251">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-252">要素がデータ バインディングに含まれている場合に、その要素のデータ コンテキストを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-252">Gets or sets the data context for an element when it participates in data binding.</span></span></summary>
        <value><span data-ttu-id="1fb7d-253">データ コンテキストとして使用するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-253">The object to use as data context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-254">*データコンテキスト*は、バインドに使用されるバインディングソースと、パスなどのバインディングのその他の特性について、要素が親要素から情報を継承できるようにする概念です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-254">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="1fb7d-255">データコンテキストは、そのオブジェクトのプロパティを評価するバインディングを使用して、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] オブジェクトに直接設定できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-255">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="1fb7d-256">または、データコンテキストを <xref:System.Windows.Data.DataSourceProvider> オブジェクトに設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-256">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="1fb7d-257">この依存関係プロパティは、プロパティ値を継承します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-257">This dependency property inherits property values.</span></span> <span data-ttu-id="1fb7d-258">ローカル値またはスタイルを使用して <xref:System.Windows.FrameworkContentElement.DataContext%2A> に他の値が設定されていない子要素がある場合、プロパティシステムは、この値が割り当てられている最も近い親要素の <xref:System.Windows.FrameworkContentElement.DataContext%2A> 値になるように値を設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-258">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="1fb7d-259">または、<xref:System.Windows.Data.Binding> クラスの次のいずれかのプロパティを使用して、バインドソースを明示的に指定することもできます。 <xref:System.Windows.Data.Binding.ElementName%2A>、<xref:System.Windows.Data.Binding.Source%2A>、または <xref:System.Windows.Data.Binding.RelativeSource%2A>です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-259">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="1fb7d-260">詳細については、[バインドソース](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)を指定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-260">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="1fb7d-261">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では、通常、<xref:System.Windows.FrameworkContentElement.DataContext%2A> は <xref:System.Windows.Data.Binding> 宣言としてに設定されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-261">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="1fb7d-262">プロパティ要素の構文または属性構文を使用できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-262">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="1fb7d-263">属性の構文については、このページの例を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-263">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="1fb7d-264">コードで <xref:System.Windows.FrameworkContentElement.DataContext%2A> を設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-264">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="1fb7d-265">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="1fb7d-265">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="1fb7d-266">XAML 属性の使用方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-266">XAML Attribute Usage</span></span>  
  
```xaml
<object DataContext="bindingUsage"/>  
```

<span data-ttu-id="1fb7d-267">- または -</span><span class="sxs-lookup"><span data-stu-id="1fb7d-267">-or-</span></span>

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```

<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="1fb7d-268">XAML 値</span><span class="sxs-lookup"><span data-stu-id="1fb7d-268">XAML Values</span></span>  
 <span data-ttu-id="1fb7d-269">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-269">*dataContextObject*</span></span>  
 <span data-ttu-id="1fb7d-270">親要素内の任意のバインドのデータコンテキストとして機能する直接埋め込まれたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-270">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="1fb7d-271">通常、このオブジェクトは <xref:System.Windows.Data.Binding> または別の <xref:System.Windows.Data.BindingBase> サブクラスです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-271">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="1fb7d-272">また、バインドを意図した [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] オブジェクト型の生データをここに配置し、実際のバインドを後で定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-272">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="1fb7d-273">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-273">*bindingUsage*</span></span>  
 <span data-ttu-id="1fb7d-274">適切なデータコンテキストに評価されるバインディングの使用。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-274">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="1fb7d-275">詳細については、「[バインディングのマークアップ拡張機能](~/docs/framework/wpf/advanced/binding-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-275">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="1fb7d-276">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-276">*resourceExtension*</span></span>  
 <span data-ttu-id="1fb7d-277">次のいずれか: `StaticResource`、または `DynamicResource`。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-277">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="1fb7d-278">この使用法は、リソース内のオブジェクトとして定義された生データを参照するときに使用されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-278">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="1fb7d-279">「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-279">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="1fb7d-280">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-280">*contextResourceKey*</span></span>  
 <span data-ttu-id="1fb7d-281"><xref:System.Windows.ResourceDictionary>内から要求されているオブジェクトのキー識別子。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-281">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-282">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-282">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-283">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-283">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="1fb7d-284">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-284">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-285">次の例では、新しいカスタムデータオブジェクトを作成し、そのオブジェクトを <xref:System.Windows.FrameworkContentElement.DataContext%2A>として確立し、バインドパスをその中のプロパティに設定することによって、<xref:System.Windows.Documents.Paragraph> 要素のバインドを設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-285">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-286">この要素のデータ コンテキストが変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-286">Occurs when this element's data context changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-287">データコンテキストとデータバインディングの詳細については、「[データバインディングの概要](~/docs/framework/wpf/data/data-binding-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-287">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1fb7d-288">要素の <xref:System.Windows.FrameworkContentElement.DataContext%2A> が変更されると、この要素のすべてのデータバインドプロパティが影響を受ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-288">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="1fb7d-289">これは、現在の要素の子孫要素であるすべての要素 (データコンテキストを継承する) と、現在の要素自体に適用されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-289">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="1fb7d-290">このようなバインディングでは、新しい <xref:System.Windows.FrameworkContentElement.DataContext%2A> が再解釈され、バインドの新しい値が反映されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-290">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="1fb7d-291">これらの変更の順序については、<xref:System.Windows.FrameworkContentElement.DataContextChanged> イベントの発生に対する保証はありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-291">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="1fb7d-292">変更は、イベントの前、イベントの後、またはすべての組み合わせで発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-292">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-293"><see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-293">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-294">このコントロールのスタイル テンプレートをテーマ内で検索するために使用するキーを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-294">Gets or sets the key to use to find the style template for this control in themes.</span></span></summary>
        <value><span data-ttu-id="1fb7d-295">スタイルのキー。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-295">The style key.</span></span> <span data-ttu-id="1fb7d-296">スタイルを設定する要素の <see cref="T:System.Type" /> になっていないと、テーマ スタイルの参照の一部として正しく機能しません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-296">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span></span> <span data-ttu-id="1fb7d-297"><see langword="null" /> は、特定のケースで許容される値です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-297"><see langword="null" /> is an accepted value for a certain case.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-298">このプロパティは、通常、直接の setter では設定されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-298">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="1fb7d-299">代わりに、新しいサブクラスを作成するたびに、この依存関係プロパティの型固有のメタデータをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-299">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="1fb7d-300">サブクラスを作成する場合は、コントロールサブクラスの静的コンストラクター内で、<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> 識別子に対して <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-300">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="1fb7d-301">たとえば、<xref:System.Windows.Documents.Bold> などのインラインクラスでは、静的コンストラクター内の <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> メタデータをオーバーライドし、いくつかのインスタンスコンストラクターを公開すること以外に、ほとんどの実装はほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-301">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="1fb7d-302"><xref:System.Windows.Documents.Bold> タグで囲まれた要素は <xref:System.Windows.FontWeights.Bold%2A> の <xref:System.Windows.Documents.TextElement.FontWeight%2A> プロパティを取得しますが、<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> の既定値を `typeof(Bold)`に設定することによって参照されたテーマスタイル内に実装されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-302">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="1fb7d-303">要素またはコントロールがテーマスタイルを意図的に使用しないようにするには、<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> プロパティを `true`に設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-303">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-304">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-304">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-305">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-305">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="1fb7d-306">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-306">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-307"><see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-307">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-308">要素が初期化された直後に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-308">Called immediately after an element is initialized.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-309">要素の読み込みプロセス中に要素が初期化されるときに発生する特別な処理を提供するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-309">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="1fb7d-310">基本 (既定) の実装では初期化を追跡する内部フラグが設定されるため、実装では基本実装を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-310">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="1fb7d-311"><xref:System.Windows.FrameworkContentElement.BeginInit%2A> が以前に呼び出された場合、基本実装では <xref:System.Windows.FrameworkContentElement.Initialized> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-311">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="1fb7d-312">それ以外の場合、<xref:System.Windows.FrameworkContentElement.BeginInit%2A> が呼び出されなかった場合、または <xref:System.Windows.FrameworkContentElement.BeginInit%2A> が呼び出されたかどうかを判断できなかった場合、イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-312">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1fb7d-313">検索対象の要素の名前。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-313">Name of the element to search for.</span></span></param>
        <summary><span data-ttu-id="1fb7d-314">指定した識別名を持つ要素を検索します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-314">Finds an element that has the provided identifier name.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-315">要求された要素。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-315">The requested element.</span></span> <span data-ttu-id="1fb7d-316">一致する要素が見つからなかった場合は <see langword="null" /> になります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-316">May be <see langword="null" /> if no matching element was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-317">この要素に子要素がある場合、これらの子要素は、要求された名前付き要素に対して再帰的に検索されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-317">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-318">次の例では、ページ上の参照されている <xref:System.Windows.Documents.FlowDocument> 内の名前で見つかった要素のプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-318">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="1fb7d-319">検索するリソースのキー識別子。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-319">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="1fb7d-320">指定されたキーを使用してリソースを検索し、要求されたリソースが見つからない場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-320">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-321">見つかったリソース。または一致するリソースが見つからなかった場合は <see langword="null" /> (<see langword="null" /> の場合は例外もスローします)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-321">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="1fb7d-322">見つからないキーに対してこのメソッドを呼び出すと、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-322">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="1fb7d-323">この場合に例外を処理しない場合は、代わりに <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-323">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="1fb7d-324"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> は、リソースが見つからない場合に `null` を返し、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-324"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="1fb7d-325">リソースが呼び出し元の要素で見つからない場合、実行時にキーによって要求された場合と同じ方法で、論理ツリーを使用して親ツリーが検索されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-325">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="1fb7d-326">通常は、返されたリソース値を使用して設定しようとしていたプロパティの型に戻り値を直ちにキャストします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-326">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-327">次の例では、マークアップで定義されたリソースを検索し、ルーティングイベントへの応答として、要素の特定のプロパティに適用します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-327">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><span data-ttu-id="1fb7d-328">要求されたリソース キーは見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-328">The requested resource key was not found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1fb7d-329"><paramref name="resourceKey" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-329"><paramref name="resourceKey" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-330">この要素がキーボード フォーカスを受け取ったときに適用される外観、効果、またはその他のスタイル特性のカスタマイズを可能にするオブジェクトを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-330">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span></span></summary>
        <value><span data-ttu-id="1fb7d-331">フォーカスに適用する目的のスタイル。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-331">The desired style to apply on focus.</span></span> <span data-ttu-id="1fb7d-332">依存関係プロパティで宣言されている既定値は、空の静的 <see cref="T:System.Windows.Style" /> です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-332">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span></span> <span data-ttu-id="1fb7d-333">ただし、実行時の有効値は、多くの場合、コントロールのテーマ サポートによって提供されたスタイルです (ただし、常にそうであるとは限りません)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-333">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-334">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]でこのプロパティを設定すると、ほとんどの場合、スタイルは要素としてインラインではなくリソースとして定義され、そのリソースは通常 <xref:System.Windows.StaticResourceExtension>として参照されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-334">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="1fb7d-335">このプロパティは視覚的な外観に影響しますが、メタデータではレポートされません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-335">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="1fb7d-336">これは、視覚的な外観の変更はイベントドリブンであり、常に適用されない可能性があるため、通常はビジュアルやレイアウト情報をメタデータに報告しないようにする必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-336">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="1fb7d-337">概念的には、コントロールに適用されるフォーカスの視覚的な動作は、要素間で一貫している必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-337">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="1fb7d-338">一貫性を適用する最も合理的な方法は、テーマ全体を作成する場合にのみフォーカスの視覚スタイルを変更することです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-338">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="1fb7d-339">このプロパティをテーマの一部としてではなく、個々のスタイルで設定することは、このプロパティの使用には適していません。これは、キーボードフォーカスに関してユーザーエクスペリエンスが混乱する可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-339">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="1fb7d-340">テーマ全体で一貫していない要素固有の動作を行う場合は、<xref:System.Windows.UIElement.IsFocused%2A> や <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>など、個々の入力状態プロパティのスタイルでトリガーを使用したり、視覚的にはない方法でトリガーを使用したりできます。既存のフォーカスの visual スタイルに干渉します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-340">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="1fb7d-341"><xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> と代替のフォーカスプロパティの設計目的の詳細については、「[コントロールのフォーカスのスタイル設定」および FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-341">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="1fb7d-342">XAML 属性の使用方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-342">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="1fb7d-343">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="1fb7d-343">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="1fb7d-344">XAML 値</span><span class="sxs-lookup"><span data-stu-id="1fb7d-344">XAML Values</span></span>  
 <span data-ttu-id="1fb7d-345">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-345">*resourceExtension*</span></span>  
 <span data-ttu-id="1fb7d-346">次のいずれか:、または。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-346">One of the following: , or .</span></span> <span data-ttu-id="1fb7d-347">「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-347">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="1fb7d-348">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-348">*styleResourceKey*</span></span>  
 <span data-ttu-id="1fb7d-349">要求されているスタイルを識別するキー。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-349">The key that identifies the style being requested.</span></span> <span data-ttu-id="1fb7d-350">キーは、<xref:System.Windows.ResourceDictionary>内の既存のリソースを参照します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-350">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1fb7d-351">Property 要素の構文は技術的には可能ですが、推奨されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-351">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="1fb7d-352">「[インラインスタイルとテンプレート」を](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-352">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="1fb7d-353">[TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md)または <xref:System.Windows.Data.Binding> を使用したバインディング参照も可能ですが、一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-353">A binding reference using [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-354">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-354">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-355">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-355">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="1fb7d-356">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-356">Metadata properties set to `true`</span></span>|<span data-ttu-id="1fb7d-357">なし</span><span class="sxs-lookup"><span data-stu-id="1fb7d-357">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-358"><see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-358">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-359">このインスタンスの <see cref="T:System.Windows.FrameworkContentElement" /> プロパティの宣言に従って[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] がカーソルを描画するように、この <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> で強制するかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-359">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span></span></summary>
        <value><span data-ttu-id="1fb7d-360">この要素の上にあるときのカーソルの表示に、このインスタンスのカーソル設定を強制的に使用する場合は <see langword="true" /> (すべての子要素も対象となります)。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-360"><see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span></span> <span data-ttu-id="1fb7d-361">既定値は <see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-361">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-362">このプロパティを `true` に設定すると、子要素によって設定されたカーソル設定がオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-362">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="1fb7d-363">一般に、アプリケーションの一般的な [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] では、子要素がカーソルを指定しようとしている場合に、ユーザーにとって混乱を招く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-363">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="1fb7d-364"><xref:System.Windows.FrameworkElement.ForceCursor%2A> の設定は、コントロールのサブクラス化や複合のシナリオに適しています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-364">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-365">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-365">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-366">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-366">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="1fb7d-367">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-367">Metadata properties set to `true`</span></span>|<span data-ttu-id="1fb7d-368">なし</span><span class="sxs-lookup"><span data-stu-id="1fb7d-368">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-369">次の例では、要素上にカーソルを強制的に置きます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-369">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-370"><see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-370">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="1fb7d-371">バインディングの取得元のターゲット <see cref="T:System.Windows.DependencyProperty" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-371">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span></span></param>
        <summary><span data-ttu-id="1fb7d-372">指定したプロパティのバインディングに関する <see cref="T:System.Windows.Data.BindingExpression" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-372">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-373">ターゲットがデータ バインドされている場合は <see cref="T:System.Windows.Data.BindingExpression" /> を返します。それ以外の場合は <see langword="null" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-373">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1fb7d-374">次の例では、プロパティに対してクエリを実行して、バインディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-374">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-375">ビジュアル親が存在しない場合に、この要素に対する代替の論理上の親を返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-375">Returns an alternative logical parent for this element if there is no visual parent.</span></span> <span data-ttu-id="1fb7d-376">この場合、<see cref="T:System.Windows.FrameworkContentElement" /> の親の値は常に <see cref="P:System.Windows.FrameworkContentElement.Parent" /> プロパティの値と同じになります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-376">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-377">このメソッドの WPF フレームワーク レベルの実装が非ビジュアルの親接続を持つ場合は <see langword="null" /> 以外の値を返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-377">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-378">既定の実装では、予期される1つのビジュアル親が返されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-378">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="1fb7d-379">カスタム実装では、代替の親リレーションシップが返される場合があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-379">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-380">この <see cref="T:System.Windows.FrameworkContentElement" /> が初期化されるときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-380">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span></span> <span data-ttu-id="1fb7d-381">これと同時に、<see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> プロパティの値が <see langword="false" /> (未定義) から <see langword="true" /> に変更されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-381">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-382">このイベントは、<xref:System.Windows.FrameworkContentElement.EndInit%2A> または <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> メソッドが呼び出されるたびに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-382">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="1fb7d-383">これらのメソッドの呼び出しは、意図的なコードまたは [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] の読み込みプロセスによって行われた可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-383">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-384">この <see cref="T:System.Windows.FrameworkContentElement" /> で使用される入力のコンテキストを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-384">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <value><span data-ttu-id="1fb7d-385">代替の入力メソッドからの入力を解釈する方法を変更する入力スコープ。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-385">The input scope, which modifies how input from alternative input methods is interpreted.</span></span> <span data-ttu-id="1fb7d-386">既定値は <see langword="null" /> です (コマンドの既定の処理が行われます)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-386">The default value is <see langword="null" /> (which results in a default handling of commands).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-387">この依存関係プロパティは、プロパティ値を継承します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-387">This dependency property inherits property values.</span></span> <span data-ttu-id="1fb7d-388">ローカル値またはスタイルを使用して <xref:System.Windows.FrameworkElement.InputScope%2A> に他の値が設定されていない子要素がある場合、プロパティシステムは、この値が割り当てられている最も近い親要素の <xref:System.Windows.FrameworkElement.InputScope%2A> 値になるように値を設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-388">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="1fb7d-389">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文の使用法が示されていますが、構文的に許可されていますが、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] でこのプロパティを設定するのは一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-389">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-390">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-390">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-391">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-391">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="1fb7d-392">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-392">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-393"><see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-393">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-394">この要素が初期化されているかどうかを示す値を取得します。要素の初期化は、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] として読み込むことによって行われる場合と、<see cref="M:System.Windows.FrameworkContentElement.EndInit" /> メソッドを明示的に呼び出すことによって行われる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-394">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span></span></summary>
        <value><span data-ttu-id="1fb7d-395">上で挙げた読み込みまたはメソッド呼び出しを通じて要素が初期化される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-395"><see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-396">このプロパティは、この要素が新しい親要素を持つように要素ツリー内で移動されたために `true` こともできます。そのため、再度読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-396">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-397">この要素が表示のために読み込まれているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-397">Gets a value indicating whether this element has been loaded for presentation.</span></span></summary>
        <value><span data-ttu-id="1fb7d-398">現在の要素が要素ツリーにアタッチされ、描画されている場合は <see langword="true" />。読み込まれた要素ツリーに要素がアタッチされていない場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-398"><see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-399">新しく構築されたインスタンスからは、このプロパティは `false`から開始され、後でコードによって削除された場合でも `true`に設定されると、`true` のままになります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-399">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-400">次のコード例では、<xref:System.Windows.FrameworkContentElement.IsLoaded%2A> を条件付きチェックとして使用して、オンデマンドハンドラーの一部として、関数 `displayData` (表示されていません) に対して、使用するページに有効な要素が読み込まれることを保証します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-400">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="1fb7d-401">同じロジックが <xref:System.Windows.FrameworkContentElement.Loaded>のイベントハンドラーとして実行されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-401">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-402">個々の要素に適用されるローカリゼーション/グローバリゼーション言語情報を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-402">Gets or sets localization/globalization language information that applies to an individual element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-403">この要素のカルチャ情報。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-403">The culture information for this element.</span></span> <span data-ttu-id="1fb7d-404">既定値は、<see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> の値が文字列 "en-US" に設定された <see cref="T:System.Windows.Markup.XmlLanguage" /> インスタンスです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-404">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-405">文字列の形式は RFC 3066 標準に従います。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-405">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="1fb7d-406">たとえば、米国の英語は "en-us" です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-406">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="1fb7d-407">値と形式の詳細については、「<xref:System.Windows.Markup.XmlLanguage>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-407">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="1fb7d-408">この依存関係プロパティは、プロパティ値を継承します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-408">This dependency property inherits property values.</span></span> <span data-ttu-id="1fb7d-409">ローカル値またはスタイルを使用して <xref:System.Windows.FrameworkElement.Language%2A> に他の値が設定されていない子要素がある場合、プロパティシステムは、この値が割り当てられている最も近い親要素の <xref:System.Windows.FrameworkElement.Language%2A> 値になるように値を設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-409">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-410">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-410">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-411">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-411">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="1fb7d-412">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-412">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-413"><see cref="P:System.Windows.FrameworkContentElement.Language" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-413">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-414">要素のレイアウトやレンダリングが完了し、操作を受け入れる準備が整ったときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-414">Occurs when the element is laid out, rendered, and ready for interaction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-415">ダイレクトルーティングイベントはルートに従わないので、これらのイベントは、発生したものと同じ要素内でのみ処理されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-415">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="1fb7d-416">直接ルーティングイベントでは、他のルーティングイベントの動作がサポートされます。これらは、アクセス可能なハンドラーコレクションをサポートし、スタイルの <xref:System.Windows.EventTrigger> として使用できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-416">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="1fb7d-417">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-418">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-418">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="1fb7d-419">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-419">Routing strategy</span></span>|<span data-ttu-id="1fb7d-420">直接</span><span class="sxs-lookup"><span data-stu-id="1fb7d-420">Direct</span></span>|  
|<span data-ttu-id="1fb7d-421">Delegate</span><span class="sxs-lookup"><span data-stu-id="1fb7d-421">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-422"><see cref="E:System.Windows.FrameworkContentElement.Loaded" /> ([Routed Events Overview (ルーティング イベントの概要)](~/docs/framework/wpf/advanced/routed-events-overview.md)) を識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-422">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-423">イベント識別子オブジェクトは、ルーティングイベントが登録されたときに作成され (<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照)、クラスハンドラーを追加するために使用できます (「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-423">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="1fb7d-424">識別子オブジェクトには、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-424">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-425">この要素の論理上の子要素に対する列挙子を取得します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-425">Gets an enumerator for the logical child elements of this element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-426">この要素の論理上の子要素に対する列挙子。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-426">An enumerator for logical child elements of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-427"><xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> と <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>の使用方法の詳細については、「 [WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-427">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="1fb7d-428">フォーカスの移動方向を表す列挙値。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-428">The direction that focus is to be moved, as a value of the enumeration.</span></span></param>
        <summary><span data-ttu-id="1fb7d-429">この要素から別の要素にキーボード フォーカスを移動します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-429">Moves the keyboard focus from this element to another element.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-430">フォーカスの移動が成功した場合は <see langword="true" /> が返されます。指定した方向にターゲット要素が存在しない場合は <see langword="false" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-430">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-431">要素の識別名を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-431">Gets or sets the identifying name of the element.</span></span> <span data-ttu-id="1fb7d-432">この名前はインスタンス参照を提供するため、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] の解析中に参照が構築されると、プログラムの分離コード (イベント ハンドラー コードなど) は要素を参照できるようになります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-432">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span></summary>
        <value><span data-ttu-id="1fb7d-433">要素の名前。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-433">The name of the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-434">このプロパティの最も一般的な使用方法は、マークアップで [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 要素名を指定する場合です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-434">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="1fb7d-435">このプロパティは、基本的に、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:Name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)を設定するための WPF フレームワークレベルの便宜的なプロパティを提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-435">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="1fb7d-436">コードから <xref:System.Windows.FrameworkContentElement.Name%2A> を取得することは一般的ではありません。コードに既に適切な参照がある場合は、要素参照のメソッドとプロパティを呼び出すだけで、<xref:System.Windows.FrameworkContentElement.Name%2A>は通常必要ありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-436">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="1fb7d-437">例外は、文字列にオーバーロードされた意味がある場合 ([!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]にその名前を表示すると便利な場合など) です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-437">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="1fb7d-438">元の <xref:System.Windows.FrameworkContentElement.Name%2A> をマークアップから設定した場合、コードから <xref:System.Windows.FrameworkContentElement.Name%2A> を設定することもお勧めしません。プロパティを変更しても、オブジェクト参照は変更されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-438">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="1fb7d-439">このようなオブジェクト参照は、基になる名前スコープが [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] の読み込み中に明示的に作成された場合にのみ作成されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-439">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="1fb7d-440">既に読み込まれている要素の <xref:System.Windows.FrameworkContentElement.Name%2A> プロパティを有効に変更するには、<xref:System.Windows.FrameworkContentElement.RegisterName%2A> を明示的に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-440">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="1fb7d-441">コードから <xref:System.Windows.FrameworkContentElement.Name%2A> を設定することが重要なケースの1つは、ストーリーボードの実行対象となる要素に名前を付けることです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-441">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="1fb7d-442">名前を登録する前に、をインスタンス化して <xref:System.Windows.NameScope> インスタンスを割り当てる必要がある場合もあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-442">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="1fb7d-443">「例」または「[ストーリーボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-443">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="1fb7d-444">コードから <xref:System.Windows.FrameworkContentElement.Name%2A> を設定すると、アプリケーションに制限がありますが、名前で要素を検索するのが一般的です。特に、ページをアプリケーションに再読み込みするナビゲーションモデルを使用していて、実行時コードが必ずしもコードビハインドであるとは限りません。それぞれのページ。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-444">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="1fb7d-445">任意の <xref:System.Windows.FrameworkContentElement>から使用できるユーティリティメソッド <xref:System.Windows.FrameworkContentElement.FindName%2A>は、その要素の論理ツリー内の <xref:System.Windows.FrameworkContentElement.Name%2A> によって要素を再帰的に検索できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-445">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="1fb7d-446">または、<xref:System.Windows.LogicalTreeHelper>の <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 静的メソッドを使用することもできます。これは、引数として <xref:System.Windows.FrameworkContentElement.Name%2A> 文字列を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-446">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="1fb7d-447">一般的に使用されるルート要素 (<xref:System.Windows.Window>、<xref:System.Windows.Controls.Page> など) は、インターフェイス <xref:System.Windows.Markup.INameScope>を実装します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-447">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="1fb7d-448">このインターフェイスの実装では、その名前がスコープ内で明確になるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-448">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-449">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-449">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-450">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-450">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="1fb7d-451">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-451">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-452"><see cref="P:System.Windows.FrameworkContentElement.Name" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-452">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="1fb7d-453">イベントに関するデータを提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-453">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="1fb7d-454"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-454">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="1fb7d-455">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-455">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-456">このメソッドには既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-456">This method has no default implementation.</span></span> <span data-ttu-id="1fb7d-457">継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-457">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="1fb7d-458">このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-458">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="1fb7d-459">この場合、一致イベントはルーティングイベントです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-459">In this case the matching event is a routed event.</span></span> <span data-ttu-id="1fb7d-460">On \* メソッドの実装パターンは、ルーティングイベントによって異なります。ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-460">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="1fb7d-461">そのため、実装では、イベント引数のソースプロパティを考慮する必要があります (ほとんどの場合、イベントを再発生させないようにする必要があります)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-461">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="1fb7d-462"><xref:System.Windows.FrameworkContentElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-462">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="1fb7d-463">考えられるシナリオの1つは、イベントの引数を受け取り、そのイベントを処理済みとして意図的に設定して、ルートを短縮することです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-463">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="1fb7d-464">イベントのイベント データ。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-464">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="1fb7d-465"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-465">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="1fb7d-466">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-466">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-467">このメソッドには既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-467">This method has no default implementation.</span></span> <span data-ttu-id="1fb7d-468">継承の中間クラスがこのメソッドを実装している場合は、base () を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-468">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="1fb7d-469">このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-469">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="1fb7d-470">この場合、一致イベントはルーティングイベントです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-470">In this case the matching event is a routed event.</span></span> <span data-ttu-id="1fb7d-471">On \* メソッドの実装パターンは、ルーティングイベントによって異なります。これは、ルーティングイベントが、必ずしもハンドラーを呼び出す要素ではなく、子要素によって発生する可能性があるためです。そのため、実装では、イベント引数のソースを取得する必要があります。プロパティを account (ほとんどの場合、イベントを再発生させないでください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-471">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="1fb7d-472"><xref:System.Windows.FrameworkContentElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-472">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="1fb7d-473">考えられるシナリオの1つは、イベントの引数を受け取り、そのイベントを処理済みとして意図的に設定して、ルートを短縮することです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-473">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="1fb7d-474">イベントのイベント データ。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-474">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="1fb7d-475"><see cref="E:System.Windows.ContentElement.GotFocus" /> イベントのクラス ハンドラー。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-475">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-476">このクラスハンドラーは、イベントがこの要素から発生した場合に、この要素に適切なフォーカス動作を設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-476">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="1fb7d-477">イベントのソースがツリー内の別の要素であった場合、ハンドラーは何も行いません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-477">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="1fb7d-478">要素のこれらの既定のフォーカス動作を変更するには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-478">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="1fb7d-479">イベントのイベント データ。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-479">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="1fb7d-480"><see cref="E:System.Windows.FrameworkContentElement.Initialized" /> イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-480">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span></span> <span data-ttu-id="1fb7d-481">このメソッドは、<see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> が <see langword="true" /> に設定されるたびに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-481">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-482">この仮想メソッドの既定の実装では、このトピックで既に説明したように、イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-482">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="1fb7d-483">オーバーライドは、この動作を維持するために base () を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-483">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="1fb7d-484"><xref:System.Windows.FrameworkContentElement.IsInitialized%2A> プロパティは読み取り専用であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-484">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="1fb7d-485">したがって、初期化動作を強制的に実行するように設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-485">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="1fb7d-486">初期化の設定は、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework によってのみ実行されることを意図しています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-486">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="1fb7d-487">変更されたプロパティ (古い値と新しい値を含む) を示すイベント データ。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-487">The event data that describes the property that changed, including the old and new values.</span></span></param>
        <summary><span data-ttu-id="1fb7d-488">この <see cref="T:System.Windows.FrameworkContentElement" /> の依存関係プロパティの有効値が更新された場合に必ず呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-488">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span></span> <span data-ttu-id="1fb7d-489">変更が発生した特定の依存関係プロパティが引数パラメーターで報告されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-489">The specific dependency property that changed is reported in the arguments parameter.</span></span> <span data-ttu-id="1fb7d-490"><see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-490">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-491">このメソッドは、一般的にプロパティの変更や無効化を検出するためのものではありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-491">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="1fb7d-492">プロパティの広範な分類に関する特定の情報がわかっている場合は、一般的な無効化パターンを変更することを意図しています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-492">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="1fb7d-493">このメソッドは、オブジェクトの有効期間中に何度も呼び出される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-493">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="1fb7d-494">したがって、特定のプロパティのメタデータをオーバーライドし、個々のプロパティに <xref:System.Windows.CoerceValueCallback> または <xref:System.Windows.PropertyChangedCallback> 関数をアタッチすると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-494">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="1fb7d-495">ただし、このメソッドは、<xref:System.Windows.FrameworkContentElement> に大量の値に関連する依存関係プロパティが含まれている場合、またはプロパティの無効化の複数の関連するケースに対して再実行する必要があるレンダリング動作などのロジックが含まれている場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-495">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="1fb7d-496">さまざまなクラスで使用できるシグネチャが異なる (パラメーターの型が <xref:System.ComponentModel.PropertyChangedEventArgs>) `OnPropertyChanged` メソッドが同じ名前であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-496">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="1fb7d-497">この `OnPropertyChanged` は、データオブジェクトの通知に使用され、<xref:System.ComponentModel.INotifyPropertyChanged>のコントラクトに含まれます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-497">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1fb7d-498">実装の最初の操作として、常に基本実装を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-498">Always call the base implementation, as the first operation in your implementation.</span></span> <span data-ttu-id="1fb7d-499">この操作を行わないと、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プロパティシステム全体が大幅に無効になり、間違った値が報告されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-499">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle"><span data-ttu-id="1fb7d-500">元のスタイル。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-500">The old style.</span></span></param>
        <param name="newStyle"><span data-ttu-id="1fb7d-501">新しいスタイル。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-501">The new style.</span></span></param>
        <summary><span data-ttu-id="1fb7d-502">この要素で使用されているスタイルが変更された場合に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-502">Invoked when the style that is in use on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-503">このメソッドには、スタイル変更条件を示す内部フラグを設定する既定の実装があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-503">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1fb7d-504">常に基本実装を呼び出します。それ以外の場合は、スタイルを適用できません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-504">Always call the base implementation, otherwise styles cannot be applied.</span></span> <span data-ttu-id="1fb7d-505">このメソッドをオーバーライドするシナリオには、派生クラスに特殊なスタイルセレクターがある場合や、スタイル値をキャッシュする場合などがあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-505">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span></span> <span data-ttu-id="1fb7d-506">テーマを変更すると、このメソッドが呼び出される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-506">Theme changes will potentially invoke this method.</span></span></para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="1fb7d-507">イベントに関するデータを提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-507">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="1fb7d-508"><see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-508">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="1fb7d-509">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-509">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-510">このメソッドには既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-510">This method has no default implementation.</span></span> <span data-ttu-id="1fb7d-511">継承の中間クラスがこのメソッドを実装している場合は、base () を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-511">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="1fb7d-512">このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-512">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="1fb7d-513">この場合、一致イベントはルーティングイベントです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-513">In this case the matching event is a routed event.</span></span> <span data-ttu-id="1fb7d-514">On \* メソッドの実装パターンは、ルーティングイベントによって異なります。これは、ルーティングイベントが、必ずしもハンドラーを呼び出す要素ではなく、子要素によって発生する可能性があるためです。そのため、実装では、イベント引数のソースを取得する必要があります。プロパティを account (ほとんどの場合、イベントを再発生させないでください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-514">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="1fb7d-515"><xref:System.Windows.FrameworkContentElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-515">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="1fb7d-516">考えられるシナリオの1つは、イベントの引数を受け取り、そのイベントを処理済みとして意図的に設定して、ルートを短縮することです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-516">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="1fb7d-517">イベントに関するデータを提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-517">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="1fb7d-518"><see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-518">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="1fb7d-519">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-519">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-520">このメソッドには既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-520">This method has no default implementation.</span></span> <span data-ttu-id="1fb7d-521">継承の中間クラスがこのメソッドを実装している場合は、base () を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-521">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="1fb7d-522">このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-522">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="1fb7d-523">この場合、一致イベントはルーティングイベントです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-523">In this case the matching event is a routed event.</span></span> <span data-ttu-id="1fb7d-524">On \* メソッドの実装パターンは、ルーティングイベントによって異なります。これは、ルーティングイベントが、必ずしもハンドラーを呼び出す要素ではなく、子要素によって発生している可能性があるためです。そのため、実装では、イベント引数の source を受け取る必要があります。プロパティを account (ほとんどの場合、イベントを再発生させないでください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-524">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="1fb7d-525"><xref:System.Windows.FrameworkContentElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-525">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="1fb7d-526">考えられるシナリオの1つは、イベントの引数を受け取り、そのイベントを処理済みとして意図的に設定して、ルートを短縮することです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-526">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-527">この要素にテーマ スタイルのスタイル プロパティを組み込むかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-527">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span></span></summary>
        <value><span data-ttu-id="1fb7d-528">この要素がテーマ スタイル プロパティを使用しない場合は <see langword="true" /> (スタイルが生成するすべてのプロパティは、ローカルのアプリケーション スタイルに起因するため、テーマ スタイル プロパティは適用されません)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-528"><see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span></span> <span data-ttu-id="1fb7d-529">まずアプリケーション スタイルを適用してから、アプリケーション スタイルで明確に設定されなかったプロパティに対してテーマ スタイルを適用する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-529"><see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-530">このプロパティの最も一般的な使用方法は、テーマスタイルを提供するスタイルの setter 内での間接的な使用です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-530">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-531">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-531">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-532">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-532">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="1fb7d-533">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-533">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-534"><see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-534">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-535">この要素の論理ツリー内での親を取得します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-535">Gets the parent in the logical tree for this element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-536">この要素の論理上の親。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-536">The logical parent for this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-537">要素の論理上の親は、アプリケーションの機能によって変わる可能性があります。このプロパティの値を維持しても、その変更は反映されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-537">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="1fb7d-538">通常は、必要な値をすぐに取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-538">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="1fb7d-539">論理ツリーの走査の詳細については、「 [WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md) 」を参照してください。また、要素の検出にこのアプローチを採用するシナリオも適しています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-539">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="1fb7d-540">プロパティシステムは、親のときに、要素のすべてのプロパティ値を再計算する可能性があります。これは、一部のプロパティが論理ツリーを通じて値を継承するためです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-540">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="1fb7d-541">バインドに適用される <xref:System.Windows.FrameworkContentElement.DataContext%2A> は、要素が親されたときにも変更できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-541">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="1fb7d-542">通常、要素の親を変更するには、専用の add メソッドまたは remove メソッドを使用するか、要素のコンテンツプロパティを設定することによって、コレクションの操作を行います。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-542">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="1fb7d-543"><xref:System.Windows.FrameworkContentElement.Parent%2A> プロパティを使用する最も一般的なシナリオは、参照を取得し、親からさまざまな <xref:System.Windows.FrameworkContentElement> プロパティ値を取得することです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-543">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="1fb7d-544">テンプレートの場合は、最終的にテンプレートの <xref:System.Windows.FrameworkContentElement.Parent%2A> が `null`されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-544">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="1fb7d-545">この点を超えて、テンプレートが実際に適用される論理ツリーに拡張するには、<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>を使用します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-545">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-546">次の例では、<xref:System.Windows.Documents.TextPointer> の <xref:System.Windows.FrameworkContentElement.Parent%2A> が特定の型であるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-546">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="1fb7d-547">予想されるフォーカスの変更を決定する方向。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-547">The direction for which a prospective focus change should be determined.</span></span></param>
        <summary><span data-ttu-id="1fb7d-548">この要素を基準に、指定したフォーカスの移動方向で次にフォーカスを受け取る要素を特定します。ただし、実際のフォーカスの移動は行われません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-548">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span></span> <span data-ttu-id="1fb7d-549">このメソッドはシールされているため、オーバーライドできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-549">This method is sealed and cannot be overridden.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-550">フォーカスが実際にスキャンされた場合にフォーカスの移動先となる、次の要素。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-550">The next element that focus would move to if focus were actually traversed.</span></span> <span data-ttu-id="1fb7d-551">この要素を基準に、指定した方向へフォーカスを移動できない場合は、<see langword="null" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-551">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-552"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> は、実際にフォーカスを移動する関連のメソッドです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-552"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="1fb7d-553"><see cref="T:System.Windows.Input.TraversalRequest" /> に、<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /> のいずれかの方向が指定されました。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-553">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span></span> <span data-ttu-id="1fb7d-554">これらの方向は、<see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> に対しては有効ではありません (<see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> に対しては有効です)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-554">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1fb7d-555">指定した名前オブジェクトの割り当てに使用する名前。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-555">Name to use for the specified name-object mapping.</span></span></param>
        <param name="scopedElement"><span data-ttu-id="1fb7d-556">割り当て対象のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-556">Object for the mapping.</span></span></param>
        <summary><span data-ttu-id="1fb7d-557"><see cref="T:System.Windows.NameScope" /> の登録メソッドへのアクセスを簡略化するアクセサーを提供します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-557">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-558">このメソッドは、<xref:System.Windows.NameScope.RegisterName%2A>を呼び出すための便利なメソッドです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-558">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="1fb7d-559">実装では、適用可能な <xref:System.Windows.NameScope> 実装が見つかるまで、連続する親要素がチェックされます。この実装は、<xref:System.Windows.Markup.INameScope>を実装する要素を検索することによって検出されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-559">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="1fb7d-560">名前スコープの詳細については、「 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-560">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="1fb7d-561">コードで作成されたアプリケーションのアニメーションストーリーボードを正しくフックするには、<xref:System.Windows.FrameworkContentElement.RegisterName%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-561">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="1fb7d-562">これは、キーストーリーボードのプロパティの1つである <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>は、ターゲット要素への参照を取得するのではなく、実行時の名前参照を使用するためです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-562">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="1fb7d-563">これは、コードから参照によってその要素にアクセスできる場合でも同様です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-563">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="1fb7d-564">ストーリーボードターゲットの名前を登録する必要がある理由の詳細については、「[ストーリーボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-564">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="1fb7d-565">コンテンツ要素のアニメーションは、コントロールのアニメーションよりも一般的ではありません。[ストーリーボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)は、コントロールのシナリオに集中します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-565">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="1fb7d-566">削除する要素。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-566">The element to remove.</span></span></param>
        <summary><span data-ttu-id="1fb7d-567">この要素の論理ツリーから、指定した要素を削除します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-567">Removes the specified element from the logical tree for this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-568">この API は主に、子コレクションのサポートを追加するときに、クラスを派生するシナリオに関連しています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-568">This API is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="1fb7d-569">ほとんどの <xref:System.Windows.FrameworkContentElement> 派生クラスは、コンテインメントを担当する専用コレクション (たとえば、<xref:System.Windows.Documents.Span> クラスの <xref:System.Windows.Documents.Span.Inlines%2A>、<xref:System.Windows.Documents.Section> クラスの <xref:System.Windows.Documents.Section.Blocks%2A>) を公開します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-569">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="1fb7d-570">通常、このようなクラスから派生すると、論理ツリーを直接操作する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-570">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-571">ローカルで定義された現在のリソース ディクショナリを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-571">Gets or sets the current locally-defined resource dictionary.</span></span></summary>
        <value><span data-ttu-id="1fb7d-572">ローカルで定義された現在のリソース。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-572">The current locally-defined resources.</span></span> <span data-ttu-id="1fb7d-573">これはリソース ディクショナリです。ディクショナリ内のリソースにはキーでアクセスします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-573">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-574">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] で完全または部分的に定義できるリソースディクショナリは、通常、プロパティ要素として作成され、通常は個々のページまたはアプリケーションのルート要素にあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-574">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="1fb7d-575">リソースディクショナリをこのレベルに配置すると、ページ内の個々の子要素 (または、アプリケーションケースでは任意のページ) から簡単に検索できるようになります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-575">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="1fb7d-576">ほとんどのアプリケーションシナリオでは、スタイルをリソースディクショナリ内のオブジェクト要素として定義するか、または外部リソースとして定義して、スタイルリソース全体を自己完結させることをお勧めします (この方法は、別のデザイナーに役立ちます)。編集する必要がある物理ファイルを分離することによる、開発者の責任からの役割。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-576">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="1fb7d-577">このプロパティは、その要素内で直接宣言されたリソースディクショナリだけを返すことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-577">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="1fb7d-578">これは、実際のリソース参照プロセスとは異なります。子要素は、各親要素で定義されている任意のリソースにアクセスして、再帰的に検索します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-578">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="1fb7d-579">リソースは、コレクション内のコードによって参照することもできますが、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] で作成されたリソースは、ディクショナリを宣言する要素によって <xref:System.Windows.FrameworkContentElement.Loaded> が発生するまで確実にアクセスできないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-579">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="1fb7d-580">実際、リソースは非同期的に解析されますが、<xref:System.Windows.FrameworkContentElement.Loaded> イベントが [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 定義されたリソースを参照できるという保証もありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-580">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="1fb7d-581">このため、一般に、実行時コードの一部として [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 定義されたリソースにのみアクセスするか、または属性値に対するスタイルやリソース拡張機能の参照などの他の [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 手法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-581">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="1fb7d-582">コードを使用してリソースにアクセスする場合は、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]から作成された[Dynamicresource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)参照と基本的に同じです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-582">When you access resources through code, it is essentially equivalent to a [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="1fb7d-583">基になる <xref:System.Windows.ResourceDictionary> は、コードを使用して、コレクション内のリソースの追加、削除、またはクエリを実行するために必要なメソッドをサポートします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-583">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="1fb7d-584"><xref:System.Windows.FrameworkContentElement.Resources%2A> プロパティは、要素のリソースコレクションを新しいまたは別の <xref:System.Windows.ResourceDictionary>として完全に置き換えるシナリオをサポートするために設定できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-584">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="1fb7d-585">表示される [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文には、<xref:System.Windows.ResourceDictionary>の要素が含まれていないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-585">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="1fb7d-586">これは、暗黙的なコレクション構文の例です。コレクション要素を表すタグを省略できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-586">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="1fb7d-587">コレクションに項目として追加された要素が代わりに指定されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-587">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="1fb7d-588">暗黙のコレクションと [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]の詳細については、「 [XAML 構文の詳細](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-588">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="1fb7d-589"><xref:System.Windows.ResourceDictionary> が要素として明示的に指定されている場合、マージされたディクショナリを導入すると、その <xref:System.Windows.ResourceDictionary>の子要素は通常ありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-589">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="1fb7d-590">詳細については、「マージされた[リソースディクショナリ](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-590">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="1fb7d-591">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="1fb7d-591">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="1fb7d-592">XAML 値</span><span class="sxs-lookup"><span data-stu-id="1fb7d-592">XAML Values</span></span>  
 <span data-ttu-id="1fb7d-593">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-593">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="1fb7d-594">1つ以上のオブジェクト要素。それぞれがリソースを定義します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-594">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="1fb7d-595">各 <xref:System.Windows.ResourceDictionary> 内の各リソースプロパティ要素には、<xref:System.Windows.ResourceDictionary>から値を取得するときに一意のキーとして機能する、 [X:Key ディレクティブ](~/docs/framework/xaml-services/x-key-directive.md)に対して一意の値を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-595">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-596">次の例では、<xref:System.Windows.Documents.FlowDocument> ルート要素で <xref:System.Windows.FrameworkContentElement.Resources%2A> コレクションを確立します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-596">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="1fb7d-597"><xref:System.Windows.Documents.FlowDocument> は、ルート要素として意味を持ついくつかの <xref:System.Windows.FrameworkContentElement> クラスの1つであるため、一般的に選択されています。リソースは通常、ページルートに格納されるか、またはアプリケーションのようなより高いレベルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-597"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1fb7d-598">指定した依存関係プロパティのためのバインディングをこの要素に添付します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-598">Attaches a binding to this element for the specified dependency property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="1fb7d-599">バインドされているプロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-599">Identifies the bound property.</span></span></param>
        <param name="path"><span data-ttu-id="1fb7d-600">ソース プロパティ名、またはバインドに使用されているプロパティへのパス。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-600">The source property name or the path to the property used for the binding.</span></span></param>
        <summary><span data-ttu-id="1fb7d-601">指定したソース プロパティ名をデータ ソースへのパスの修飾として使用して、この要素にバインディングを添付します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-601">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-602">バインドの条件を記録します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-602">Records the conditions of the binding.</span></span> <span data-ttu-id="1fb7d-603">この戻り値は、エラーをチェックするために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-603">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-604">このメソッドは、現在のインスタンスを <xref:System.Windows.DependencyObject>として渡し、指定された `path` パラメーターに基づいて新しい <xref:System.Windows.Data.Binding> を作成する <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>を呼び出すための便利なメソッドです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-604">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="1fb7d-605">この署名は、単純な既定のバインドを確立する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-605">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="1fb7d-606">バインドプロパティを既定以外の条件に指定する必要がある場合、または <xref:System.Windows.Data.MultiBinding> または <xref:System.Windows.Data.PriorityBinding>を使用する場合は、<xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> シグネチャを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-606">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-607">次の例では、新しいカスタムデータオブジェクトを作成し、そのオブジェクトを <xref:System.Windows.FrameworkContentElement.DataContext%2A>として確立し、バインドパスをその中のプロパティに設定することによって、<xref:System.Windows.Documents.Paragraph> 要素のバインドを設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-607">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="1fb7d-608">バインドされているプロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-608">Identifies the bound property.</span></span></param>
        <param name="binding"><span data-ttu-id="1fb7d-609">データ バインディングを表します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-609">Represents a data binding.</span></span></param>
        <summary><span data-ttu-id="1fb7d-610">指定したバインディング オブジェクトに基づいて、この要素にバインドをアタッチします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-610">Attaches a binding to this element, based on the provided binding object.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-611">バインドの条件を記録します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-611">Records the conditions of the binding.</span></span> <span data-ttu-id="1fb7d-612">この戻り値は、エラーをチェックするために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-612">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-613">このメソッドは、現在のインスタンスを <xref:System.Windows.DependencyObject>として渡す <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>を呼び出すための便利なメソッドです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-613">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-614">次の例では、新しい <xref:System.Windows.Data.Binding> を作成し、ソースを新しく構築された `DateTime` オブジェクトに設定することによって、<xref:System.Windows.Documents.Paragraph> 要素のバインドを設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-614">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="1fb7d-615">リソースのバインド先のプロパティ。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-615">The property to which the resource is bound.</span></span></param>
        <param name="name"><span data-ttu-id="1fb7d-616">リソースの名前。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-616">The name of the resource.</span></span></param>
        <summary><span data-ttu-id="1fb7d-617">指定した名前のリソースを検索し、指定したプロパティにそのリソースへのリソース参照を設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-617">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-618">リソース参照は、マークアップで[Dynamicresource マークアップ拡張機能](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)を使用する場合と似ています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-618">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="1fb7d-619">リソース参照は、指定されたプロパティの値を実行時の遅延ベースで提供する内部式を作成します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-619">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="1fb7d-620">式は、リソースディクショナリが内部イベントによって変更された値を示した場合、または現在の要素が親された場合 (親の変更によって辞書参照パスが変更される場合) は常に再評価されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-620">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-621">シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.FrameworkContentElement.Resources" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-621">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-622"><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkContentElement.Resources" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-622"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-623">ローカル <xref:System.Windows.FrameworkContentElement.Resources%2A>に少なくとも1つのキー付きリソースがある場合は `true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-623">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-624">シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.FrameworkContentElement.Style" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-624">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-625"><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkContentElement.Style" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-625"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-626"><xref:System.Windows.Style> がローカルに設定されている場合は、`true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-626">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-627">この要素のバインディングに参加しているデータ ソースが変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-627">Occurs when any associated data source participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-628">このイベントは、この要素に関連付けられている <xref:System.Windows.Data.Binding> によって発生する <xref:System.Windows.Data.Binding.SourceUpdated> イベントを示します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-628">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="1fb7d-629">XAML 属性の使用方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-629">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-630">この要素が使用するスタイルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-630">Gets or sets the style to be used by this element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-631">要素に適用される既定以外のスタイル (存在する場合)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-631">The applied, nondefault style for the element, if present.</span></span> <span data-ttu-id="1fb7d-632">それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-632">Otherwise, <see langword="null" />.</span></span> <span data-ttu-id="1fb7d-633">既定で構築された <see cref="T:System.Windows.FrameworkContentElement" /> の既定値は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-633">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-634">現在のスタイルは、通常、テーマからの既定のスタイル、またはページレベルまたはアプリケーションレベルのリソースによってその型のオブジェクトに適用されるスタイル (暗黙的なスタイル) によって提供されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-634">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="1fb7d-635">このプロパティは、既定 (テーマ) のスタイルを設定または返しませんが、暗黙的なスタイルまたは明示的なスタイルを返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-635">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="1fb7d-636">暗黙的または明示的なスタイルの場合、スタイルがリソースとしてアクセスされているか、ローカルに定義されているかは関係ありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-636">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="1fb7d-637">スタイルの設定にはいくつかの制限があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-637">Setting the styles has some restrictions.</span></span> <span data-ttu-id="1fb7d-638"><xref:System.Windows.FrameworkContentElement.Style%2A> のプロパティ全体を、いつでも新しい <xref:System.Windows.Style> にリセットできます。これにより、レイアウト再合成が強制的に適用されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-638">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="1fb7d-639">ただし、読み込まれた要素によってそのスタイルが使用されるとすぐに、<xref:System.Windows.Style> が sealed と見なされます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-639">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="1fb7d-640">使用中のスタイル (<xref:System.Windows.Style.Setters%2A>のコレクション内にあるものなど) の個々のプロパティを変更しようとすると、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-640">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="1fb7d-641">マークアップで定義されたスタイルは、リソースディクショナリ (リソースの場合) から読み込まれたとき、またはそれが含まれているページが読み込まれるとすぐに使用中と見なされます (インラインスタイルの場合)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-641">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="1fb7d-642"><xref:System.Windows.FrameworkContentElement.Style%2A> は、特殊な優先順位を持つ依存関係プロパティです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-642"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="1fb7d-643">ローカルで設定されたスタイルは、一般に、プロパティシステムで最も優先順位が高いものになります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-643">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="1fb7d-644">この時点で <xref:System.Windows.FrameworkContentElement.Style%2A> が null の場合、プロパティシステムの読み込み中に、その型を指定する定義済みのリソースとして暗黙的なスタイルを確認します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-644">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="1fb7d-645">この手順の後にスタイルが null の場合、スタイルは既定 (テーマ) のスタイルになりますが、既定のスタイルは <xref:System.Windows.FrameworkContentElement.Style%2A> プロパティ値では返されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-645">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="1fb7d-646">「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-646">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="1fb7d-647">XAML 属性の使用方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-647">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="1fb7d-648">XAML 値</span><span class="sxs-lookup"><span data-stu-id="1fb7d-648">XAML Values</span></span>  
 <span data-ttu-id="1fb7d-649">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-649">*resourceExtension*</span></span>  
 <span data-ttu-id="1fb7d-650">次のいずれか:、または。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-650">One of the following: , or .</span></span> <span data-ttu-id="1fb7d-651">「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-651">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="1fb7d-652">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-652">*styleResourceKey*</span></span>  
 <span data-ttu-id="1fb7d-653">要求されているスタイルを識別するキー。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-653">The key that identifies the style being requested.</span></span> <span data-ttu-id="1fb7d-654">キーは、<xref:System.Windows.ResourceDictionary>内の既存のリソースを参照します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-654">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1fb7d-655">Property 要素の構文は技術的には可能ですが、推奨されません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-655">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="1fb7d-656">「[インラインスタイルとテンプレート」を](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-656">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="1fb7d-657">[TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md)または <xref:System.Windows.Data.Binding> を使用したバインディング参照も可能ですが、一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-657">A binding reference using [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-658">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-658">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-659">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-659">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="1fb7d-660">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-660">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-661">次の例では、<xref:System.Windows.Documents.FlowDocument> ルート要素で <xref:System.Windows.FrameworkContentElement.Resources%2A> コレクションを確立し、<xref:System.Windows.Documents.Paragraph>の特定のスタイルとしてリソースとして参照します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-661">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-662"><see cref="P:System.Windows.FrameworkContentElement.Style" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-662">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName"><span data-ttu-id="1fb7d-663">要求されたアンビエント プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-663">The name of the requested ambient property.</span></span></param>
        <summary><span data-ttu-id="1fb7d-664">このメンバーの説明については、<see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> メソッドのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-664">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-665"><paramref name="propertyName" /> を使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-665"><see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-666">このメンバーは、明示的なインターフェイス メンバーの実装です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-666">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1fb7d-667">これは、<xref:System.Windows.FrameworkContentElement> のインスタンスが <xref:System.Windows.Markup.IQueryAmbient> インターフェイスにキャストされる場合のみ、使用できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-667">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-668">この要素に関するユーザー定義情報の格納に使用できる任意のオブジェクト値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-668">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span></span></summary>
        <value><span data-ttu-id="1fb7d-669">任意の値。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-669">The intended value.</span></span> <span data-ttu-id="1fb7d-670">このプロパティには既定値はありません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-670">This property has no default value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-671">このプロパティは、Visual Basic for Applications や Windows フォームなど、他の Microsoft プログラミングモデルのタグプロパティに似ています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-671">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="1fb7d-672">これは、アプリケーション開発者がサブクラス化を強制せずに、任意の要素に関する基本的なカスタム情報を格納するための既存の場所を提供することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-672">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="1fb7d-673">XAML 値</span><span class="sxs-lookup"><span data-stu-id="1fb7d-673">XAML Values</span></span>  
 <span data-ttu-id="1fb7d-674">このプロパティはオブジェクトを取得するため、XAML の <xref:System.Windows.FrameworkContentElement.Tag%2A> プロパティを、既知の組み込み型コンバーター (文字列など) を持つオブジェクト以外のものに設定するには、プロパティ要素の使用法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-674">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="1fb7d-675">この方法で使用されるオブジェクトは、通常、標準の WPF 名前空間内にはないため、XAML 要素として導入されるためには、外部名前空間への名前空間マッピングが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-675">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-676">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-676">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-677">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-677">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="1fb7d-678">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-678">Metadata properties set to `true`</span></span>|<span data-ttu-id="1fb7d-679">なし</span><span class="sxs-lookup"><span data-stu-id="1fb7d-679">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-680"><see cref="P:System.Windows.FrameworkContentElement.Tag" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-680">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-681">この要素のバインドに関連する対象プロパティが変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-681">Occurs when any associated target property participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-682">このイベントは、この要素に関連付けられている <xref:System.Windows.Data.Binding> によって発生する <xref:System.Windows.Data.Binding.TargetUpdated> イベントを示します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-682">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="1fb7d-683">これは通常、問題のバインディングが双方向のバインディングであり、バインドされた依存関係プロパティが、プロパティがサポートする検証またはキャッシュスキームごとに、前のプロパティ値の無効化をものしていることを意味します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-683">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="1fb7d-684">このイベントのイベント引数は、どのバインドプロパティが変更されたかを通知します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-684">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="1fb7d-685">XAML 属性の使用方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-685">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-686">この要素の親テンプレートへの参照を取得します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-686">Gets a reference to the template parent of this element.</span></span> <span data-ttu-id="1fb7d-687">このプロパティは、要素がテンプレートによって作成されていない場合は無効です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-687">This property is not relevant if the element was not created through a template.</span></span></summary>
        <value><span data-ttu-id="1fb7d-688">この要素が作成される原因となった <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> が属する要素。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-688">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span></span> <span data-ttu-id="1fb7d-689">この値は、 <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-689">This value is frequently <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-690">テンプレートは実際には共有オブジェクトであり、テンプレートの内容は一度だけ作成されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-690">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="1fb7d-691">したがって、テンプレートからの要素へのオブジェクト参照を取得した場合、見かけ上の論理ツリーがページルートに届かないことがあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-691">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="1fb7d-692">このようなテンプレート参照をページの論理ツリーに接続するには、<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 値を取得し、必要に応じてその要素ツリー内を移動し続ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-692">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="1fb7d-693">一般的な方法によってアプリケーションのページからオブジェクト参照を取得した場合、その要素はテンプレートから作成されていない可能性があるため、多くの場合、共通のオブジェクトに対して <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> が `null` されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-693"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="1fb7d-694"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> が `null` されていない場合は、ヒットテスト、特定の低レベルの入力イベントのイベント処理、列挙子の操作などの操作を含み、テンプレートから返された要素を返すことがあります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-694">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-695">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] でこの要素に対して表示されるツールヒント オブジェクトを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-695">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><span data-ttu-id="1fb7d-696">ツールヒント オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-696">The tooltip object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-697">このプロパティの値が <xref:System.Windows.Controls.ToolTip>型である場合、これは [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]で使用されるツールヒントです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-697">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="1fb7d-698">値が他の型の場合は、その値がシステムによって提供 (構築) される <xref:System.Windows.Controls.ToolTip> の*コンテンツ*として使用されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-698">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="1fb7d-699">詳細については、「<xref:System.Windows.Controls.ToolTipService>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-699">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="1fb7d-700">サービスクラスには、ツールヒントをさらにカスタマイズするために使用できる添付プロパティが用意されています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-700">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="1fb7d-701">XAML 属性の使用方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-701">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="1fb7d-702">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="1fb7d-702">XAML Property Element Usage</span></span>  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
```

<span data-ttu-id="1fb7d-703">- または -</span><span class="sxs-lookup"><span data-stu-id="1fb7d-703">-or-</span></span>

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```

<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="1fb7d-704">XAML 値</span><span class="sxs-lookup"><span data-stu-id="1fb7d-704">XAML Values</span></span>  
 <span data-ttu-id="1fb7d-705">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-705">*toolTipContent*</span></span>  
 <span data-ttu-id="1fb7d-706"><xref:System.Windows.FrameworkContentElement.ToolTip%2A>の表示テキストになる文字列。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-706">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="1fb7d-707">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="1fb7d-707">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="1fb7d-708">オブジェクト要素の形式で提供される、<xref:System.Windows.FrameworkContentElement> のコンテンツとして使用されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-708">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="1fb7d-709">通常、これは <xref:System.Windows.FrameworkElement> またはその他の要素の1つであり、最終的には複合内のテキストコンテンツを含む、<xref:System.Windows.FrameworkContentElement.ToolTip%2A>のレイアウトの複合を作成します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-709">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="1fb7d-710">この使用法では、<xref:System.Windows.Controls.ToolTip> 要素が解析された [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]から暗黙的に作成され、 *toolTipObjectContent*コンテンツがその <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> プロパティとして設定されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-710">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="1fb7d-711"><`ToolTip`.../></span><span class="sxs-lookup"><span data-stu-id="1fb7d-711"><`ToolTip` .../></span></span>  
 <span data-ttu-id="1fb7d-712">以下を参照してください。<xref:System.Windows.Controls.ToolTip></span><span class="sxs-lookup"><span data-stu-id="1fb7d-712">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="1fb7d-713">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-713">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-714">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-714">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="1fb7d-715">メタデータプロパティが `true` に設定される</span><span class="sxs-lookup"><span data-stu-id="1fb7d-715">Metadata properties set to `true`</span></span>|<span data-ttu-id="1fb7d-716">なし</span><span class="sxs-lookup"><span data-stu-id="1fb7d-716">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-717">次の例では、<xref:System.Windows.FrameworkElement.ToolTip%2A> プロパティの値を文字列に直接設定します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-717">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-718">要素のツールヒントが閉じる直前に発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-718">Occurs just before any tooltip on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-719">ツールヒントを閉じないようにするには、イベントのハンドラーがハンドラーを処理済みとしてマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-719">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="1fb7d-720">このイベントは、スタイルの <xref:System.Windows.EventTrigger> にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-720">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="1fb7d-721">これは、このイベントの識別子フィールドが、イベントの add/remove メソッドを公開しないサービスからの実装を再使用するためです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-721">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="1fb7d-722">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-722">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-723">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-723">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="1fb7d-724">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-724">Routing strategy</span></span>|<span data-ttu-id="1fb7d-725">直接</span><span class="sxs-lookup"><span data-stu-id="1fb7d-725">Direct</span></span>|  
|<span data-ttu-id="1fb7d-726">Delegate</span><span class="sxs-lookup"><span data-stu-id="1fb7d-726">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-727"><see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> ([Routed Events Overview (ルーティング イベントの概要)](~/docs/framework/wpf/advanced/routed-events-overview.md)) を識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-727">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-728">イベント識別子オブジェクトは、ルーティングイベントが登録されたときに作成され (<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照)、クラスハンドラーを追加するために使用できます (「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-728">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="1fb7d-729">識別子オブジェクトには、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-729">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-730">要素のツールヒントが開かれたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-730">Occurs when any tooltip on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-731">ツールヒントを手動で開くには、イベントのハンドラーが関連するイベントを処理済みとしてマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-731">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="1fb7d-732">それ以外の場合は、[<xref:System.Windows.FrameworkContentElement.ToolTip%2A>] プロパティの値を使用して、コンテキストメニューを自動的に開きます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-732">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="1fb7d-733">イベントを処理済みとしてマークすると、既定のアクションが実質的にキャンセルされます。また、<xref:System.Windows.FrameworkContentElement.ToolTip%2A> プロパティの値をリセットし、新しい <xref:System.Windows.Controls.ContextMenu>を開くことができます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-733">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="1fb7d-734"><xref:System.Windows.FrameworkContentElement.ToolTip%2A> が null 参照である場合、または設定が解除されている場合は、このイベントは発生しないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-734">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="1fb7d-735">このイベントは、スタイルの <xref:System.Windows.EventTrigger> にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-735">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="1fb7d-736">これは、このイベントの識別子フィールドが、イベントの add/remove メソッドを公開しないサービスからの実装を再使用するためです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-736">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="1fb7d-737">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-737">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-738">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-738">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="1fb7d-739">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-739">Routing strategy</span></span>|<span data-ttu-id="1fb7d-740">直接</span><span class="sxs-lookup"><span data-stu-id="1fb7d-740">Direct</span></span>|  
|<span data-ttu-id="1fb7d-741">Delegate</span><span class="sxs-lookup"><span data-stu-id="1fb7d-741">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-742"><see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> ([Routed Events Overview (ルーティング イベントの概要)](~/docs/framework/wpf/advanced/routed-events-overview.md)) を識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-742">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-743">イベント識別子オブジェクトは、ルーティングイベントが登録されたときに作成され (<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照)、クラスハンドラーを追加するために使用できます (「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-743">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="1fb7d-744">識別子オブジェクトには、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-744">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-745"><see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-745">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="1fb7d-746">検索するリソースのキー識別子。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-746">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="1fb7d-747">指定されたキーを使用してリソースを検索し、見つかった場合はそのリソースを返します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-747">Searches for a resource with the specified key, and returns that resource if found.</span></span></summary>
        <returns><span data-ttu-id="1fb7d-748">見つかったリソース。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-748">The found resource.</span></span> <span data-ttu-id="1fb7d-749">リソースが見つからなかった場合は、<see langword="null" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-749">If no resource was found, <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-750">リソースが呼び出し元の要素で見つからない場合、論理ツリーを使用して親ツリーが検索されます。これは、実行時にキーによって動的リソース参照が要求された場合に、ツリーが検索されるのと同じです。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-750">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="1fb7d-751">通常は、返されたリソース値を使用して設定しようとしていたプロパティの型に戻り値を直ちにキャストします。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-751">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="1fb7d-752"><xref:System.Windows.FrameworkContentElement.FindResource%2A> メソッドの動作は似ていますが、指定されたキーを持つリソースが見つからない場合に例外がスローされる点が異なります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-752">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1fb7d-753">次の例では、マークアップで定義されたリソースを検索し、ルーティングイベントへの応答として、要素の特定のプロパティに適用します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-753">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-754">読み込まれた要素の要素ツリーから要素が削除されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-754">Occurs when the element is removed from an element tree of loaded elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-755">ダイレクトルーティングイベントはルートに従わないので、これらのイベントは、発生したものと同じ要素内でのみ処理されます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-755">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="1fb7d-756">直接ルーティングイベントでは、他のルーティングイベントの動作がサポートされます。これらは、アクセス可能なハンドラーコレクションをサポートし、スタイルの <xref:System.Windows.EventTrigger> として使用できます。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-756">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="1fb7d-757">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="1fb7d-757">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="1fb7d-758">識別子フィールド</span><span class="sxs-lookup"><span data-stu-id="1fb7d-758">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="1fb7d-759">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="1fb7d-759">Routing strategy</span></span>|<span data-ttu-id="1fb7d-760">直接</span><span class="sxs-lookup"><span data-stu-id="1fb7d-760">Direct</span></span>|  
|<span data-ttu-id="1fb7d-761">Delegate</span><span class="sxs-lookup"><span data-stu-id="1fb7d-761">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1fb7d-762"><see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> ([Routed Events Overview (ルーティング イベントの概要)](~/docs/framework/wpf/advanced/routed-events-overview.md)) を識別します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-762">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-763">イベント識別子オブジェクトは、ルーティングイベントが登録されたときに作成され (<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照)、クラスハンドラーを追加するために使用できます (「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-763">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="1fb7d-764">識別子オブジェクトには、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-764">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1fb7d-765">現在のスコープから削除する名前とオブジェクトのペアの名前。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-765">Name of the name-object pair to remove from the current scope.</span></span></param>
        <summary><span data-ttu-id="1fb7d-766"><see cref="T:System.Windows.NameScope" /> の登録解除メソッドへのアクセスを簡略化します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-766">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1fb7d-767">同じ名前の別の要素を再登録する場合にのみ、名前を登録解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-767">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1fb7d-768">現在の <see cref="T:System.Windows.FrameworkContentElement" /> に既定のスタイルを再度適用します。</span><span class="sxs-lookup"><span data-stu-id="1fb7d-768">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
