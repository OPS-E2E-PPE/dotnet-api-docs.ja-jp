<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a317628ea2cfbb0ebc91749a076d6d2cd0d348d2" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83478285" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface ISupportInitialize&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>WPF フレームワーク レベルのプロパティ、イベント、およびメソッドのセットを Windows Presentation Foundation (WPF) 要素で利用できます。 このクラスは WPF フレームワーク レベルの実装として用意されており、<see cref="T:System.Windows.UIElement" /> によって定義される WPF コア レベル API 上に構築されています。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> は、WPF フレームワークレベルの要素クラスと WPF のコアレベルの <xref:System.Windows.UIElement> presentation services のセットとの間の接続ポイントです。 これらの概念の詳細については、「 [WPF のアーキテクチャ](~/docs/framework/wpf/advanced/wpf-architecture.md)」を参照してください。  
  
 <xref:System.Windows.FrameworkElement> によって <xref:System.Windows.UIElement> が拡張され、次の機能が追加されます。  
  
-   **レイアウトシステム定義**: <xref:System.Windows.FrameworkElement> <xref:System.Windows.UIElement>で仮想メンバーとして定義された特定のメソッドに対して、特定の WPF フレームワークレベルの実装を提供します。 特に、特定の WPF コアレベルのレイアウトオーバーライドをシールし、代わりに、派生クラスでオーバーライドする必要がある WPF フレームワークレベルの同等の <xref:System.Windows.FrameworkElement> を提供します。 たとえば <xref:System.Windows.FrameworkElement> は <xref:System.Windows.UIElement.ArrangeCore%2A> シールされていますが <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>を提供しています。 これらの変更は、WPF フレームワークレベルで、<xref:System.Windows.FrameworkElement> 派生クラスをレンダリングできる完全なレイアウトシステムが配置されていることを反映しています。 WPF のコアレベルでは、一般的な [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ベースのレイアウトソリューションを構築する特定のメンバーが配置されていますが、レイアウトシステムの実際のエンジンは定義されていません。 詳細については、「[Layout](~/docs/framework/wpf/advanced/layout.md)」 (レイアウト) を参照してください。  
  
-   **論理ツリー:** 一般的な [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プログラミングモデルは、多くの場合、要素のツリーとして表現されます。 要素のツリーを論理ツリーとして表現できるようになり、マークアップでそのツリーを定義するためのサポートが <xref:System.Windows.FrameworkElement> レベルで実装されます。 ただし <xref:System.Windows.FrameworkElement> は意図的にコンテンツモデルを定義しないため、派生クラスにその責任を残します。 詳細については、「[WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。  
  
-   **オブジェクトの有効期間イベント:** 多くの場合、要素がいつ初期化されるか (コンストラクターが呼び出されます)、または要素が最初に論理ツリーに読み込まれるタイミングを知ることが役立ちます。 <xref:System.Windows.FrameworkElement> は、オブジェクトの有効期間に関連するいくつかのイベントを定義します。これにより、子要素の追加など、要素を含む分離コード操作に便利なフックが提供されます。 詳細については、「[オブジェクトの有効期間イベント](~/docs/framework/wpf/advanced/object-lifetime-events.md)」を参照してください。  
  
-   **データバインディングと動的リソース参照のサポート:** データバインディングとリソースのプロパティレベルのサポートは <xref:System.Windows.DependencyProperty> クラスによって実装され、プロパティシステムに組み込まれていますが、<xref:System.Windows.Expression> として格納されているメンバー値を解決する機能 (データバインディングと動的リソースの両方の基になるプログラミング構成要素) は <xref:System.Windows.FrameworkElement>によって実装されます。 詳細については、「[データバインディングの概要](~/docs/framework/wpf/data/data-binding-overview.md)」と「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
-   **Styles:** <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement.Style%2A> プロパティを定義します。 ただし、<xref:System.Windows.FrameworkElement> では、テンプレートのサポートがまだ定義されていないか、デコレーターをサポートしていません。 これらの機能は、<xref:System.Windows.Controls.Control> や <xref:System.Windows.Controls.ContentControl>などのコントロールクラスによって導入されています。  
  
-   **その他のアニメーションのサポート:** 一部のアニメーションサポートは WPF コアレベルで既に定義されていますが、<xref:System.Windows.FrameworkElement.BeginStoryboard%2A> および関連するメンバーを実装することによって、これを拡張 <xref:System.Windows.FrameworkElement> ます。  
  
 クラス階層からわかるように、多くの [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] クラスは、直接、または <xref:System.Windows.Controls.Panel> や <xref:System.Windows.Controls.Control>などの中間基本クラスを使用して <xref:System.Windows.FrameworkElement>から派生します。  
  
 <xref:System.Windows.FrameworkElement> を基底クラスとして使用する場合は、最初に既存の派生クラスを確認することをお勧めします。 <xref:System.Windows.FrameworkElement> では、いくつかの基本的なシナリオがサポートされますが、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]で [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] を作成するために使用するビルディングブロックの意味では、"要素" に適した多くの機能がありません。 たとえば、<xref:System.Windows.FrameworkElement> は真のコンテンツモデルを定義していません。基底クラスとして <xref:System.Windows.FrameworkElement>、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 子要素を作成できるプロパティは定義しません。 特に、<xref:System.Windows.Controls.Control> と <xref:System.Windows.Controls.ContentControl>を確認することが必要になる場合があります。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画時の高さを取得します。</summary>
        <value>要素の高さ ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] の値)。 既定値は 0 (ゼロ) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、他の高さ入力に基づいて計算された値であり、レイアウトシステムです。 値は、実際のレンダリングパスに基づいてレイアウトシステム自体によって設定されます。したがって、入力の変更の基礎となる <xref:System.Windows.FrameworkElement.Height%2A> などのプロパティの設定値よりも少し遅れが生じることがあります。  
  
 <xref:System.Windows.FrameworkElement.ActualHeight%2A> は計算された値であるため、レイアウトシステムによるさまざまな操作の結果として、複数の変更が報告される可能性があることに注意する必要があります。 レイアウト システムが、子要素に必要な測定スペース、親要素による制約などを計算している場合があります。  
  
 このプロパティを [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]から設定することはできませんが、スタイルの値に基づいて <xref:System.Windows.Trigger> を作成することはできます。  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、さまざまな高さのプロパティを表示します。  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画時の幅を取得します。</summary>
        <value>要素の幅 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] の値)。 既定値は 0 (ゼロ) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、他の幅入力とレイアウトシステムに基づく計算値です。 値は、実際のレンダリングパスに基づいてレイアウトシステム自体によって設定されます。したがって、入力の変更の基礎となる <xref:System.Windows.FrameworkElement.Width%2A> などのプロパティの設定値よりも少し遅れが生じることがあります。  
  
 <xref:System.Windows.FrameworkElement.ActualWidth%2A> は計算された値であるため、レイアウトシステムによるさまざまな操作の結果として、複数の変更が報告される可能性があることに注意する必要があります。 レイアウト システムが、子要素に必要な測定スペース、親要素による制約などを計算している場合があります。  
  
 このプロパティを [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]から設定することはできませんが、スタイルの値に基づいて <xref:System.Windows.Trigger> を作成することはできます。  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、さまざまな幅のプロパティを表示します。  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">追加される子要素。</param>
        <summary>指定したオブジェクトをこの要素の論理ツリーに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、要素の論理上の子要素を表すオブジェクトのコレクションの実装に使用します。 子要素コレクションのコレクションのメンテナンスは、プロパティの getter または setter、変更されたイベントのクラス処理、コンストラクター、またはコレクション型自体で行うことができます。  
  
 コントロールの作成者にとっては、このレベルで論理ツリーを操作することは推奨されません。ただし、使用できる基本コントロールクラスのコンテンツモデルが制御シナリオに適していない場合は除きます。 <xref:System.Windows.Controls.ContentControl>、<xref:System.Windows.Controls.ItemsControl>、および <xref:System.Windows.Controls.HeaderedItemsControl>のレベルでサブクラス化することを検討してください。 これらのクラスは、専用の Api を使用して論理ツリーの子要素を適用するコンテンツモデルを提供します。また、テンプレートを使用したスタイル設定などの [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 制御で通常は望ましい他の機能をサポートします。 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> と <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>の使用方法の詳細については、「 [WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。  
  
 論理ツリーが別のプロセスによって反復処理されている場合に、<xref:System.Windows.FrameworkElement.AddLogicalChild%2A> が例外をスローすることがあります。  
  
   
  
## Examples  
 次の例では、独自のビジュアル層実装を行うカスタム <xref:System.Windows.FrameworkElement> の `Child` プロパティを実装しています。 プロパティセッターは、値が変更された場合に、クラス固有のビジュアルコレクションだけでなく、論理ツリーから古い値が削除されるように設計されています。 プロパティ値がキャッシュされ、新しい値が論理ツリーとカスタムビジュアルコレクションの両方に追加されます。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>必要に応じて現在のテンプレートのビジュアル ツリーを構築し、この呼び出しによってビジュアル ツリーが再構築されたかどうかを示す値を返します。</summary>
        <returns>ビジュアルがツリーに追加された場合は <see langword="true" />、それ以外の場合は <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションはこのメソッドを呼び出して、要素のビジュアルツリーが完全であることを保証できます。 この保証手順は、コードがツリー内の子要素をチェックする場合に必要になることがあります。 アプリケーション内の一般的な要素ロジックでは、テンプレートが有効期間内の適切な位置にある要素に自動的に適用されるため、<xref:System.Windows.FrameworkElement.ApplyTemplate%2A> を呼び出す必要はありません。  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> は、WPF フレームワークレベルのレイアウトシステムによって、すべてのメジャーパスで呼び出されます。  
  
 派生クラスは、<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> クラスハンドラーを使用して、このメソッドが明示的に呼び出された場合、またはレイアウトシステムによって呼び出された場合に通知を受け取ることができ <xref:System.Windows.FrameworkElement> ます。 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> は、テンプレートが完全に生成され、論理ツリーにアタッチされた後に呼び出されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">この要素が要素自体と子を配置するために使用する親の末尾の領域。</param>
        <summary><see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (<see cref="T:System.Windows.UIElement" /> で仮想メソッドとして定義されています) を実装し、その実装をシールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはシールされています。 要素のレイアウトの配置パス専用にカスタム要素のロジックをオーバーライドするには、<xref:System.Windows.FrameworkElement> 派生クラスで <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>をオーバーライドする必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">この要素が要素自体と子を配置するために使用する親の末尾の領域。</param>
        <summary>派生クラスでオーバーライドされると、子要素を配置し、<see cref="T:System.Windows.FrameworkElement" /> 派生クラスのサイズを決定します。</summary>
        <returns>使用する実際のサイズ。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>レイアウト処理の配置パスをカスタマイズするコントロールの作成者は、このメソッドをオーバーライドする必要があります。 実装パターンでは、表示されている各子要素の <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> を呼び出し、各子要素の最終的な目的のサイズを <paramref name="finalRect" /> パラメーターとして渡す必要があります。 親要素は各子の <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> を呼び出す必要があります。そうしないと、子要素はレンダリングされません。  
  
多くの派生クラスは、このメソッドの実装を提供します。 目立つのは、<see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />、<see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />、<see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />です。</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素の初期化プロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、要素を要素ツリーにまだ公開したり接続したりしない方法で調整する場合に、個々の要素に対して呼び出すことができます。 たとえば、新しい <xref:System.Windows.FrameworkElement>を作成しても、まだ論理ツリーにアタッチしていない可能性があります。 または、要素が子要素である論理ツリーが、アプリケーションのウィンドウまたはページに接続されていない可能性があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>要素の読み込みプロセス中に要素が初期化される前に発生する特別な処理を提供するには、このメソッドを実装します。  
  
基本 (既定) の実装では初期化を追跡する内部フラグが設定されるため、実装では基本実装を呼び出す必要があります。 考えられる1つの実装は、コンストラクターによって既に有効にされていない独自のプライベートクラス初期化ルーチンへのフックとして、このメソッドを使用することです。  
  
<see cref="M:System.Windows.FrameworkElement.EndInit" /> が呼び出される前に、同じ要素で <see cref="M:System.Windows.FrameworkElement.BeginInit" /> が複数回呼び出された場合、基本実装では例外がスローされます。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリーボード。</param>
        <summary>指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的なアニメーションのシナリオでは、この方法は使用しません。 通常は、マークアップで <xref:System.Windows.Media.Animation.Storyboard> または <xref:System.Windows.Media.Animation.BeginStoryboard> 要素を作成し、次に要素の <xref:System.Windows.EventTrigger> コンテンツとして配置します。 イベントによってトリガーされると、アニメーションが実行されます。 <xref:System.Windows.Media.Animation.Storyboard> の制御側面の大部分は、マークアップで公開されているプロパティによって対処できます。  
  
 `isControllable`、パラメーターを使用しない署名、またはそのパラメーターが `false`指定されている場合は、アニメーションが "塗りつぶし" の期間に達するとすぐに、アニメーションに関連付けられているタイムラインの時計が削除されます。 そのため、1回実行した後にアニメーションを再起動することはできません。 アニメーションを制御するには、ストーリーボードが[X:Name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)を持つか、コード内で参照によってアクセスできる必要もあります。  
  
   
  
## Examples  
 次の例では、リソースから <xref:System.Windows.Media.Animation.Storyboard> を取得し、内部イベントがクラスで処理されたときにその <xref:System.Windows.Media.Animation.Storyboard> を実行します。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリーボード。</param>
        <param name="handoffBehavior">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙値。</param>
        <summary>プロパティが既にアニメーション化されていた場合にどうするかを指定するオプションを使用して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的なアニメーションのシナリオでは、この方法は使用しません。 通常は、マークアップで <xref:System.Windows.Media.Animation.Storyboard> または <xref:System.Windows.Media.Animation.BeginStoryboard> 要素を作成し、次に要素の <xref:System.Windows.EventTrigger> コンテンツとして配置します。 イベントによってトリガーされると、アニメーションが実行されます。 <xref:System.Windows.Media.Animation.Storyboard> の制御側面の大部分は、マークアップで公開されているプロパティによって対処できます。  
  
 `isControllable`、パラメーターを使用しない署名、またはそのパラメーターが `false`指定されている場合は、アニメーションが "塗りつぶし" の期間に達するとすぐに、アニメーションに関連付けられているタイムラインの時計が削除されます。 そのため、1回実行した後にアニメーションを再起動することはできません。 アニメーションを制御するには、ストーリーボードが[X:Name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)を持つか、コード内で参照によってアクセスできる必要もあります。  
  
 ハンドオフ動作は、<xref:System.Windows.Media.Animation.BeginStoryboard>の属性として指定できます。  
  
## <a name="using-the-compose-handoffbehavior"></a>作成 HandoffBehavior の使用  
 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>を使用して <xref:System.Windows.Media.Animation.Storyboard>、<xref:System.Windows.Media.Animation.AnimationTimeline>、または <xref:System.Windows.Media.Animation.AnimationClock> をプロパティに適用すると、そのプロパティに以前関連付けられていたすべての <xref:System.Windows.Media.Animation.Clock> オブジェクトが引き続きシステムリソースを消費します。タイミングシステムは、クロックを自動的に削除しません。  
  
 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>を使用して多数のクロックを適用するときのパフォーマンスの問題を回避するには、アニメーション化されたプロパティから完成したクロックを削除する必要があります。 クロックを削除するには、いくつかの方法があります。  
  
-   プロパティからすべてのクロックを削除するには、アニメーション化されたオブジェクトの <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> または <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> メソッドを使用します。 最初のパラメーターとしてアニメーション化するプロパティを指定し、2番目のパラメーターとして `null` します。 これにより、プロパティからすべてのアニメーションクロックが削除されます。  
  
-   特定の <xref:System.Windows.Media.Animation.AnimationClock> をクロックの一覧から削除するには、<xref:System.Windows.Media.Animation.AnimationClock> の <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティを使用して <xref:System.Windows.Media.Animation.ClockController>を取得し、次に <xref:System.Windows.Media.Animation.ClockController.Remove%2A> の <xref:System.Windows.Media.Animation.ClockController>メソッドを呼び出します。 これは通常、クロックの <xref:System.Windows.Media.Animation.Clock.Completed> イベントハンドラーで実行されます。 <xref:System.Windows.Media.Animation.ClockController>によって制御できるのはルートクロックのみであることに注意してください。子クロックの <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティは `null`を返します。 また、クロックの有効期間が無期限の場合は、<xref:System.Windows.Media.Animation.Clock.Completed> イベントが発生しないことにも注意してください。  その場合、ユーザーは <xref:System.Windows.Media.Animation.ClockController.Remove%2A>を呼び出すタイミングを決定する必要があります。  
  
 これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。  オブジェクトがガベージコレクションされると、そのクロックも切断され、ガベージコレクトされます。  
  
 クロックオブジェクトの詳細については、「[アニメーションとタイミングシステムの概要](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、リソースから <xref:System.Windows.Media.Animation.Storyboard> を取得し、内部イベントがクラスで処理されたときにその <xref:System.Windows.Media.Animation.Storyboard> を実行します。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリーボード。</param>
        <param name="handoffBehavior">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙値。</param>
        <param name="isControllable">アニメーションを起動した後に、アニメーションを制御できるかどうか (一時停止できるかどうか) を宣言します。</param>
        <summary>開始後のアニメーションの制御の状態を指定して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的なアニメーションのシナリオでは、この方法は使用しません。 通常は、マークアップで <xref:System.Windows.Media.Animation.Storyboard> または <xref:System.Windows.Media.Animation.BeginStoryboard> 要素を作成し、次に要素の <xref:System.Windows.EventTrigger> コンテンツとして配置します。 イベントによってトリガーされると、アニメーションが実行されます。 <xref:System.Windows.Media.Animation.Storyboard> の制御側面の大部分は、マークアップで公開されているプロパティによって対処できます。  
  
 `isControllable`、パラメーターを使用しない署名、またはそのパラメーターが `false`指定されている場合は、アニメーションが "塗りつぶし" の期間に達するとすぐに、アニメーションに関連付けられているタイムラインの時計が削除されます。 そのため、1回実行した後にアニメーションを再起動することはできません。 アニメーションを制御するには、ストーリーボードが[X:Name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)を持つか、コード内で参照によってアクセスできる必要もあります。  
  
 ハンドオフ動作は、<xref:System.Windows.Media.Animation.BeginStoryboard>の属性として指定できます。  
  
## <a name="using-the-compose-handoffbehavior"></a>作成 HandoffBehavior の使用  
 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>を使用して <xref:System.Windows.Media.Animation.Storyboard>、<xref:System.Windows.Media.Animation.AnimationTimeline>、または <xref:System.Windows.Media.Animation.AnimationClock> をプロパティに適用すると、そのプロパティに以前関連付けられていたすべての <xref:System.Windows.Media.Animation.Clock> オブジェクトが引き続きシステムリソースを消費します。タイミングシステムは、クロックを自動的に削除しません。  
  
 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>を使用して多数のクロックを適用するときのパフォーマンスの問題を回避するには、アニメーション化されたプロパティから完成したクロックを削除する必要があります。 クロックを削除するには、いくつかの方法があります。  
  
-   プロパティからすべてのクロックを削除するには、アニメーション化されたオブジェクトの <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> または <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> メソッドを使用します。 最初のパラメーターとしてアニメーション化するプロパティを指定し、2番目のパラメーターとして `null` します。 これにより、プロパティからすべてのアニメーションクロックが削除されます。  
  
-   特定の <xref:System.Windows.Media.Animation.AnimationClock> をクロックの一覧から削除するには、<xref:System.Windows.Media.Animation.AnimationClock> の <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティを使用して <xref:System.Windows.Media.Animation.ClockController>を取得し、次に <xref:System.Windows.Media.Animation.ClockController.Remove%2A> の <xref:System.Windows.Media.Animation.ClockController>メソッドを呼び出します。 これは通常、クロックの <xref:System.Windows.Media.Animation.Clock.Completed> イベントハンドラーで実行されます。 <xref:System.Windows.Media.Animation.ClockController>によって制御できるのはルートクロックのみであることに注意してください。子クロックの <xref:System.Windows.Media.Animation.Clock.Controller%2A> プロパティは `null`を返します。 また、クロックの有効期間が無期限の場合は、<xref:System.Windows.Media.Animation.Clock.Completed> イベントが発生しないことにも注意してください。  その場合、ユーザーは <xref:System.Windows.Media.Animation.ClockController.Remove%2A>を呼び出すタイミングを決定する必要があります。  
  
 これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。  オブジェクトがガベージコレクションされると、そのクロックも切断され、ガベージコレクトされます。  
  
 クロックオブジェクトの詳細については、「[アニメーションとタイミングシステムの概要](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素に使用される <see cref="T:System.Windows.Data.BindingGroup" /> を取得または設定します。</summary>
        <value>要素に使用される <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> を使用すると、オブジェクトの複数のプロパティの値を検証できます。 たとえば、ユーザーにアドレスを入力するように求めるメッセージが表示され、`Address`型のオブジェクトが設定されているとします。このオブジェクトには、`Street`、`City`、`ZipCode`、`Country`というプロパティがユーザーが指定した値と共に格納されます。 このアプリケーションには、4つの <xref:System.Windows.Controls.TextBox> コントロールを含むパネルがあり、それぞれがオブジェクトのプロパティの1つにバインドされています。 <xref:System.Windows.Data.BindingGroup> 内の <xref:System.Windows.Controls.ValidationRule> を使用して、`Address` オブジェクトを検証できます。 たとえば、<xref:System.Windows.Controls.ValidationRule> は、住所の国/地域に対して郵便番号が有効であることを確認できます。  
  
 子要素は、他の継承可能なプロパティと同様に、親要素から <xref:System.Windows.Data.BindingGroup> を継承します。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、ユーザーが2つのオブジェクトのプロパティを等しい値に設定したかどうかを確認するアプリケーションの一部です。 最初の例では、2つの <xref:System.Windows.Controls.TextBox> コントロールを作成し、それぞれが異なるデータソースにバインドされます。 <xref:System.Windows.Controls.StackPanel> には、2つの文字列が等しいことを確認する <xref:System.Windows.Controls.ValidationRule> を含む <xref:System.Windows.Data.BindingGroup> があります。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 次の例では、前の例で使用している <xref:System.Windows.Controls.ValidationRule> を示します。  <xref:System.Windows.Controls.ValidationRule.Validate%2A> メソッドのオーバーライドでは、この例では <xref:System.Windows.Data.BindingGroup> から各ソースオブジェクトを取得し、オブジェクトのプロパティが等しいかどうかを確認します。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 <xref:System.Windows.Controls.ValidationRule>を呼び出すには、<xref:System.Windows.Data.BindingGroup.UpdateSources%2A> メソッドを呼び出します。  次の例では、ボタンの click イベントが発生したときに <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> を呼び出します。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.BindingGroup" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素が含まれているスクロール可能な領域内に、この要素を表示することを試みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素が含まれているスクロール可能な領域内に、この要素を表示することを試みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すと、現在の要素を起点とする <xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントが発生します。 このイベントは、<xref:System.Windows.Controls.ScrollViewer>、または派生または類似のクラスによって処理できるように生成されます。 期待される動作は、イベントが親要素によって処理され、イベントデータで処理されたとマークされ、イベントのソースが <xref:System.Windows.Controls.ScrollViewer> コントロールに埋め込まれたロジックを通じて表示されることです。 <xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントも <xref:System.Windows.FrameworkElement.BringIntoView%2A> メソッドも、成功または失敗に関する情報を送信しません。これに対して、イベントは通常、成功時に処理済みとしてマークされます。 失敗の理由には、<xref:System.Windows.Visibility.Visible>以外の値の <xref:System.Windows.UIElement.Visibility%2A> など、要素の設定を含めることができます。  
  
 `targetRectangle`を指定しない署名を使用すると、要素のサイズ全体 (<xref:System.Windows.UIElement.RenderSize%2A>) が表示されます。  
  
 このメソッドを呼び出すと、要素を含む任意の親のスクロール可能な領域で <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> が呼び出される可能性があります。 この要素がスクロール可能な領域に含まれていない場合でも、<xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントは発生しますが、イベントリスナーが存在しないため、効果はありません。  
  
   
  
## Examples  
 次の例では、移動先の URI (uniform resource identifier) にフラグメントが含まれている場合に常に応答するアプリケーションナビゲーションイベントのハンドラーを実装しています。 このフラグメントは、ハッシュ記号 (#) に続く URI で名前が付けられ、実装されている動作によって、要素がフレーム内でスクロールされます。 この例では、<xref:System.Windows.FrameworkElement.BringIntoView%2A> と <xref:System.Windows.FrameworkElement.RequestBringIntoView> がスクロール動作を要求します。  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">指定した、表示する必要がある要素のサイズ。</param>
        <summary>この要素が含まれているスクロール可能な領域内で、この要素の指定したサイズの領域が表示されるように試みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すと、現在の要素を起点とする <xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントが発生します。 このイベントは、<xref:System.Windows.Controls.ScrollViewer>、または派生または類似のクラスによって処理できるように生成されます。 期待される動作は、イベントが親要素によって処理され、イベントデータで処理されたとマークされ、イベントのソースが <xref:System.Windows.Controls.ScrollViewer> コントロールに埋め込まれたロジックを通じて表示されることです。 <xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントも <xref:System.Windows.FrameworkElement.BringIntoView%2A> メソッドも、成功または失敗に関する情報を送信しません。これに対して、イベントは通常、成功時に処理済みとしてマークされます。 失敗の理由には、<xref:System.Windows.Visibility.Visible>以外の値の <xref:System.Windows.UIElement.Visibility%2A> など、要素の設定を含めることができます。  
  
 `targetRectangle`を指定しない署名を使用すると、要素のサイズ全体 (<xref:System.Windows.UIElement.RenderSize%2A>) が表示されます。  
  
 このメソッドを呼び出すと、要素を含む任意の親のスクロール可能な領域で <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> が呼び出される可能性があります。 この要素がスクロール可能な領域に含まれていない場合でも、<xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントは発生しますが、イベントリスナーが存在しないため、効果はありません。  
  
   
  
## Examples  
 次の例では、制約されたスクロール領域に大きなグラフィックがあります。 ページ上のボタンには、ビューを大きなグラフィックの特定の領域にスクロールするハンドラーがあります。  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素内から [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] によってコンテキスト メニューが要求された場合に常に表示されるコンテキスト メニュー要素を取得または設定します。</summary>
        <value>この要素に割り当てられたコンテキスト メニュー。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> 自体は <xref:System.Windows.FrameworkElement> 派生クラスであり、<xref:System.Windows.Controls.ContextMenu> 自体が <xref:System.Windows.FrameworkElement.ContextMenu%2A> プロパティを持つことができます。 ただし、これによりユーザーにとってわかりにくいコンテキストメニューエクスペリエンスが作成されるため、この方法はお勧めしません。  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のコンテキスト メニューが閉じる直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテキストメニューを終了しないようにするには、イベントのハンドラーがそれを処理済みとしてマークする必要があります。  
  
 このイベントをスタイルの <xref:System.Windows.EventTrigger> として使用するには、イベントの基になるサービスの定義を参照する必要があります。  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (この使用方法が必要になるのは、基になるサービスイベントを公開する <xref:System.Windows.FrameworkElement> のイベント実装が、トリガーとして使用できるように <xref:System.Windows.FrameworkElement.ContextMenuClosing> 識別子をマップしないためです)。  
  
 <xref:System.Windows.Controls.ContextMenu> 自体は <xref:System.Windows.FrameworkElement> 派生クラスですが、コンテキストメニューでは <xref:System.Windows.FrameworkElement.ContextMenuClosing> イベントは直接発生しません。 代わりに、コンテキストメニューをプロパティとして "所有" する要素からイベントが発生し、ユーザーが UI のコンテキストメニューを閉じようとしたときにのみ発生します。 ただし、<xref:System.Windows.Controls.ContextMenu> 自体が <xref:System.Windows.FrameworkElement.ContextMenu%2A> プロパティ (入れ子になったコンテキストメニュー) を持つことができます。 この場合、<xref:System.Windows.Controls.ContextMenu> は、入れ子になった <xref:System.Windows.Controls.ContextMenu> を実際に所有し、イベントを発生させる可能性があります。イベントのソースは、入れ子になったコンテキストメニューになります。  
  
 <xref:System.Windows.Controls.ContextMenu> クラス自体にも同様のイベント (<xref:System.Windows.Controls.ContextMenu.Closed>) がありますが、<xref:System.Windows.Controls.ContextMenu.Closed> イベントではユーザー操作をキャンセルすることはできません。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|ルーティング方法|バブリング|  
|委任|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のコンテキスト メニューが開くときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテキストメニューを手動で開くには、イベントのハンドラーが関連するイベントを処理済みとしてマークする必要があります。 それ以外の場合は、[<xref:System.Windows.FrameworkElement.ContextMenu%2A>] プロパティの既存の値を使用して、ショートカットメニューが自動的に開きます。 イベントを処理済みとしてマークすると、既定のアクションが実質的にキャンセルされます。また、<xref:System.Windows.FrameworkElement.ContextMenu%2A> プロパティの値をリセットし、新しい <xref:System.Windows.Controls.ContextMenu>を開くことができます。 ただし、タイミングの問題に注意する必要があります。 コンテキストメニューを <xref:System.Windows.FrameworkElement.ContextMenuOpening> ハンドラーで完全に置き換えるには、最初のコンテキストメニューを null または空にすることはできません。 または、イベントを処理し、新しいコンテキストメニューを手動で開く必要がある場合もあります。 詳細については、「[方法: ContextMenuOpening イベントを処理する](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)」を参照してください。  
  
 このイベントをスタイルの <xref:System.Windows.EventTrigger> として使用するには、基になる添付イベントを参照する必要があります。  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (この使用方法が必要になるのは、基になるサービスイベントを公開する <xref:System.Windows.FrameworkElement> のイベント実装が、トリガーで使用できるように <xref:System.Windows.FrameworkElement.ContextMenuOpening> 識別子をマップしないためです)。  
  
 <xref:System.Windows.Controls.ContextMenu> 自体は <xref:System.Windows.FrameworkElement> 派生クラスですが、このイベントは、ソースとして開かれているコンテキストメニューからは発生しません。 イベントは、コンテキストメニューをプロパティとして "所有" する要素から発生し、ユーザーが UI でコンテキストメニューを開こうとしたときにのみ発生します。 <xref:System.Windows.Controls.ContextMenu> 自体が <xref:System.Windows.FrameworkElement.ContextMenu%2A> プロパティを持つことはできますが、このシナリオは避ける必要があります (詳細については、「<xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>」を参照してください)。  
  
 <xref:System.Windows.Controls.ContextMenu> クラス自体にも同様のイベント (<xref:System.Windows.Controls.ContextMenu.Opened>) がありますが <xref:System.Windows.Controls.ContextMenu.Opened> では、ユーザー操作をキャンセルすることはできません。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|ルーティング方法|バブリング|  
|委任|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ContextMenu" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にマウス ポインターが置かれたときに表示されるカーソルを取得または設定します。</summary>
        <value>表示対象のカーソル。 既定値はこの依存関係プロパティごとに <see langword="null" /> として定義されます。 ただし、実行時における実用的な既定値は、さまざまな要因から取得されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]でこのプロパティを設定すると、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] プロセッサは <xref:System.Windows.Input.Cursor> クラスの型変換に依存して文字列を評価します。 指定された文字列は、<xref:System.Windows.Input.CursorType> 値に評価される必要があります。 詳細については、<xref:System.Windows.Input.Cursor> を参照してください。  
  
 このプロパティによって確立されたカーソルは、マウスポインターがこの要素の上にあるときに表示されるかどうかは、<xref:System.Windows.FrameworkElement.ForceCursor%2A> プロパティの値にも依存します。 また、アクティブなドラッグ、マウスのキャプチャ、コントロール内のテキスト編集モードなどのイベント関連の考慮事項は、このプロパティで指定した値よりも優先順位の高いカーソルにも影響します。  
  
 このプロパティを最終的な既定値に設定する動作を元に戻すには、再度 `null` に設定します。  
  
 `null` の既定値は、実際のカーソル値の決定がここで遅延され、他の場所から取得する必要があることを意味します。 任意のソースからプログラムの値を指定せずに表示された場合、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] アプリケーションの視覚的な既定のカーソルは矢印になります。 ただし、一時的なカーソルの変更は、要素が渡されたときに要素の <xref:System.Windows.FrameworkElement.Cursor%2A> 値に設定されません。 <xref:System.Windows.FrameworkElement.Cursor%2A> プロパティは、実際に設定されている場合には null 以外の値のみを報告します。たとえば、コードやスタイルを使用します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] アプリケーションにマウスを移動するたびに、<xref:System.Windows.UIElement.QueryCursor> イベントが発生します。 イベントのバブルと、ルートにあるすべての要素には、イベントを処理し、このイベントの引数を使用してカーソルの値を設定する機会があります。 これは、ほとんどの場合に視覚的に見えるカーソルを生成するメカニズムです。 <xref:System.Windows.UIElement.QueryCursor> ハンドラーがカーソルの結果を返す場合、イベントが処理され、引数の値が変更されたという事実は、<xref:System.Windows.FrameworkElement.ForceCursor%2A> が設定されていない限り、<xref:System.Windows.FrameworkElement.Cursor%2A> プロパティの値よりも優先されます。  
  
 カスタムカーソルを作成しない場合は、通常、このプロパティを <xref:System.Windows.Input.Cursors> クラスの静的なプロパティ値に設定します。 コードに <xref:System.Windows.FrameworkElement.Cursor%2A> を設定するには、次のいずれかが必要です。  
  
-   <xref:System.Windows.Input.Cursor> コンストラクターを呼び出して、<xref:System.Windows.Input.Cursor> インスタンスを取得します。 <xref:System.Windows.Input.Cursor> コンストラクターのシグネチャはどちらも、カスタムカーソルの <xref:System.Windows.Input.Cursor> オブジェクトを作成することを想定して、ストリームまたはファイルを使用します。  
  
-   <xref:System.Windows.Input.CursorConverter> クラスとその <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> メソッドを使用して、<xref:System.Windows.Input.CursorType>、または <xref:System.Windows.Input.CursorType>に評価できる文字列を指定し、戻り値を <xref:System.Windows.Input.Cursor>にキャストします。  
  
 部分信頼では、<xref:System.Windows.Input.Cursor> をカスタム値に設定することはできません。 カスタムカーソルの詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例は、カーソルグラフィックを意図的に設定する方法を示しています。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Cursor" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がデータ バインディングに含まれている場合に、その要素のデータ コンテキストを取得または設定します。</summary>
        <value>データ コンテキストとして使用するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *データコンテキスト*は、バインドに使用されるデータソースや、パスなどのその他の特性について、要素が親要素から情報を継承できるようにする概念です。  
  
 データコンテキストは、そのオブジェクトのプロパティを評価するバインディングを使用して、.NET オブジェクトに直接設定できます。 または、データコンテキストを <xref:System.Windows.Data.DataSourceProvider> オブジェクトに設定することもできます。  
  
 この依存関係プロパティは、プロパティ値を継承します。 ローカル値またはスタイルによって確立された <xref:System.Windows.FrameworkElement.DataContext%2A> の他の値を持たない子要素がある場合、プロパティシステムは、この値が割り当てられている最も近い親要素の <xref:System.Windows.FrameworkElement.DataContext%2A> 値になるように値を設定します。  
  
 または、<xref:System.Windows.Data.Binding> クラスの次のいずれかのプロパティを使用して、バインドソースを明示的に指定することもできます。
  
    - [https://login.microsoftonline.com/consumers/](<xref:System.Windows.Data.Binding.ElementName%2A>)
    - [https://login.microsoftonline.com/consumers/](<xref:System.Windows.Data.Binding.Source%2A>)
    - [https://login.microsoftonline.com/consumers/](<xref:System.Windows.Data.Binding.RelativeSource%2A>) 
  
  詳細については、「[方法: バインディングソースを指定](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)する」を参照してください。  
  
 XAML では、通常、<xref:System.Windows.FrameworkElement.DataContext%2A> は <xref:System.Windows.Data.Binding> 宣言として設定されます。 プロパティ要素の構文または属性構文を使用できます。 属性の構文については、このページの例を参照してください。 コードを使用して <xref:System.Windows.FrameworkElement.DataContext%2A>を設定することもできます。  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> は、あるコンテキストが別のコンテキストにバインドされている可能性のあるシナリオを容易にするためのバインド可能なプロパティです。 ただし、<xref:System.Windows.FrameworkElement.DataContext%2A>にバインドする場合は、循環バインディング参照を作成しないように注意してください (<xref:System.Windows.FrameworkElement.DataContext%2A> をそれ自体にバインドしないでください。 <xref:System.Windows.FrameworkElement.DataContext%2A> プロパティのプロパティ値の継承の特性によって実行できます)。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml  
<object DataContext="bindingUsage"/>  
```

または

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML の値  
 *dataContextObject*  
 親要素内の任意のバインドのデータコンテキストとして機能する直接埋め込まれたオブジェクト。 通常、このオブジェクトは <xref:System.Windows.Data.Binding> または別の <xref:System.Windows.Data.BindingBase> 派生クラスです。 また、バインドを目的としたオブジェクトの種類の生データをここに配置し、実際のバインドを後で定義することもできます。  
  
 *bindingUsage*  
 適切なデータコンテキストに評価されるバインディングの使用。 詳細については、「[バインディングのマークアップ拡張機能](~/docs/framework/wpf/advanced/binding-markup-extension.md)」を参照してください。  
  
 *resourceExtension*  
 [`StaticResource`](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)または[`DynamicResource`](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)のいずれかです。 この使用法は、リソース内のオブジェクトとして定義された生データを参照するときに使用されます。 「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
 *contextResourceKey*  
 <xref:System.Windows.ResourceDictionary>内から要求されているオブジェクトのキー識別子。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例では、データコンテキストがバインディングにどのように作用するかを示し、バインドされたプロパティの特定の値を定義する情報を提供します。  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のデータ コンテキストが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データコンテキストとデータバインディングの詳細については、「[データバインディングの概要](~/docs/framework/wpf/data/data-binding-overview.md)」を参照してください。  
  
> [!IMPORTANT]
>  要素の <xref:System.Windows.FrameworkElement.DataContext%2A> が変更されると、この要素のすべてのデータバインドプロパティが影響を受ける可能性があります。 これは、データコンテキストを継承する論理ツリー内の現在の要素の子要素であるすべての要素と、現在の要素自体に適用されます。 このような既存のバインディングでは、新しい <xref:System.Windows.FrameworkElement.DataContext%2A> を再解釈し、バインドの結果を再評価する必要があります。 データバインディングエンジンは、これらの再評価の順序を決定するものではなく、<xref:System.Windows.FrameworkElement.DataContextChanged> イベントの発生を基準としています。 再評価は、イベントの前、イベントの後、または任意の組み合わせで行うことができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.DataContext" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーマ スタイルを使用または定義するときに、このコントロールのスタイルを参照するために使用されるキーを取得または設定します。</summary>
        <value>スタイルのキー。 テーマ スタイル参照の一部として正常に機能するために、この値は、スタイルを設定するコントロールの <see cref="T:System.Type" /> である必要があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、通常、直接プロパティアクセサーのいずれかを使用して設定されるわけではありません。 代わりに、新しい <xref:System.Windows.FrameworkElement> 派生クラスを作成するたびに、この依存関係プロパティの型固有のメタデータをオーバーライドします。 コントロールを派生させる場合は、コントロールの派生クラス (または同等のクラスの初期化) の静的コンストラクター内で、<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> 識別子に対して <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> メソッドを呼び出します。  
  
 通常、コントロールは、このプロパティの既定値を独自の型にオーバーライドしますが、場合によっては、テーマディクショナリ内のスタイルが存在する基本型を使用することもできます。 これは、基本コントロールのコントロールテンプレートでその派生コントロールのビジュアル表現が完全に定義されていて、派生型で公開されている追加のメンバーがコントロールテンプレートの一部として追加の要素を必要としない場合にのみ実用的です。  
  
 要素またはコントロールがテーマスタイルを意図的に使用しないようにするには、<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> プロパティを `true`に設定します。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例は、「解説」で説明されている依存関係プロパティメタデータオーバーライドの使用方法を示しています。 このコードでは、専用のコントロールライブラリアセンブリから使用することを意図した `NumericUpDown` カスタムコントロールクラスを定義します。 図に示す静的コンストラクターは、いくつかのプライベート初期化関数を参照し、クラスハンドラーを登録します (もう1つの一般的なコントロールのサブクラス化に関する説明を参照してください。[ルーティングイベントを処理済みとしてマークし、クラスを処理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)します)。最後に、`NumericUpDown` クラスの <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 依存関係プロパティのメタデータをオーバーライド <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> は常に、意図したキーとして独自の型を返します。これは、テーマスタイルシステムが、任意のスタイルではないコントロールのスタイルを検索するために使用する規則です。 完全なサンプルでは、そのキーによって参照される実際のコントロールのテーマスタイルも定義します。「 [NumericUpDown Custom Control With Theme AND UI Automation Support Sample」を](https://go.microsoft.com/fwlink/?LinkID=160025)参照してください。  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  この例の完全なソースコードは、と[Visual Basic](https://github.com/dotnet/dotnet-api-docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary)の両方[C#](https://github.com/dotnet/dotnet-api-docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary)について GitHub で入手できます。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">テーマと UI オートメーションサポートのサンプルを使用した NumericUpDown カスタムコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素の初期化プロセスが完了したことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.BeginInit%2A> が以前に呼び出された場合、基本実装では <xref:System.Windows.FrameworkElement.Initialized> イベントが発生します。 それ以外の場合、<xref:System.Windows.FrameworkElement.BeginInit%2A> が呼び出されなかった場合、または <xref:System.Windows.FrameworkElement.BeginInit%2A> が呼び出されたかどうかを判断できなかった場合、<xref:System.Windows.FrameworkElement.Initialized> は発生せず、代わりに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">以前に <see cref="M:System.Windows.FrameworkElement.EndInit" /> が呼び出されていないこの要素で、<see cref="M:System.Windows.FrameworkElement.BeginInit" /> が呼び出されました。</exception>
        <block subset="none" type="overrides"><para>要素の読み込みプロセス中に要素が初期化されるときに発生する特別な処理を提供するには、このメソッドを実装します。  
  
 基本 (既定) の実装では初期化を追跡する内部フラグが設定されるため、実装では基本実装を呼び出す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求された要素の名前。</param>
        <summary>指定した識別名を持つ要素を検索します。</summary>
        <returns>要求された要素。 一致する要素が見つからなかった場合は <see langword="null" /> になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素に子要素がある場合、これらの子要素は、要求された名前付き要素に対して再帰的に検索されます。  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> は、現在の要素の名前スコープ内で動作します。 詳細については、「 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">x:Name 属性</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要求したリソースのキー識別子。</param>
        <summary>指定したキーを持つリソースを検索します。要求したリソースが見つからない場合は例外がスローされます。</summary>
        <returns>要求されたリソース。 指定したキーを持つリソースが見つからなかった場合は例外がスローされます。 その場合は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 値が返されることもあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  見つからないキーに対してこのメソッドを呼び出すと、例外がスローされます。 <xref:System.Windows.FrameworkElement.FindResource%2A>を呼び出した結果として発生する例外を処理しない場合は、代わりに <xref:System.Windows.FrameworkElement.TryFindResource%2A> を呼び出します。 <xref:System.Windows.FrameworkElement.TryFindResource%2A> は、要求されたリソースが見つからない場合に `null` を返し、例外をスローしません。  
  
 リソースが呼び出し元の要素で見つからない場合は、論理ツリー内の親要素が次に検索され、次にアプリケーション、テーマ、およびシステムリソースが検索されます。 このルックアップ方法は、マークアップで動的リソース参照によってリソースが要求された場合のツリーの検索方法と同じです。 リソースルックアップの詳細については、「 [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
 通常は、返されたリソース値を使用して設定したプロパティの型に <xref:System.Windows.FrameworkElement.FindResource%2A> 戻り値を直ちにキャストします。  
  
 リソースキーは必ずしも文字列であるとは限りません。 たとえば、テーマレベルでのコントロールのスタイルは、コントロールの <xref:System.Type> に意図的にキーを設定します。また、コントロールのアプリケーションまたはページスタイルは、通常、この同じキーの規則を使用します。 詳細については、「[スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」または「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、名前付きリソースを取得し、それを適切な型にキャストしてプロパティに入力します。  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><paramref name="resourceKey" /> が見つからず、<see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> イベントのイベント ハンドラーが存在しません。  
  
または 
 <paramref name="resourceKey" /> が見つからず、<see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> イベントで <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> プロパティが <see langword="false" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウトを制御する親要素内でのテキストやその他の [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 要素のフロー方向を取得または設定します。</summary>
        <value>テキストやその他の [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 要素の親要素内でのフロー方向を示す列挙値。 既定値は <see cref="F:System.Windows.FlowDirection.LeftToRight" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの使用法によって、この要素の <xref:System.Windows.FrameworkElement.FlowDirection%2A> が設定されます。 プロパティ値の継承により、要素に <xref:System.Windows.FrameworkElement.FlowDirection%2A> を設定すると、ローカルに <xref:System.Windows.FrameworkElement.FlowDirection%2A> 設定されていないすべての子要素、またはスタイルなどの他の手段で <xref:System.Windows.FrameworkElement.FlowDirection%2A> が設定される可能性があります。  
  
 このプロパティは、アプリケーションのカルチャ情報の一部として自動的に設定されるわけではありません。要素には、必ずしもカルチャ情報によって暗黙的に指定される一般的なフロー方向に従うことを意図していないコンテンツが含まれる可能性があるためです。 グローバリゼーションの考慮事項の詳細については、「 [WPF のグローバリゼーション](~/docs/framework/wpf/advanced/globalization-for-wpf.md)」を参照してください。  
  
 このプロパティには [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] プロパティアクセサーが定義されているため、依存関係プロパティとして機能します。 ただし、添付ファイルとして登録されているので、添付プロパティとしても機能することができます。 アタッチされた登録は、主にプロパティ値の継承がサポートされるようにするために使用されますが、プロパティを添付プロパティとして使用することもできます。 添付プロパティの使用は、フローの方向を設定する対象のオブジェクトが、レイアウトを実行する <xref:System.Windows.FrameworkElement> 親要素を持ち、それ自体が <xref:System.Windows.FrameworkElement>ではなく、`FlowDirection` プロパティが直接定義されていない場合にのみ関連します。 (<xref:System.Windows.Documents.Block> や <xref:System.Windows.Documents.Inline> などのフロードキュメントクラスの中には、独自の `FlowDirection`を定義するものもあれば、フローの方向を設定することもできます。 プロパティ値は、添付プロパティの使用を必要とせずに最終的なコンテンツホストによって読み取られます)。  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
 \<*オブジェクト* **system.windows.flowdirection>**= "<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このプロパティは、次の [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 添付プロパティを使用して、派生クラス <xref:System.Windows.FrameworkElement> ないクラスで設定することもできます。  
  
 `<`*オブジェクト*`FrameworkElement.`**system.windows.flowdirection>**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 このプロパティは、依存関係プロパティと添付プロパティの両方です。「解説」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がキーボード フォーカスを受け取ったときに適用される外観、効果、またはその他のスタイル特性のカスタマイズを可能にするプロパティを取得または設定します。</summary>
        <value>フォーカスに適用する目的のスタイル。 依存関係プロパティで宣言されている既定値は、空の静的 <see cref="T:System.Windows.Style" /> です。 ただし、実行時の有効値は、多くの場合、コントロールのテーマ サポートによって提供されたスタイルです (ただし、常にそうであるとは限りません)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティはビジュアルの外観に影響しますが、メタデータ内の <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> を報告しません。 これは、視覚的な外観の変更はイベントドリブンであり、常に適用されない可能性があるため、通常はビジュアルやレイアウト情報をメタデータに報告しないようにしてください。  
  
 概念的には、コントロールに適用されるフォーカスの視覚的な動作は、コントロールからコントロールまで一貫している必要があります。 一貫性を適用する最も合理的な方法は、テーマ全体を作成する場合にのみフォーカスの視覚スタイルを変更することです。 このプロパティをテーマの一部としてではなく、個々のコントロールスタイルで設定することは、このプロパティを使用するためのものではありません。これは、キーボードフォーカスに関してユーザーエクスペリエンスが混乱する可能性があるためです。 テーマ全体で一貫していないコントロール固有の動作を行う場合は、<xref:System.Windows.UIElement.IsFocused%2A> や <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>など、個々の入力状態プロパティのスタイルでトリガーを使用し、既存のフォーカスの視覚スタイルを視覚的に干渉しないようにする方法があります。 <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> と代替のフォーカスプロパティの設計目的の詳細については、「[コントロールのフォーカスのスタイル設定」および FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)を参照してください。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML の値  
 *resourceExtension*  
 次のいずれか:、または。 「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
 *styleResourceKey*  
 要求されているスタイルを識別するキー。 キーは、<xref:System.Windows.ResourceDictionary>内の既存のリソースを参照します。  
  
> [!NOTE]
>  Property 要素の構文は技術的には可能ですが、推奨されません。 「[インラインスタイルとテンプレート」を](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)参照してください。 [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md)または <xref:System.Windows.Data.Binding> を使用したバインディング参照も可能ですが、一般的ではありません。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> でカーソルを <see cref="P:System.Windows.FrameworkElement.Cursor" /> プロパティの宣言に従って描画するように[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] を強制するかどうかを示す値を取得または設定します。</summary>
        <value>この要素の上にあるときのカーソルの表示に <see cref="P:System.Windows.FrameworkElement.Cursor" /> の現在の設定を強制的に使用する場合は <see langword="true" /> (すべての子要素を含む)。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを `true` に設定すると、子要素によって設定されたカーソル設定がオーバーライドされます。 一般に、アプリケーションの一般的な [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] では、子要素がカーソルを指定しようとしている場合に、ユーザーにとって混乱を招く可能性があります。 <xref:System.Windows.FrameworkElement.ForceCursor%2A> の設定は、コントロールのサブクラス化や複合のシナリオに適しています。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、カーソル値を強制的に指定します。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ForceCursor" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">バインディングを取得するターゲット <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>指定したプロパティでのバインディングを表す <see cref="T:System.Windows.Data.BindingExpression" /> を返します。</summary>
        <returns>ターゲット プロパティにアクティブなバインディングが設定されている場合は <see cref="T:System.Windows.Data.BindingExpression" />。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `null` の戻り値をチェックする手法は、プロパティにアクティブなバインディングがあるかどうかを判断するために使用できます。  
  
 このメソッドは、実際には <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> メソッドをラップする単なるラッパーです。 <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> は、現在のインスタンスと `dp` パラメーターを <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>に渡します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="P:System.Windows.FrameworkElement.FlowDirection" /> を返す要素。</param>
        <summary>指定した <see cref="T:System.Windows.DependencyObject" /> の <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 添付プロパティの値を取得します。</summary>
        <returns>列挙体の値としての要求されたフローの方向。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの主な目的は、<xref:System.Windows.FrameworkElement.FlowDirection%2A> プロパティの添付プロパティの構文をサポートすることです。したがって、指定された <xref:System.Windows.FrameworkElement> の子要素は、親要素内の配置のフロー方向を指定できます。 現在の <xref:System.Windows.FrameworkElement>の値を取得するには、直接 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] アクセサー <xref:System.Windows.FrameworkElement.FlowDirection%2A>を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">ビジュアル プレゼンテーションを行う要素の部分のサイズ。</param>
        <summary>クリッピング マスクのジオメトリを返します。 クリッピング マスクは、利用可能な表示領域より大きな要素をレイアウト システムが配置しようとすると適用されます。</summary>
        <returns>クリッピング ジオメトリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 レイアウトシステムの動作の一部として、`layoutSlotSize` から余白が減算されます。  
  
 Null 参照が返された場合は、クリッピングが発生しないことを示します。 <xref:System.Windows.UIElement.ClipToBounds%2A> が `false`場合、既定の実装は常に `null` を返します。 このメソッドは、<xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType> をオーバーライドします。 <xref:System.Windows.FrameworkElement> の実装では、計算で <xref:System.Windows.FrameworkElement.MaxHeight%2A> と <xref:System.Windows.FrameworkElement.MaxWidth%2A> を使用します。 <xref:System.Windows.FrameworkElement> のいくつかのサブクラスは、このメソッドを再度オーバーライドします。 <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>は、装飾が通常の境界の外側にあることが多いため、常にをオーバーライドして `null` を返します。 <xref:System.Windows.UIElement.ClipToBounds%2A> が `false`の場合、<xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> と <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> は `null` を返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="P:System.Windows.UIElement.ClipToBounds" /> が <see langword="false" />場合、既定の実装は常に <see langword="null" /> を返します。 通常、オーバーライドは、基本クラスとは対照的に、派生クラスとそのレイアウトロジックの関係と目的に応じて、この動作を維持することが求められます。</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">検索する子の名前。</param>
        <summary>インスタンス化された <see cref="T:System.Windows.Controls.ControlTemplate" /> のビジュアル ツリー内にある名前付き要素を返します。</summary>
        <returns>要求された要素。 要求した名前の要素が存在しない場合は <see langword="null" /> になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] のテンプレートには、自己完結型の名前スコープがあります。 これは、テンプレートが再使用されるためです。また、1つのコントロールの複数のインスタンスがテンプレートをインスタンス化している場合、テンプレートで定義されているすべての名前は一意のままにできません。 <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> メソッドを呼び出して、インスタンス化された後にテンプレートから取得したオブジェクトへの参照を返します。 <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> メソッドを使用してテンプレートから項目を検索することはできません。これは <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> がより一般的なスコープで動作し、適用後に <xref:System.Windows.Controls.ControlTemplate> クラス自体とインスタンス化されたテンプレートの間に接続がないためです。  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> は、このメソッドと同じ機能を提供します。 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> は保護されるのではなくパブリックです。また、要素内のテンプレートにアクセスしてその中の名前付き項目を検索できるようにする正しい名前スコープの考慮事項を使用します。 親コントロールの外部にある要素を取得する必要がある場合は、<xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ビジュアル親が存在しない場合に、この要素に対する代替の論理上の親を返します。</summary>
        <returns>このメソッドの WPF フレームワーク レベルの実装が非ビジュアルの親接続を持つ場合は <see langword="null" /> 以外の値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType> をオーバーライドします。 既定の <xref:System.Windows.FrameworkElement> 実装では、想定される1つのビジュアル親が返されます。これは、<xref:System.Windows.FrameworkElement.Parent%2A> 値を取得する場合と同じ結果になります。 派生クラスの実装は、代替の親リレーションシップを返す場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">コレクション内の要求された子要素の 0 から始まるインデックス。</param>
        <summary><see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> をオーバーライドし、子要素のコレクションから指定したインデックス位置の子を返します。</summary>
        <returns>要求された子要素。 これは <see langword="null" /> を返しません。指定されたインデックスが範囲外の場合、例外がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> の実装では、有効なインデックスは0だけです。 <xref:System.Windows.FrameworkElement.GetVisualChild%2A> のコンテンツモデルでは、コレクションではなく、0個または1個の子要素がサポートされます。  
  
   
  
## Examples  
 次の例では、カスタム装飾が、複数のビジュアルな子のために保持する <xref:System.Windows.Media.VisualCollection> によって宣言された値を使用する方法を示します。 これらの値は、<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> と <xref:System.Windows.FrameworkElement.GetVisualChild%2A>の上書きによって報告されます。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>この実装は、視覚的な子要素のわかりやすいコレクションを保持しない要素に対してのみ有効です。 このようなコレクションを持つ要素は、このメソッドをオーバーライドし、その要素でサポートされている子要素コレクション内の等価のインデックスにインデックスをマップする必要があります。 0から <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (-1) までの範囲のインデックスは、有効な要素を返す必要があります。その他のインデックスは、範囲外の例外をスローする必要があります。 子コレクションをサポートし、<see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> をオーバーライドして複数の子要素を返すことができる要素型の例は <see cref="T:System.Windows.Controls.Panel" />です。  
  
<see cref="T:System.Windows.FrameworkElement" /> の既定の実装では、ビジュアル子は1つだけであることを前提としています。 0以外の <paramref name="index" /> に渡された値を指定すると、例外がスローされます。 デコレーター、装飾、特化されたレンダリングを持つ要素など、いくつかの一般的な要素は、<see cref="T:System.Windows.FrameworkElement" /> 実装 (中間基本クラスからの実装) をオーバーライドします。 一部の実装では、1つのビジュアル子を強制的に適用し、他の実装ではコレクションを許可します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の推奨される高さを取得または設定します。</summary>
        <value>要素の高さ ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.NaN" /> です。 この値は 0.0 以上にする必要があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> は、高さ情報を指定する <xref:System.Windows.FrameworkElement> の書き込み可能な3つのプロパティの1つです。 もう1つは <xref:System.Windows.FrameworkElement.MinHeight%2A> と <xref:System.Windows.FrameworkElement.MaxHeight%2A>です。 これらの値の間に競合がある場合、実際の高さを決定するためのアプリケーションの順序は、最初の <xref:System.Windows.FrameworkElement.MinHeight%2A> が受け入れられ、<xref:System.Windows.FrameworkElement.MaxHeight%2A>される必要があります。また、範囲内にある場合は <xref:System.Windows.FrameworkElement.Height%2A>ます。  
  
 この要素が他の要素内の子要素である場合、このプロパティを値に設定することは、実際には推奨値にすぎません。 レイアウトシステムおよび親要素の特定のレイアウトロジックでは、レイアウト処理中に値が非バインド入力として使用されます。 実際には、<xref:System.Windows.FrameworkElement> はほぼ常に他の要素の子要素です。<xref:System.Windows.Window>に <xref:System.Windows.FrameworkElement.Height%2A> を設定した場合でも同様です。 (<xref:System.Windows.Window>の場合、その値は、基になるアプリケーションモデルで、アプリケーションをホストする Hwnd を作成する基本的なレンダリング仮定を確立するときに使用されます)。  
  
 許容される <xref:System.Double> 値に加えて、このプロパティを <xref:System.Double.NaN?displayProperty=nameWithType>することもできます。 これは、コードで自動サイズ変更動作を指定する方法です。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] では、値を文字列 "Auto" (大文字と小文字を区別しない) に設定して、自動サイズ変更動作を有効にします。 自動サイズ変更動作は、要素が使用可能な高さを塗りつぶすことを意味します。 ただし、特定のコントロールでは、既定のテーマスタイルによって既定値が提供されることがよくあります。これは、明示的に有効にしない限り、自動サイズ変更動作を無効にします。  
  
 このプロパティの戻り値は、その値に設定されている値と常に同じです。 これに対し、<xref:System.Windows.FrameworkElement.ActualHeight%2A> の値は異なる場合があります。 これは、何らかの理由で提案されたサイズがレイアウトによって拒否されたため、または瞬間的に発生する可能性があります。 レイアウトシステム自体は、プロパティシステムの <xref:System.Windows.FrameworkElement.Height%2A> のセットに対して非同期的に動作し、特定のサイズ変更プロパティの変更がまだ処理されていない可能性があります。  
  
 <xref:System.Double> 値の値の制限は、<xref:System.Windows.ValidateValueCallback> メカニズムによって適用されます。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
 検証チェックに加えて、レイアウトシステムによって適用される <xref:System.Windows.FrameworkElement.Height%2A> に対して非決定的な上限が設定されています (これは、<xref:System.Single.MaxValue?displayProperty=nameWithType> よりも大きいが <xref:System.Double.MaxValue?displayProperty=nameWithType>よりも小さい非常に大きい数値です)。 この制約を超えた場合、要素はレンダリングされず、例外はスローされません。 ビジュアル表示の最大サイズよりも大幅に大きい値に <xref:System.Windows.FrameworkElement.Height%2A> を設定しないか、またはこの非決定的な上限を超えることができます。  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml
<object Height="double"/>  
```

または

```xaml
<object Height="qualifiedDouble"/>  
```

または

```xaml
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML の値  
 *double*  
 <xref:System.Double>  
  
 0.0 以上の <xref:System.Double> 値の文字列表現。 上限については、「解説」を参照してください。 この値は、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] の測定値として解釈されます。 文字列には、小数点を明示的に含める必要があります。 たとえば、`1` の値は許容されます。  
  
 *qualifiedDouble*  
 前に説明した*double*値。その後に、`px`、`in`、`cm`、`pt`のいずれかの単位宣言文字列が続きます。  
  
 `px` (既定値) は [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` はインチ。1in==96px  
  
 `cm` はセンチメートルです。1cm = = (96/2.54) px  
  
 `pt` はポイント。1pt==(96/72) px  
  
 **Auto**  
 自動サイズ調整の動作を有効にします。 「解説」を参照してください。  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Height" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、Panel またはアイテム コントロールのような親要素内に構成されるときに適用される水平方向の配置特性を取得または設定します。</summary>
        <value>列挙体の値としての水平方向の配置設定。 既定では、 <see cref="F:System.Windows.HorizontalAlignment.Stretch" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素に対して <xref:System.Windows.FrameworkElement.Height%2A> および <xref:System.Windows.FrameworkElement.Width%2A> のプロパティが明示的に設定されている場合、これらの測定値はレイアウト中の方が高くなり、<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> を <xref:System.Windows.HorizontalAlignment.Stretch>に設定した場合の一般的な効果はキャンセルされます。  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> は、実際の依存関係プロパティに対する [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] プロパティアクセサーです。 この特定の依存関係プロパティでは、サブクラス要素 (特にコントロール) では、明らかに "既定" 値が異なることがよくあります。 これは通常、次の2つの方法のいずれかで発生します。依存関係プロパティは特定のサブクラスに再登録されますが、既定値を設定するために異なるメタデータを使用します。または、適用される既定のスタイルによって、その依存関係プロパティの値が異なるように設定されています。 たとえば、<xref:System.Windows.Controls.Label> コントロールの <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> の明らかな "既定" は、<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> から <xref:System.Windows.FrameworkElement>直接継承され <xref:System.Windows.Controls.Label> ている場合でも <xref:System.Windows.HorizontalAlignment.Left>されます。 これは、スタイルのコントロールテンプレート内で、<xref:System.Windows.Controls.Label>の既定のスタイルで値がリセットされたためです。  
  
 <xref:System.Windows.Controls.Canvas> は、レイアウトの作成時に <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> を使用しません。 <xref:System.Windows.Controls.Canvas> は絶対配置に基づいているためです。  
  
 <xref:System.Windows.Controls.Label> または派生クラスによって継承される場合、<xref:System.Windows.Controls.Label> この依存関係プロパティの既定値を <xref:System.Windows.HorizontalAlignment.Left>するように再定義します。  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティ値の継承、リソース キーのルックアップ、および RelativeSource FindAncestor 検索のスコープの制限を取得または設定します。</summary>
        <value>列挙体の値。 既定では、 <see cref="F:System.Windows.InheritanceBehavior.Default" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素ツリーセット内の特定の境界は、継承動作のスコープを意図的に制限したり、リソースの参照を強制してアプリケーションのリソースをチェックしたり、RelativeSource FindAncestor の参照が現在の要素またはその他の要素に対してクエリを実行したりしないように <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> します。 RelativeSource FindAncestor 参照は、<xref:System.Windows.Data.RelativeSource.Mode%2A> プロパティが <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> 値に設定されている <xref:System.Windows.Data.RelativeSource> をバインドが使用する場合に発生します。  
  
 派生クラスでこのプロパティを設定する場合は、静的コンストラクターまたは他の初期化ルーチン内で実行する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> が初期化されるときに発生します。 このイベントと同時に、<see cref="P:System.Windows.FrameworkElement.IsInitialized" /> プロパティの値が <see langword="false" /> (未定義) から <see langword="true" /> に変更されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.FrameworkElement.EndInit%2A> または <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> メソッドが呼び出されるたびに発生します。 どちらのメソッドの呼び出しも、アプリケーションコードから、または [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ページが処理されるときの [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] プロセッサ動作を通じて発生する可能性があります。  
  
 <xref:System.Windows.FrameworkElement.Loaded> と <xref:System.Windows.FrameworkElement.Initialized> のどちらを処理するかは、要件によって異なります。 要素のプロパティを読み取り、プロパティをリセットする必要がなく、レイアウト情報を必要としない場合は、<xref:System.Windows.FrameworkElement.Initialized> の動作に適したイベントである可能性があります。 要素のすべてのプロパティを使用できるようにする必要があり、レイアウトをリセットする可能性のあるプロパティを設定する場合は、<xref:System.Windows.FrameworkElement.Loaded> 動作する方が適切なイベントである可能性があります。 新しいレイアウトパスが必要であることを示すために、ハンドラーがレイアウトシステムによって解釈されるプロパティをリセットする場合は、再入に注意してください。 (変更された場合、新しいレイアウトパスを必要とするプロパティがわからない場合は、プロパティの <xref:System.Windows.FrameworkPropertyMetadata> 値を確認する必要があります)。  
  
 <xref:System.Windows.FrameworkElement>のオブジェクトイベントのシーケンス、および関連するいくつかのアプリケーションおよび要素クラスの詳細については、「[オブジェクトの有効期間イベント](~/docs/framework/wpf/advanced/object-lifetime-events.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> で使用される入力のコンテキストを取得または設定します。</summary>
        <value>代替の入力メソッドからの入力を解釈する方法を変更する入力スコープ。 既定値は <see langword="null" /> です (コマンドの既定の処理が行われます)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この依存関係プロパティは、プロパティ値を継承します。 ローカル値またはスタイルによって確立された <xref:System.Windows.FrameworkElement.InputScope%2A> の他の値を持たない子要素がある場合、プロパティシステムは、この値が割り当てられている最も近い祖先要素の <xref:System.Windows.FrameworkElement.InputScope%2A> 値になるように値を設定します。  
  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文の使用法が示されていますが、構文的に許可されていますが、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] でこのプロパティを設定するのは一般的ではありません。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.InputScope" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] プロセッサによって処理されている間、またはこの要素の <see cref="M:System.Windows.FrameworkElement.EndInit" /> メソッドが明示的に呼び出されたときに初期化されたかどうかを示す値を取得します。</summary>
        <value>前述の [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 処理やメソッド呼び出しごとに要素が初期化された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、この要素が新しい親要素を持つように論理ツリー内で移動された場合にも `true` ことがあります。そのため再読み込みが再び行われます。  
  
 このプロパティは、<xref:System.Windows.FrameworkElement.BeginInit%2A> と <xref:System.Windows.FrameworkElement.EndInit%2A>を使用している場合に便利です。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] プロセッサによって読み込まれる論理ツリー内の要素は、確実に初期化されます。 論理ツリーに含まれていない要素は <xref:System.Windows.FrameworkElement.EndInit%2A> が呼び出されたときに初期化されます。 <xref:System.Windows.FrameworkElement.BeginInit%2A> と <xref:System.Windows.FrameworkElement.EndInit%2A>の特定の処理が存在しない場合、コンストラクターが初期化された結果を返すとすぐにこれが発生します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が表示のために読み込まれているかどうかを示す値を取得します。</summary>
        <value>現在の要素が要素ツリーにアタッチされている場合は <see langword="true" />。読み込まれた要素ツリーに要素がアタッチされていない場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しく構築された <xref:System.Windows.FrameworkElement>では、このプロパティは `false`から開始され、`true`に設定された後も、要素がコードによって接続された論理ツリーから削除された場合でも、`true` のままになります。 `true` 状態は、要素がプレゼンテーションエンジンに読み込まれるときに、一般的なプレゼンテーションロジックによって設定されます。  
  
 通常、読み込まれた要素はレンダリングされますが、すべての <xref:System.Windows.FrameworkElement> 派生クラスがプレゼンテーションを持つわけではなく、<xref:System.Windows.UIElement.Visibility%2A> などの他のプロパティがプレゼンテーションに影響を与える可能性があります。  
  
   
  
## Examples  
 次の例では、2つのハンドラーを実装しています。1つはルート要素の <xref:System.Windows.FrameworkElement.Loaded> イベントを処理します。したがって、ページルート要素がイベントの有意性であるため、その要素が読み込まれることを確認します。 もう1つのハンドラーはユーザーコントロールにフックされ、<xref:System.Windows.FrameworkElement.IsLoaded%2A> を呼び出して、ルート要素が完全に読み込まれることを保証します。 どちらのハンドラーも、子要素に新しいデータを設定する同じ関数 (非表示) を呼び出します。  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素に適用されるローカライズ/グローバリゼーション言語情報を取得または設定します。</summary>
        <value>この要素の言語情報。 既定値は、<see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 値が文字列 "en-US" に設定されている <see cref="T:System.Windows.Markup.XmlLanguage" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列の形式は RFC 3066 標準に従います。 たとえば、英語 (米国) は "en-us" です。 値と形式の詳細については、「<xref:System.Windows.Markup.XmlLanguage>」を参照してください。  
  
 この依存関係プロパティは、プロパティ値を継承します。 ローカル値またはスタイルによって確立された <xref:System.Windows.FrameworkElement.Language%2A> の他の値を持たない子要素がある場合、プロパティシステムは、この値が割り当てられている最も近い祖先要素の <xref:System.Windows.FrameworkElement.Language%2A> 値になるように値を設定します。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] は、`xml:lang` 属性の一般的な意味を定義します。 <xref:System.Windows.FrameworkElement.Language%2A> は、本質的にこの属性の意味を依存関係プロパティとして公開します。 <xref:System.Windows.FrameworkElement.Language%2A> はプログラムによって調整できます。また、`xml:lang` 属性が [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]の子要素スコープに継承できる方法と同じ方法で、プロパティシステム値の継承に参加できます。 <xref:System.Windows.FrameworkElement.Language%2A>を設定すると、その値が `xml:lang` になり、以前の値が上書きされます。 詳細については、「 [XAML での xml: lang の処理](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Language" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウトの実行時にこの要素に適用するグラフィック変換を取得または設定します。</summary>
        <value>この要素で使用する変換。 既定では、 <see cref="P:System.Windows.Media.Transform.Identity" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.RenderTransform%2A>とは対照的に、<xref:System.Windows.FrameworkElement.LayoutTransform%2A> はレイアウトの結果に影響します。  
  
 変換を設定すると、スケーリングと回転の強力な機能が提供されます。 ただし、<xref:System.Windows.FrameworkElement.LayoutTransform%2A> は <xref:System.Windows.Media.TranslateTransform> 操作を無視します。 これは、<xref:System.Windows.FrameworkElement> の子要素のレイアウトシステムの動作によって、スケールまたは回転された要素の位置へのオフセットが、親要素のレイアウトと座標系に自動修正されるためです。  
  
 レイアウトシステムによる完全なパスを必要としないシナリオで起動すると、アプリケーションのパフォーマンスが低下する可能性があります。これは、<xref:System.Windows.FrameworkElement.LayoutTransform%2A> が原因です。 <xref:System.Windows.Controls.Panel>の <xref:System.Windows.Controls.Panel.Children%2A> コレクションに <xref:System.Windows.FrameworkElement.LayoutTransform%2A> を適用すると、レイアウトシステムによって新しいパスがトリガーされ、すべての画面上のオブジェクトが強制的に再測定および再配置されます。 完全なアプリケーション [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]を更新する場合は、この機能が必要になることがあります。 ただし、完全なレイアウトパスを必要としない場合は、<xref:System.Windows.UIElement.RenderTransform%2A> プロパティを使用します。これはレイアウトシステムを呼び出しません。したがって、通常はこのシナリオに適した選択肢です。  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> が役に立つシナリオの例としては、メニューコンポーネントなどの要素を水平から垂直へ、またはその逆方向に回転させたり、フォーカスを合わせて要素を拡大縮小したり、編集動作を提供したりすることがあります。  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例は、<xref:System.Windows.FrameworkElement.LayoutTransform%2A> を要素に適用する方法を示しています。 この例では、<xref:System.Windows.Controls.Button> のインスタンスを作成し、親 <xref:System.Windows.Controls.Grid>内でホストします。 また、<xref:System.Windows.FrameworkElement.LayoutTransform%2A> プロパティを使用して、<xref:System.Windows.Controls.Button>に <xref:System.Windows.Media.RotateTransform> を適用します。  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">2-d 変換のサンプル</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のレイアウトやレンダリングが完了し、操作を受け入れる準備が整ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、<xref:System.Windows.FrameworkElement.Loaded> は、要素の初期化シーケンスで最後に発生したイベントです。 <xref:System.Windows.FrameworkElement.Initialized>後に常に発生します。 <xref:System.Windows.FrameworkElement.Loaded> と <xref:System.Windows.FrameworkElement.Initialized> のどちらを処理するかは、要件によって異なります。 要素のプロパティを読み取り、プロパティをリセットする必要がなく、レイアウト情報を必要としない場合は、<xref:System.Windows.FrameworkElement.Initialized> の動作に適したイベントである可能性があります。 要素のすべてのプロパティを使用できるようにする必要があり、レイアウトをリセットする可能性のあるプロパティを設定する場合は、<xref:System.Windows.FrameworkElement.Loaded> 動作する方が適切なイベントである可能性があります。 新しいレイアウトパスが必要であることを示すために、ハンドラーがレイアウトシステムによって解釈されるプロパティをリセットする場合は、再入に注意してください。 (変更された場合、新しいレイアウトパスを必要とするプロパティがわからない場合は、プロパティの <xref:System.Windows.FrameworkPropertyMetadata> 値を確認する必要があります)。  
  
 <xref:System.Windows.FrameworkElement>のオブジェクトイベントのシーケンス、および関連するいくつかのアプリケーションおよび要素クラスの詳細については、「[オブジェクトの有効期間イベント](~/docs/framework/wpf/advanced/object-lifetime-events.md)」を参照してください。  
  
 ダイレクトルーティングイベントはルートに従わないので、これらのイベントは、発生したものと同じ要素内でのみ処理されます。 直接ルーティングイベントでは、他のルーティングイベントの動作がサポートされます。これらは、アクセス可能なハンドラーコレクションをサポートし、スタイルの <xref:System.Windows.EventTrigger> として使用できます。  
  
 ユーザーが開始したシステムテーマの変更の結果として、<xref:System.Windows.FrameworkElement.Loaded> と <xref:System.Windows.FrameworkElement.Unloaded> の両方がコントロールで発生する可能性があります。 テーマを変更すると、コントロールテンプレートとそれに含まれるビジュアルツリーが無効化されます。これにより、コントロール全体がアンロードされ、再読み込みされます。 したがって、ページが最初にページへの移動によって読み込まれた場合にのみ、<xref:System.Windows.FrameworkElement.Loaded> を発生させることはできません。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|ルーティング方法|直接|  
|委任|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.Loaded" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の論理上の子要素に対する列挙子を取得します。</summary>
        <value>この要素の論理上の子要素に対する列挙子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> を使用すると、子要素を反復処理できます。 これは、定義済みの専用のコレクションがなくても、複数の子要素 (特に子要素 <xref:System.Windows.FrameworkContentElement>) を含む要素に便利です。  
  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> と <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>の使用方法の詳細については、「 [WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array のマークアップ拡張機能</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の外側の余白を取得または設定します。</summary>
        <value>要素の余白の値を提供します。 既定値は、すべてのプロパティが 0 (ゼロ) の <see cref="T:System.Windows.Thickness" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 余白は、この要素とその他の要素の間のスペースで、レイアウトによって [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]が作成されるときに隣接します。 共有要素は、ピア要素 (共通の親コントロールのコレクション内の他の要素など) である場合もあれば、この要素の親である場合もあります。  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> は、余白を非対称に設定できるように、数値ではなく <xref:System.Windows.Thickness> 構造として設定されます。 <xref:System.Windows.Thickness> 構造体自体は、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 属性構文で非対称 <xref:System.Windows.FrameworkElement.Margin%2A> を指定できるように、文字列型の変換をサポートしています。  
  
 0以外の余白は、要素のレイアウトの <xref:System.Windows.FrameworkElement.ActualWidth%2A> と <xref:System.Windows.FrameworkElement.ActualHeight%2A>の外側にスペースを適用します。  
  
 余白は、レイアウト内の兄弟要素に追加されます。たとえば、隣接する2つの要素が隣接するエッジに30を設定している場合、隣接する2つの要素の間に60単位の領域があります。  
  
 余白が設定されている要素は、割り当てられた四角形の領域が余白と要素のコンテンツ領域に十分な大きさでない場合は、通常、指定された <xref:System.Windows.FrameworkElement.Margin%2A> のサイズを制限しません。 要素のコンテンツ領域は、レイアウトが計算されるときに制約されます。 余白が制限されるのは、コンテンツが既にゼロに制限されている場合のみです。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml  
<object Margin="left,top,right,bottom"/>  
```

または

```xaml
<object Margin="left,top"/>  
```

または  

```xaml
<object Margin="thicknessReference"/>  
```

<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML の値  
 *left、top、right、bottom*  
 <xref:System.Windows.Thickness> 構造体の4つの可能なディメンションプロパティを指定する0から <xref:System.Double.PositiveInfinity> までの数値。  
  
 属性の使用法では、指定された順序で適用される省略された値も、対称的かつ論理的に使用することもできます。 たとえば、`Margin="20"` は、すべてのプロパティが20に設定された <xref:System.Windows.Thickness> を意味します。 `Margin="20,50"` は <xref:System.Windows.Thickness.Right%2A> <xref:System.Windows.Thickness.Left%2A> の <xref:System.Windows.Thickness> を20に設定し、<xref:System.Windows.Thickness.Top%2A> と <xref:System.Windows.Thickness.Bottom%2A> を50に設定して解釈されます。  
  
 <xref:System.Windows.Thickness> メジャーの既定の単位は [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]です。 また、任意のメジャーに `cm`、`in`、または `pt` の単位の種類の文字列を追加することによって、他の単位を指定することもできます。  
  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 属性として指定する数値には小数点を指定する必要があります (0 は許容されますが、0.0 として指定する必要はありません)。 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] の使用方法の詳細については、「<xref:System.Windows.Thickness>」を参照してください。  
  
 *thicknessReference*  
 既存の <xref:System.Windows.Thickness>へのオブジェクト参照。 これは、`}`、、または `}` 参照である可能性があります。 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] の使用方法の詳細については、「<xref:System.Windows.Thickness>」を参照してください。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Margin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の高さの最大値を取得または設定します。</summary>
        <value>要素の最大高 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.PositiveInfinity" /> です。 この値は、0.0 以上の任意の値を指定できます。 <see cref="F:System.Double.PositiveInfinity" /> も有効です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、高さ情報を指定する <xref:System.Windows.FrameworkElement> の3つのプロパティのうちの1つです。 もう1つは <xref:System.Windows.FrameworkElement.MinHeight%2A> と <xref:System.Windows.FrameworkElement.Height%2A>です。  これらの値の間に競合がある場合、実際の高さを決定するためのアプリケーションの順序は、最初に <xref:System.Windows.FrameworkElement.MinHeight%2A> が受け入れられる必要があります。次に、<xref:System.Windows.FrameworkElement.MaxHeight%2A>ます。これらの各値が範囲内にある場合は <xref:System.Windows.FrameworkElement.Height%2A>ます。  
  
 <xref:System.Double> 値の値の制限は、<xref:System.Windows.ValidateValueCallback> メカニズムによって適用されます。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml  
<object MaxHeight="double"/>  
```

または

```xaml
<object MaxHeight ="qualifiedDouble"/>  
```

<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML の値  
 *double*  
 <xref:System.Double>  
  
 0.0 以上の <xref:System.Double> 値の文字列表現。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] の測定値として解釈されます。 文字列には、小数点を明示的に含める必要があります。 たとえば、`1` の値は許容されます。  
  
 [プロパティ値] セクションで説明したのと同じ <xref:System.Double> 範囲制限が適用されますが、値を明示的に <xref:System.Double.PositiveInfinity>に設定する必要がある場合は、 [X:Static マークアップ拡張機能](~/docs/framework/xaml-services/x-static-markup-extension.md)を使用する必要があります。  
  
 *qualifiedDouble*  
 前に説明した*double*値。その後に、`px`、`in`、`cm`、`pt`のいずれかの単位宣言文字列が続きます。  
  
 `px` (既定値) は [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` はインチ。1in==96px  
  
 `cm` はセンチメートルです。1cm = = (96/2.54) px  
  
 `pt` はポイント。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MaxHeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の幅の最大値を取得または設定します。</summary>
        <value>要素の最大の幅 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.PositiveInfinity" /> です。 この値は、0.0 以上の任意の値を指定できます。 <see cref="F:System.Double.PositiveInfinity" /> も有効です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、幅情報を指定する <xref:System.Windows.FrameworkElement> の3つのプロパティのうちの1つです。 もう1つは <xref:System.Windows.FrameworkElement.MinWidth%2A> と <xref:System.Windows.FrameworkElement.Width%2A>です。 これらの値の間に競合がある場合、実際の幅を決定するためのアプリケーションの順序は、最初に <xref:System.Windows.FrameworkElement.MinWidth%2A> する必要があります。次に、<xref:System.Windows.FrameworkElement.MaxWidth%2A>、それぞれが境界内にある場合は <xref:System.Windows.FrameworkElement.Width%2A>ます。  
  
 <xref:System.Double> 値の値の制限は、<xref:System.Windows.ValidateValueCallback> メカニズムによって適用されます。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml 
<object MaxWidth="double"/>  
```

または

```xaml
<object MaxWidth="qualifiedDouble"/>  
```

<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML の値  
 *double*  
 <xref:System.Double>  
  
 0.0 以上の <xref:System.Double> 値の文字列表現。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] の測定値として解釈されます。 文字列には、小数点を明示的に含める必要があります。 たとえば、`1` の値は許容されます。  
  
 [プロパティの値] セクションに記載されているのと同じ <xref:System.Double> 範囲の制限が適用されます。ただし、値を <xref:System.Double.PositiveInfinity>に設定するには、 [X:Static Markup Extension](~/docs/framework/xaml-services/x-static-markup-extension.md)を使用する必要があります。  
  
 *qualifiedDouble*  
 前に説明した*double*値。その後に、`px`、`in`、`cm`、`pt`のいずれかの単位宣言文字列が続きます。  
  
 `px` (既定値) は [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` はインチ。1in==96px  
  
 `cm` はセンチメートルです。1cm = = (96/2.54) px  
  
 `pt` はポイント。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MaxWidth" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">親要素が子要素に与えることが利用可能なサイズ。</param>
        <summary><see cref="T:System.Windows.FrameworkElement" /> の測定パス レイアウト システムの基本動作を実装します。</summary>
        <returns>レイアウト内のこの要素の必要なサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、WPF のコアレベルと WPF フレームワークレベルのレイアウトメジャーの実装に接続するために <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> をオーバーライドします。 <xref:System.Windows.FrameworkElement> の実装は、メソッドをシールします。 WPF フレームワークレベルでビルドされる要素の測定パスレイアウト動作を調整するには、代わりに <xref:System.Windows.FrameworkElement.MeasureOverride%2A> をオーバーライドします。 WPF フレームワークレベルで意図的に構築されていない要素または <xref:System.Windows.FrameworkElement>を使用する要素の測定パスレイアウト動作を調整するには、<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">この要素が子要素に提供できる使用可能なサイズ。 あらゆるコンテンツに要素がサイズを合わせることを示す値として、無限大を指定できます。</param>
        <summary>派生クラスでオーバーライドされると、子要素に必要なレイアウトのサイズを測定し、<see cref="T:System.Windows.FrameworkElement" /> 派生クラスのサイズを決定します。</summary>
        <returns>子要素のサイズの計算に基づいて、この要素が判断したレイアウト時に必要なサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MeasureOverride%2A> をオーバーライドして、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] レイアウトシステムに参加するときに、要素のカスタムレイアウトのサイズ変更動作を実装します。 実装では、次の操作を行う必要があります。  
  
1.  レイアウトの一部である子要素の特定のコレクションを反復処理し、各子要素の <xref:System.Windows.UIElement.Measure%2A> を呼び出します。  
  
2.  子ですぐに <xref:System.Windows.UIElement.DesiredSize%2A> を取得します (これは <xref:System.Windows.UIElement.Measure%2A> が呼び出された後にプロパティとして設定されます)。  
  
3.  子要素の測定値に基づいて、親のネットワークの目的のサイズを計算します。  
  
 <xref:System.Windows.FrameworkElement.MeasureOverride%2A> の戻り値は、要素独自の目的のサイズにする必要があります。これは、現在の要素の親要素のメジャー入力になります。 この同じプロセスは、ページのルート要素に到達するまでレイアウトシステムを経由し続けます。  
  
 このプロセスでは、子要素がより多くの領域を必要としていることを示すために、子要素が最初の `availableSize` よりも大きい <xref:System.Windows.UIElement.DesiredSize%2A> サイズを返すことがあります。 これは、スクロール可能な領域を導入することによって、親コントロールのサイズを変更することによって、親コントロールのサイズを変更することによって、独自の実装で処理することができます。  
  
> [!IMPORTANT]
>  要素は、このプロセス中に各子の <xref:System.Windows.UIElement.Measure%2A> を呼び出す必要があります。そうしないと、子要素のサイズが正しく設定または配置されません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>次の非コンパイルコードは、この実装パターンを示しています。  <c>Visualchildren</c>は、独自の要素で定義する必要がある子の列挙可能なコレクションプロパティを表します。 プロパティには、任意の名前を付けることができます。 <c>Visualchildren</c>は、この例のためのプレースホルダー名です。 <c>visualchildren</c>は、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] または名前付けパターンの一部で提供される API ではありません。 
  
[! code-csharp[CorePseudocode # FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)][! code-vb[CorePseudocode # FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の高さの最小値を取得または設定します。</summary>
        <value>要素の高さの最小値 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は 0.0 です。 この値は、0.0 以上の任意の値を指定できます。 ただし、<see cref="F:System.Double.PositiveInfinity" /> は有効でなく、<see cref="F:System.Double.NaN" /> も有効ではありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、高さ情報を指定する <xref:System.Windows.FrameworkElement> の3つのプロパティのうちの1つです。  もう1つは <xref:System.Windows.FrameworkElement.Height%2A> と <xref:System.Windows.FrameworkElement.MaxHeight%2A>です。 これらの値の間に競合がある場合、実際の高さを決定するためのアプリケーションの順序は、最初に <xref:System.Windows.FrameworkElement.MinHeight%2A> が受け入れられる必要があります。次に、<xref:System.Windows.FrameworkElement.MaxHeight%2A>ます。これらの各値が範囲内にある場合は <xref:System.Windows.FrameworkElement.Height%2A>ます。  
  
 <xref:System.Double> 値の値の制限は、<xref:System.Windows.ValidateValueCallback> メカニズムによって適用されます。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml
<object MinHeight="double"/>  
```

または

```xaml
<object MinHeight="qualifiedDouble"/>  
```

<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML の値  
 *double*  
 <xref:System.Double>  
  
 0.0 以上の <xref:System.Double> 値の文字列表現。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] の測定値として解釈されます。 文字列には、小数点を明示的に含める必要があります。 たとえば、`1` の値は許容されます。  
  
 [プロパティの値] セクションに記載されているのと同じ <xref:System.Double> 範囲の制限が適用されます。  
  
 *qualifiedDouble*  
 前に説明した*double*値。その後に、`px`、`in`、`cm`、`pt`のいずれかの単位宣言文字列が続きます。  
  
 `px` (既定値) は [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` はインチ。1in==96px  
  
 `cm` はセンチメートルです。1cm = = (96/2.54) px  
  
 `pt` はポイント。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MinHeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の幅の最小値を取得または設定します。</summary>
        <value>要素の幅の最小値 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は 0.0 です。 この値は、0.0 以上の任意の値を指定できます。 ただし、<see cref="F:System.Double.PositiveInfinity" /> と <see cref="F:System.Double.NaN" /> は無効です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、幅情報を指定する <xref:System.Windows.FrameworkElement> の3つのプロパティのうちの1つです。  もう1つは <xref:System.Windows.FrameworkElement.Width%2A> と <xref:System.Windows.FrameworkElement.MaxWidth%2A>です。  これらの値の間に競合がある場合、実際の幅を決定するためのアプリケーションの順序は、最初に <xref:System.Windows.FrameworkElement.MinWidth%2A> する必要があります。次に、<xref:System.Windows.FrameworkElement.MaxWidth%2A>、それぞれが境界内にある場合は <xref:System.Windows.FrameworkElement.Width%2A>ます。  
  
 <xref:System.Double> 値の値の制限は、<xref:System.Windows.ValidateValueCallback> メカニズムによって適用されます。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml 
<object MinWidth="double"/>  
```

または

```xaml
<object MinWidth="qualifiedDouble"/>  
```
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML の値  
 *double*  
 <xref:System.Double>  
  
 0.0 以上の <xref:System.Double> 値の文字列表現。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] の測定値として解釈されます。 文字列には、小数点を明示的に含める必要があります。 たとえば、`1` の値は許容されます。  
  
 [プロパティの値] セクションに記載されているのと同じ <xref:System.Double> 範囲の制限が適用されます。  
  
 *qualifiedDouble*  
 前に説明した*double*値。その後に、`px`、`in`、`cm`、`pt`のいずれかの単位宣言文字列が続きます。  
  
 `px` (既定値) は [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` はインチ。1in==96px  
  
 `cm` はセンチメートルです。1cm = = (96/2.54) px  
  
 `pt` はポイント。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MinWidth" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">フォーカスの移動方向を表す列挙値。</param>
        <summary>指定した移動方向の別の要素にこの要素からキーボード フォーカスを移動します。</summary>
        <returns>フォーカスの移動が成功した場合は <see langword="true" /> が返されます。指定した方向にターゲット要素が存在しない場合や、ターゲット要素にキーボード フォーカスを設定できなかった場合は、<see langword="false" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装は <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> をオーバーライドし、メソッドをシールします。  
  
   
  
## Examples  
 次の例では、いくつかの可能なボタン入力を処理するハンドラーを実装しています。 各ボタンは、可能な <xref:System.Windows.Input.FocusNavigationDirection>を表します。 ハンドラーは、現在のキーボードフォーカスを持つ要素を追跡し、指定された <xref:System.Windows.Input.TraversalRequest> 型パラメーターの初期化として適切な <xref:System.Windows.Input.FocusNavigationDirection> を指定することによって、その要素に対して <xref:System.Windows.FrameworkElement.MoveFocus%2A> を呼び出します。  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の識別名を取得または設定します。 この名前は参照を提供するため、イベント ハンドラー コードなどの分離コードは、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] プロセッサによる処理の際に、構築された後のマークアップ要素を参照できます。</summary>
        <value>要素の名前です。 既定値は空の文字列です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの最も一般的な使用方法は、マークアップの属性として [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 要素名を指定することです。  
  
 このプロパティは、基本的に、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:Name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)を設定するための WPF フレームワークレベルの便宜的なプロパティを提供します。  
  
 名前スコープ内で一意である必要があります。 詳細については、「 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)」を参照してください。  
  
 コードで要素を作成する場合は、<xref:System.Windows.FrameworkElement.Name%2A> を取得するのは一般的ではありません。 コードに適切な参照が既にある場合は、要素参照のメソッドとプロパティを呼び出すだけで、通常は <xref:System.Windows.FrameworkElement.Name%2A>は必要ありません。 これに対する例外は、<xref:System.Windows.FrameworkElement.Name%2A> 文字列にオーバーロードされた意味がある場合です。たとえば、[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]にその名前を表示すると便利な場合です。 元の <xref:System.Windows.FrameworkElement.Name%2A> をマークアップから設定した場合、分離コードから <xref:System.Windows.FrameworkElement.Name%2A> を設定することもお勧めしません。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] を読み込んだ後にプロパティを変更しても、元のオブジェクト参照は変更されません。 オブジェクト参照は、基になる名前スコープが解析中に明示的に作成された場合にのみ作成されます。 既に読み込まれている要素の <xref:System.Windows.FrameworkElement.Name%2A> プロパティを有効に変更するには、<xref:System.Windows.FrameworkElement.RegisterName%2A> を明示的に呼び出す必要があります。  
  
 コードから <xref:System.Windows.FrameworkElement.Name%2A> を設定することが重要なケースの1つは、ストーリーボードが実行される要素の名前を登録するときに、それらを実行時に参照できるようにすることです。 名前を登録する前に、をインスタンス化して <xref:System.Windows.NameScope> インスタンスを割り当てる必要がある場合もあります。 「例」または「[ストーリーボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)」を参照してください。  
  
 コードから <xref:System.Windows.FrameworkElement.Name%2A> を設定するアプリケーションは限られていますが、<xref:System.Windows.FrameworkElement.Name%2A> によって要素を取得する方が一般的です。 特定のシナリオとして、アプリケーションがアプリケーションにページを再読み込みするナビゲーションモデルがサポートされていて、実行時コードがそのページに対して定義された分離コードではない場合があります。 任意の <xref:System.Windows.FrameworkElement>から使用できるユーティリティメソッド <xref:System.Windows.FrameworkElement.FindName%2A>は、その要素の論理ツリー内の <xref:System.Windows.FrameworkElement.Name%2A> によって要素を検索し、必要に応じてツリーを再帰的に検索できます。 または、<xref:System.Windows.LogicalTreeHelper>の <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 静的メソッドを使用して、引数として <xref:System.Windows.FrameworkElement.Name%2A> 文字列を受け取ることもできます。  
  
 一般的に使用されるルート要素 (<xref:System.Windows.Window>、<xref:System.Windows.Controls.Page> など) は、インターフェイス <xref:System.Windows.Markup.INameScope>を実装します。 このインターフェイスの実装では、その名前がスコープ内で明確になるようにする必要があります。 このインターフェイスを定義するルート要素は、関連するすべての Api の名前スコープの動作の境界も定義します。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> プロパティは、他のプロセスの識別子としても機能します。 たとえば、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] オートメーションモデルでは、クライアントとプロバイダーの AutomationId として <xref:System.Windows.FrameworkElement.Name%2A> が使用されます。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> に使用される文字列値には、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] の仕様で定義されている、基になる[X:Name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)によって課せられるいくつかの制限があります。 特に、<xref:System.Windows.FrameworkElement.Name%2A> は文字またはアンダースコア (_) で始まり、アルファベット、数字、またはアンダースコアのみで構成されている必要があります。 詳細については、「 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)」を参照してください。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> は、アニメーション化できない (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> がメタデータに `true` される) 非常に少ない依存関係プロパティの1つです。これは、アニメーションを対象とするために名前自体が不可欠であるためです。 <xref:System.Windows.FrameworkElement.Name%2A> のデータバインディングは技術的には可能ですが、データバインド <xref:System.Windows.FrameworkElement.Name%2A> は、コードビハインドの識別子接続ポイントを提供するために、プロパティの主な目的を果たすことができないため、非常に一般的なシナリオです。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.NameProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.FrameworkElement.Name%2A> プロパティをコードで設定し、<xref:System.Windows.FrameworkElement.RegisterName%2A>を呼び出すことによって、新しく作成された <xref:System.Windows.NameScope> に名前を登録します。 ここで説明する手法は、ストーリーボードを使用してアニメーション化するための要件です。これは、ストーリーボードが <xref:System.Windows.FrameworkElement.Name%2A>によってターゲットにする必要があり、オブジェクト参照の対象にすることができないためです。  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Name" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、アプリケーション コードまたは内部プロセスが <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /> を呼び出すたびに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。  
  
 テンプレートは、要素に適用される <xref:System.Windows.Style> のテンプレートプロパティから取得される、要素の完了したビジュアルツリーのセクションです。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.FrameworkElement" /> の派生クラスでは、次のようなさまざまなシナリオで、このメソッドを通知として使用できます。 
-要素のビジュアルツリーの残りの部分をビルドする独自のコードの実装を呼び出すことができます。  
  
-テンプレートから取得した名前付き要素への参照の取得など、テンプレートを適用したビジュアルツリーに依存するコードを実行できます。  
  
-テンプレートのビジュアルツリーが完成した後に存在するだけの意味のあるサービスを導入することができます。  
  
-他の要因に依存するテンプレート内の要素の状態とプロパティを設定できます。 たとえば、プロパティ値は、親要素を知っている場合、または特定の派生クラスで共通のテンプレートが使用されている場合にのみ検出できます。  
  
実装では、常に、独自の実装の前に基本実装を呼び出す必要があります。 <see cref="T:System.Windows.FrameworkElement" /> 自体には既定の実装はありませんが、介在するクラスが考えられます。  
  
 <see cref="T:System.Windows.Controls.Control" /> には、<see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />と同様のオーバーライドが用意されています。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理の <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 On * メソッドの実装パターンは、ルーティングイベントによって異なります。これは、ルーティングイベントが、必ずしもハンドラーを呼び出す要素ではなく、子要素によって発生している可能性があるためです。そのため、実装では、イベント引数のソースプロパティを考慮に入れる必要があります (ほとんどの場合、イベントを再発生させない <xref:System.Windows.FrameworkElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。 考えられるシナリオの1つは、イベントの引数を受け取り、イベントを処理済みとして意図的にマークすることです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 On * メソッドの実装パターンは、ルーティングイベントによって異なります。これは、ルーティングイベントが、必ずしもハンドラーを呼び出す要素ではなく、子要素によって発生している可能性があるためです。そのため、実装では、イベント引数のソースプロパティを考慮に入れる必要があります (ほとんどの場合、イベントを再発生させない <xref:System.Windows.FrameworkElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。 考えられるシナリオの1つは、イベントの引数を受け取り、イベントを処理済みとして意図的にマークすることです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.GotFocus" /> イベントが、その経路上でこの要素に到達するたびに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本要素によって公開されている他のいくつかのメソッドとは異なり、<xref:System.Windows.FrameworkElement.OnGotFocus%2A> には既定の実装があります。 具体的には、<xref:System.Windows.UIElement.OnGotFocus%2A>の基本要素の次のレベルで、null 実装をオーバーライドする実装があります。 呼び出された場合、<xref:System.Windows.FrameworkElement.OnGotFocus%2A> は、キーボードフォーカスが原因で現在の要素からイベントが発生した場合に、この要素に適切なフォーカス動作を設定します。 <xref:System.Windows.FrameworkElement.OnGotFocus%2A> ハンドラーは、フォーカスが現在の要素に設定されている場合でも、イベント引数を処理済みとしてマークしません。 イベントのソースが (現在の要素ではなく) ツリー内の別の要素であった場合、ハンドラーは何も行いません。  
  
 このメソッドは、要素の既定のフォーカス動作を変更するためにオーバーライドできます。ただし、この方法でフォーカス動作を変更すると、要素にフォーカスを設定することができないため、より適切に処理することができます (「<xref:System.Windows.UIElement.Focusable%2A>」を参照してください)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>引数で処理されるイベントをマークする場合は、要素ツリー内の他の親要素でのイベント処理の結果に注意する必要があります。 このハンドラーはバブルルーティングを使用するイベントで動作するため、イベント引数ごとに現在の <paramref name="sender" /> にフォーカスを設定することは適切ではない可能性があります。 フォーカスは、特定のコントロールの複合に応じて、複合子要素または親要素に移動する必要がある場合があります。 したがって、フォーカスイベントを処理済みとしてマークすることが推奨されるのは、イベントがルーティングされるビジュアルツリー全体が、作成したコントロールの複合の一部である場合のみです。</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.FrameworkElement.Initialized" /> イベントを発生させます。 このメソッドは、<see cref="P:System.Windows.FrameworkElement.IsInitialized" /> が内部で <see langword="true" /> に設定されるたびに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この特定の On * メソッドは、クラスハンドラーのフックではありません。 また、このメソッドは、確立された [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] の * メソッド規則に厳密に従っていません。このメソッドをオーバーライドすることによって、このメソッドをオーバーライドし、基本実装を呼び出さずに、一致するイベントを抑制する  
  
 <xref:System.Windows.FrameworkElement.IsInitialized%2A> プロパティは読み取り専用なので、初期化動作を強制するように <xref:System.Windows.FrameworkElement.IsInitialized%2A> を設定することはできません。 初期化状態の設定は、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework によってのみ実行されることを意図しています。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>この仮想メソッドの既定の実装は、上で説明したようにイベントを発生させます。 オーバーライドでは、この動作を保持するために基本実装を呼び出す必要があります。 基本の実装を呼び出すことができない場合は、<see cref="T:System.Windows.FrameworkElement" /> 派生クラスの <see cref="E:System.Windows.FrameworkElement.Initialized" /> イベントが発生するだけでなく、この基本実装によって実装されている2つの重要なスタイルとテーマスタイルの初期化操作も抑制します。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更されたプロパティと、新旧の値を記述するイベント データ。</param>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> の依存関係プロパティの有効値が更新された場合に必ず呼び出されます。 変更が発生した特定の依存関係プロパティが引数パラメーターで報告されます。 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> をオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、一般的にプロパティの変更や無効化を検出するためのものではありません。 プロパティの広範な分類に関する特定の情報がわかっている場合は、一般的な無効化パターンを変更することを意図しています。  
  
 このメソッドは、オブジェクトの有効期間中に何度も呼び出される可能性があります。 したがって、特定のプロパティのメタデータをオーバーライドし、個々のプロパティに <xref:System.Windows.CoerceValueCallback> または <xref:System.Windows.PropertyChangedCallback> 関数をアタッチすると、パフォーマンスが向上します。 ただし、このメソッドは、<xref:System.Windows.FrameworkElement> に大量の値に関連する依存関係プロパティが含まれている場合、またはプロパティの無効化の複数の関連するケースに対して再実行する必要があるレンダリング動作などのロジックが含まれている場合に使用します。  
  
 さまざまなクラスで使用できるシグネチャが異なる (パラメーターの型が <xref:System.ComponentModel.PropertyChangedEventArgs>) `OnPropertyChanged` メソッドが同じ名前であることに注意してください。 この `OnPropertyChanged` は、データオブジェクトの通知に使用され、<xref:System.ComponentModel.INotifyPropertyChanged>のコントラクトに含まれます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>実装の最初の操作として、常に基本実装を呼び出します。 この操作を行わないと、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プロパティシステム全体が大幅に無効になり、間違った値が報告されます。 また、特定の <see cref="T:System.Windows.FrameworkElement" /> 実装は、表示されるユーザーインターフェイスに影響を与えるさまざまなプロパティに対して適切な状態を維持する役割も担います。 これには、適切なタイミングでのスタイルの変更に基づいて、ビジュアルツリーを無効にすることが含まれます。</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">変更に関係する、古いサイズと新しいサイズの詳細。</param>
        <summary>指定した情報を最終的なイベント データの一部として使用して、<see cref="E:System.Windows.FrameworkElement.SizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.UIElement.OnRenderSizeChanged%2A> をオーバーライドします。 このメソッドを呼び出すと、指定された引数の変更内容に応じて、<xref:System.Windows.FrameworkElement.ActualWidth%2A> プロパティ、<xref:System.Windows.FrameworkElement.ActualHeight%2A> プロパティ、またはその両方がリセットされ、常にイベントが発生します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>一般的なレイアウトシナリオでは、このメソッドをオーバーライドしないでください。 レイアウトシステムは、考えられるすべてのレイアウトの配置および測定ケースが確実に考慮されるように、意図的に非同期で動作します。 レイアウトシステムオーバーライドメソッド <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> と <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> は通常、必要なレイアウトのカスタマイズには十分です。 <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> は仮想として公開されます。 <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> をオーバーライドして、入力イベントに関連する実行時の動作の変更と、応答の control 再合成との組み合わせによって、レイアウト情報が不正確になる可能性がある例外的なケースを修正できます。  
  
派生クラスでこのメソッドをオーバーライドすることもできます (プロテクトになっていますが、シールされていません)。 既定の WPF フレームワークレベルのレンダリング動作を無効にする特別な理由がない限り、常に基本実装を呼び出して、上記の動作を保持します。 標準の WPF フレームワークレベルレイアウトシステムの実装を使用している場合、<see cref="E:System.Windows.FrameworkElement.SizeChanged" /> イベントの発生に失敗すると、非標準のレイアウトの動作が発生します。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">元のスタイル。</param>
        <param name="newStyle">新しいスタイル。</param>
        <summary>この要素で使用されているスタイルが変更された場合に呼び出されます。スタイルが変更されるとレイアウトが無効になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、スタイル変更条件を示す内部フラグを設定する既定の実装があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>通常、このメソッドをオーバーライドする必要はありません。 メジャーまたは整列の変更に関係するスタイルを変更した場合は、<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> / <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />、または既定の実装が一般的に実装されていることを前提として、既に別のレンダリングサイクルがトリガーされます。 <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> のオーバーライドは、<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> / <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> の実装が意図的に最適化されているか、部分的な更新をサポートしていても、スタイルに変更を直接適用する必要がある場合に適しています。 (部分更新では、複数のインクリメンタル呼び出しを <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> して、任意の子要素で <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> する必要があります)。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理の <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 On * メソッドの実装パターンは、ルーティングイベントによって異なります。これは、ルーティングイベントが、必ずしもハンドラーを呼び出す要素ではなく、子要素によって発生している可能性があるためです。そのため、実装では、イベント引数のソースプロパティを考慮に入れる必要があります (ほとんどの場合、イベントを再発生させない <xref:System.Windows.FrameworkElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。 考えられるシナリオの1つは、イベントの引数を受け取り、イベントを処理済みとして意図的にマークすることです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary><see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。これは、インスタンスハンドラーではなくクラスハンドラーを使用して、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 On * メソッドの実装パターンは、ルーティングイベントによって異なります。これは、ルーティングイベントが、必ずしもハンドラーを呼び出す要素ではなく、子要素によって発生している可能性があるためです。そのため、実装では、イベント引数のソースプロパティを考慮に入れる必要があります (ほとんどの場合、イベントを再発生させない <xref:System.Windows.FrameworkElement> のサブクラスでは、ルートでイベントを受信したときにプライベートクラスハンドラーメソッドを呼び出すことができます。 考えられるシナリオの1つは、イベントの引数を受け取り、そのイベントを処理済みとして意図的に設定して、ルートを短縮することです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">前の親要素。 以前、要素にビジュアル親が存在していなかったことを示す <see langword="null" /> である可能性があります。</param>
        <summary>ビジュアル ツリー内のこの要素の親が変更されたときに呼び出されます。 <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" /> をオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビジュアルツリーは、コレクションなどの視覚的に表示されない要素を省略し、テーマやスタイルの合成に基づいて一部の要素を展開するため、論理ツリーとは異なる可能性があります。 詳細については、「[WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>新しい親に対するこの仮想メソッドクエリの既定の実装では、さまざまな初期化イベントが発生し、必要に応じて <see cref="T:System.Windows.FrameworkElement" /> の初期化状態に関する内部フラグが設定されます。 最後に、<see cref="T:System.Windows.UIElement" />によって宣言された一連の基本実装を呼び出し、<see cref="T:System.Windows.Media.Visual" />でそのベースを呼び出します。 常に基本実装を呼び出してこの動作を保持します。それ以外の場合は、別の要素の子として宣言されている場合、この要素の要素ツリーの動作が想定どおりでない可能性があります。  
  
いくつかの既存の [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] クラスは、このメソッドをオーバーライドします。たとえば、<see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />、<see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />です。 最も一般的なシナリオは、新しい親が特定の型であることを強制することです。 これには、新しい親が型テストの何らかの方法で失敗した場合に、例外をスローすることが含まれることがあります。 このシナリオの特化されたバージョンは、リスト項目およびメニュー項目の実装に存在します。これは、に格納する適切なコレクションを所有する親ビジュアルの外部では意味がありません。 これらのケースでは必ずしも例外が発生するとは限りません。これは、"regular" 親が一時的でない親要素に依存するデザイナーシナリオがある可能性があるためです。  
  
このメソッドは、通常はルート要素である特定の要素 (<see cref="T:System.Windows.Window" />など) でもオーバーライドされます。 もう1つのケースは、マークアップの明らかなルート要素であり、コンパイルされた論理ツリー (<see cref="T:System.Windows.Controls.Page" />など) でより多くのインフラストラクチャを自動生成する要素です。 <see cref="T:System.Windows.Window" /> と <see cref="T:System.Windows.Controls.Page" /> の実装は、メソッドを意図的に封印します。</para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、テーマのスタイルのスタイル プロパティが含まれるかどうかを示す値を取得または設定します。</summary>
        <value>この要素がテーマ スタイル プロパティを使用しない場合は <see langword="true" /> (スタイルが生成するすべてのプロパティは、ローカルのアプリケーション スタイルに起因するため、テーマ スタイル プロパティは適用されません)。 まずアプリケーション スタイルを適用してから、アプリケーション スタイルで明確に設定されなかったプロパティに対してテーマ スタイルを適用する場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの最も一般的な使用方法は、テーマスタイルを提供するスタイルの setter 内での間接的な使用です。  
  
> [!IMPORTANT]
>  コントロールで <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> を `true` に設定した場合は、テーマスタイルによって提供される既定のコントロールテンプレートが抑制されます。 このコントロールテンプレートには、通常、コントロールの基本的な [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 機能と視覚エフェクトを提供するコンテンツプレゼンターとその他の複合要素が含まれています。 コントロールで、既定のテーマスタイルと同じ機能を引き続きサポートする場合は、同じ構造体をレプリケートするコントロールテンプレートを使用して、代替スタイルを指定する必要があります。 詳しくは、「[コントロールの作成の概要](~/docs/framework/wpf/controls/control-authoring-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の論理上の親要素を取得します。</summary>
        <value>この要素の論理上の親。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> は、要素がインスタンス化されていても、最終的にページレベルのルート要素またはアプリケーションオブジェクトに接続する論理ツリーにアタッチされていない場合に `null` できます。  
  
 要素の論理上の親は、アプリケーションの機能によって変わる可能性があります。このプロパティの値を維持しても、その変更は反映されません。 通常は、必要な値をすぐに取得する必要があります。  
  
 論理ツリーの走査の詳細と、親要素の検出の手法として <xref:System.Windows.FrameworkElement.Parent%2A> を使用するシナリオについては、「 [WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md) 」を参照してください。  
  
 プロパティエンジンは、親のときに、要素のすべてのプロパティ値を再計算する可能性があります。これは、一部のプロパティが論理ツリーを通じて値を継承するためです。 バインドに適用される <xref:System.Windows.FrameworkElement.DataContext%2A> は、要素が親されたときにも変更できます。  
  
 通常、要素の親を変更するには、専用の add メソッドまたは remove メソッドを使用するか、要素のコンテンツプロパティを設定することによって、コレクションの操作を行います。  
  
 <xref:System.Windows.FrameworkElement.Parent%2A> プロパティを使用する最も一般的なシナリオは、参照を取得し、親からさまざまな <xref:System.Windows.FrameworkElement> プロパティ値を取得することです。 テンプレートの場合は、最終的にテンプレートの <xref:System.Windows.FrameworkElement.Parent%2A> が `null`されます。 この点を超えて、テンプレートが実際に適用される論理ツリーに拡張するには、<xref:System.Windows.FrameworkElement.TemplatedParent%2A>を使用します。  
  
 このプロパティは、論理ツリーの親とは異なる場合に、ビジュアルツリーの親を報告しないことに注意してください。 一般的なアプリケーションの場合、ビジュアルツリーの親は通常は重要ではありませんが、特定のビジュアルレベルのケースに必要な親要素である場合があります。 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Media.VisualTreeHelper>) をご覧ください。  
  
   
  
## Examples  
 次の例では、要素の親を確認し、親のプロパティ値を使用して、一致する子要素のプロパティを設定するコードを示します。 この場合、表示サイズに影響するプロパティです。  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">変更を報告している子要素。</param>
        <summary><see cref="T:System.Windows.FrameworkElement" /> の特殊化されたサブクラスでインクリメンタル レイアウトの実装をサポートします。 レイアウト中に親のメジャーまたは整列パスに影響を与えるものとしてメタデータ内でマークされているプロパティを子要素が無効にすると、<see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> が呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素に、いくつかのプロパティが無効にされた子要素があり、プロパティが <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> としてマークされているか、登録時にプロパティメタデータに <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> た場合、このメソッドが呼び出されます。 この要素でレイアウトの部分的な (増分) 更新がサポートされている場合、メソッドの呼び出しは親要素に対して、特定の子要素を再測定する必要があることを通知します。  
  
 既定では、<xref:System.Windows.FrameworkElement> は増分レイアウトをサポートしておらず、<xref:System.Windows.FrameworkElement> クラスでは、このメソッドには既定の実装がありません。 既定のレイアウトシステムの動作を変更する必要があるため、このメソッドをオーバーライドする必要があるというシナリオは一般的ではありません。  
  
 実装シナリオの例としては、WPF フレームワークレベルのレイアウトシステムよりも制限の厳しい子要素に対して、クラスに型の制限がある場合が考えられます。 これらのカスタム要素の性質により、カスタムレイアウト動作を実装すると、プロパティの変更が意図的に遅延される可能性があります。 たとえば、measure/arrange メソッドのオーバーライドでは、子要素の描画パスを最適化しようとしますが、通常は別のレイアウトパスになるような特定の種類の変更に対して遅延が発生する可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">予想されるフォーカスの変更を決定する方向。</param>
        <summary>この要素を基準に、指定したフォーカスの移動方向で次にフォーカスを受け取る要素を特定します。ただし、実際のフォーカスの移動は行われません。</summary>
        <returns>フォーカスが実際にスキャンされた場合にフォーカスの移動先となる、次の要素。 この要素を基準に、指定した方向へフォーカスを移動できない場合は、<see langword="null" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> は、実際にフォーカスを移動する関連のメソッドです。  
  
   
  
## Examples  
 次の例では、いくつかのボタン入力を処理するハンドラーを実装します。各ボタンは、可能な <xref:System.Windows.Input.FocusNavigationDirection>を表します。 ハンドラーは、現在のキーボードフォーカスを持つ要素を追跡し、その要素に対して <xref:System.Windows.FrameworkElement.PredictFocus%2A> を呼び出し、指定された <xref:System.Windows.Input.TraversalRequest> 型パラメーターの初期化として適切な <xref:System.Windows.Input.FocusNavigationDirection> を指定します。 この要素に移動するのではなく、<xref:System.Windows.FrameworkElement.MoveFocus%2A> のように、ハンドラーは視覚化を目的として予測されたフォーカス先の物理寸法を変更します。  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Windows.Input.TraversalRequest" /> に、<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /> のいずれかの方向が指定されました。 これらの方向は、<see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> に対しては有効ではありません (<see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> に対しては有効です)。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">指定した名前オブジェクトの割り当てに使用する名前。</param>
        <param name="scopedElement">割り当て対象のオブジェクト。</param>
        <summary><see cref="T:System.Windows.NameScope" /> の登録メソッドへのアクセスを簡略化するアクセサーを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.NameScope.RegisterName%2A>を呼び出すための便利なメソッドです。 実装では、適用可能な <xref:System.Windows.NameScope> 実装が見つかるまで、連続する親要素がチェックされます。この実装は、<xref:System.Windows.Markup.INameScope>を実装する要素を検索することによって検出されます。 名前スコープの詳細については、「 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)」を参照してください。  
  
 コードで作成されたアプリケーションのアニメーションストーリーボードを正しくフックするには、<xref:System.Windows.FrameworkElement.RegisterName%2A> を呼び出す必要があります。 これは、キーストーリーボードのプロパティの1つである <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>は、ターゲット要素への参照を取得するのではなく、実行時の名前参照を使用するためです。 これは、コードから参照によってその要素にアクセスできる場合でも同様です。 ストーリーボードターゲットの名前を登録する必要がある理由の詳細については、「[ストーリーボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)」を参照してください。  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">削除する要素です。</param>
        <summary>指定されたオブジェクトをこの要素の論理ツリーから削除します。 <see cref="T:System.Windows.FrameworkElement" /> は、この削除との同期を維持するために影響を受ける論理ツリーの親ポインターを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、要素の論理的な子を表すオブジェクトのコレクションの実装に使用します。 これは、プロパティの getter または setter、`Changed` イベントのクラスハンドラー、コンストラクター、またはコレクション型自体で行うことができます。  
  
 コントロールの作成者は、指定された基本コントロールクラスのコンテンツモデルが適切でない場合を除き、このレベルで論理ツリーを操作することは推奨されません。 <xref:System.Windows.Controls.ContentControl>、<xref:System.Windows.Controls.ItemsControl>、および <xref:System.Windows.Controls.HeaderedItemsControl>のレベルでサブクラス化することを検討してください。 これらのクラスは、専用の Api を使用して論理的な子の適用を特定するコンテンツモデルを提供します。また、テンプレートを使用したスタイル設定などの [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 制御で通常は望ましい他の機能をサポートします。  
  
   
  
## Examples  
 次の例では、独自のビジュアル層実装を行うカスタム <xref:System.Windows.FrameworkElement> の `Child` プロパティを実装しています。 プロパティの setter は、値が変更された場合に、クラス固有のビジュアルコレクションだけでなく、論理ツリーから古い値が削除されるように設計されています。 値がキャッシュされた後、新しい値が標準の WPF フレームワークレベルの論理ツリーとカスタムビジュアルコレクションの両方に追加されます。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素で <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> が呼び出されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントを発生させる要素がスクロール可能な領域内に表示される必要があることを親 <xref:System.Windows.Controls.ScrollViewer> (または派生クラス) に示します。 <xref:System.Windows.Controls.ScrollViewer> は、イベントのクラス処理を使用して、<xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントを処理済みとしてマークします。 一般に <xref:System.Windows.FrameworkElement.RequestBringIntoView> イベントデータは、スクロール領域を制御するクラス、または任意のインスタンスハンドラーによって処理されるようにマークすることはできません。これにより、<xref:System.Windows.FrameworkElement.BringIntoView%2A>を呼び出した要素の目的が妨げられる可能性があるためです。  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|ルーティング方法|バブリング|  
|委任|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカルで定義されたリソース ディクショナリを取得または設定します。</summary>
        <value>ローカルで定義された現在のリソース ディクショナリ。各リソースにはキーでアクセスできます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] で完全または部分的に定義できるリソースディクショナリは、通常、プロパティ要素として作成され、通常は個々のページまたはアプリケーションのルート要素にあります。 リソースディクショナリをこのレベルに配置すると、ページ内の個々の子要素 (または、アプリケーションケースでは任意のページ) から簡単に検索できるようになります。 ほとんどのアプリケーションシナリオでは、スタイルをリソースディクショナリ内のオブジェクト要素として定義するか、または外部リソースとして定義して、スタイルリソース全体を自己完結させることをお勧めします (この方法を使用すると、編集が必要な物理ファイルを分離することによって、開発者の責任からデザイナーの役割を分離  
  
 このプロパティは、その要素内で直接宣言されたリソースディクショナリだけを返すことに注意してください。 これは、実際のリソース参照プロセスとは異なります。子要素は、各親要素で定義されている任意のリソースにアクセスして、再帰的に検索します。  
  
 リソースは、コレクション内のコードによって参照することもできますが、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] で作成されたリソースは、ディクショナリを宣言する要素によって <xref:System.Windows.FrameworkElement.Loaded> が発生するまで確実にアクセスできないことに注意してください。 実際、リソースは、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 定義されたリソースを参照できる保証であることを <xref:System.Windows.FrameworkElement.Loaded> イベントではなく、非同期的に解析されます。 このため、一般に、実行時コードの一部として [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 定義されたリソースにのみアクセスするか、または属性値に対するスタイルやリソース拡張機能の参照などの他の [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 手法を使用する必要があります。 コードを使用してリソースにアクセスする場合は、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]から作成された[Dynamicresource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)参照と基本的に同じです。  
  
 基になる <xref:System.Windows.ResourceDictionary> は、コードを使用して、コレクション内のリソースの追加、削除、またはクエリを実行するために必要なメソッドをサポートします。 <xref:System.Windows.FrameworkElement.Resources%2A> プロパティは、要素のリソースコレクションを新しいまたは別の <xref:System.Windows.ResourceDictionary>として完全に置き換えるシナリオをサポートするために設定できます。  
  
 表示される [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文には、<xref:System.Windows.ResourceDictionary>の要素が含まれていないことに注意してください。 これは、暗黙的なコレクション構文の例です。コレクション要素を表すタグを省略できます。 コレクションに項目として追加された要素が代わりに指定されます。 暗黙のコレクションと [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]の詳細については、「 [XAML 構文の詳細](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)」を参照してください。 <xref:System.Windows.ResourceDictionary> が要素として明示的に指定されている場合、マージされたディクショナリを導入すると、その <xref:System.Windows.ResourceDictionary>の子要素は通常ありません。 詳細については、「マージされた[リソースディクショナリ](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)」を参照してください。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML の値  
 *oneOrMoreResourceElements*  
 1つ以上のオブジェクト要素。それぞれがリソースを定義します。 各 <xref:System.Windows.ResourceDictionary> 内の各リソースプロパティ要素には、<xref:System.Windows.ResourceDictionary>から値を取得するときに一意のキーとして機能する、 [X:Key ディレクティブ](~/docs/framework/xaml-services/x-key-directive.md)に対して一意の値を指定する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">x:Key 属性</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した依存関係プロパティのためのバインディングをこの要素に添付します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">バインディングを確立する必要がある対象のプロパティを識別します。</param>
        <param name="path">ソース プロパティ名、またはバインドに使用されているプロパティへのパス。</param>
        <summary>指定したソース プロパティ名をデータ ソースへのパスの修飾として使用して、この要素にバインディングを添付します。</summary>
        <returns>バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のインスタンスを <xref:System.Windows.DependencyObject>として渡し、指定された `path` パラメーターに基づいて新しい <xref:System.Windows.Data.Binding> を作成する <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>を呼び出すための便利なメソッドです。 この署名は、単純な既定のバインドを確立する場合に便利です。 バインドプロパティを既定以外の条件に指定する必要がある場合、または <xref:System.Windows.Data.MultiBinding> または <xref:System.Windows.Data.PriorityBinding>を使用する場合は、<xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> シグネチャを使用する必要があります。  
  
   
  
## Examples  
 次の例では、特定のパスを使用してバインディングを設定します。  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">バインドを確立する必要があるプロパティを識別します。</param>
        <param name="binding">データ バインディングの詳細を表します。</param>
        <summary>指定したバインディング オブジェクトに基づいて、この要素にバインドをアタッチします。</summary>
        <returns>バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のインスタンスを <xref:System.Windows.DependencyObject>として渡す <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>を呼び出すための便利なメソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">フロー方向を指定する要素。</param>
        <param name="value">方向を指定する列挙値。</param>
        <summary>指定された要素の <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 添付プロパティの値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.FrameworkElement.FlowDirection%2A> プロパティの添付プロパティ構文をサポートしているため、指定された <xref:System.Windows.FrameworkElement> の子要素は、親要素内の配置のフロー方向を指定できます。 現在の <xref:System.Windows.FrameworkElement>に値を設定するには、直接 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] アクセサー <xref:System.Windows.FrameworkElement.FlowDirection%2A>を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">リソースのバインド先のプロパティ。</param>
        <param name="name">リソースの名前。</param>
        <summary>指定した名前のリソースを検索し、指定したプロパティにそのリソースへのリソース参照を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソース参照は、マークアップで[Dynamicresource マークアップ拡張機能](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)を使用する場合と似ています。 リソース参照は、指定されたプロパティの値を実行時の遅延ベースで提供する内部式を作成します。 式は、リソースディクショナリが内部イベントによって変更された値を示した場合、または現在の要素が親された場合 (親の変更によって辞書参照パスが変更される場合) は常に再評価されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、<see cref="P:System.Windows.FrameworkElement.Resources" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkElement.Resources" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカル <xref:System.Windows.FrameworkElement.Resources%2A>にキー付きリソースが少なくとも1つ存在する限り、`true` が返されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、<see cref="P:System.Windows.FrameworkElement.Style" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkElement.Style" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Style> がローカルに設定されている場合は、`true` が返されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、<see cref="P:System.Windows.FrameworkElement.Triggers" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkElement.Triggers" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.FrameworkElement.Triggers%2A> プロパティがローカルに設定されている場合に `true` を返します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> プロパティまたは <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> プロパティの値が変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ダイレクトルーティングイベントはルートに従わないので、これらのイベントは、発生したものと同じ要素内でのみ処理されます。 直接ルーティングイベントでは、他のルーティングイベントの動作がサポートされます。これらは、アクセス可能なハンドラーコレクションをサポートし、スタイルの <xref:System.Windows.EventTrigger> として使用できます。  
  
 レイアウトシステムは、このイベントの <xref:System.Windows.SizeChangedEventArgs> argument クラス内のプロパティを読み取り、報告されたサイズ変更を有意と見なす必要があるかどうかを判断します。 これにより、レイアウトシステムまたはコントロール固有のレイアウト実装で、古い高さ値と新しい高さ値の間で視覚的になるべくの違いによってレイアウトの変更が強制されないようにすることができます。 なるべくの違いは、浮動小数点データ型の丸め処理または計算結果の計算が原因である可能性があります。  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|ルーティング方法|直接|  
|委任|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.SizeChanged" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の既存のプロパティ バインディングのソース値が変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、この要素に関連付けられている <xref:System.Windows.Data.Binding> によって発生する <xref:System.Windows.Data.Binding.SourceUpdated> イベントのエイリアスを作成します。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が使用するスタイルを、表示されるときに取得または設定します。</summary>
        <value>要素に適用される既定以外のスタイル (存在する場合)。 それ以外の場合は <see langword="null" />。 既定で構築された <see cref="T:System.Windows.FrameworkElement" /> の既定値は <see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの場合、現在のスタイルは、コントロールのテーマからの既定のスタイル、またはページレベルまたはアプリケーションレベルのリソースによってその型のコントロールに一般的に適用されるスタイル (暗黙的なスタイル) によって提供されます。 このプロパティは、既定 (テーマ) のスタイルを設定または返しませんが、暗黙的なスタイルまたは要素に対して動作する明示的なスタイルのいずれかを返します。 暗黙的または明示的なスタイルの場合、スタイルがリソースとして指定されているか、ローカルに定義されているかは関係ありません。  
  
 スタイルの設定にはいくつかの制限があります。 <xref:System.Windows.FrameworkElement.Style%2A> のプロパティ全体を、いつでも新しい <xref:System.Windows.Style> にリセットできます。これにより、レイアウト再合成が強制的に適用されます。 ただし、読み込まれた要素によってそのスタイルが使用されるとすぐに、<xref:System.Windows.Style> が sealed と見なされます。 使用中のスタイル (<xref:System.Windows.Style.Setters%2A>のコレクション内にあるものなど) の個々のプロパティを変更しようとすると、例外がスローされます。 マークアップで定義されたスタイルは、リソースディクショナリ (リソースの場合) から読み込まれたとき、またはそれが含まれているページが読み込まれるとすぐに使用中と見なされます (インラインスタイルの場合)。  
  
 <xref:System.Windows.FrameworkElement.Style%2A> は、特殊な優先順位を持つ依存関係プロパティです。 ローカルで設定されたスタイルは、一般に、プロパティシステムで最も優先順位が高いものになります。 この時点で <xref:System.Windows.FrameworkElement.Style%2A> が null の場合、プロパティシステムの読み込み中に、その型を指定するローカルリソースまたはアプリケーションリソースの暗黙的なスタイルを確認します。 この手順の後でスタイルが null の場合は、通常、プレゼンテーション目的で動作するスタイルは既定 (テーマ) のスタイルから取得されますが、<xref:System.Windows.FrameworkElement.Style%2A> のプロパティ値では既定のスタイルは返されません。 「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」 [、「スタイルとテンプレート」を](~/docs/framework/wpf/controls/styling-and-templating.md)参照してください。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML の値  
 *resourceExtension*  
 次のいずれか:、または。 「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
 *styleResourceKey*  
 要求されているスタイルを識別するキー。 キーは、<xref:System.Windows.ResourceDictionary>内の既存のリソースを参照します。  
  
> [!NOTE]
>  Property 要素の構文は技術的には可能ですが、ほとんどのスタイルのシナリオでは推奨されません。 「[インラインスタイルとテンプレート」を](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)参照してください。 [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md)または <xref:System.Windows.Data.Binding> を使用したバインディング参照も可能ですが、一般的ではありません。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例では、リソースディクショナリでスタイルを定義します。  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Style" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool&#xA;override this.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool" Usage="frameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable propertyName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求されたアンビエント プロパティの名前。</param>
        <summary>このメンバーの説明については、<see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> メソッドのトピックを参照してください。</summary>
        <returns><paramref name="propertyName" /> を使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Windows.FrameworkElement> のインスタンスが <xref:System.Windows.Markup.IQueryAmbient> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関するユーザー定義情報の格納に使用できる任意のオブジェクト値を取得または設定します。</summary>
        <value>任意の値。 このプロパティに既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、Visual Basic for Applications や Windows フォームなど、他の Microsoft プログラミングモデルのタグプロパティに似ています。 <xref:System.Windows.FrameworkElement.Tag%2A> は、既存のプロパティの場所を提供することを目的としています。この場所には、要素をサブクラス化する必要なく、任意の <xref:System.Windows.FrameworkElement> に関する基本的なカスタム情報を格納できます。  
  
 このプロパティはオブジェクトを取得するため、XAML の <xref:System.Windows.FrameworkElement.Tag%2A> プロパティを、既知の組み込み型コンバーター (文字列など) を持つオブジェクト以外のものに設定するには、プロパティ要素の使用法を使用する必要があります。 この方法で使用されるオブジェクトは、通常、標準の WPF 名前空間内にはないため、XAML 要素として導入されるためには、外部名前空間への名前空間マッピングが必要になる場合があります。 詳細については、「 [WPF xaml および xaml の Xaml 名前空間と名前空間の割り当て](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)」および「 [Wpf のカスタムクラス](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.TagProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Tag" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のプロパティ バインディングのターゲット値が変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、この要素に関連付けられている <xref:System.Windows.Data.Binding> によって発生する <xref:System.Windows.Data.Binding.TargetUpdated> イベントのエイリアスを作成します。 これは、通常、問題のバインディングが双方向のバインディングであり、バインドされた依存関係プロパティが、プロパティまたはデータソースがサポートする検証またはキャッシュスキームに従って、前のプロパティ値が無効であることをものしていることを意味します。  
  
 <xref:System.Windows.FrameworkElement.TargetUpdated> イベントのイベントデータを使用して、対象の値の更新を報告している特定のプロパティを特定します。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の親テンプレートへの参照を取得します。 このプロパティは、要素がテンプレートによって作成されていない場合は無効です。</summary>
        <value>この要素が作成される原因となった <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> が属する要素。 多くの場合、この値は <see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> は、多くの場合、アプリケーションマークアップまたはコードで作成されるオブジェクトに対して `null` ます。 これは、テンプレートを使用せずに、これらのオブジェクトを直接作成するためです。 ルートまたは一般的な名前参照によって論理ツリーをウォークすることによって取得されたオブジェクト参照は、テンプレートからのものではありません。  
  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> が `null` されない可能性があるケースとしては、ヒットテスト、特定の低レベルの入力イベントのイベント処理、<xref:System.Windows.Media.VisualTreeHelper>を使用したビジュアルツリーのウォーク、テンプレートからの要素を返す可能性がある列挙子の操作などがあります。 また、既存の <xref:System.Windows.FrameworkTemplate> に対して <xref:System.Windows.FrameworkTemplate.FindName%2A> を明示的に呼び出し、返されたオブジェクトを操作する場合もあります。  
  
 テンプレートは実際には共有オブジェクトであり、テンプレートの内容は一度だけ作成されます。 したがって、テンプレートからの要素へのオブジェクト参照を取得した場合、見かけ上の論理ツリーがページルートに届かないことがあります。 このようなテンプレート参照をページの論理ツリーに接続するには、<xref:System.Windows.FrameworkElement.TemplatedParent%2A> 値を取得し、必要に応じてその要素ツリー内を移動し続ける必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] でこの要素に対して表示されるツールヒント オブジェクトを取得または設定します。</summary>
        <value>ツールヒント オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値が <xref:System.Windows.Controls.ToolTip>型の場合、その値は [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]で使用されるツールヒントです。  値が他の型の場合は、その値がシステムによって提供 (構築) される <xref:System.Windows.Controls.ToolTip> の*コンテンツ*として使用されます。 詳細については、<xref:System.Windows.Controls.ToolTipService> を参照してください。 サービスクラスには、<xref:System.Windows.Controls.ToolTip>をさらにカスタマイズするために使用できる添付プロパティが用意されています。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>
```

または

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML の値  
 *toolTipContent*  
 <xref:System.Windows.FrameworkElement.ToolTip%2A>の表示テキストになる文字列。  
  
 *toolTipObjectContent*  
 オブジェクト要素の形式で提供される、<xref:System.Windows.FrameworkElement>のコンテンツとして使用されるオブジェクト。 通常、これは <xref:System.Windows.FrameworkElement> またはその他の要素の1つであり、最終的には複合内のテキストコンテンツを含む、<xref:System.Windows.FrameworkElement.ToolTip%2A>のレイアウトの複合を作成します。 この使用法では、<xref:System.Windows.Controls.ToolTip> 要素が解析された [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]から暗黙的に作成され、 *toolTipObjectContent*コンテンツがその <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> プロパティとして設定されます。  
  
 <`ToolTip`.../>  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Controls.ToolTip>) をご覧ください。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、コード内に <xref:System.Windows.Controls.ToolTip> を作成し、<xref:System.Windows.Controls.Primitives.StatusBar> コントロールの <xref:System.Windows.FrameworkElement.ToolTip%2A> プロパティを設定します。  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のツールヒントが閉じる直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.ToolTipClosing> イベントを処理済みとしてマークしても、ツールヒントの終了はキャンセルされません。 ツールヒントが表示されると、UI を使用したユーザー操作に応答する場合にのみ、ツールヒントが終了します。  
  
 このイベントは、スタイルの <xref:System.Windows.EventTrigger> にすることはできません。 これは、このイベントの識別子フィールドがサービスレベルのイベントの add/remove イベントメソッドを公開しないサービスからの実装を再使用するためです。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|ルーティング方法|直接|  
|委任|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のツールヒントが開かれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UI にツールヒントが表示されないようにするには、<xref:System.Windows.FrameworkElement.ToolTipOpening> のハンドラーで <xref:System.Windows.Controls.ToolTipEventArgs> イベントデータを処理済みとしてマークします。 それ以外の場合は、<xref:System.Windows.FrameworkElement.ToolTip%2A> プロパティの値をツールヒントの内容として使用して、ツールヒントが表示されます。 もう1つの考えられるシナリオは、ツールヒントが表示される直前に、イベントソースである要素の <xref:System.Windows.FrameworkElement.ToolTip%2A> プロパティの値をリセットするハンドラーを記述できることです。  
  
 <xref:System.Windows.FrameworkElement.ToolTip%2A> の値が `null` または設定されていない場合、<xref:System.Windows.FrameworkElement.ToolTipOpening> は発生しません。 ツールヒントが開いているとき、または開いている間は、`null` に <xref:System.Windows.FrameworkElement.ToolTip%2A> を意図的に設定しないでください。これには、ツールヒントを閉じる効果がありません。代わりに、UI に望ましくない視覚的な成果物が作成されます。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> イベントをスタイルの <xref:System.Windows.EventTrigger> にすることはできません。 これは、このイベントの識別子フィールドがサービスレベルのイベントの add/remove イベントメソッドを公開しないサービスからの実装を再使用するためです。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|ルーティング方法|直接|  
|委任|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ToolTip" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に直接、または子要素で設定されているトリガーのコレクションを取得します。</summary>
        <value>厳密に型指定された <see cref="T:System.Windows.Trigger" /> オブジェクトのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このプロパティを設定できるのは、表示されているコレクション構文を使用するか、コレクションオブジェクトにアクセスし、Add などのさまざまなメソッドを使用して [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] だけです。 コレクションオブジェクト自体にアクセスするプロパティは読み取り専用で、コレクション自体は読み取り/書き込み可能です。 プロパティはルート要素にのみ存在します。検索または他の場所に設定しようとすると、例外がスローされます。  
  
 このプロパティを使用すると、この要素で使用されているスタイルの一部として存在するトリガーを調べることはできません。 このメソッドは、マークアップまたはコードのいずれかでコレクションに文字どおりに追加されるトリガーのコレクションのみを報告します。 通常、要素には、既定ではそのような要素が存在しません (インスタンスのテンプレートを使用)。これは、コントロールの複合から、代わりにスタイルで設定されるトリガーの方が一般的です。  
  
 動作 (および、どの要素が <xref:System.Windows.FrameworkElement.Triggers%2A> コレクションとして宣言されているか) では、トリガー条件とトリガー効果の両方がこの要素上に存在するか、論理ツリー内の子要素上にある可能性があります。 <xref:System.Windows.FrameworkElement.Loaded> などの有効期間イベントを使用してこのコレクションを取得すると、子要素のトリガーがまだ完全に読み込まれていない可能性があることに注意してください。コレクションは、実際に実行される場合よりも小さくなります。  
  
 要素に対して確立されたトリガーのコレクションでは、プロパティトリガー (<xref:System.Windows.Trigger>) ではなく <xref:System.Windows.EventTrigger>のみがサポートされていることに注意してください。 プロパティトリガーが必要な場合は、これらをスタイルまたはテンプレート内に配置し、<xref:System.Windows.FrameworkElement.Style%2A> プロパティを使用して直接、または暗黙的なスタイル参照を使用してそのスタイルまたはテンプレートを要素に割り当てる必要があります。  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML の値  
 *oneOrMoreTriggers*  
 1つ以上の定義済みの <xref:System.Windows.EventTrigger> 要素。 このようなトリガーには、有効なストーリーボードアクションと参照が含まれている必要があります。 このコレクションは、ページのルート要素でのみ設定できることに注意してください。 詳細については、「[ストーリーボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースのキー識別子。</param>
        <summary>指定されたキーを使用してリソースを検索し、見つかった場合はそのリソースを返します。</summary>
        <returns>見つかったリソース。指定した <paramref name="key" /> のリソースが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソースが呼び出し元の要素で見つからない場合は、実行時にキーによってリソースが要求された場合にツリーが検索されるのと同じ方法で、親リソースツリーが上方向に検索されます。 メソッドは、<xref:System.Windows.FrameworkElement.TryFindResource%2A> が呼び出された時点のツリーの既存の条件に従って、リソースツリー内の任意の場所にそのキーのリソースが存在しない場合にのみ `null` を返します。  
  
 通常は、返されたリソース値を使用して設定しようとしていたプロパティの型に戻り値を直ちにキャストします。  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A> メソッドの動作は似ていますが、指定されたキーを持つリソースが返されなかった場合に例外がスローされる点が異なります。  
  
   
  
## Examples  
 次の例は、ボタンハンドラーとして実装されています。ボタンをクリックすると、その背景が、<xref:System.Windows.FrameworkElement.TryFindResource%2A> を呼び出すことによって取得されるリソース定義のブラシに設定されます。 これにより、要素ツリーが表示され、リソースが検索されます (リソース自体は [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] で定義されており、表示されません)。  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み込まれた要素の要素ツリーから要素が削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ダイレクトルーティングイベントはルートに従わないので、これらのイベントは、発生したものと同じ要素内でのみ処理されます。 直接ルーティングイベントでは、他のルーティングイベントの動作がサポートされます。これらは、アクセス可能なハンドラーコレクションをサポートし、スタイルの <xref:System.Windows.EventTrigger> として使用できます。  
  
 ユーザーが開始したシステムテーマの変更の結果として、<xref:System.Windows.FrameworkElement.Loaded> と <xref:System.Windows.FrameworkElement.Unloaded> の両方がコントロールで発生する可能性があります。 テーマを変更すると、コントロールテンプレートとそれに含まれるビジュアルツリーが無効化されます。これにより、コントロール全体がアンロードされ、再読み込みされます。 したがって、<xref:System.Windows.FrameworkElement.Unloaded> がページから移動したときにのみ発生することを想定することはできません。  
  
 アプリケーションのシャットダウンが開始された後に、<xref:System.Windows.FrameworkElement.Unloaded> イベントが発生しないことに注意してください。 アプリケーションのシャットダウンは、<xref:System.Windows.Application.ShutdownMode%2A> プロパティによって定義された条件が発生したときに発生します。 <xref:System.Windows.Window> や <xref:System.Windows.Controls.UserControl>などの <xref:System.Windows.FrameworkElement.Unloaded> イベントのハンドラー内にクリーンアップコードを配置すると、予期したとおりに呼び出されないことがあります。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|ルーティング方法|直接|  
|委任|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.Unloaded" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">現在のスコープから削除する名前とオブジェクトのペアの名前。</param>
        <summary><see cref="T:System.Windows.NameScope" /> の登録解除メソッドへのアクセスを簡略化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じ名前の別の要素を再登録する場合にのみ、名前を登録解除する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Windows.FrameworkElement" /> に既定のスタイルを再度適用します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウトの間に、この要素のサイズおよび位置にレイアウトの丸めを適用するかどうかを示す値を取得または設定します。</summary>
        <value>レイアウトの丸めを適用する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素の <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> プロパティが `true`場合、<xref:System.Windows.UIElement.Measure%2A> と <xref:System.Windows.UIElement.Arrange%2A> のパスで計算される整数以外のすべてのピクセル値は、全体のピクセル値に丸められます。  
  
 このプロパティは、子要素によって継承されます。  
  
> [!NOTE]
>  ルート要素で `true` するには、<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> を設定する必要があります。 レイアウトシステムは、親座標に子座標を追加します。したがって、親座標がピクセル境界上にない場合、子座標もピクセル境界上にありません。 ルートに <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> を設定できない場合は、必要な効果を得るために、子に <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> を設定します。  
  
 ピクセル境界にオブジェクトを描画すると、エッジがデバイスピクセルの途中にあるときに、アンチエイリアシングによって生成される半透明の端が除去されます。 次の図は、デバイスピクセルの途中にある単一のピクセル幅線の出力を示しています。 左側の線は、レイアウトの丸め処理を使用せず、アンチエイリアス化されています。 右側の線は、レイアウトの丸め処理を使用します。  
  
 ![1&#45;つのピクセル線と比較した、アンチエイリアス行。](~/add/media/pixelsnaplinecompare.PNG "単一のピクセル線と比較したアンチエイリアス線。")  
  
 レイアウトの丸め処理や <xref:System.Windows.GridUnitType.Star> サイズ変更を使用する場合、サブピクセルレンダリングを避けるために、レイアウトシステムは列または行の測定値に小さいバリエーションを作成します。 たとえば、1つのグリッドの合計幅が100で、<xref:System.Windows.GridUnitType.Star>サイズがそれぞれ3列に設定されている場合、幅33.3 が等しい3つの列を作成するのではなく、幅が33、幅が34の2つの列がレイアウトシステムによって作成されます。  
  
> [!NOTE]
>  .NET 4.6 では、境界があるコントロールでのクリッピングのインスタンスを減らすために、レイアウトの丸め処理が行われました。 既定では、ターゲットフレームワークが4.6 以上 .NET Framework 場合、この機能は有効になっています。 以前のバージョンのフレームワークを対象とするアプリケーションでは、app.config ファイルに次の設定を追加することで新しい動作を選択できます。 `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` は、アプリケーションが .NET Framework 4.6 で実行されている場合にのみ有効になります。  
  
   
  
## Examples  
 次の例は、<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> プロパティが1つのピクセル幅の線に与える影響を示しています。 左側の線はレイアウトの丸め処理を使用しないので、右側の線はレイアウトの丸め処理を使用します。 ウィンドウのサイズをゆっくりと変更すると、レイアウトの丸め処理の違いがわかります。  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、Panel またはアイテム コントロールのような親要素内に作成されるときに適用される垂直方向の配置特性を取得または設定します。</summary>
        <value>垂直方向の配置の設定。 既定では、 <see cref="F:System.Windows.VerticalAlignment.Stretch" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素に対して <xref:System.Windows.FrameworkElement.Height%2A> および <xref:System.Windows.FrameworkElement.Width%2A> プロパティが明示的に設定されている場合、これらの測定はレイアウトの方向をとり、このプロパティを <xref:System.Windows.VerticalAlignment.Stretch>に設定した場合の通常の効果を取り消します。  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> は、実際の依存関係プロパティに対する [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] プロパティアクセサーです。 この特定の依存関係プロパティは、派生要素クラス (特にコントロール) では、明らかに "既定" 値が異なることがよくあります。 これは通常、次の2つの方法のいずれかで発生します。依存関係プロパティは、特定の派生クラスに再登録されますが、既定値を設定するために異なるメタデータを使用します。または、適用される既定のスタイルによって、その依存関係プロパティの値が異なるように設定されています。 たとえば、<xref:System.Windows.Controls.ComboBoxItem> コントロールの <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> の明らかな "既定" は、<xref:System.Windows.FrameworkElement.VerticalAlignment%2A> から <xref:System.Windows.FrameworkElement>直接継承され <xref:System.Windows.Controls.ComboBoxItem> ている場合でも <xref:System.Windows.VerticalAlignment.Center>されます。 これは、スタイルのコントロールテンプレート内で、<xref:System.Windows.Controls.ComboBoxItem>の既定のスタイルで値がリセットされたためです。  
  
 <xref:System.Windows.Controls.Canvas> は、レイアウトの作成時に <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> を使用しません。 <xref:System.Windows.Controls.Canvas> は絶対配置に基づいているためです。  
  
 <xref:System.Windows.Controls.ComboBoxItem> または任意の派生クラスによって継承されると、<xref:System.Windows.Controls.ComboBoxItem> このプロパティの既定値を <xref:System.Windows.VerticalAlignment.Center>するように再定義します。  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素内でビジュアル子要素の数を取得します。</summary>
        <value>この要素のビジュアル子要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> の <xref:System.Windows.FrameworkElement> の実装では、常に0または1が返されます。 1つを超える可能性のあるビジュアル子コレクションを保持するクラスは、このプロパティと <xref:System.Windows.FrameworkElement.GetVisualChild%2A>の両方をオーバーライドする必要があります。  
  
 このプロパティは、通常、レイアウトのオーバーライド (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>、<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>) を実装するために、現在の子コレクションの上限を決定するために使用されます。  
  
   
  
## Examples  
 次の例では、カスタム装飾が、複数のビジュアルな子のために保持している <xref:System.Windows.Media.VisualCollection> によって宣言された値を使用し、<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> と <xref:System.Windows.FrameworkElement.GetVisualChild%2A>のオーバーライドによってこれらの値を報告する方法を示します。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>クラスで子要素コレクション内の複数のビジュアル子がサポートされている場合は、このプロパティをオーバーライドして、そのコレクション内の要素の数を返します。 コレクションオブジェクト自体がカウントを返す場合でも、この操作を行う必要があります。 WPF フレームワークレベルでの要素のレイアウトロジックは、すべての要素が <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> プロパティを通じて有効なカウントを返すことを前提としています。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の幅を取得または設定します。</summary>
        <value>要素の幅 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.NaN" /> です。 この値は 0.0 以上にする必要があります。 上限については、「解説」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、幅情報を指定する <xref:System.Windows.FrameworkElement> の3つのプロパティのうちの1つです。  もう1つは <xref:System.Windows.FrameworkElement.MinWidth%2A> と <xref:System.Windows.FrameworkElement.MaxWidth%2A>です。  これらの値の間に競合がある場合、実際の幅を決定するためのアプリケーションの順序は、最初に <xref:System.Windows.FrameworkElement.MinWidth%2A> する必要があります。次に、<xref:System.Windows.FrameworkElement.MaxWidth%2A>、それぞれが境界内にある場合は <xref:System.Windows.FrameworkElement.Width%2A>ます。  
  
 このプロパティの戻り値は、その値に設定されている値と常に同じです。 これに対し、<xref:System.Windows.FrameworkElement.ActualWidth%2A> の値は異なる場合があります。 何らかの理由で、レイアウトが提案されたサイズを拒否した可能性があります。 また、レイアウトシステム自体は、<xref:System.Windows.FrameworkElement.Width%2A> のプロパティシステムセットに対して非同期的に動作し、特定のサイズ変更プロパティの変更がまだ処理されていない可能性があります。  
  
 許容される <xref:System.Double> 値に加えて、このプロパティを <xref:System.Double.NaN?displayProperty=nameWithType>することもできます。 ここでは、自動サイズ変更動作を指定します。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] では、値を文字列 "Auto" (大文字と小文字を区別しない) に設定して、自動サイズ変更動作を有効にします。 自動サイズ変更動作とは、使用可能な幅が要素によって塗りつぶされることを意味します。 ただし、特定のコントロールでは、既定のスタイルで既定値が提供されることがよくあります。これは、明示的に有効にしない限り、自動サイズ変更動作を無効にします。  
  
 検証チェックに加えて、レイアウトシステムによって適用される <xref:System.Windows.FrameworkElement.Width%2A> に対して非決定的な上限が設定されています (これは、<xref:System.Single.MaxValue?displayProperty=nameWithType> よりも大きいが <xref:System.Double.MaxValue?displayProperty=nameWithType>よりも小さい非常に大きい数値です)。 この制約を超えた場合、要素はレンダリングされず、例外はスローされません。 ビジュアル表示の最大サイズよりも大幅に大きい値に <xref:System.Windows.FrameworkElement.Width%2A> を設定しないか、またはこの非決定的な上限を超えることができます。  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```xaml 
<object Width="double"/>  
```

または

```xaml
<object Width ="qualifiedDouble"/>  
```

または

```xaml
<object Width ="Auto"/>  
```  

<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML の値  
 *double*  
 <xref:System.Double>  
  
 0.0 以上の <xref:System.Double> 値の文字列表現。 上限については、「解説」を参照してください。 この値は、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] の測定値として解釈されます。 文字列には、小数点を明示的に含める必要があります。 たとえば、`1` の値は許容されます。  
  
 *qualifiedDouble*  
 前に説明した*double*値。その後に、`px`、`in`、`cm`、`pt`のいずれかの単位宣言文字列が続きます。  
  
 `px` (既定値) は [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` はインチ。1in==96px  
  
 `cm` はセンチメートルです。1cm = = (96/2.54) px  
  
 `pt` はポイント。1pt==(96/72) px  
  
 `Auto`  
 自動サイズ調整の動作を有効にします。 「解説」を参照してください。  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|メタデータプロパティが `true` に設定される|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Width" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
