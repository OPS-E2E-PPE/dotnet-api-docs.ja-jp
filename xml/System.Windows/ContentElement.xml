<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cae12657f2e674dbc5ada20ad60f9af4354bf3d9" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83538222" /></Metadata><TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type ContentElement = class&#xA;    inherit DependencyObject&#xA;    interface IInputElement&#xA;    interface IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>コンテンツ要素に WPF コア レベルの基底クラスを提供します。 コンテンツ要素は、直感的なマークアップ指向レイアウト モデルと、意図的に単純なオブジェクト モデルを使用し、フロー スタイル プレゼンテーション用に設計されています。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement> は、次の一般的なコンテンツ特性を定義します。  
  
-   入力: すべての <xref:System.Windows.ContentElement> 派生クラスは、キーボード、マウス、ドラッグアンドドロップ操作、スタイラスコントロール、およびアクセラレータからの基本的な入力キャプチャをサポートしています。  
  
-   フォーカス: すべての <xref:System.Windows.ContentElement> 派生クラスがフォーカスできる可能性があります。 (ただし、<xref:System.Windows.ContentElement> 基底クラスの既定のフォーカスが設定された状態は `false`です。 <xref:System.Windows.ContentElement> にフォーカスを設定する方法の詳細については、「<xref:System.Windows.ContentElement.Focusable%2A>」を参照してください。)また、このクラスには、関連する要素間でフォーカスを走査するために使用できる Api が含まれています。  
  
-   イベント: <xref:System.Windows.ContentElement> には、入力とフォーカスに関連するイベントが含まれます。また、状態の変更に関するイベントも含まれます。 多くの場合、<xref:System.Windows.ContentElement> イベントはルーティングイベントです。 場合によっては、ルーティングイベントにトンネリングとバブルルーティングの両方の方法があり、同じ状態または条件に応じて個別のイベントとして発生します。 また、<xref:System.Windows.ContentElement> では、ルーティングイベントを発生させることができ、イベントに対してハンドラーを追加または削除できる Api を定義します。  
  
 <xref:System.Windows.ContentElement> は、<xref:System.Windows.UIElement>と多くの共通 Api を共有します。 これらの共通 Api は、共有クラスの継承からは取得されません。 ただし、共通の名前付け、類似した動作、および各クラスの Api の類似した内部実装を共有します。 類似性は、<xref:System.Windows.ContentElement> と <xref:System.Windows.UIElement> が要素ベースである各クラスであるためです。ただし、それぞれのマークアップオブジェクトモデルの動作にはそれぞれ異なる意図があります。  
  
 特に、<xref:System.Windows.UIElement> は <xref:System.Windows.Media.Visual>から降下します。これは、複合ウィンドウ内の四角形領域に <xref:System.Windows.ContentElement> を表示するための下位レベルのグラフィックスをサポートしています。 <xref:System.Windows.ContentElement> 一方、フローや折り返しなど、ドキュメントのシナリオに共通する概念がサポートされるようになります。 これらの2つの関連するクラスは、共通のインターフェイス <xref:System.Windows.IInputElement> および <xref:System.Windows.Media.Animation.IAnimatable>も実装しています。  

 ## <a name="notes-to-inheritors"></a>継承に関する注意事項

 <xref:System.Windows.ContentElement> クラスは、フロー形式プレゼンテーションの完全なコンテンツ要素のすべての側面をまだ定義していません。 <xref:System.Windows.FrameworkContentElement> は、<xref:System.Windows.ContentElement>のすぐに派生したクラスです。 <xref:System.Windows.FrameworkContentElement> には、コンテンツホスト内の <xref:System.Windows.FrameworkContentElement> の表示と、WPF フレームワークレベルレイアウトシステムの使用をサポートする追加メンバーの完全なセットが含まれています。

 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.ContentElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHandler (routedEvent As RoutedEvent, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じイベントに対して、例外を発生させることなく同じハンドラーを複数回追加できます。 ただし、ハンドラーは実際にはイベントが処理されるときに複数回呼び出されます。 そのため、この動作がハンドラーの実装で考慮する必要がある副作用について考えてみてください。  
  
 通常、このメソッドを使用して、カスタムルーティングイベントの [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] イベントアクセスパターン用の "add" アクセサーの実装を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHandler (routedEvent As RoutedEvent, handler As Delegate, handledEventsToo As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <param name="handledEventsToo">イベント データ内でルーティング イベントがハンドル済みとしてマークされている場合でも呼び出されるようにハンドラーを登録するには <see langword="true" />。ルーティング イベントが既にハンドル済みとしてマークされている場合はハンドラーを呼び出ないという既定の条件を使用してハンドラーを登録する場合は <see langword="false" />。  
  
既定では、 <see langword="false" />です。  
  
ルーティング イベントの再処理を機械的に要求しないでください。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。 イベント ルート上の別の要素により既にハンドル済みとしてマークされているルーティング イベントに対し、指定したハンドラーが呼び出されるようにするには、<paramref name="handledEventsToo" /> を <see langword="true" /> に指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 低レベルの入力イベントを実用的な方法で処理することは、複雑なタスクです。 多くのコントロールは、特定のイベントが処理済みとしてマークされている動作を実装し、別の直感的なイベントに置き換えます。 一般に、コントロールは、そのための設計目的がある場合にのみ、プラットフォーム入力イベントを処理済みとしてマークします。 特定のシナリオでは、これらの設計の意図が、入力イベントの特定の処理に必要なものではない可能性があります。 これらのシナリオでは、`true` のように `handledEventsToo` にハンドラーを登録することが適切です。 ただし、この作業は定期的に行うべきではありません。 処理された場合でも、すべてのイベントに応答してハンドラーを呼び出すと、独自のアプリケーションイベント処理ロジックが複雑になります。 ハンドラーのロジックが大きくなると、パフォーマンスが低下する可能性があります。 開発プロセス中に、アプリケーションロジックで処理するイベントを処理する必要がある場合は、既に処理されているイベントのハンドラーのアタッチを予約する必要があります。  
  
 特定のイベント制御の組み合わせのクラス処理動作を回避するためのもう1つの方法は、そのイベントのプレビューを使用することです。 たとえば、<xref:System.Windows.ContentElement.MouseLeftButtonDown> がクラス処理によって処理済みとしてマークされている場合は、代わりに <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> のハンドラーを追加できる可能性があります。  
  
 同じイベントに対して、例外を発生させることなく同じハンドラーを複数回追加できます。 ただし、ハンドラーは実際にはイベントが処理されるときに複数回呼び出されます。 そのため、この動作がハンドラーの実装で考慮する必要がある副作用について考えてみてください。  
  
 通常、このメソッドを使用して、カスタムルーティングイベントの [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] イベントアクセスパターン用の "add" アクセサーの実装を提供します。  
  
   
  
## Examples  
 次の例では、`handledEventsToo` `true`を使用して、定義されたハンドラーをページ上のいずれかの名前付き要素にアタッチするページで <xref:System.Windows.FrameworkElement.Initialized> イベントに対して呼び出されるハンドラーを実装します。 このハンドラーは、ルート上の別の要素が、ルートの処理要素に到達する前に、処理された共有イベントデータをマークした場合でも呼び出されます。  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">ハンドラーの追加先のイベント ルート。</param>
        <param name="e">ハンドラーを追加するために使用されるイベント データ。 このメソッドは、引数の <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティを使用してハンドラーを作成します。</param>
        <summary>現在の <see cref="T:System.Windows.EventRoute" /> イベント ハンドラー コレクションのハンドラーを、指定した <see cref="T:System.Windows.ContentElement" /> に追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテンツホストの子要素のハンドラーをホスト <xref:System.Windows.EventRoute>に追加するために、<xref:System.Windows.IContentHost>を実装するかどうかに関係なく、このメソッドをコンテンツホスト要素に使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ アンド ドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。</summary>
        <value>この要素をドラッグアンドドロップ操作の対象として使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ドラッグアンドドロップ操作は、既定では有効になっていません。 <xref:System.Windows.ContentElement.AllowDrop%2A> を `true`に設定して、意図的に有効にする必要があります。 この基本設定以外に、ドラッグアンドドロップ動作は完全に実装固有であり、<xref:System.Windows.ContentElement> またはその他の基本要素クラスでは定義されません。 たとえば、<xref:System.Windows.Controls.RichTextBox>などの特定のコントロールには既定の動作がありますが、このような動作を持つ <xref:System.Windows.ContentElement> 派生クラスはありません。 ドラッグアンドドロップの詳細については、「[ドラッグアンドドロップの概要](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)」を参照してください。  
  
 <xref:System.Windows.FrameworkContentElement> は、この依存関係プロパティのメタデータを実装でオーバーライドします。 具体的には、<xref:System.Windows.FrameworkContentElement> は、このプロパティがプロパティ値の継承を許可することを指定します (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> はメタデータで `true` ます)。 このコンテキストでのプロパティ値の継承では、ローカル値またはスタイルによって割り当てられた <xref:System.Windows.ContentElement.AllowDrop%2A> の他の値を持たない子要素がある場合、この値が割り当てられている最も近い親要素の値 (スタイル、既定値、またはローカル値) が割り当てられます。 つまり、ルート要素で drop 操作を許可するかどうかを指定し、その値を `false`の値に明示的に割り当てていないすべての <xref:System.Windows.FrameworkContentElement> 子要素に反映させることができます。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]で <xref:System.Windows.ContentElement.AllowDrop%2A> を設定します。  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AllowDrop" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティの識別子。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。 既存のアニメーションは停止され、新しいアニメーションに置き換えられます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティからアニメーションを削除するには、そのプロパティの識別子を `dp` として指定し、`clock` を `null`として指定します。 これにより、アニメーションが削除され、アニメーション化されたプロパティがその基本値に設定されます。 ただし、最初に関連付けられたアニメーションクロックは停止しません。 その時計に割り当てられているその他のアニメーションは、引き続き実行されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティ。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <param name="handoffBehavior">列挙体の値。 既定値は <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> で、既存のアニメーションを停止して新しいアニメーションに置き換えます。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用し、プロパティでアニメーションが既に適用されているときに行われる処理を指定する機能も提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティからアニメーションを削除するには、そのプロパティの識別子を `dp` として指定し、`clock` を `null`として指定します。 これにより、アニメーションが削除され、アニメーション化されたプロパティがその基本値に設定されます。 ただし、最初に関連付けられたアニメーションクロックは停止しません。 その時計に割り当てられているその他のアニメーションは、引き続き実行されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素にキャプチャされているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素にキャプチャされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素上で押されているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素上で押されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素上で押されているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素上で押されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</param>
        <param name="animation">開始するアニメーションのタイムライン。</param>
        <summary>この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティがアニメーション化されているかどうかを確認する場合は、アニメーションが開始され、アニメーション化されていない開始点を超える最初のフレームがレンダリングされると、アニメーションがアニメーション化されたと見なされます。  
  
 `animation` の <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> が `null`場合、現在のアニメーションはすべて削除され、プロパティの現在の値が保持されます。  
  
 `animation` 値全体が `null`場合、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられたアニメーションタイムラインは停止しません。 そのタイムラインに割り当てられたその他のアニメーションは、引き続き実行されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</param>
        <param name="animation">適用されるアニメーションのタイムライン。</param>
        <param name="handoffBehavior">プロパティ値に既に影響している現在の (実行中の) アニメーションと新しいアニメーションが対話する方法を指定する列挙値。</param>
        <summary>この要素のアニメーション化対象のプロパティを指定して、特定のアニメーションを開始します。プロパティの既存のアニメーションが実行中である場合の動作も指定できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティがアニメーション化されているかどうかを確認する場合は、アニメーションが開始され、アニメーション化されていない開始点を超える最初のフレームがレンダリングされると、アニメーションがアニメーション化されたと見なされます。  
  
 `animation` の <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> が `null`場合、現在のアニメーションはすべて削除され、プロパティの現在の値が保持されます。  
  
 `animation` 値全体が `null`場合、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられたアニメーションタイムラインは停止しません。 そのタイムラインに割り当てられたその他のアニメーションは、引き続き実行されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="contentElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にマウスをキャプチャするように強制することを試みます。</summary>
        <returns>マウスが正常にキャプチャされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キャプチャするには、要素を有効にする必要があります。 <xref:System.Windows.ContentElement.CaptureMouse%2A>を呼び出す前に <xref:System.Windows.ContentElement.IsEnabled%2A> が `true` かどうかを確認します。  
  
 <xref:System.Windows.ContentElement.CaptureMouse%2A> を呼び出すと `true`が返される場合、<xref:System.Windows.ContentElement.IsMouseCaptured%2A> も `true`ます。  
  
 <xref:System.Windows.ContentElement.CaptureMouse%2A> を呼び出すと `true`が返された場合、<xref:System.Windows.ContentElement.GotMouseCapture> および <xref:System.Windows.ContentElement.IsMouseCapturedChanged> イベントが発生し、<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> メソッドが呼び出された要素として報告されたイベントデータが <xref:System.Windows.ContentElement.CaptureMouse%2A> されます。 キャプチャを強制的に実行すると、既存のキャプチャに干渉する可能性があります。特に、ドラッグアンドドロップに関連するキャプチャがマウスで発生する場合です。  
  
 すべての要素からマウスキャプチャをクリアするには、`null`として指定された `element` パラメーターを使用して <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> を呼び出します。  
  
   
  
## Examples  
 次の例では、マウスが要素によって既にキャプチャされているかどうかに基づいて、キャプチャをキャプチャします。 この例では、想定されるキャプチャターゲット要素が <xref:System.Windows.IInputElement> インターフェイスにキャストされるため、最初に <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> メソッドが呼び出されます。 <xref:System.Windows.IInputElement> へのキャストは、マウスをキャプチャする要素が <xref:System.Windows.UIElement> であるか <xref:System.Windows.ContentElement>であるかわからない場合に役立つ手法です。 インターフェイスのキャストとインターフェイスメソッドの呼び出しでは、<xref:System.Windows.UIElement> または <xref:System.Windows.ContentElement>のいずれかに評価版をキャストしなくても、適切な型固有の CaptureMouse 実装が内部的に呼び出されます。 この同じキャスト手法は、入力関連のイベントの多くや、その他の入力関連のメソッドなど、<xref:System.Windows.IInputElement> によって定義される他のメンバーでも機能します。  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="contentElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にスタイラスをキャプチャするように強制することを試みます。</summary>
        <returns>スタイラスが正常にキャプチャされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基になる既定のスタイラスデバイスに基づく既定の実装では、常に `true`が返されます。 ただし、入力システムのデバイスの実装を提供する入力デバイスを拡張する場合は、異なる結果を返す可能性がある別のスタイラスデバイスの実装でシステムを作成することができます。  
  
 要素は、スタイラスをキャプチャすると、スタイラスが境界の外側にある場合でもスタイラス入力を受け取ります。 スタイラスは、通常、ドラッグアンドドロップ操作中にのみキャプチャされます。  
  
 このメソッドを呼び出すと、基になる静的 <xref:System.Windows.Input.Stylus> メソッド <xref:System.Windows.Input.Stylus.Capture%2A>が呼び出されます。 実際のキャプチャ動作は、アクティブなスタイラスデバイス実装によって実装されます。  
  
 キャプチャするには、要素を有効にする必要があります。 <xref:System.Windows.ContentElement.CaptureStylus%2A>を呼び出す前に <xref:System.Windows.ContentElement.IsEnabled%2A> が返さ `true` かどうかを確認します。  
  
 <xref:System.Windows.ContentElement.CaptureStylus%2A> を呼び出すと `true`が返される場合、<xref:System.Windows.ContentElement.IsStylusCaptured%2A> も `true`ます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureTouch (touchDevice As TouchDevice) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice">キャプチャの対象となるデバイス。</param>
        <summary>この要素にタッチをキャプチャするように強制することを試みます。</summary>
        <returns>指定したタッチがこの要素にキャプチャされる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.TouchDevice> が現在別の要素にキャプチャされている場合、<xref:System.Windows.ContentElement.CaptureTouch%2A> は `false` を返します。  
  
 <xref:System.Windows.ContentElement.CaptureTouch%2A> が `true`を返す場合、<xref:System.Windows.ContentElement.GotTouchCapture> イベントが発生します。  
  
 この要素から1つのタッチのキャプチャを解放するには、<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> メソッドを使用して、解放するタッチデバイスを指定します。 この要素からのすべてのタッチを解放するには、<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクションを取得します。</summary>
        <value>すべての <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.CommandBinding> を使用すると、この要素に対する特定のコマンドのコマンド処理を有効にし、コマンド、そのイベント、およびこの要素によってアタッチされるハンドラーとの間のリンケージを宣言できます。  
  
 <xref:System.Windows.ContentElement.CommandBindings%2A> コレクションを設定するための一般的な方法として、<xref:System.Windows.Input.CommandManager> メソッドをプログラムによって使用する方法があります。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML の値  
 *oneOrMoreCommandBindings*  
 1つ以上の <xref:System.Windows.Input.CommandBinding> 要素。 これらのそれぞれには、既知のコマンドに設定された <xref:System.Windows.Input.CommandBinding.Command%2A> 属性と、<xref:System.Windows.Input.CommandBinding.CanExecute> および <xref:System.Windows.Input.CommandBinding.Executed> ハンドラーの実装に対して設定された属性が必要です。 詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.DragEnter> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewDragEnter>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnDragEnter%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.DragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.DragLeave> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.DragDrop.PreviewDragLeave>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnDragLeave%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.DragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、要素の境界内でドラッグが発生した場合でも発生します。 ドラッグが境界の外側で開始された後、内を移動すると、このイベントも発生し、<xref:System.Windows.ContentElement.DragEnter> および関連するプレビューイベントも発生します。  
  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.DragOver> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.DragOverEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.DragDrop.PreviewDragOver>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnDragOver%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.DragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.Drop> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.DropEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewDrop>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnDrop%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.Drop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="contentElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にフォーカスを設定することを試みます。</summary>
        <returns>キーボード フォーカスをこの要素に設定できなかった場合は <see langword="true" />。このメソッド呼び出しがフォーカスを強制しなかった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスを設定できるようにするには、<xref:System.Windows.ContentElement.Focusable%2A> と <xref:System.Windows.ContentElement.IsEnabled%2A> を両方とも `true`する必要があります。 既定では、ほとんどすべての <xref:System.Windows.ContentElement> 派生クラスが <xref:System.Windows.ContentElement.Focusable%2A> ないことに注意してください。  
  
 要素がフォーカス可能で有効になっている場合でも、特定のツリー (複合コントロールなど) 内のイベント処理は、フォーカスを許可しないことでプレビューフォーカスイベントに応答する可能性があるため、このメソッドは `false`を返します。  
  
 一般に、キーボードフォーカスと論理フォーカスという2つの異なる概念が適用されます。これは、常に同一であるとは限りません。 このメソッドは、論理フォーカスを設定します。 特にキーボードフォーカスを設定するプログラム的な方法はありません。キーボードフォーカスは、ユーザー入力によって決定されます。 詳細については、「[フォーカスの概要](~/docs/framework/wpf/advanced/focus-overview.md)」と「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
 <xref:System.Windows.ContentElement.Focus%2A> を呼び出すと `true`が返される場合、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A> と <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> も `true`ます。  
  
 関連するプロパティがまだ `true`ていない場合、<xref:System.Windows.ContentElement.Focus%2A>を呼び出すと、次の1つ以上のイベントが次の順序で発生します。 <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>、<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (ソースは新しいフォーカスターゲット)、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>、<xref:System.Windows.ContentElement.LostKeyboardFocus>、<xref:System.Windows.ContentElement.GotKeyboardFocus> (ソースは新しいフォーカスターゲット) です。  
  
   
  
## Examples  
 次の例は、ドキュメント内の指定された名前付き段落を検索し、それにフォーカスを設定するページ読み込みイベントハンドラーです。 既定では、段落はフォーカスを設定できません。この段落にはスタイルが適用されています (表示されません)。スタイル <xref:System.Windows.Setter> を使用して、フォーカスを設定可能にしています。  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。</summary>
        <value>要素がフォーカス可能な場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスがある要素のみがキーボード入力を受け取ります。  
  
 特定の派生クラスでは、この依存関係プロパティのメタデータをオーバーライドして、既定で派生クラスにフォーカスを設定できるようにすることができます。  
  
 <xref:System.Windows.Documents.Hyperlink> またはその派生クラスによって継承されると、<xref:System.Windows.Documents.Hyperlink> この依存関係プロパティのメタデータをオーバーライドし、このプロパティの既定値を `true`するように再定義します。  
  
### <a name="dependency-property-information"></a>依存関係プロパティの情報
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.FocusableProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
## <a name="notes-to-inheritors"></a>継承に関する注意事項

<xref:System.Windows.ContentElement>から派生する場合は、要素にフォーカスを設定できるようにするかどうかを検討します。既定ではフォーカスを設定できないためです。 要素にフォーカスを設定できるようにするには、次のように、派生クラスの静的コンストラクターでこのプロパティのメタデータをオーバーライドします。  

[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
[!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
ここで `myElement` は、メタデータ値をオーバーライドする型のクラス名です。
  
## Examples  
 次の例では、<xref:System.Windows.Documents.Paragraph> に既定でフォーカスを設定し、フォーカスを受け取ると視覚的な動作を与えるスタイルを作成します。  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.Focusable" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.Focusable" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="contentElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">確認する依存関係プロパティ。</param>
        <summary>この要素の、指定したプロパティの基本プロパティ値を返します。実行中または停止済みのアニメーションでアニメーション化される値は無視されます。</summary>
        <returns>指定した依存関係プロパティにアニメーションが添付されていないような場合のプロパティ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティにアニメーションがアタッチされていない場合、<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> 戻り値は常に <xref:System.Windows.DependencyObject.GetValue%2A> 戻り値と同じになります。 アニメーションがアタッチされている場合、開始値と停止値を含むすべての可能なアニメーションの派生値は無視され、プロパティ値は他のすべての入力に基づいて決定されます。 詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="contentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、ビジュアル親が存在しない場合に、この要素の代替[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] の親を返します。</summary>
        <returns>報告する代替の親接続を派生クラスの実装が持つ場合のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの既定の仮想実装では、`null`が返されます。 <xref:System.Windows.FrameworkContentElement> は、実際の実装を提供します。  
  
 代替の親は、イベントのルーティングに使用されます。これは、要素が、ビジュアルツリーを、標準の親にルーティングするための標準的なパターンとは別の方法でルーティングされるようにする場合、またはプレビュールーティング方式で下に移動する場合に使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.GiveFeedback> イベントを使用すると、ドラッグアンドドロップ操作中にユーザーに視覚的なフィードバックを提供するために、ドラッグイベントのソースでマウスポインターの外観を変更できます。 視覚的なフィードバックにより、ドラッグアンドドロップ操作が進行中であることが強調されます。  
  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.GiveFeedback> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.GiveFeedback> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewGiveFeedback>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnGiveFeedback%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド呼び出しを使用してフォーカスが意図的に強制されていても、前のキーボードフォーカスが別のスコープに存在する場合、論理フォーカスはキーボードフォーカスとは異なります。 このシナリオでは、キーボードフォーカスはそのままで、<xref:System.Windows.ContentElement.Focus%2A> メソッドが呼び出される要素は引き続き論理フォーカスを取得します。  
  
 このイベントをより正確に解釈することは、ルート内の要素の <xref:System.Windows.ContentElement.IsFocused%2A> プロパティの値が `false` から `true`に変更されたときに発生することです。  
  
 このイベントはバブルルーティングを使用するため、フォーカスを受け取る要素は、イベントハンドラーが実際にアタッチされている要素ではなく子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、フォーカスを取得した実際の要素を特定します。  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネリングイベントがありません。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnGotFocus%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> は、要素のフォーカス状態を保持するプロパティの状態の変化を追跡する類似したイベントです。<xref:System.Windows.ContentElement.GotKeyboardFocus> イベントは、同じ状況の多くで発生します。  
  
 このイベントはバブルルーティングを使用するため、フォーカスがある要素は、イベントハンドラーが実際にアタッチされている要素ではなく、子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、フォーカスを持つ実際の要素を特定します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.GotKeyboardFocus> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.GotKeyboardFocus> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がマウスをキャプチャすると、マウスポインターが境界の外側にある場合でもマウス入力を受け取ります。 マウスは、通常、ドラッグアンドドロップ操作中にキャプチャされ、ドラッグアンドドロップ操作のドロップ操作が発生するまでキャプチャされたままになります。  
  
 このイベントはバブルルーティングを使用するため、キャプチャを持つ要素は、イベントハンドラーが実際にアタッチされている要素ではなく、子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、マウスキャプチャを持つ実際の要素を特定します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.GotMouseCapture> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.GotMouseCapture> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義された対応するトンネリングイベントがありません。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnGotMouseCapture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がスタイラスをキャプチャすると、ポインターが境界の外側にある場合でもスタイラス入力を受け取ります。 スタイラスは、通常、ドラッグアンドドロップ操作中にキャプチャされ、ドラッグアンドドロップ操作のドロップ操作が発生するまでキャプチャを保持します。  
  
 このイベントはバブルルーティングを使用するため、キャプチャを持つ要素は、イベントハンドラーが実際にアタッチされている要素ではなく、子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、capture を持つ実際の要素を特定します。  
  
 このイベントは、このクラスの添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.GotStylusCapture> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.GotStylusCapture> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義された対応するトンネリングイベントがありません。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnGotStylusCapture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがこの要素にキャプチャされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnGotTouchCapture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にアニメーション化されたプロパティかあるどうかを示す値を取得します。</summary>
        <value>プロパティのいずれかに添付されたアニメーションをこの要素が持つ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、永続的な (ロックされていない、常に実行されている) アニメーション、または特定のタイムラインを持つアニメーションに対して `true` を返します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている入力バインディングのコレクションを取得します。</summary>
        <value>入力バインディングのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入力バインドでは、入力デバイスへのコマンドのバインドがサポートされています。 たとえば、<xref:System.Windows.Input.MouseBinding> は、マウスデバイスに固有のプロパティを含む入力バインドを実装します。  
  
 入力バインディングのコレクションには、型に関連する入力バインディングと、インスタンスで宣言されている入力バインドの両方が含まれます。  
  
 関連するプロパティ <xref:System.Windows.ContentElement.CommandBindings%2A>は、コマンドバインドのコレクションを保持します。 これらのバインディングは、コマンド処理の次のレベルを表すという点で、入力バインドとは異なります。これは、既知のコマンドに関連付けられているアクションと、それらのクラス固有のハンドラーです。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML の値  
 *Oneor、Inputbindings*  
 1つ以上の <xref:System.Windows.Input.InputBinding> 要素 (通常は <xref:System.Windows.Input.KeyBinding> または <xref:System.Windows.Input.MouseBinding> 派生クラス)。 これらのそれぞれには、<xref:System.Windows.Input.InputBinding.Command%2A> と <xref:System.Windows.Input.InputBinding.Gesture%2A> 属性が設定されている必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] で有効かどうかを示す値を取得または設定します。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Documents.Hyperlink> が <xref:System.Windows.ContentElement.IsEnabled%2A> `false`に設定されている場合に、代替ビジュアル動作を提供するプロパティ setter を含むスタイルを作成します。  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.ContentElement.IsEnabled" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラス内で <see cref="P:System.Windows.ContentElement.IsEnabled" /> の戻り値になる値を取得します。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## <a name="notes-to-inheritors"></a>継承に関する注意事項

このプロパティの既定の実装では、値がキャッシュされ、この要素の親要素が有効になっているかどうかも計算されます。 親が有効になっていない場合は、実際のユーザーインターフェイスで子要素を効果的に有効にすることはできません。 この実装をオーバーライドする場合は、この動作を維持するために基本実装を呼び出すようにしてください。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に論理フォーカスがあるかどうかを判断する値を取得します。</summary>
        <value>この要素に論理フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションに複数のフォーカス区分 (メニューコンテンツとアプリケーションの残りの部分など) がある場合、論理フォーカスはキーボードフォーカスとは異なる場合があります。 このシナリオでは、キーボードフォーカスはアプリケーション UI の1つの要素にしか配置できませんが、他のフォーカス区分内の特定の要素は引き続き論理フォーカスを保持する場合があります。 論理フォーカスの詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」と「[フォーカスの概要](~/docs/framework/wpf/advanced/focus-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Documents.Paragraph> に既定でフォーカスを設定し、フォーカスを受け取ると視覚的な動作を与えるスタイルを作成します。  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)] などの入力方式システムで、この要素への入力処理が有効になっているかどうかを示す値を取得します。</summary>
        <value>入力方式がアクティブである場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 基になる添付プロパティの既定値は <see langword="true" />ですが、この値は実行時に入力方式の状態の影響を受けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、現在有効になっている入力方法 (キーボード、音声、およびその他の入力デバイス) に対して、添付プロパティ <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> によって返される値を返します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>この要素にキーボード フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キーボード フォーカスが要素または子要素内にあるかどうかを示す値を取得します。</summary>
        <value>キーボード フォーカスがその要素またはその子要素にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値を変更すると、通常は、派生クラスによってイベントを抑制する <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> がオーバーライドされていない限り、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> イベントが発生します。  
  
 このプロパティは直接設定しませんが、<xref:System.Windows.ContentElement.Focus%2A>を呼び出すか、<xref:System.Windows.ContentElement.MoveFocus%2A> 要求を行うことによって、要素にフォーカスを設定することができます。 これらのいずれかのメソッド呼び出しによって、このプロパティ値が変更する場合があります。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウスがこの要素にキャプチャされているかどうかを示す値を取得します。</summary>
        <value>要素にマウス キャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスキャプチャの状態は、インプロセスのドラッグアンドドロップ操作に関連しています。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、マウスが要素によって既にキャプチャされているかどうかに基づいて、マウスキャプチャの状態をオンまたはオフにします。  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素または要素ツリー内の子要素がマウス キャプチャを保持するかどうかを決定する値を取得します。</summary>
        <value>この要素または格納されている要素がマウス キャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> の値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</summary>
        <value>マウス ポインターがヒット テストと同じ要素の結果上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.IsMouseOver%2A>とは異なり、このプロパティは、マウスポインターがヒットテストの場合と同様に、リテラル要素の上にある場合にのみ `true` ます。 マウスポインターが子要素の上にある場合、特に、要素の深いテンプレートと複合要素の一部である要素に対しては、このプロパティは `false`されます。 コントロールがどのように合成されているかわからない場合 (たとえば、定義したコントロールのカスタムコントロールテンプレートでこのプロパティを使用する場合)、このプロパティは予期しない結果を返す可能性があります。 コントロールを作成しないほとんどのシナリオでは、代わりに <xref:System.Windows.ContentElement.IsMouseOver%2A> を使用します。  
  
 この要素によってマウスがキャプチャされ、このプロパティがキャプチャ時に `true` された場合、このプロパティは、マウスキャプチャが失われ、ポインターがその境界を越えていなくなるまで、`true` を返し続けます。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素 (子ビジュアル要素またはそのコントロールの複合を含む) 上にあるかどうかを示す値を取得します。</summary>
        <value>マウス ポインターが要素またはその子要素の上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 似た "IsMouseOverChanged" イベントは存在しませんが、いくつかの類似イベントがあります。 たとえば、<xref:System.Windows.ContentElement.MouseEnter>、<xref:System.Windows.ContentElement.MouseMove>、および <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>を使用できます。  
  
 この要素がマウスをキャプチャすると、マウスのキャプチャが失われ、マウスポインターが要素の境界内から出るまで、このプロパティは `true` のままになります。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Documents.Hyperlink> が `true`<xref:System.Windows.ContentElement.IsMouseOver%2A> レポートを表示するときに、代替ビジュアル動作を提供するプロパティ setter を含むスタイルを作成します。  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にスタイラスがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>要素にスタイラスのキャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスのキャプチャをこの要素 (子要素およびコントロールの複合を含む) が保持するかどうかを示す値を取得します。</summary>
        <value>スタイラスのキャプチャがこの要素内に保持されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</summary>
        <value>スタイラスがヒット テストと同じ要素の上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.IsStylusOver%2A>とは異なり、このプロパティは、スタイラスが要素上にある場合にのみ `true` ます。 スタイラスが子要素または要素のより深い複合要素の一部である要素上にある場合、このプロパティは `false`されます。  
  
 コントロールがどのように合成されているかわからない場合 (たとえば、定義したコントロールのカスタムコントロールテンプレートでこのプロパティを使用する場合)、このプロパティは予期しない結果を返す可能性があります。 コントロールを作成しないほとんどのシナリオでは、代わりに <xref:System.Windows.ContentElement.IsStylusOver%2A> を使用します。  
  
 この要素にスタイラスのキャプチャが含まれており、このプロパティがキャプチャ時に `true` 場合、スタイラスのキャプチャが失われ、スタイラスがその境界を越えない限り、このプロパティは `true` のままです。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、ルーティングイベントではなく [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素 (子ビジュアル要素を含む) 上にあるかどうかを示す値を取得します。</summary>
        <value>スタイラスが要素またはその子要素上に存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素にスタイラスのキャプチャがある場合、スタイラスのキャプチャが失われ、ポインターが境界外になるまで、このプロパティは `true` のままになります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|メタデータプロパティが `true` に設定される|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがある状態でキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キー処理は、コマンド処理やテキスト構成などの他のプラットフォーム機能とやり取りします。 <xref:System.Windows.ContentElement.KeyDown> イベントは、特定のコントロールで想定どおりに動作しない可能性がある下位レベルのテキスト入力イベントです。 これは、一部のコントロールには、テキスト入力処理と関連イベントの上位レベルのバージョンを提供するコントロールの複合またはクラス処理があるためです。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.KeyDown> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.KeyDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewKeyDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnKeyDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.KeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に <xref:System.Windows.ContentElement.KeyUp> がクラスメンバーリストに含まれるようにします。 <xref:System.Windows.ContentElement.KeyUp> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewKeyUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnKeyUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.KeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 このシナリオでは、キーボードフォーカスはそのまま残り、<xref:System.Windows.ContentElement.Focus%2A> メソッドが呼び出される要素は論理フォーカスを取得します。  
  
 このイベントをより正確に解釈することは、ルートの要素の <xref:System.Windows.ContentElement.IsFocused%2A> プロパティの値が `true` から `false`に変化したときに発生することです。  
  
 このイベントはバブルルーティングを使用するため、フォーカスを失った要素は、イベントハンドラーが実際にアタッチされている要素ではなく子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、フォーカスを取得した実際の要素を特定します。  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネリングイベントがありません。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnLostFocus%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントはバブルルーティングを使用するため、フォーカスを失った要素は、イベントハンドラーが実際にアタッチされている要素ではなく子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、フォーカスを失った実際の要素を特定します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.LostKeyboardFocus> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.LostKeyboardFocus> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がマウスをキャプチャすると、ポインターが境界の外側にある場合でもマウス入力を受け取ります。 マウスは、通常、ドラッグアンドドロップ操作中にのみキャプチャされます。  
  
 このイベントはバブルルーティングを使用するため、キャプチャを失った要素は、イベントハンドラーが実際にアタッチされている要素ではなく、子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、キャプチャを失った実際の要素を特定します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.LostMouseCapture> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.LostMouseCapture> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義された対応するトンネリングイベントがありません。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnLostMouseCapture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がスタイラスをキャプチャすると、ポインターが境界の外側にある場合でもスタイラス入力を受け取ります。 スタイラスは、通常、ドラッグアンドドロップ操作中にのみキャプチャされます。  
  
 このイベントはバブルルーティングを使用するため、フォーカスを失った要素は、イベントハンドラーが実際にアタッチされている要素ではなく子要素である場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、フォーカスを失った実際の要素を特定します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.LostStylusCapture> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.LostStylusCapture> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義された対応するトンネリングイベントがありません。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnLostStylusCapture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がタッチのキャプチャを失うと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnLostTouchCapture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.MouseDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.MouseDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 <xref:System.Windows.ContentElement.MouseDown> イベントは、多くの場合、<xref:System.Windows.ContentElement.MouseLeftButtonDown> または <xref:System.Windows.ContentElement.MouseRightButtonDown>と共に発生します。これは、2つの標準マウスボタンのいずれかの押下に対応します。 <xref:System.Windows.ContentElement.MouseLeftButtonDown> と <xref:System.Windows.ContentElement.MouseRightButtonDown> もルーティングイベントですが、これらは直接ルーティングイベントであり、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> イベントがイベントルートに沿ってこの要素に到達すると、適切なボタン固有のイベントが発生します。 <xref:System.Windows.ContentElement.MouseLeftButtonDown> または <xref:System.Windows.ContentElement.MouseRightButtonDown>については、「解説」を参照してください。  
  
> [!IMPORTANT]
>  コントロールに似た動作を持ついくつかの <xref:System.Windows.ContentElement> 派生クラス (<xref:System.Windows.Documents.Hyperlink>など) には、マウスボタンイベントに固有のクラス処理が含まれる場合があります。 マウスの左ボタンダウンイベントは、コントロールでクラス処理を行う最も可能性の高いイベントです。 クラスの処理では、多くの場合、基になる <xref:System.Windows.Input.Mouse> クラスのイベントを処理済みとしてマークします。 イベントが処理済みとしてマークされると、その要素にアタッチされている他のインスタンスハンドラーは通常は発生しません。 UI ツリー内のルートに向かうバブル方向の要素に関連付けられているその他のクラスまたはインスタンスハンドラーも、通常は発生しません。  
  
 前の「」で説明されている問題を解決しても、次のいずれかの方法を使用してクラスを処理する派生クラスで、マウスの左ボタンダウンイベントの <xref:System.Windows.ContentElement.MouseDown> イベントを受け取ることができます。  
  
-   <xref:System.Windows.ContentElement.PreviewMouseDown> イベントのハンドラーをアタッチします。これは、コントロールによって処理されるようにマークされていません。 これはプレビューイベントであるため、ルートからルートが開始され、コントロールにトンネリングされることに注意してください。  
  
-   <xref:System.Windows.ContentElement.AddHandler%2A> を呼び出し、ハンドラーがルーティングイベントデータで既に処理済みとしてマークされている場合でもイベントをリッスンできるようにする署名オプションを選択して、コントロール procedurally にハンドラーを登録します。  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewMouseDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseEnter> は、ダイレクトイベント処理ルーティング戦略を使用する[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)です。 ルートに沿って直接ルーティングイベントは発生しません。代わりに、それらが発生した要素で処理されます。 ただし、スタイルのイベントトリガーなど、ルーティングイベントの動作の他の側面が有効になります。  
  
 <xref:System.Windows.ContentElement.MouseEnter> はマウスポインターが要素の境界内に入ったことを追跡しますが、このイベントはさらに、<xref:System.Windows.ContentElement.IsMouseOver%2A> プロパティ値が `false` からこの要素の `true` に変更されたことを報告します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.MouseEnter> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.MouseEnter> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseEnter%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseLeave> は、ダイレクトイベント処理ルーティング戦略を使用する[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)です。 ルートに沿って直接ルーティングイベントは発生しません。代わりに、それらが発生した要素で処理されます。 ただし、スタイルのイベントトリガーなど、ルーティングイベントの動作の他の側面が有効になります。  
  
 <xref:System.Windows.ContentElement.MouseLeave> はマウスが要素から離れたことを追跡しますが、このイベントはさらに、<xref:System.Windows.ContentElement.IsMouseOver%2A> プロパティ値が `true` からこの要素の `false` に変更されたことを報告します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.MouseLeave> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.MouseLeave> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseLeave%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてバブルルートに従っているように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
> [!IMPORTANT]
>  コントロールに似た動作を持ついくつかの <xref:System.Windows.ContentElement> 派生クラス (<xref:System.Windows.Documents.Hyperlink>など) には、マウスボタンイベントに固有のクラス処理が含まれる場合があります。 マウスの左ボタンダウンイベントは、コントロールでクラス処理を行う最も可能性の高いイベントです。 クラスの処理では、多くの場合、基になる <xref:System.Windows.Input.Mouse> クラスのイベントを処理済みとしてマークします。 イベントが処理済みとしてマークされると、その要素にアタッチされている他のインスタンスハンドラーは通常は発生しません。 UI ツリー内のルートに向かうバブル方向の要素に関連付けられているその他のクラスまたはインスタンスハンドラーも、通常は発生しません。  
  
 前の「」で説明されている問題を解決しても、次のいずれかの方法を使用してクラスを処理する派生クラスで、マウスの左ボタンダウンイベントの <xref:System.Windows.ContentElement.MouseLeftButtonDown> イベントを受け取ることができます。  
  
-   <xref:System.Windows.ContentElement.PreviewMouseDown> イベントのハンドラーをアタッチします。これは、コントロールによって処理されるようにマークされていません。 これはプレビューイベントであるため、ルートからルートが開始され、コントロールにトンネリングされることに注意してください。  
  
-   <xref:System.Windows.ContentElement.AddHandler%2A> を呼び出し、ハンドラーがルーティングイベントデータで既に処理済みとしてマークされている場合でもイベントをリッスンできるようにする署名オプションを選択して、コントロール procedurally にハンドラーを登録します。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてバブルルートに従っているように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.MouseMove> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.MouseMove> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewMouseMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてバブルルートに従っているように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
 右ボタンマウスイベントは、多くの場合、アプリケーションシナリオでネイティブに処理されます。 たとえば、マウスの右ボタンを押すと、コンテキストメニューが表示する場合があります。 「 [ContextMenu の概要](~/docs/framework/wpf/controls/contextmenu-overview.md)」を参照してください。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてバブルルートに従っているように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.MouseUp> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.MouseUp> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 <xref:System.Windows.ContentElement.MouseUp> イベントは、多くの場合、<xref:System.Windows.ContentElement.MouseLeftButtonUp> または <xref:System.Windows.ContentElement.MouseRightButtonUp>と共に発生します。これは、2つの標準マウスボタンのいずれかのリリースに対応します。 <xref:System.Windows.ContentElement.MouseLeftButtonUp> と <xref:System.Windows.ContentElement.MouseRightButtonUp> もルーティングイベントですが、これらは直接ルーティングイベントであり、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> イベントがイベントルートに沿ってこの要素に到達すると、適切なボタン固有のイベントが発生します。 <xref:System.Windows.ContentElement.MouseLeftButtonUp> または <xref:System.Windows.ContentElement.MouseRightButtonUp>については、「解説」を参照してください。  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewMouseUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスポインターがある場所よりもフォーカスまたはマウスキャプチャが優先されます。そのため、フォーカスまたはキャプチャされた要素から <xref:System.Windows.ContentElement.MouseWheel> イベントを受け取った場合、マウスポインターが実際に別の要素を超えている可能性があります。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.MouseWheel> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.MouseWheel> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewMouseWheel>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnMouseWheel%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.MouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="contentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">既存のタブ オーダーを検査するモード、または視覚的な移動方向を示すプロパティを含む検査要求。</param>
        <summary>この要素から別の要素へのフォーカスの移動を試みます。 フォーカスの移動方向は、ガイドラインの方向によって指定され、この要素のビジュアル親の編成内で解釈されます。</summary>
        <returns>要求した検査が実行された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの戻り値を必ず確認してください。 コントロールのコンポジションで定義されているタブストップに走査を実行し、トラバーサル要求がラップを要求しなかった場合、`false` の戻り値が返されることがあります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="contentElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Windows Presentation Foundation (WPF) インフラストラクチャに対するクラス固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> の実装を返します。</summary>
        <returns>型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## <a name="notes-to-inheritors"></a>継承に関する注意事項

このメソッドの実装は、通常、特定の <xref:System.Windows.Automation.Peers.AutomationPeer> 実装のコンストラクターを呼び出し、それを戻り値として返します。  
  
 WPF インフラストラクチャに固有の <xref:System.Windows.Automation.Peers.AutomationPeer> 実装を提供するために、すべての <xref:System.Windows.ContentElement> 派生クラスはこのメソッドを実装する必要があります。 このパターンの実装の詳細については、「<xref:System.Windows.Automation.Peers.AutomationPeer>」を参照してください。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.ContentElement.GotFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>提供されたイベント データを使用して、<see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、仮想には、イベントを発生させる既定の実装があります。  
  
 この\* メソッドの実装では、イベントを発生させることを意図しています。この同じメソッドの実装は、<xref:System.Windows.ContentElement.IsFocused%2A> プロパティの値が変更されたときにイベントを発生させるために、内部的に呼び出されます。 <xref:System.Windows.ContentElement.OnGotFocus%2A> の実装は\* 実装上の他の Windows Presentation Foundation (WPF) とは異なります。これは、そのイベントのクラス処理を追加するのに便利な方法のみを提供します。  
  
## <a name="notes-to-inheritors"></a>継承に関する注意事項

意図的に、または異常なイベントを発生させない必要がある場合を除き、実装が基本実装を呼び出すようにしてください。 そうしないと、通常のユーザー操作では、通常はこの要素にフォーカスが設定されているため、<xref:System.Windows.ContentElement.GotFocus> イベントは発生しません。 要素にフォーカスを設定しない場合は、<xref:System.Windows.ContentElement.Focusable> を `false`に設定することによって、要素がフォーカスされないようにすることができます。
既定では <xref:System.Windows.ContentElement.Focusable> はフォーカスが設定されていないため、<xref:System.Windows.ContentElement.Focusable> を意図的に設定する必要がない場合があることに注意してください。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>タッチがこの要素にキャプチャされているときに発生する <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> をオーバーライドして、<xref:System.Windows.ContentElement.GotTouchCapture> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドは、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> イベントが発生します。 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> イベントがルーティングイベントではないことに注意してください。 したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> です。</param>
        <summary>この要素によって <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> イベントが発生する直前に呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドは、<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> イベントが発生します。 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> イベントがルーティングイベントではないことに注意してください。 したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドは、<xref:System.Windows.ContentElement.IsMouseCaptured%2A> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<xref:System.Windows.ContentElement.IsMouseCapturedChanged> イベントが発生します。 <xref:System.Windows.ContentElement.IsMouseCapturedChanged> イベントがルーティングイベントではないことに注意してください。 したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> です。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>この仮想メソッドは、<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> イベントが発生します。 イベントがルーティングイベントではないことに注意してください。したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドは、<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> イベントが発生します。 <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> イベントがルーティングイベントではないことに注意してください。 したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> です。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドは、<xref:System.Windows.ContentElement.IsStylusCaptured%2A> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<xref:System.Windows.ContentElement.IsStylusCapturedChanged> イベントが発生します。 イベントがルーティングイベントではないことに注意してください。 したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドは、<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> イベントが発生します。 イベントがルーティングイベントではないことに注意してください。 したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドは、<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> の依存関係プロパティの値が変更されたときに発生します。 最初に仮想メソッドが発生し、必要に応じてイベントデータを操作できます。 その後、同じイベントデータインスタンスを使用して、<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> イベントが発生します。 イベントがルーティングイベントではないことに注意してください。 したがって、クラスハンドラーで処理済みとしてマークすることはできません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーストロークは、専用の入力マネージャーによって処理されます。 入力やコマンドのバインドなど、キーストロークに依存するその他のプログラミング機能は、通常のキーストロークとして公開される前に、キーストロークを処理することがあります。 これらの入力システム機能によってイベントが処理済みとしてマークされている場合、<xref:System.Windows.ContentElement.OnKeyDown%2A> は呼び出されません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーストロークは、専用の入力マネージャーによって処理されます。 入力やコマンドのバインドなど、キーストロークに依存するその他のプログラミング機能は、通常のキーストロークとして公開される前に、キーストロークを処理することがあります。 これらの入力システム機能によってイベントが処理済みとしてマークされている場合、<xref:System.Windows.ContentElement.OnKeyUp%2A> は呼び出されません。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.ContentElement.LostFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>提供されたイベント データを使って、<see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、仮想には、イベントを発生させる既定の実装があります。  
  
 この\* メソッドの実装では、イベントを発生させることを意図しています。この同じメソッドの実装は、<xref:System.Windows.ContentElement.IsFocused%2A> プロパティの値が変更されたときにイベントを発生させるために、内部的に呼び出されます。 この実装は、\* 実装上の他の Windows Presentation Foundation (WPF) とは異なります。これは、そのイベントのクラス処理を追加するのに便利な方法のみを提供します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>意図的に、または異常なイベントを発生させない必要がある場合を除き、実装が基本実装を呼び出すようにしてください。 そうしないと、通常のユーザー操作では、通常はこの要素にフォーカスが設定されているため、<see cref="E:System.Windows.ContentElement.LostFocus" /> イベントは発生しません。 要素にフォーカスを設定しない場合は、<see cref="P:System.Windows.ContentElement.Focusable" /> を <see langword="false" />に設定することによって、要素がフォーカスされないようにすることができます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>この要素がタッチのキャプチャを失ったときに発生する <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> をオーバーライドして、<xref:System.Windows.ContentElement.LostTouchCapture> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスボタンの操作も、専用の入力マネージャーによって処理されます。 入力バインドやコマンドバインドなど、マウスボタンの操作に依存するその他のプログラミング機能では、一般的なマウスボタン操作として公開される前に、アクションのハンドラーが呼び出されることがあります。 これらの入力システム機能が <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> イベントを処理済みとしてマークした場合、<xref:System.Windows.ContentElement.OnMouseDown%2A> は呼び出されません。  
  
 このクラスハンドラーを使用してイベントを処理済みとしてマークすると、<xref:System.Windows.ContentElement.MouseLeftButtonDown> と <xref:System.Windows.ContentElement.MouseRightButtonDown>に影響する可能性があります。 これらのイベントのいずれかは、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> を受信したときに、受信側の要素で発生する可能性があります。  
  
 このイベントをクラス処理で処理済みとしてマークした場合、subevents は依然として発生します。ただし、処理された状態はイベントデータに渡されます。 イベントがクラス処理で処理される場合、ハンドラーをアタッチするために `handledEventsToo` `true` で明示的に <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用しない限り、subevents のインスタンスハンドラーは呼び出されません。 クラスハンドラーは、`handledEventsToo` `true`で <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> シグネチャに登録されていない限り、呼び出されません。 <xref:System.Windows.ContentElement.OnMouseDown%2A>を処理することで、すべての潜在的なマウスボタンのダウンアクションをクラスの処理に反映させることができます。 この動作は望ましくない可能性があります。このため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は注意が必要です。  
  
 ボタン固有の各ダイレクトイベントには、virtual On\* メソッドもあります。これらのボタン固有のクラスハンドラーをオーバーライドする方が適しているかどうかを検討してください。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントで、直接ルーティング方法が使用されます。 イベントを処理済みとしてマークすることは、(`handledEventsToo`を指定しない) 一般的なインスタンスハンドラーが呼び出されないようにする場合にも役立ちます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントで、直接ルーティング方法が使用されます。 イベントを処理済みとしてマークすることは、(`handledEventsToo`を指定しない) 一般的なインスタンスハンドラーが呼び出されないようにする場合にも役立ちます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseLeftButtonDown> イベントは、バブルルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> はバブルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.MouseLeftButtonDown>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.MouseLeftButtonDown> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 または、特定のマウス状態のイベント処理を変更するために、このメソッドをオーバーライドすることもできます。 基本実装の呼び出しを選択するかどうかは、シナリオによって異なります。 Base を呼び出さないと、先祖クラスでそのマウスイベントの既定の入力処理が無効になり、<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>も呼び出されます。 たとえば、<xref:System.Windows.Controls.Button> から派生させ、基本実装を呼び出さずに派生クラスの <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> をオーバーライドできます。ただし、このオーバーライドによって <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントは無効になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseLeftButtonUp> イベントは、バブルルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> はバブルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.MouseLeftButtonUp>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.MouseLeftButtonUp> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseRightButtonDown> イベントは、バブルルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> はバブルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.MouseRightButtonDown>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.MouseRightButtonDown> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 または、特定のマウス状態のイベント処理を変更するために、このメソッドをオーバーライドすることもできます。 基本実装の呼び出しを選択するかどうかは、シナリオによって異なります。 Base を呼び出さないと、先祖クラスでそのマウスイベントの既定の入力処理が無効になり、<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>も呼び出されます。 たとえば、<xref:System.Windows.Controls.Control> から派生させ、base を呼び出さずに派生クラスの <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> をオーバーライドできます。ただし、このオーバーライドにより、<xref:System.Windows.Controls.Control> の既定の動作の一部であるコントロールのコンテキストメニューサービスが無効になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseRightButtonUp> イベントは、バブルルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> はバブルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.MouseRightButtonUp>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.MouseRightButtonUp> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスボタンの操作も、専用の入力マネージャーによって処理されます。 入力バインドやコマンドバインドなど、マウスボタンの操作に依存するその他のプログラミング機能では、一般的なマウスボタン操作として公開される前に、アクションのハンドラーが呼び出されることがあります。 これらの入力システム機能が <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> イベントを処理済みとしてマークした場合、<xref:System.Windows.ContentElement.OnMouseUp%2A> は呼び出されません。  
  
 このクラスハンドラーを使用してイベントを処理済みとしてマークすると、<xref:System.Windows.ContentElement.MouseLeftButtonUp> と <xref:System.Windows.ContentElement.MouseRightButtonUp>に影響する可能性があります。 これらのイベントのいずれかは、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> を受信したときに、受信側の要素で発生する可能性があります。  
  
 このイベントをクラス処理で処理済みとしてマークした場合、subevents は依然として発生します。ただし、処理された状態はイベントデータに渡されます。 イベントがクラス処理で処理される場合、ハンドラーをアタッチするために `handledEventsToo` `true` で明示的に <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用しない限り、subevents のインスタンスハンドラーは呼び出されません。 クラスハンドラーは、`handledEventsToo` `true`で <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> シグネチャに登録されていない限り、呼び出されません。 <xref:System.Windows.ContentElement.OnMouseUp%2A>を処理することで、すべてのマウスボタンのアップアクションをクラスの処理に反映させることができます。 この動作は望ましくない可能性があります。このため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は注意が必要です。  
  
 ボタン固有の各ダイレクトイベントには、virtual On\* メソッドもあります。これらのボタン固有のクラスハンドラーをオーバーライドする方が適しているかどうかを検討してください。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 添付ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスボタンの操作も、専用の入力マネージャーによって処理されます。 入力バインドやコマンドバインドなど、マウスボタンの操作に依存するその他のプログラミング機能では、一般的なマウスボタン操作として公開される前に、アクションのハンドラーが呼び出されることがあります。 これらの入力システム機能が <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> イベントを処理済みとしてマークした場合、<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> は呼び出されません。  
  
 このクラスハンドラーを使用してイベントを処理済みとしてマークすると、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> と <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>に影響する可能性があります。 これらのイベントのいずれかは、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> を受信したときに、受信側の要素で発生する可能性があります。  
  
 このイベントをクラス処理で処理済みとしてマークした場合、subevents は依然として発生します。ただし、処理された状態はイベントデータに渡されます。 イベントがクラス処理で処理される場合、ハンドラーをアタッチするために `handledEventsToo` `true` で明示的に <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用しない限り、subevents のインスタンスハンドラーは呼び出されません。 クラスハンドラーは、`handledEventsToo` `true`で <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> シグネチャに登録されていない限り、呼び出されません。 <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>を処理することで、すべての潜在的なマウスボタンのダウンアクションをクラスの処理に反映させることができます。 この動作は望ましくない可能性があります。このため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は注意が必要です。  
  
 ボタン固有の各ダイレクトイベントには、virtual On\* メソッドもあります。これらのボタン固有のクラスハンドラーをオーバーライドする方が適しているかどうかを検討してください。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> イベントは、トンネリングルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> はトンネルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 または、特定のマウス状態のイベント処理を変更するために、このメソッドをオーバーライドすることもできます。 基本実装の呼び出しを選択するかどうかは、シナリオによって異なります。 Base を呼び出さないと、先祖クラスでそのマウスイベントの既定の入力処理が無効になり、<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>も呼び出されます。 たとえば、<xref:System.Windows.Controls.Button> から派生させ、基本実装を呼び出さずに派生クラスの <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> をオーバーライドできます。ただし、このオーバーライドによって <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントは無効になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> イベントは、トンネリングルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> はトンネルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> イベントは、トンネリングルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> はトンネルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.MouseRightButtonDown>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 または、特定のマウス状態のイベント処理を変更するために、このメソッドをオーバーライドすることもできます。 基本実装の呼び出しを選択するかどうかは、シナリオによって異なります。 Base を呼び出さないと、先祖クラスでそのマウスイベントの既定の入力処理が無効になり、<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>も呼び出されます。 たとえば、<xref:System.Windows.Controls.Control> から派生させ、base を呼び出さずに派生クラスの <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> をオーバーライドできます。ただし、このオーバーライドにより、<xref:System.Windows.Controls.Control> の既定の動作の一部であるコントロールのコンテキストメニューサービスが無効になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> イベントは、トンネリングルートを移動するように見えますが、実際には間接的に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> はトンネルルーティングされる基になるイベントです。イベントルートに沿った各 <xref:System.Windows.ContentElement> は、同一の処理を使用して、直接ルーティングイベント <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>を発生させます。 この要素の目的のために <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> イベントを処理済みとしてマークできますが、処理された状態は、イベントルートに沿った他の要素に perpetuate ません。 ただし、一般的なインスタンスハンドラー (`handledEventsToo`が指定されていない) が呼び出されないようにするために、イベントを処理済みとしてマークすることもできます。  
  
 <xref:System.Windows.ContentElement> での一般的なマウスイベント処理の既定の実装では <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> がリッスンされ、適切なローカルイベントに変換されます。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンストラクターで、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>の代替クラスハンドラーを登録します。 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>をオーバーライドすることによって、<xref:System.Windows.ContentElement> のマウス処理動作を変更することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスボタンの操作も、専用の入力マネージャーによって処理されます。 入力バインドやコマンドバインドなど、マウスボタンの操作に依存するその他のプログラミング機能では、一般的なマウスボタン操作として公開される前に、アクションのハンドラーが呼び出されることがあります。 これらの入力システム機能が <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> イベントを処理済みとしてマークした場合、<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> は呼び出されません。  
  
 このクラスハンドラーを使用してイベントを処理済みとしてマークすると、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> と <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>に影響する可能性があります。 これらのイベントのいずれかは、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> を受信したときに、受信側の要素で発生する可能性があります。  
  
 このイベントをクラス処理で処理済みとしてマークした場合、subevents は依然として発生します。ただし、処理された状態はイベントデータに渡されます。 イベントがクラス処理で処理される場合、ハンドラーをアタッチするために `handledEventsToo` `true` で明示的に <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用しない限り、subevents のインスタンスハンドラーは呼び出されません。 クラスハンドラーは、`handledEventsToo` `true`で <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> シグネチャに登録されていない限り、呼び出されません。 <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>を処理することで、すべてのマウスボタンのアップアクションをクラスの処理に反映させることができます。 この動作は望ましくない可能性があります。このため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は注意が必要です。  
  
 ボタン固有の各ダイレクトイベントには、virtual On\* メソッドもあります。これらのボタン固有のクラスハンドラーをオーバーライドする方が適しているかどうかを検討してください。  
  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。 プレビューイベント専用のもう1つのシナリオは、対応するバブルクラスハンドラーが呼び出されないように、それらを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>この要素がタッチで押されたときに発生する <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> をオーバーライドして、<xref:System.Windows.ContentElement.PreviewTouchDown> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> をオーバーライドして、<xref:System.Windows.ContentElement.PreviewTouchMove> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> をオーバーライドして、<xref:System.Windows.ContentElement.PreviewTouchUp> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="contentElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 イベントを処理済みとしてマークすることは、(`handledEventsToo`を指定しない) 一般的なインスタンスハンドラーが呼び出されないようにする場合にも役立ちます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。 基本情報は、要件に応じて、特別な処理の前または後に呼び出すことができます。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 イベントを処理済みとしてマークすることは、(`handledEventsToo`を指定しない) 一般的なインスタンスハンドラーが呼び出されないようにする場合にも役立ちます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには既定の実装がありません。 継承の中間クラスはこのメソッドを実装する可能性があるため、実装で基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、\* メソッドの [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントパターンに似ています。このメソッドは、インスタンスハンドラーではなくクラスハンドラーを確立することによって、派生クラスから一致するイベントを処理する手段を提供します。 この場合、一致イベントはルーティングイベントです。 ルーティングイベントは子要素によって発生する可能性がありますが、必ずしもハンドラーを呼び出す要素ではないため、On\* メソッドの実装パターンはルーティングイベントによって異なります。 そのため、実装では、イベントデータのソースプロパティを調べる必要があります。 ほとんどの場合、イベントを reraise しないようにしてください。  
  
 このメソッドをオーバーライドするか、<xref:System.Windows.EventManager.RegisterClassHandler%2A>にクラスハンドラーを登録することによって、<xref:System.Windows.ContentElement> の派生クラスは、イベントがイベントルートに沿って受信されたときにプライベートクラスハンドラーメソッドを呼び出すことができます。 クラス処理が適切なシナリオの1つは、イベントデータを操作し、ルーティングイベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>この要素の内部がタッチで押されたときに発生する <see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchDown%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnTouchDown%2A> をオーバーライドして、<xref:System.Windows.ContentElement.TouchDown> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnTouchDown%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>この要素の境界の外部から内部にタッチが移動したときに発生する <see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchEnter%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnTouchEnter%2A> をオーバーライドして、<xref:System.Windows.ContentElement.TouchEnter> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnTouchEnter%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>この要素の境界の内部から外部にタッチが移動したときに発生する <see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchLeave%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnTouchLeave%2A> をオーバーライドして、<xref:System.Windows.ContentElement.TouchLeave> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnTouchLeave%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchMove%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnTouchMove%2A> をオーバーライドして、<xref:System.Windows.ContentElement.TouchMove> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnTouchMove%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Input.TouchEventArgs" /> です。</param>
        <summary>この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.OnTouchUp%2A> メソッドには既定の実装がありません。 派生クラスの <xref:System.Windows.ContentElement.OnTouchUp%2A> をオーバーライドして、<xref:System.Windows.ContentElement.TouchUp> イベントを処理します。 基本クラスがイベントを受け取るようにするには、基本クラスの <xref:System.Windows.ContentElement.OnTouchUp%2A> メソッドを必ず呼び出してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="contentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求したフォーカス検査の方向。</param>
        <summary>派生クラスでオーバーライドされると、指定したフォーカス検査方向のフォーカスを受け取ることになる要素を返します。実際にはフォーカスはその要素に移動しません。</summary>
        <returns><see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> が実際に呼び出された場合にフォーカスを受け取る要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでのこのメソッドの既定の実装は不完全であり、常に `null`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewDragEnter> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewDragEnter> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.DragEnter>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewDragLeave> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewDragLeave> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.DragLeave>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewDragOver> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewDragOver> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.DragOver>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewDragOver%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewDrop> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewDrop> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.Drop>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewDrop%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewDrop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が開始されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewGiveFeedback> イベントを使用すると、ドラッグアンドドロップ操作中にユーザーに視覚的なフィードバックを提供するために、ドラッグイベントのソースでマウスポインターの外観を変更できます。  
  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewGiveFeedback> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewGiveFeedback> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.GiveFeedback>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントではトンネリングルーティングが使用されるため、フォーカスがある要素は、イベントハンドラーが実際にアタッチされている要素ではなく子要素になる場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、フォーカスを持つ実際の要素を特定します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.GotKeyboardFocus>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でいずれかのキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キー処理は、コマンド処理やテキスト構成などの他のプラットフォーム機能とやり取りします。 <xref:System.Windows.ContentElement.KeyDown> イベントは、特定のコントロールで想定どおりに動作しない可能性がある下位レベルのテキスト入力イベントです。 これは、一部のコントロールには、テキスト入力処理と関連イベントの上位レベルのバージョンを提供するコントロールの複合またはクラス処理があるためです。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewKeyDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewKeyDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.KeyDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でキーが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キー処理は、コマンド処理やテキスト構成などの他のプラットフォーム機能とやり取りします。 <xref:System.Windows.ContentElement.KeyUp> イベントは、特定のコントロールで想定どおりに動作しない可能性がある下位レベルのテキスト入力イベントです。 これは、一部のコントロールには、テキスト入力処理と関連イベントの上位レベルのバージョンを提供するコントロールの複合またはクラス処理があるためです。 詳細については、個々のコントロールのドキュメントを参照してください。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewKeyUp> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewKeyUp> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.KeyUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントではトンネリングルーティングが使用されるため、フォーカスを失った要素は、イベントハンドラーが実際にアタッチされている要素ではなく子要素になる場合があります。 イベントデータの <xref:System.Windows.RoutedEventArgs.Source%2A> を調べて、フォーカスを失った実際の要素を特定します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.LostKeyboardFocus>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewMouseDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewMouseDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 <xref:System.Windows.ContentElement.PreviewMouseDown> イベントは、多くの場合、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>と共に発生します。これは、2つの標準マウスボタンのいずれかの押下に対応します。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> と <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> もルーティングイベントですが、これらは直接ルーティングイベントであり、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> イベントがイベントルートに沿ってこの要素に到達すると、適切なボタン固有のイベントが発生します。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>については、「解説」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.MouseDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてトンネリングルートに従うように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてトンネリングルートに従うように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、マウスポインターが要素の境界内に最初に入ってから、マウスポインターが要素の境界内に残ったままになると、両方とも発生します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewMouseMove> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewMouseMove> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.MouseMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてトンネリングルートに従うように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)は、要素ツリーを通じてトンネリングルートに従うように見えますが、実際には、各 <xref:System.Windows.ContentElement>によって要素ツリーに沿って発生する直接ルーティングイベントです。  
  
 このイベントは、イベントルートに沿って各要素によって処理される添付イベントである、基になる <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> イベントのマウスボタンの詳細を報告する、関連するいくつかのイベントの1つです。  
  
 このイベントの引数は、基になる <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> イベントの引数を公開します。 イベントルートに従ってイベントが処理済みとしてマークされている場合は、マウスボタンの特定のイベントが引き続き発生します。ただし、マウスボタンの特定のイベントのハンドラーは、イベントのリスナーにするために、既に処理済みとしてマークされているイベントを処理するオプションを使用して、明示的に <xref:System.Windows.ContentElement.AddHandler%2A>を呼び出すことによって追加する必要があります。  
  
 概念的には、このイベント (および <xref:System.Windows.ContentElement>でのその他のマウスボタンイベント) は、(<xref:System.Windows.Input.Mouse> クラスによって提供されるサービス定義を使用した) マウス "サービス" と考えることができます。 イベントは、イベントデータ内の元のマウスイベントのマウスボタンの状態 (左右、上から下) をチェックしなくて済むようにします。 標準以外のボタンの状態を確認するなど、より高度なシナリオでは、<xref:System.Windows.ContentElement>ではなく、<xref:System.Windows.Input.Mouse> クラスで Api を使用することが必要になる場合があります。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewMouseUp> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewMouseUp> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 <xref:System.Windows.ContentElement.PreviewMouseUp> イベントは、多くの場合、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>と共に発生します。これは、2つの標準マウスボタンのいずれかの押下に対応します。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> と <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> もルーティングイベントですが、これらは直接ルーティングイベントであり、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> イベントがイベントルートに沿ってこの要素に到達すると、適切なボタン固有のイベントが発生します。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>については、「解説」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.MouseUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスポインターがある場所よりもフォーカスまたはマウスキャプチャが優先されます。そのため、フォーカスまたはキャプチャされた要素からこのイベントを受け取った場合、マウスポインターが実際に別の要素を超えている可能性があります。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewMouseMove> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewMouseMove> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.MouseWheel>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> イベントを使用すると、ドラッグ元はドラッグアンドドロップ操作をキャンセルする必要があるかどうかを宣言できます。  
  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewQueryContinueDrag> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.QueryContinueDrag>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusButtonDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusButtonDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusButtonDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusButtonUp> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusButtonUp> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusButtonUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusInAirMove> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusInAirMove> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusInAirMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusInRange> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusInRange> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusInRange>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素上にあるときにスタイラスが移動すると発生します。 このイベントを発生させるためには、デジタイザーによって検出されている間にスタイラスが移動する必要があります。それ以外の場合には、代わりに <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusMove> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusMove> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusOutOfRange> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusOutOfRange>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スタイラスジェスチャの詳細については、「<xref:System.Windows.Input.SystemGesture>」を参照してください。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusSystemGesture> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusSystemGesture>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewStylusDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewStylusDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.StylusUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.PreviewTextInput> イベントを使用すると、コンポーネントまたはアプリケーションは、デバイスに依存しない方法でテキスト入力をリッスンできます。 キーボードは <xref:System.Windows.ContentElement.PreviewTextInput>の主な手段です。ただし、音声、手書き、およびその他の入力デバイスでも <xref:System.Windows.ContentElement.PreviewTextInput>が生成される可能性があります。  
  
 キーの組み合わせ (既定のキーボードまたは入力方式のエディター) では、複数のキーイベントによってテキスト入力イベントが1つだけ発生する場合があります。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.PreviewTextInput> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.PreviewTextInput> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.TextInput>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewTextInput%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、<xref:System.Windows.ContentElement.PreviewTouchDown> イベントと <xref:System.Windows.ContentElement.TouchDown> イベントは、指が画面に触れると移動するまで発生しません。 画面上で指を押しながら移動せずに押すと、<xref:System.Windows.Input.Stylus>のプレスアンドホールド動作が発生します。 プレスアンドホールドの動作は、マウスの右クリックに相当します。  
  
 指が画面に触れるとすぐに <xref:System.Windows.ContentElement.PreviewTouchDown> および <xref:System.Windows.ContentElement.TouchDown> イベントが発生するようにするには、この要素の <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> 添付プロパティを `false` に設定します。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.TouchDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.TouchMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|ルーティング方法|トンネリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するバブルイベントは <xref:System.Windows.ContentElement.TouchUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.QueryContinueDrag> イベントは、ドラッグ元がドラッグアンドドロップ操作をキャンセルする必要があるかどうかを判断するために使用します。  
  
 このイベントは、このクラスの <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.QueryContinueDrag> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.QueryContinueDrag> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カーソルの表示が要求されると発生します。 このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.QueryCursor> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.QueryCursor> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 このイベント名によって参照されているカーソルは、必ずしもテキストカーソル (挿入ポイントとも呼ばれます) ではありません。 代わりに、このコンテキストのカーソルは、Windows プログラミングにおけるいくつかの入力関連のデバイスまたは概念に関連する、画面上のグラフィカルな表示を宣言するオブジェクトです。 このオブジェクトは、WPF の <xref:System.Windows.Input.Cursor> クラスによって表されます。 WPF 入力システムでは、マウスポインターの画面上の位置を表すときに、このカーソルを変更できます。 <xref:System.Windows.Input.Cursors> 列挙体の定義済みの値を使用することも、カスタムカーソルをイメージファイルとして宣言することもできます。  
  
 <xref:System.Windows.ContentElement.QueryCursor> イベントのリッスンは、カーソル管理の効率的な手法ではありません。 代わりに、各要素は <xref:System.Windows.FrameworkContentElement.Cursor%2A> と <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>を使用して独自のカーソル動作を定義する必要があります。 <xref:System.Windows.ContentElement.QueryCursor> に依存するのは、WPF フレームワークレベルの基本要素を使用していない場合、または要素単位でカーソル動作を定義するときにニーズを満たしていない特殊な状況においてのみです。 <xref:System.Windows.ContentElement.QueryCursor>に応答してカーソル動作を実装する方法の詳細については、「<xref:System.Windows.Input.QueryCursorEventHandler>」を参照してください。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   定義された対応するトンネリングイベントがありません。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnQueryCursor%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.QueryCursor" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納し、発生するイベントを識別する <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>特定のルーティング イベントを発生させます。 発生する <see cref="T:System.Windows.RoutedEvent" /> は、提供された <see cref="T:System.Windows.RoutedEventArgs" /> インスタンス内で識別されます (そのイベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティとして)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` パラメーターは、すべてのルーティングイベントデータの共通基本型として型指定されます。ただし、イベントデータは、発生したイベントに対して使用できる最も具体的なイベントデータ型として指定する必要があります。これは <xref:System.Windows.RoutedEventArgs> 派生クラスに、発生時に特定のイベントを想定した実際のデータプロパティが含まれているためです。  
  
 <xref:System.Windows.RoutedEventArgs> は、イベントの状態プロパティではありません。また、どのルーティングイベントを発生させるかも識別します。 このイベント発生パターンとルーティングイベントデータはどちらも、イベントに関連するプロパティだけを含む [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントとデータクラスとは異なります。  
  
   
  
## Examples  
 次の例では、イベントデータを作成し、イベント識別子をデータに追加した後、イベントデータインスタンスを使用してカスタムルーティングイベントを発生させます。  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="contentElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キャプチャされているすべてのタッチ デバイスをこの要素から解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="contentElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素がマウス キャプチャを保持していた場合、キャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素がキャプチャを保持していない場合、このメソッドを呼び出しても効果はありません。 このメソッドを呼び出す前に、<xref:System.Windows.ContentElement.IsMouseCaptured%2A> の値を確認することを検討してください。  
  
   
  
## Examples  
 次のハンドラーは、マウスボタンの状態に従って、マウスキャプチャをキャプチャまたは解放します。 この例では、[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]でマウスポインターを移動する以外に、キャプチャされたマウスの動きを別の目的で使用する方法を示します。  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="contentElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素がスタイラス デバイス キャプチャを保持していた場合、キャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素がキャプチャを保持していない場合、このメソッドを呼び出しても効果はありません。 このメソッドを呼び出す前に、<xref:System.Windows.ContentElement.IsStylusCaptured%2A> の値を確認することを検討してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseTouchCapture (touchDevice As TouchDevice) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice">解放の対象となるデバイス。</param>
        <summary>指定されたタッチ デバイスをこの要素から解放することを試みます。</summary>
        <returns>タッチ デバイスが解放された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveHandler (routedEvent As RoutedEvent, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドラーがアタッチされているルーティング イベントの識別子。</param>
        <param name="handler">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</param>
        <summary>指定したルーティング イベント ハンドラーをこの要素から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この API を使用する最も一般的なシナリオは、カスタムルーティングイベントに関連付けられた [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "ラッパー" イベントを実装する場合です。具体的には、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] レベルでハンドラーの "削除" ロジックを実装する場合です。 この例では、このシナリオについて説明します。  
  
 メソッド呼び出しの入力パラメーターに一致する条件に登録されたハンドラーがない場合、このメソッドを呼び出すことはできません。  
  
 条件に一致する複数のハンドラーがアタッチされている場合は、イベントハンドラーストア内の最初のハンドラーだけが削除されます。 この動作は、`-=` 演算子の [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] の動作と一致します。  
  
 `routedEvent` も `handler` も `null`ない可能性があります。 いずれかの値を `null` として指定しようとすると、例外が発生します。  
  
 このメソッドは `handledEventsToo` パラメーター情報を無視します。これは、既に処理されたイベントの処理を可能にする <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> シグネチャを使用してハンドラーが最初に追加された場合に提供されます。 どちらの種類のハンドラーも削除されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.ContentElement.CommandBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.CommandBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、<xref:System.Windows.ContentElement.CommandBindings%2A> がローカルに設定されている場合に `true` を返します。  
  
 この `ShouldSerialize` メソッドは、<xref:System.Windows.UIElement.CommandBindings%2A> プロパティに単純な既定値がないために用意されています。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 通常、このメソッドは、デザイナーを開発しているか、<xref:System.Windows.UIElement>を組み込んだ独自のコントロールを開発している場合に呼び出します。  
  
 詳細については、「 [ShouldSerialize メソッドと Reset メソッドによる既定値の定義](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.ContentElement.InputBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.InputBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、<xref:System.Windows.ContentElement.InputBindings%2A> がローカルに設定されている場合に `true` を返します。  
  
 この `ShouldSerialize` メソッドは、<xref:System.Windows.UIElement.InputBindings%2A> プロパティに単純な既定値がないために用意されています。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 通常、このメソッドは、デザイナーを開発しているか、<xref:System.Windows.UIElement>を組み込んだ独自のコントロールを開発している場合に呼び出します。  
  
 詳細については、「 [ShouldSerialize メソッドと Reset メソッドによる既定値の定義](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusButtonDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusButtonDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusButtonDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusButtonDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusButtonUp> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusButtonUp> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusButtonUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusButtonUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusDown> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusDown> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.StylusEnter> は、ダイレクトイベント処理ルーティング戦略を使用する[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)です。 ルートに沿って直接ルーティングイベントは発生しません。代わりに、それらが発生した要素で処理されます。 ただし、スタイルのイベントトリガーなど、ルーティングイベントの動作の他の側面が有効になります。  
  
 <xref:System.Windows.ContentElement.StylusEnter> は、スタイラスが要素の境界内に入るタイミングを追跡しますが、このイベントはさらに、<xref:System.Windows.ContentElement.IsStylusOver%2A> プロパティ値が `false` からこの要素の `true` に変更されたことを報告します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusEnter> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusEnter> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusEnter%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusInAirMove> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusInAirMove> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusInAirMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusInAirMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusInRange> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusInRange> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusInRange>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusInRange%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.StylusLeave> は、ダイレクトイベント処理ルーティング戦略を使用する[ルーティングイベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)です。 ルートに沿って直接ルーティングイベントは発生しません。代わりに、それらが発生した要素で処理されます。 ただし、スタイルのイベントトリガーなど、ルーティングイベントの動作の他の側面が有効になります。  
  
 <xref:System.Windows.ContentElement.StylusLeave> はスタイラスが要素の境界内から出たときに追跡しますが、このイベントはさらに、<xref:System.Windows.ContentElement.IsStylusOver%2A> プロパティ値が `true` からこの要素の `false` に変更されたことを報告します。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusLeave> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusLeave> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusLeave%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上を移動すると発生します。 このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。 それ以外の場合は、代わりに <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusMove> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusMove> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスが検出可能になるにはデジタイザーから離れすぎているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusOutOfRange> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusOutOfRange> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スタイラスジェスチャの詳細については、「<xref:System.Windows.Input.SystemGesture>」を参照してください。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusSystemGesture> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusSystemGesture> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、このクラスの <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.StylusUp> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.StylusUp> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
 タッチ、マウス、およびスタイラスの入力は、特定の関係にあります。 詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewStylusUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnStylusUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.StylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  このイベントは、複合コントロールの内部実装によって処理済みとして既にマークされている場合があります。 以下の注釈を参照してください。  
  
 <xref:System.Windows.ContentElement.TextInput> イベントは、複合コントロールの内部実装によって処理済みとして既にマークされている場合があります。 たとえば、<xref:System.Windows.Controls.TextBox> は、<xref:System.Windows.ContentElement.TextInput> イベントが既に処理済みとしてマークされている複合コントロールです。その複合内。 コントロールは、方向キーなど、一部の種類の入力をそのコントロールに対して特別な意味を持つものとして解釈する必要があるため、これを行います。 テキスト入力のハンドラーをアタッチするイベントとして <xref:System.Windows.ContentElement.PreviewTextInput> を使用すると、より良い結果が得られる場合があります。 この手法を使用すると、コントロールの構成によってこのイベントが既に処理済みとしてマークされている場合は、イベントルートに沿ってハンドラーがイベントを受信できなくなります。  
  
 <xref:System.Windows.ContentElement.TextInput> イベントを使用すると、コンポーネントまたはアプリケーションは、デバイスに依存しない方法でテキスト入力をリッスンできます。 キーボードは <xref:System.Windows.ContentElement.TextInput>の主な手段ですが、音声、手書き、およびその他の入力デバイスも <xref:System.Windows.ContentElement.TextInput>を発生させることができます。  
  
 キーの組み合わせにより、既定のキーボードまたは入力方式のエディターによって、複数のキーイベントによってテキスト入力イベントが1つだけ発生する場合があります。  
  
 このイベントは、このクラスの <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> 添付イベントのエイリアスを作成し、<xref:System.Windows.ContentElement> が基本要素として継承されている場合に、<xref:System.Windows.ContentElement.TextInput> がクラスメンバーリストの一部になるようにします。 <xref:System.Windows.ContentElement.TextInput> イベントにアタッチされるイベントハンドラーは、基になる <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> アタッチされるイベントにアタッチされ、同じイベントデータインスタンスを受け取ります。  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.TextInputEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewTextInput>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnTextInput%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、<xref:System.Windows.ContentElement.PreviewTouchDown> イベントと <xref:System.Windows.ContentElement.TouchDown> イベントは、指が画面に触れると移動するまで発生しません。 画面上で指を押しながら移動せずに押すと、<xref:System.Windows.Input.Stylus>のプレスアンドホールド動作が発生します。 プレスアンドホールドの動作は、マウスの右クリックに相当します。  
  
 指が画面に触れるとすぐに <xref:System.Windows.ContentElement.PreviewTouchDown> および <xref:System.Windows.ContentElement.TouchDown> イベントが発生するようにするには、この要素の <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> 添付プロパティを `false` に設定します。  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewTouchDown>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnTouchDown%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがこの要素の境界の外部から内部に移動すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、タッチデバイスがこの UI 要素にキャプチャされているかどうかに関係なく、常に発生します。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnTouchEnter%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>この要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>この要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のいずれかの子要素上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>この要素またはそのビジュアル ツリー内のいずれかの子要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがこの要素の境界の内部から外部に移動すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|ルーティング方法|直接|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnTouchLeave%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewTouchMove>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnTouchMove%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|ルーティング方法|バブリング|  
|デリゲート|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するトンネリングイベントは <xref:System.Windows.ContentElement.PreviewTouchUp>です。  
  
-   派生クラスでこのイベントのクラス処理を実装するには、<xref:System.Windows.ContentElement.OnTouchUp%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
