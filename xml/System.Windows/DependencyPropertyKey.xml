<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a6e2c2bf33d13e1feb3e0866a2765f0b9625d4dc" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82487233" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyKey sealed" />
  <TypeSignature Language="F#" Value="type DependencyPropertyKey = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="0bff9-101">読み取り専用の依存関係プロパティへの制限された書き込みアクセスに必要な依存関係プロパティ識別子を提供します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-101">Provides a dependency property identifier for limited write access to a read-only dependency property.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0bff9-102"><xref:System.Windows.DependencyPropertyKey> インスタンスは、<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> または <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>メソッドを使用して、依存関係プロパティの登録呼び出しの戻り値として取得されます。</span><span class="sxs-lookup"><span data-stu-id="0bff9-102"><xref:System.Windows.DependencyPropertyKey> instances are obtained as the return value of a dependency property registration call using the methods <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> or <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="0bff9-103">依存関係プロパティを登録する型は、クラスロジックの一部としてプロパティの値を調整する <xref:System.Windows.DependencyObject.SetValue%2A> および <xref:System.Windows.DependencyObject.ClearValue%2A> の呼び出しで <xref:System.Windows.DependencyPropertyKey> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="0bff9-103">The types that register a dependency property can use the <xref:System.Windows.DependencyPropertyKey> in calls to <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.ClearValue%2A> that adjust the property's value as part of class logic.</span></span> <span data-ttu-id="0bff9-104">キーのアクセスレベルで許可されている場合、関連するクラスはキーと依存関係プロパティも使用できます。</span><span class="sxs-lookup"><span data-stu-id="0bff9-104">If permitted by the access level of the key, related classes can use the key and the dependency property also.</span></span> <span data-ttu-id="0bff9-105">たとえば、キーを内部として宣言し、同じアセンブリ内の他の型もその依存関係プロパティを設定できます。</span><span class="sxs-lookup"><span data-stu-id="0bff9-105">For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</span></span>  
  
 <span data-ttu-id="0bff9-106">読み取り専用の依存関係プロパティの登録によって返される <xref:System.Windows.DependencyPropertyKey> をパブリックにすることはできません。キーを公開すると、プロパティが設定可能になるため、読み取り専用の依存関係プロパティとして登録するポイントが無効になります。</span><span class="sxs-lookup"><span data-stu-id="0bff9-106">The <xref:System.Windows.DependencyPropertyKey> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</span></span> <span data-ttu-id="0bff9-107">また、キーを公開すると、使用可能な依存関係プロパティの動作と [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] プロパティラッパーの実装が一致しません。これは、クラスの設計が不適切であることを示します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-107">Also, exposing the key causes a mismatch between the available dependency property behaviors and its [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] property wrapper implementations, which is bad class design.</span></span>  
  
 <span data-ttu-id="0bff9-108">代わりに、キー自体を公開するのではなく、<xref:System.Windows.DependencyPropertyKey> の <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> 値をクラスの `public static readonly`<xref:System.Windows.DependencyProperty> として公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0bff9-108">Instead of exposing the key itself, you should instead expose the <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value of the <xref:System.Windows.DependencyPropertyKey> as a `public static readonly`<xref:System.Windows.DependencyProperty> on your class.</span></span> <span data-ttu-id="0bff9-109">これにより、プロパティは、ローカルに設定された値の列挙など、特定のプロパティシステム操作に対して有効な依存関係プロパティ識別子を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="0bff9-109">This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</span></span> <span data-ttu-id="0bff9-110">ただし、取得した識別子には、多くのプロパティシステム操作に対する <xref:System.Windows.DependencyProperty> の完全な機能はありません。</span><span class="sxs-lookup"><span data-stu-id="0bff9-110">However, the identifier thus obtained does not have the full capabilities of a <xref:System.Windows.DependencyProperty> for many property system operations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0bff9-111">次の例では、読み取り専用の依存関係プロパティを登録し、他のクラスメンバーの2つの目的でキーを使用しています。 get "wrapper" を実装し、他のプロパティ値の計算に基づいて値を設定する保護された決定操作の識別子として使用します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-111">The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0bff9-112">この特殊な読み取り専用依存関係プロパティ識別子に関連付けられている依存関係プロパティ識別子を取得します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-112">Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</span></span></summary>
        <value><span data-ttu-id="0bff9-113">関連する依存関係プロパティ識別子。</span><span class="sxs-lookup"><span data-stu-id="0bff9-113">The relevant dependency property identifier.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0bff9-114"><xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> 値を使用すると、読み取り専用プロパティの識別子は、読み取り/書き込み依存関係プロパティで使用されるものと同じインターフェイスの一部を使用して、共通プロパティシステム操作に参加できます。</span><span class="sxs-lookup"><span data-stu-id="0bff9-114">The <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</span></span>  
  
 <span data-ttu-id="0bff9-115">読み取り専用の依存関係プロパティの get プロパティアクセサーを実装するには、クラスに <xref:System.Windows.DependencyProperty> 識別子を作成して公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0bff9-115">In order to implement the get property accessor for a read-only dependency property, you should create and expose a <xref:System.Windows.DependencyProperty> identifier on your class.</span></span> <span data-ttu-id="0bff9-116">これには 2 つの目的があります。</span><span class="sxs-lookup"><span data-stu-id="0bff9-116">This serves two purposes:</span></span>  
  
-   <span data-ttu-id="0bff9-117">独自のクラスには、プロパティラッパーの get アクセサーを実装するために <xref:System.Windows.DependencyProperty> 識別子が必要です。</span><span class="sxs-lookup"><span data-stu-id="0bff9-117">Your own class needs the <xref:System.Windows.DependencyProperty> identifier in order to implement the get accessor for the property wrapper.</span></span> <span data-ttu-id="0bff9-118">Get アクセサーを実装する <xref:System.Windows.DependencyObject.GetValue%2A> 呼び出しのパラメーターとして <xref:System.Windows.DependencyProperty> を使用します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-118">You use the <xref:System.Windows.DependencyProperty> as a parameter for the <xref:System.Windows.DependencyObject.GetValue%2A> call that implements the get accessor.</span></span>  
  
-   <span data-ttu-id="0bff9-119"><xref:System.Windows.DependencyProperty> 識別子は、メタデータに依存する他のメソッドが標準形式でアクセスできるように、依存関係プロパティをプロパティシステムに公開します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-119"><xref:System.Windows.DependencyProperty> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</span></span> <span data-ttu-id="0bff9-120">たとえば、一部の <xref:System.Windows.DependencyObject> で <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> を呼び出し、ローカルに設定されたプロパティ (値と識別子) の列挙を取得した場合、読み取り専用の依存関係プロパティに対して返される識別子は、キーではなく <xref:System.Windows.DependencyProperty> の値になります。</span><span class="sxs-lookup"><span data-stu-id="0bff9-120">For instance, if you called <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> on some <xref:System.Windows.DependencyObject> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <xref:System.Windows.DependencyProperty> value rather than the key.</span></span> <span data-ttu-id="0bff9-121"><xref:System.Windows.DependencyProperty> 識別子を公開しないと、読み取り専用の依存関係プロパティのセキュリティはどのような方法でも向上しません。これにより、後続の派生クラスとクラスのインスタンスの両方で、プロパティに関連する操作が難しくなります。</span><span class="sxs-lookup"><span data-stu-id="0bff9-121">Not exposing a <xref:System.Windows.DependencyProperty> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</span></span>  
  
 <span data-ttu-id="0bff9-122">クラスで <xref:System.Windows.DependencyProperty> 識別子を公開するには、キーで <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> を直接呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-122">To expose the  <xref:System.Windows.DependencyProperty> identifier on your class, you call <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> directly on your key.</span></span> <span data-ttu-id="0bff9-123">この値を使用して、<xref:System.Windows.DependencyPropertyKey>に対応する `public static readonly`<xref:System.Windows.DependencyProperty> 識別子をクラスに作成します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-123">Use this value to create a `public static readonly`<xref:System.Windows.DependencyProperty> identifier on the class, which parallels the <xref:System.Windows.DependencyPropertyKey>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0bff9-124">次の例では、<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> を呼び出して、クラスの `AquariumGraphic` 読み取り専用の依存関係プロパティの <xref:System.Windows.DependencyProperty> 識別子 (`AquariumGraphicProperty`) を公開しています。</span><span class="sxs-lookup"><span data-stu-id="0bff9-124">The following example calls <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> to expose the <xref:System.Windows.DependencyProperty> identifier (`AquariumGraphicProperty`) for the `AquariumGraphic` read-only dependency property on a class.</span></span> <span data-ttu-id="0bff9-125">この例では、<xref:System.Windows.DependencyPropertyKey> の作成 (内部メンバー) と `AquariumGraphic`の get アクセサーも示しています。</span><span class="sxs-lookup"><span data-stu-id="0bff9-125">The example also shows the <xref:System.Windows.DependencyPropertyKey> creation (as an internal member) and the get accessor for `AquariumGraphic`.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyPropertyKey.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType"><span data-ttu-id="0bff9-126">この依存関係プロパティが存在し、メタデータをオーバーライドする必要がある型。</span><span class="sxs-lookup"><span data-stu-id="0bff9-126">The type on which this dependency property exists and metadata should be overridden.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="0bff9-127">この型に対して提供されるメタデータ。</span><span class="sxs-lookup"><span data-stu-id="0bff9-127">Metadata supplied for this type.</span></span></param>
        <summary><span data-ttu-id="0bff9-128">この依存関係プロパティ識別子によって表される読み取り専用の依存関係プロパティのメタデータをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="0bff9-128">Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0bff9-129">読み取り専用の依存関係プロパティでのメタデータのオーバーライドは、読み取り/書き込み依存関係プロパティでメタデータをオーバーライドする場合と同様の理由で実行されます。また、メタデータに指定されている動作によって設定動作 (既定値) が変更される可能性があるため、キーレベルでのアクセスが制限されます。</span><span class="sxs-lookup"><span data-stu-id="0bff9-129">Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</span></span>  
  
 <span data-ttu-id="0bff9-130">読み取り/書き込み依存関係プロパティの場合と同様に、読み取り専用の依存関係プロパティのメタデータのオーバーライドは、プロパティシステムによって使用されるプロパティの前にのみ行う必要があります (これは、プロパティを登録するオブジェクトの特定のインスタンスがインスタンス化される時間に相当します)。</span><span class="sxs-lookup"><span data-stu-id="0bff9-130">As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</span></span> <span data-ttu-id="0bff9-131"><xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> の呼び出しは、このメソッドの `forType` パラメーターとして自身を提供する型の静的コンストラクター内、またはそのクラスの同等の初期化でのみ実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0bff9-131">Calls to <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or equivalent initialization for that class.</span></span>  
  
 <span data-ttu-id="0bff9-132">このメソッドは、<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> メソッドに実際に転送し、<xref:System.Windows.DependencyPropertyKey> インスタンスをキーパラメーターとして渡します。</span><span class="sxs-lookup"><span data-stu-id="0bff9-132">This method effectively forwards to the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method, passing the <xref:System.Windows.DependencyPropertyKey> instance as the key parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0bff9-133">次の例では、クラスが継承する既存の読み取り専用の依存関係プロパティのメタデータをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="0bff9-133">The following example overrides metadata for an existing read-only dependency property that a class inherits.</span></span> <span data-ttu-id="0bff9-134">この場合、シナリオの目標は、基本プロパティのメタデータに含まれていなかった強制値のコールバックを追加することでした。</span><span class="sxs-lookup"><span data-stu-id="0bff9-134">In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</span></span> <span data-ttu-id="0bff9-135">また、メタデータをオーバーライドする他の理由により、メタデータをオーバーライドすることもできます (既定値の変更、<xref:System.Windows.FrameworkPropertyMetadataOptions> 値の追加など)。</span><span class="sxs-lookup"><span data-stu-id="0bff9-135">You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <xref:System.Windows.FrameworkPropertyMetadataOptions> values, etc.)</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0bff9-136">読み取り/書き込み用の依存関係プロパティでメタデータをオーバーライドしようとしました (このシグネチャを使用してオーバーライドすることはできません)。</span><span class="sxs-lookup"><span data-stu-id="0bff9-136">Attempted metadata override on a read-write dependency property (cannot be done using this signature).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0bff9-137">提供された型に存在するので、プロパティのメタデータは既に確立されています。</span><span class="sxs-lookup"><span data-stu-id="0bff9-137">Metadata was already established for the property as it exists on the provided type.</span></span></exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>
