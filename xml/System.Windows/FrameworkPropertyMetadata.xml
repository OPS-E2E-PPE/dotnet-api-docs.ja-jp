<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ce96c7f17159e18230483df6ba5137fe0a7bd166" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78836691" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>依存関係プロパティのメタデータを報告または適用します。特に、フレームワークに固有のプロパティのシステム特性を追加します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスは、(<xref:System.Windows.UIPropertyMetadata>を通じて) <xref:System.Windows.PropertyMetadata> から派生します。 ほとんどの WPF フレームワークレベルのアプリケーション開発では、<xref:System.Windows.FrameworkPropertyMetadata> は基本メタデータ型 <xref:System.Windows.PropertyMetadata> または <xref:System.Windows.UIPropertyMetadata>ではなく、依存関係プロパティのメタデータに使用される型です。 これは、既存の依存関係プロパティと、ほとんどのカスタム依存関係プロパティのシナリオで当てはまります。  
  
 <xref:System.Windows.PropertyMetadata> 基底クラスを補完するこのクラスによって宣言されたメンバーには、プロパティの継承、データバインディング、レイアウトなど、WPF フレームワークレベルのプロパティシステムの動作を指定または報告する、さまざまなブール型プロパティが含まれます。  
  
 <xref:System.Windows.FrameworkPropertyMetadata> インスタンスを作成するためのいくつかのコンストラクターシグネチャは、<xref:System.Windows.FrameworkPropertyMetadataOptions> パラメーターを受け取ります。 <xref:System.Windows.FrameworkPropertyMetadataOptions> 列挙体は、コンストラクターで初期動作を指定するためにのみ使用され、それ以外の場合は <xref:System.Windows.FrameworkPropertyMetadata> の構築後に公開されません。 構築されたインスタンスから、コンストラクターの呼び出しで使用される列挙値の名前を共有するさまざまなプロパティを使用して、対応する情報を取得または設定できます。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
   
  
## Examples  
 次の例では、特定の所有者の依存関係プロパティのメタデータを、初期の基本 <xref:System.Windows.PropertyMetadata> 型として取得します。 そのメタデータは <xref:System.Windows.FrameworkPropertyMetadata>にキャストされます。 キャストによって有効な <xref:System.Windows.FrameworkPropertyMetadata>が返された場合、単純な UI (図には示されていません) を使用して、さまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティ値が報告されます。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この署名により、<xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> のすべての値がプロパティの既定値に初期化されます。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> が `null`され、さまざまな <xref:System.Windows.FrameworkPropertyMetadata> ブール型プロパティが `false`されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <summary>指定した既定値を使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した <see cref="T:System.Windows.FrameworkPropertyMetadata" /> コールバックを使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <summary>指定した既定値とフレームワーク レベルのメタデータ オプションを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
 `flags` パラメーターで set フラグとしてマークされた値は、その <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前に一致する <xref:System.Windows.FrameworkPropertyMetadata> プロパティのブール値を `true`に設定します。 メタデータが特定のプロパティシステム操作にまだ適用されていない限り、メタデータのプロパティの値を変更できます。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値と <see cref="T:System.Windows.FrameworkPropertyMetadata" /> コールバックを使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこの依存関係プロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定したコールバックを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装では、基本初期化子を呼び出し、基本インスタンスのプロパティを設定することによって `coerceValueCallback` を追加します。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、および <see cref="T:System.Windows.FrameworkPropertyMetadata" /> コールバックを使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
 `flags` パラメーターで set フラグとしてマークされた値は、その <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前に一致する <xref:System.Windows.FrameworkPropertyMetadata> プロパティのブール値を `true`に設定します。 メタデータが特定のプロパティシステム操作にまだ適用されていない限り、メタデータのプロパティの値を変更できます。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこの依存関係プロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値とコールバックを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、およびコールバックを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
 `flags` パラメーターで set フラグとしてマークされた値は、その <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前に一致する <xref:System.Windows.FrameworkPropertyMetadata> プロパティのブール値を `true`に設定します。 メタデータが特定のプロパティシステム操作にまだ適用されていない限り、メタデータのプロパティの値を変更できます。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこの依存関係プロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <param name="isAnimationProhibited">該当するメタデータが適用されるプロパティがプロパティ システムによってアニメーション化されないようにする場合は <see langword="true" />。 このようなプロパティのアニメーション化を試みると、プロパティ システムでランタイム例外が発生します。 プロパティのアニメーション化を許可する場合は <see langword="false" />。 既定では、 <see langword="false" />です。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、指定したコールバック、およびプロパティでのアニメーションを無効にするブール値を使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
 `isAnimationProhibited` パラメーターは、直接の基本 <xref:System.Windows.UIPropertyMetadata> クラスによって宣言された <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> プロパティの初期値を設定します。  
  
 `flags` パラメーターで set フラグとしてマークされた値は、その <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前に一致する <xref:System.Windows.FrameworkPropertyMetadata> プロパティのブール値を `true`に設定します。 メタデータが特定のプロパティシステム操作にまだ適用されていない限り、メタデータのプロパティの値を変更できます。  
  
   
  
## Examples  
 次の例では、このコンストラクターシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean, defaultUpdateSourceTrigger As UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <param name="isAnimationProhibited">該当するメタデータが適用されるプロパティがプロパティ システムによってアニメーション化されないようにする場合は <see langword="true" />。 このようなプロパティのアニメーション化を試みると、プロパティ システムでランタイム例外が発生します。 既定では、 <see langword="false" />です。</param>
        <param name="defaultUpdateSourceTrigger"><see cref="T:System.Windows.Data.UpdateSourceTrigger" /> が <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> に設定されているバインディングをこのプロパティに対して適用するときに使用する <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、指定したコールバック、プロパティでのアニメーションを無効にするブール値、および既定のデータ バインディング更新トリガーを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用されている依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります。 プロパティシステムは、プロパティの有効な値を実行時まで評価しません。そのため、既定値の型またはプロパティの型の不一致の結果は実行時エラーになります。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> は、プロパティシステムで特別な意味を持ち、依存関係プロパティの既定値として使用することはできません。  
  
 `isAnimationProhibited` パラメーターは、直接の基本 <xref:System.Windows.UIPropertyMetadata> クラスによって宣言された <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> プロパティの初期値を設定します。  
  
 バインディングの更新ソースの動作の詳細については、「[データバインディングの概要](~/docs/framework/wpf/data/data-binding-overview.md)」を参照してください。  
  
 `flags` パラメーターで set フラグとしてマークされた値は、その <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前に一致する <xref:System.Windows.FrameworkPropertyMetadata> プロパティのブール値を `true`に設定します。 メタデータが特定のプロパティシステム操作にまだ適用されていない限り、メタデータのプロパティの値を変更できます。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティが配置パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが配置パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> と <xref:System.Windows.FrameworkContentElement> には、要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視する <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> の実装が含まれています。 このロジックの一部として、有効な値を変更する依存関係プロパティと <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> が `true` に設定されたメタデータを持つ依存関係プロパティは、その要素のビジュアルを無効にするために遅延要求を開始します (<xref:System.Windows.UIElement.InvalidateArrange%2A>への呼び出し)。 この WPF フレームワークレベルの実装は既に配置されているため、WPF フレームワークレベルのレイアウト動作を大幅に置き換えたり変更したりしない限り、通常は <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> で依存関係プロパティを検索する必要はありません。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装では、<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> が `true`場合に、依存関係プロパティの変更に類似した動作を選択することがあります。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティフィールドから既定のメタデータを取得し、その中のさまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティの値を照会します。また、情報を使用して、"メタデータブラウザー" を実装するテーブルを設定します。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティが測定パスに影響する可能性があるかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが測定パスに影響する可能性がある場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> と <xref:System.Windows.FrameworkContentElement> には、要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視する <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> の実装が含まれています。 このロジックの一部として、有効な値を変更し <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> のメタデータを持つ依存関係プロパティは `true` に設定され、遅延要求を開始してその要素のビジュアルを無効にします。 この WPF フレームワークレベルの実装は既に配置されているため、WPF フレームワークレベルのレイアウト動作を大幅に置き換えたり変更したりしない限り、通常は <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> で依存関係プロパティを検索する必要はありません。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装では、<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> が `true`場合に、依存関係プロパティの変更に類似した動作を選択することがあります。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティフィールドから既定のメタデータを取得し、その中のさまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティの値を照会します。また、情報を使用して、"メタデータブラウザー" を実装するテーブルを設定します。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティがその親要素のレイアウトの配置パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する可能性のある依存関係プロパティが特にその親要素の配置パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> と <xref:System.Windows.FrameworkContentElement> には、要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視する <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> の実装が含まれています。 このロジックの一部として、有効な値を変更する依存関係プロパティと <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> が `true` に設定されたメタデータを持つ依存関係プロパティは、親要素のビジュアルを無効にするために遅延要求を開始します。  
  
 通常、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> を使用して、<xref:System.Windows.FrameworkElement> プロパティの変更を親要素に報告する必要はありません。これは、要素自体に独自の <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> が既に `true`として存在するためです。 通常はこれで十分です。子要素が変更された場合は、通常、必要に応じて親の配置が開始されるためです。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> は、<xref:System.Windows.FrameworkContentElement> 派生クラスに使用されることがあります。 この場合、子要素はプロパティを設定しますが、<xref:System.Windows.FrameworkContentElement> 派生クラスは独自のレンダリングを制御しません。 レンダリングは、コンテンツホストとして機能する <xref:System.Windows.FrameworkElement> 親要素によって処理されます。 たとえば、子要素によって <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 添付プロパティの値を変更すると、親の位置が変更されるため、親の配置が無効になります。 したがって、<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 添付プロパティには、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> が `true`れているメタデータが含まれています。 別の例として <xref:System.Windows.Controls.Control.Padding%2A>があります。このプロパティが変更されると、使用可能な領域に応じて親が子の位置を変更する場合があります。  
  
 この WPF フレームワークレベルの実装は既に配置されているため、WPF フレームワークレベルのレイアウト動作を大幅に置き換えたり変更したりしない限り、通常は <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> で依存関係プロパティを検索する必要はありません。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装では、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> が `true`場合に、依存関係プロパティの変更に類似した動作を選択することがあります。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティがその親要素のレイアウトの測定パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが特にその親要素の測定パスに影響する可能性がある場合は<see langword="true" /> 、それ以外の場合は <see langword="false" />。既定値は <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> と <xref:System.Windows.FrameworkContentElement> には、要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視する <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> の実装が含まれています。 このロジックの一部として、有効な値を変更する依存関係プロパティと <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> が `true` に設定されたメタデータを持つ依存関係プロパティは、親要素のビジュアルを無効にするために遅延要求を開始します。 この WPF フレームワークレベルの実装は既に配置されているため、WPF フレームワークレベルのレイアウト動作を大幅に置き換えたり変更したりしない限り、通常は <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> で依存関係プロパティを検索する必要はありません。  
  
 通常、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> を使用して、<xref:System.Windows.FrameworkElement> プロパティの変更を親要素に報告する必要はありません。これは、要素自体に独自の <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> が既に `true`として存在するためです。 通常はこれで十分です。子要素の変更は、通常、必要に応じて親メジャーパスを開始するためです。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> は、<xref:System.Windows.FrameworkContentElement> 派生クラスに使用されることがあります。 この場合、子要素はプロパティを設定しますが、<xref:System.Windows.FrameworkContentElement> 派生クラスは独自のレンダリングを制御しません。 レンダリングは、コンテンツホストとして機能する <xref:System.Windows.FrameworkElement> 親要素によって処理されます。 たとえば、子要素によって <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> プロパティの値を変更すると、段落の相対間隔が変更され、コンテンツホストのサイズが増減する可能性があるため、親のメジャーが無効になります。 したがって、<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> プロパティには、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> が `true`れているメタデータが含まれています。  
  
 コンテンツホスト要素は、コンテンツホストのレンダリングロジックの一部として <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> が `true`される依存関係プロパティの変更も頻繁に検索します。 たとえば、<xref:System.Windows.Controls.TextBox> 要素は、テキスト内の特定の変更に応答し、<xref:System.Windows.Controls.TextBox> の境界ボックスを変更する必要がある場合があります。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装では、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> が `true`場合に、依存関係プロパティの変更に類似した動作を選択することがあります。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティが一般的なレイアウトに何らかの形で影響する (配置や測定に特に影響を与えないが再描画が必要になる) 可能性があるかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティがレンダリングに影響を与える場合は、<see langword="true" /> 。それ以外の場合は、 <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> と <xref:System.Windows.FrameworkContentElement> には、要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視する <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> の実装が含まれています。 このロジックの一部として、有効な値を変更し <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> のメタデータを持つ依存関係プロパティは `true` に設定され、遅延要求を開始してその要素のビジュアルを無効にします。 この WPF フレームワークレベルの実装は既に配置されているため、WPF フレームワークレベルのレイアウト動作を大幅に置き換えたり変更したりしない限り、通常は <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> で依存関係プロパティを検索する必要はありません。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装では、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> が `true`場合に、依存関係プロパティの変更に類似した動作を選択することがあります。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティフィールドから既定のメタデータを取得し、その中のさまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティの値を照会します。また、情報を使用して、"メタデータブラウザー" を実装するテーブルを設定します。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティが既定で双方向をバインドするかどうかを示す値を取得または設定します。</summary>
        <value>既定でこのメタデータが存在する依存関係プロパティが双方向をバインドする場合は、<see langword="true" /> 。それ以外の場合は、 <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが `true`されていない場合、バインディング更新は、<xref:System.Windows.Data.Binding> コンストラクターまたは同等の [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文の既定の動作に基づいて、既定で一方向になります。  
  
 既存の要素では、通常、このプロパティは、状態を報告し、ユーザー操作によって変更可能な依存関係プロパティのメタデータの `true` に設定されています (<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>など)。  
  
 このプロパティは、一般に依存関係プロパティの既定のバインディング更新特性のみを報告します。 インスタンスでこのプロパティに設定されたバインディングでは、バインディングの <xref:System.Windows.Data.Binding.Mode%2A> プロパティをローカルに設定し、この既定値を変更できます。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティフィールドから既定のメタデータを取得し、その中のさまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティの値を照会します。また、情報を使用して、"メタデータブラウザー" を実装するテーブルを設定します。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータを含むプロパティに対して、<see cref="T:System.Windows.Data.UpdateSourceTrigger" /> が <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> に設定されているバインディングを適用するときに使用する <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> の既定値を取得または設定します。</summary>
        <value><see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> 以外の列挙値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティが <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> に設定されています。設定した値は、バインディングで要求されたときの既定値になります。</exception>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値が継承可能かどうかを示す値を取得または設定します。</summary>
        <value>プロパティ値が継承可能な場合は<see langword="true" /> 、それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ値の継承は、WPF フレームワークレベルでの [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プロパティシステムの機能です。これにより、特定の依存関係プロパティを、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 要素ツリーのルートにある要素にローカルに設定し、そのプロパティを持つ子要素の論理ツリー内のすべての要素によってその値を継承することができます。 プロパティ値の継承は、既定では有効になっていません。有効にすると、パフォーマンスに影響します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
> [!NOTE]
>  プロパティ値の継承は非添付依存関係プロパティに対して機能するように見える場合がありますが、ランタイムツリー内の特定のオブジェクトとオブジェクトの区分を通じて非添付プロパティの継承の動作が定義されていません。 メタデータで <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> を指定するプロパティを登録するには、常に <xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用します。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティフィールドから既定のメタデータを取得し、その中のさまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティの値を照会します。また、情報を使用して、"メタデータブラウザー" を実装するテーブルを設定します。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティのデータ バインディングがサポートされているかどうかを示す値を取得します。</summary>
        <value>このメタデータが適用される依存関係プロパティでデータ バインドがサポートされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="true" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、次の2つの条件のいずれかについて `false` を報告します。依存関係プロパティが読み取り専用である (メタデータではなく依存関係プロパティ識別子で報告されている) か、または別のメタデータプロパティの値 (<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>) がこのメタデータで `true` に設定されているため、依存関係プロパティへの このプロパティは便宜上、呼び出し元が <xref:System.Windows.DependencyProperty.ReadOnly%2A> と <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>の両方をチェックする必要がないようにするために公開されています。  
  
 それ以外の読み取り/書き込みプロパティでデータバインディングがサポートされないように指定するメタデータを作成する場合は、フラグ <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> を指定します (名前付け規則の違いについては、<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>を参照してください)。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティフィールドから既定のメタデータを取得し、その中のさまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティの値を照会します。また、情報を使用して、"メタデータブラウザー" を実装するテーブルを設定します。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティがデータ バインディングをサポートしているかどうかを示す値を取得または設定します。</summary>
        <value>プロパティがデータ バインドをサポートしない場合は<see langword="true" /> 、それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメタデータプロパティは、読み取り/書き込みプロパティであるにもかかわらず、データバインディングをサポートしていないプロパティに対して特に `true` に設定されていることに注意してください。 ほとんどの場合、依存関係プロパティが宣言されている場合、データバインディングが必要になるのは、依存関係プロパティが有用な主要なシナリオの1つであるためです。 <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>とは異なり、これは、特定のバインディングで後で変更できる既定値を変更するだけではありません。 この `true` プロパティを依存関係プロパティのメタデータに設定すると、その依存関係プロパティに対して、すべてのバインドが式を使用して値を適用するのを無効にします。  
  
 読み取り専用の依存関係プロパティは、変更された値を適用できる setter がないため、データバインディングをサポートしていませんが、<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>の `false` を報告します。 これは、<xref:System.Windows.FrameworkPropertyMetadataOptions> 値に対応するプロパティは、プロパティの名前付けによって示される最終的な結果の動作を常に報告するのではなく、メタデータが実際にどのように設定されているかについて、パリティを報告するためです。 特定の依存関係プロパティでデータバインディングが許可されるかどうかを判断するには、通常、<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> を確認する必要があります。 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> は、<xref:System.Windows.DependencyProperty.ReadOnly%2A> と <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> の両方を1つの操作としてチェックし、予想される結果を生成するのに便利です。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャーナル実装の一部としてアプリケーションが格納できる、または格納する必要のあるジャーナル情報がこのプロパティに格納されているかどうか示す値を取得または設定します。</summary>
        <value>このメタデータが適用される依存関係プロパティに対してジャーナルを実行する必要がある場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">マージする基本のメタデータ。</param>
        <param name="dp">このメタデータが適用されている依存関係プロパティ。</param>
        <summary>ソース メタデータと基本メタデータのマージを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、メタデータがオーバーライドされるときに内部的に使用されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.PropertyMetadata" /> (またはこのクラスで特に) から派生したクラスは、実装に追加したメタデータプロパティを考慮するために、このメソッドをオーバーライドする必要があります。 たとえば、実装によって新しいフラグ列挙値が追加されている場合、<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> の実装では、これらのフラグを正しく組み合わせることができる必要があります。  
  
基本実装では、階層内の以前の型で既に定義されているすべてのプロパティを結合するため、独自の実装の前に常に基本実装を呼び出します。  
  
<see cref="T:System.Windows.FrameworkPropertyMetadata" /> の <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 実装によって追加される動作は、<see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> などのメタデータの特定の WPF フレームワークレベルのプロパティが、ビットごとの or 演算で結合されることです。  
  
<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> の動作は、<see cref="T:System.Windows.FrameworkPropertyMetadata" />されるオーバーライドメタデータを使用して <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />を呼び出すことによって既存の依存関係プロパティのプロパティメタデータをオーバーライドするときの動作も実装します。</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">メタデータが適用された依存関係プロパティ。</param>
        <param name="targetType">該当するメタデータが型固有のメタデータの場合、このメタデータに関連付けられている型。 これが既定のメタデータである場合は、この値に <see langword="null" /> を指定できます。</param>
        <summary>このメタデータがプロパティに適用されたときに呼び出され、メタデータがシールされることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkPropertyMetadata> インスタンスのデータ構造の変更可能性は、このメソッドが呼び出されたときに変更不可としてマークされる必要があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>このメソッドの <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 実装では、基本実装を呼び出すだけではありません。</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の論理ツリー内の特定のコンテンツ境界にまたがってプロパティ値の継承を評価するかどうかを示す値を取得または設定します。</summary>
        <value>プロパティ値の継承が特定のコンテンツ境界をまたがる場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメタデータは、特別な親要素である子要素の境界を越えて、プロパティ値の継承動作に対してめったに適用されない変更を報告します。 このような境界の典型的な例として、<xref:System.Windows.Controls.Frame>の内容があります。この場合、<xref:System.Windows.Controls.Frame> コンテンツは <xref:System.Windows.Controls.Frame>の存在とは無関係に再読み込みされる可能性があります。 必要なプロパティシステムの動作では、プロパティ値の継承は、<xref:System.Windows.Controls.Frame>の内容に進むことができません。これらの内容は、フレームをホストするアプリケーションが所有または制御していない要素である可能性があるためです。 <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> を `true`に設定してメタデータを指定し、`true`として <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> を指定すると、メタデータが適用されるプロパティが <xref:System.Windows.Controls.Frame> 境界または同様の境界を越えても継承可能になります。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用された後、メタデータインスタンスとメタデータの詳細を伝えるプロパティが不変と見なされるようになりました。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティのサブプロパティが格納オブジェクトのレンダリングに影響しないかどうかを示す値を取得または設定します。</summary>
        <value>サブプロパティ値の変更がレンダリングに影響しない場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメタデータオプションは、参照型である依存関係プロパティに関連します。この型には、独自のプロパティ値が含まれています。 通常、レイアウトシステムのロジックでは、サブプロパティを持つすべての依存関係プロパティがレイアウトに影響を与える可能性があると想定します。これは、変更のすべてのサブプロパティを確認すると、実際に別のレンダリングパスを実行するよりも時間がかかるためです。 このオプションを `true` に設定すると、WPF フレームワークレベルのレイアウトシステム実装のパフォーマンスを最適化するのに役立ちます。  
  
 <xref:System.Windows.PropertyMetadata> の派生クラスのプロパティは、通常、読み取り/書き込み可能としてオブジェクトモデルで定義されます。 これは、インスタンスの初期化後に調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用されると、メタデータの詳細を伝えるメタデータインスタンスとプロパティが変更不可と見なされるようになります。 このメタデータインスタンスで `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 後にこのプロパティを設定しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 このクラスのメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされてメタデータのプロパティを設定できないように、メタデータが依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>
