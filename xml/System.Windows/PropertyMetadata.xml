<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a81f8d07405397122ace4236bd53c12c4a00f69" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78808611" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="705c6-101">登録時の条件など、特定の種類に適用されるときの依存関係プロパティの動作を定義します。</span><span class="sxs-lookup"><span data-stu-id="705c6-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-102">プロパティメタデータは、<xref:System.Windows.DependencyProperty.Register%2A> メソッド (または添付プロパティまたは読み取り専用の依存関係プロパティのバリエーション) を呼び出すとき、または <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> メソッドを呼び出すときに元の所有者の登録後に、依存関係プロパティの登録時に定義および使用できます。</span><span class="sxs-lookup"><span data-stu-id="705c6-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="705c6-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> は、プロパティのメタデータも受け取ります。</span><span class="sxs-lookup"><span data-stu-id="705c6-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="705c6-104">このクラスは、これらの各呼び出しで使用できる具象基本クラスです。</span><span class="sxs-lookup"><span data-stu-id="705c6-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="705c6-105">ただし、<xref:System.Windows.FrameworkPropertyMetadata>などの派生クラスのいずれかを使用してメタデータを指定することは非常に一般的です。</span><span class="sxs-lookup"><span data-stu-id="705c6-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="705c6-106">これらの派生クラスは、ブール型プロパティ値として格納されるより詳細なメタデータをサポートします。これは、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework レベルでのみ実装されるプロパティシステムとレイアウト動作を検出または有効にするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="705c6-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="705c6-107">このクラスのいくつかのプロパティは、オブジェクトモデルへの読み取り/書き込みですが、<xref:System.Windows.DependencyProperty.Register%2A> や <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>などのプロパティシステム操作で使用されているインスタンスの前にのみ書き込むことができます。</span><span class="sxs-lookup"><span data-stu-id="705c6-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="705c6-108">これらの各プロパティは、コンストラクターによって設定されている場合もありますが、<xref:System.Windows.PropertyMetadata.Merge%2A> メソッドの実装で設定できるように公開されています。</span><span class="sxs-lookup"><span data-stu-id="705c6-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="705c6-109">XAML テキストの使用</span><span class="sxs-lookup"><span data-stu-id="705c6-109">XAML Text Usage</span></span>  
 <span data-ttu-id="705c6-110">この型と、この型のメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。</span><span class="sxs-lookup"><span data-stu-id="705c6-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="705c6-111"><see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="705c6-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="705c6-112"><see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="705c6-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="705c6-113">依存関係プロパティに指定する既定値。通常、特定の型の値として指定されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span></span></param>
        <summary><span data-ttu-id="705c6-114">メタデータが適用される依存関係プロパティの指定した既定値を使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="705c6-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-115">`defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。</span><span class="sxs-lookup"><span data-stu-id="705c6-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="705c6-116">メタデータの既定値の型と、それが適用される依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります (不一致によって実行時例外が発生します)。</span><span class="sxs-lookup"><span data-stu-id="705c6-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="705c6-117">パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="705c6-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="705c6-118">これを行おうとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="705c6-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="705c6-119"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</span><span class="sxs-lookup"><span data-stu-id="705c6-119"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="705c6-120">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</span><span class="sxs-lookup"><span data-stu-id="705c6-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="705c6-121">指定した <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="705c6-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="705c6-122">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-122">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="705c6-123">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</span><span class="sxs-lookup"><span data-stu-id="705c6-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="705c6-124">指定した既定値と <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="705c6-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-125">`defaultValue` 提供された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。</span><span class="sxs-lookup"><span data-stu-id="705c6-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="705c6-126">メタデータの既定値の型と、それが適用される依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります (不一致によって実行時例外が発生します)。</span><span class="sxs-lookup"><span data-stu-id="705c6-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="705c6-127">パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="705c6-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="705c6-128">これを行おうとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="705c6-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="705c6-129"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</span><span class="sxs-lookup"><span data-stu-id="705c6-129"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="705c6-130">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-130">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="705c6-131">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</span><span class="sxs-lookup"><span data-stu-id="705c6-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="705c6-132">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照です。</span><span class="sxs-lookup"><span data-stu-id="705c6-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="705c6-133">指定した既定値とコールバックを使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="705c6-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-134"><xref:System.Windows.PropertyChangedCallback>ではなく <xref:System.Windows.CoerceValueCallback> を指定する場合は、`propertyChangedCallback` パラメーターに `null` を渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="705c6-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="705c6-135">`defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。</span><span class="sxs-lookup"><span data-stu-id="705c6-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="705c6-136">メタデータの既定値の型と、それが適用される依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります (不一致によって実行時例外が発生します)。</span><span class="sxs-lookup"><span data-stu-id="705c6-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="705c6-137">パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="705c6-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="705c6-138">これを行おうとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="705c6-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="705c6-139"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</span><span class="sxs-lookup"><span data-stu-id="705c6-139"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="705c6-140">このメタデータに指定されている <see cref="T:System.Windows.CoerceValueCallback" /> 実装への参照を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="705c6-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="705c6-141"><see cref="T:System.Windows.CoerceValueCallback" /> 実装参照。</span><span class="sxs-lookup"><span data-stu-id="705c6-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-142">プロパティメタデータのコールバックは、通常、含んでいる型のパブリックメンバーではないため、既存の依存関係プロパティのメタデータを使用するだけのほとんどのシナリオでは、このプロパティの値は重要ではありません。</span><span class="sxs-lookup"><span data-stu-id="705c6-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="705c6-143">このプロパティが公開される理由の1つは、基本メタデータとオーバーライド/追加メタデータの両方で <xref:System.Windows.CoerceValueCallback>が指定されている場合に、メタデータサブクラスが必要なマージロジックを実行できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="705c6-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="705c6-144">ただし、<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> の既定のマージロジックでは、前のロジックが置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="705c6-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="705c6-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> は、オブジェクトモデルで読み取り/書き込み可能として定義されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="705c6-146">これは、<xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後に <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> を調整できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="705c6-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="705c6-147">ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになりました。</span><span class="sxs-lookup"><span data-stu-id="705c6-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="705c6-148">このメタデータインスタンスに `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> を設定しようとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="705c6-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="705c6-149">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</span><span class="sxs-lookup"><span data-stu-id="705c6-149">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="705c6-150">依存関係プロパティの既定値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="705c6-150">Gets or sets the default value of the dependency property.</span></span></summary>
        <value><span data-ttu-id="705c6-151">プロパティの既定値です。</span><span class="sxs-lookup"><span data-stu-id="705c6-151">The default value of the property.</span></span> <span data-ttu-id="705c6-152">パラメーターなしのコンストラクターを使用して作成された <see cref="T:System.Windows.PropertyMetadata" /> インスタンスの既定値は <see cref="F:System.Windows.DependencyProperty.UnsetValue" />されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> は、オブジェクトモデルで読み取り/書き込み可能として定義されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="705c6-154">これは、<xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後に <xref:System.Windows.PropertyMetadata.DefaultValue%2A> を調整できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="705c6-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="705c6-155">ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになりました。</span><span class="sxs-lookup"><span data-stu-id="705c6-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="705c6-156">このメタデータインスタンスに `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> <xref:System.Windows.PropertyMetadata.DefaultValue%2A> を設定しようとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="705c6-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="705c6-157">パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.PropertyMetadata.DefaultValue%2A> またはコンストラクターを使用して <xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="705c6-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="705c6-158">これを行おうとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="705c6-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="705c6-159">XAML テキストの使用</span><span class="sxs-lookup"><span data-stu-id="705c6-159">XAML Text Usage</span></span>  
 <span data-ttu-id="705c6-160">この型のメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。</span><span class="sxs-lookup"><span data-stu-id="705c6-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="705c6-161">いったん作成した後は、値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</span><span class="sxs-lookup"><span data-stu-id="705c6-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="705c6-162">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</span><span class="sxs-lookup"><span data-stu-id="705c6-162">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="705c6-163">メタデータが何らかの方法でプロパティに適用されていて、該当のメタデータ インスタンスが不変の状態にあるかどうかを判断する値を取得します。</span><span class="sxs-lookup"><span data-stu-id="705c6-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span></span></summary>
        <value><span data-ttu-id="705c6-164">メタデータ インスタンスが不変の状態の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="705c6-164"><see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-165"><xref:System.Windows.PropertyMetadata.DefaultValue%2A>などの <xref:System.Windows.PropertyMetadata>のさまざまなプロパティは、オブジェクトモデルで読み取り/書き込み可能として定義されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="705c6-166">これは、これらのプロパティを <xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後で調整できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="705c6-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="705c6-167">ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として依存関係プロパティに適用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになります。</span><span class="sxs-lookup"><span data-stu-id="705c6-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="705c6-168">これらの呼び出しのいずれかの時点で、<xref:System.Windows.PropertyMetadata.OnApply%2A> が呼び出され、このプロパティの値は `true`に設定されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="705c6-169">次の例では、カスタムメタデータプロパティの設定操作の前に <xref:System.Windows.PropertyMetadata.IsSealed%2A> を確認します。</span><span class="sxs-lookup"><span data-stu-id="705c6-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="705c6-170">このインスタンスの値とマージする基本メタデータ。</span><span class="sxs-lookup"><span data-stu-id="705c6-170">The base metadata to merge with this instance's values.</span></span></param>
        <param name="dp"><span data-ttu-id="705c6-171">このメタデータが適用される依存関係プロパティ。</span><span class="sxs-lookup"><span data-stu-id="705c6-171">The dependency property to which this metadata is being applied.</span></span></param>
        <summary><span data-ttu-id="705c6-172">このメタデータと基本メタデータをマージします。</span><span class="sxs-lookup"><span data-stu-id="705c6-172">Merges this metadata with the base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-173">このメソッドは、メタデータがオーバーライドされるときに内部的に使用されます (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> メソッド)。</span><span class="sxs-lookup"><span data-stu-id="705c6-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="705c6-174">次の例では、プロパティメタデータに追加のプロパティを追加するカスタムメタデータ型のマージを実装します。</span><span class="sxs-lookup"><span data-stu-id="705c6-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="705c6-175"><see cref="T:System.Windows.PropertyMetadata" /> から派生するクラス実装では、実装に追加したメタデータプロパティを考慮するために、このメソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="705c6-175">Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations.</span></span> <span data-ttu-id="705c6-176">たとえば、実装によって新しいフラグ列挙値が追加されている場合、<see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> の実装では、これらのフラグを正しく組み合わせることができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="705c6-176">For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.</span></span>  
  
<span data-ttu-id="705c6-177">基本実装では <see cref="T:System.Windows.PropertyMetadata" /> 型で既に定義されているすべてのプロパティの結合が処理されるため、実装コードの前に常に基本実装を呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="705c6-177">Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.</span></span>  
  
<span data-ttu-id="705c6-178">マージの正確な動作はユーザーによって設定されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-178">The exact behavior of the merge is up to you.</span></span> <span data-ttu-id="705c6-179">値を組み合わせるか、派生メタデータが既定値のままである場合は基本値に戻すか、または特定のメタデータクラスに追加したプロパティの型に基づいて他の多くの動作を指定するかを選択できます。</span><span class="sxs-lookup"><span data-stu-id="705c6-179">You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="705c6-180">メタデータが適用された依存関係プロパティ。</span><span class="sxs-lookup"><span data-stu-id="705c6-180">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="705c6-181">該当するメタデータが型固有のメタデータの場合、このメタデータに関連付けられている型。</span><span class="sxs-lookup"><span data-stu-id="705c6-181">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="705c6-182">これが既定のメタデータの場合、この値は null 参照です。</span><span class="sxs-lookup"><span data-stu-id="705c6-182">If this is default metadata, this value is a null reference.</span></span></param>
        <summary><span data-ttu-id="705c6-183">このメタデータがプロパティに適用されたときに呼び出され、メタデータがシールされることを示します。</span><span class="sxs-lookup"><span data-stu-id="705c6-183">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-184">サブクラスを使用すると、<xref:System.Windows.PropertyMetadata.OnApply%2A> が呼び出された後に、<xref:System.Windows.PropertyMetadata> サブクラスのデータ構造のすべての変更性を変更不可としてマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="705c6-184">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="705c6-185">この値は、メタデータがプロパティシステム操作に適用されると呼び出されます (レジスタ、所有者の追加、メタデータのオーバーライド)。</span><span class="sxs-lookup"><span data-stu-id="705c6-185">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="705c6-186">このメタデータに指定されている <see cref="T:System.Windows.PropertyChangedCallback" /> 実装への参照を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="705c6-186">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="705c6-187"><see cref="T:System.Windows.PropertyChangedCallback" /> 実装参照。</span><span class="sxs-lookup"><span data-stu-id="705c6-187">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="705c6-188">プロパティメタデータ内のコールバックは、通常、定義型のパブリックメンバーではないため、既存の依存関係プロパティのメタデータを使用するだけのほとんどのシナリオでは、このプロパティの値は重要ではありません。</span><span class="sxs-lookup"><span data-stu-id="705c6-188">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="705c6-189">このプロパティが公開される理由の1つは、基本メタデータとオーバーライド/追加メタデータの両方で <xref:System.Windows.PropertyChangedCallback>が指定されている場合に、メタデータクラスが必要なマージロジックを実行できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="705c6-189">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="705c6-190">の既定のマージロジックでは、テーブル内のすべての <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> の実装を保持し、それぞれを呼び出します。また、最初に階層内の最上位のクラスによって確立されたコールバックを使用します。</span><span class="sxs-lookup"><span data-stu-id="705c6-190">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="705c6-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> は、オブジェクトモデルで読み取り/書き込み可能として定義されます。</span><span class="sxs-lookup"><span data-stu-id="705c6-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="705c6-192">これは、<xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後に <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> を調整できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="705c6-192">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="705c6-193">ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになりました。</span><span class="sxs-lookup"><span data-stu-id="705c6-193">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="705c6-194">このメタデータインスタンスに `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> を設定しようとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="705c6-194">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="705c6-195">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</span><span class="sxs-lookup"><span data-stu-id="705c6-195">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
