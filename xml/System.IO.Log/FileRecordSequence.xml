<Type Name="FileRecordSequence" FullName="System.IO.Log.FileRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a68264be8dbac27ef46ffa9dd2a76043c4738bf5" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78824575" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.FileRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type FileRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>ファイル上に <see cref="T:System.IO.Log.IRecordSequence" /> を実装します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.FileRecordSequence> は、ファイル システム内の単一のログ ファイルに基づくレコード シーケンスです。 これは、単純なファイルに基づくログ上の <xref:System.IO.Log.IRecordSequence> インターフェイスの簡単な実装です。  
  
 ファイル ベースのログを操作するには、アプリケーションを実行しているアカウントに十分な特権が必要です。特権は、<xref:System.IO.Log.FileRecordSequence> の構築時にファイル システムのセキュリティで指定されます。 さらに、構築時に FullTrust への要求が行われます。 アクセス許可の検査の結果は、事後に Windows セキュリティ モデルに合わせてキャッシュされます。 レコード シーケンスのコンテンツを権限のないユーザーに誤って開示しないことを確認することをお勧めします。  
  
   
  
## Examples  
 次の例では、レコード シーケンスを作成し、レコードを追加し、最後にレコードを読み取ります。  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.IO.Log.FileRecordSequence" /> インスタンスがカプセル化するファイルの相対パスまたは絶対パス。</param>
        <summary>指定したファイルを使用して、<see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、ファイルへの読み取り/書き込みアクセスを作成し、共有読み取りアクセス モードでファイルを開きます。 そのため、ファイルを書き込みアクセスで開く操作をこのプロセスまたは他のプロセスで要求すると、この <xref:System.IO.Log.FileRecordSequence> インスタンスを破棄していない限り、要求は失敗しますが、読み取りは成功します。 `path` が見つからない場合、サイズが 0 バイトの新しいファイルが作成されます。  
  
   
  
## Examples  
 次の例では、レコードシーケンスを作成してレコードを追加し、レコードを読み取り、最後にシーケンスを破棄します。  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> によって指定されたファイルが有効ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> で指定したファイルが見つかりません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定のログ ストアへのアクセスは、オペレーティング システムにより拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.IO.Log.FileRecordSequence" /> インスタンスがカプセル化するファイルの相対パスまたは絶対パス。</param>
        <param name="access">ユーザーがログ ファイルに対して持つアクセスの種類を制御する有効な <see cref="T:System.IO.FileAccess" /> 値。</param>
        <summary>ファイルおよびアクセス モードを指定して、<see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> によって指定されたファイルが有効ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> で指定したファイルが見つかりません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定のログ ストアへのアクセスは、オペレーティング システムにより拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access, int size);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess * int -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access, size)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.IO.Log.FileRecordSequence" /> インスタンスがカプセル化するファイルの相対パスまたは絶対パス。</param>
        <param name="access">ユーザーがログ ファイルに対して持つアクセスの種類を制御する有効な <see cref="T:System.IO.FileAccess" /> 値。</param>
        <param name="size">開くログ ファイルのサイズ。</param>
        <summary>ファイル、アクセス モード、およびファイル サイズを指定して、<see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上のパラメーターが有効範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> によって指定されたファイルが有効ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> で指定したファイルが見つかりません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定のログ ストアへのアクセスは、オペレーティング システムにより拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="fileRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">レコード シーケンスの新しい基本シーケンス番号。</param>
        <summary>ログの基本シーケンス番号を前方移動します。 このメソッドは継承できません。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> が正しくありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。</exception>
        <exception cref="T:System.IO.IOException">シーケンスの変更中に I/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ログ レコードを <see cref="T:System.IO.Log.FileRecordSequence" />に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、レコード シーケンスを作成し、レコードを追加し、最後にレコードを読み取ります。  
  
 [!code-csharp[IRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#0)]
 [!code-vb[IRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <summary>ログ レコードを <see cref="T:System.IO.Log.FileRecordSequence" />に書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
   
  
## Examples  
 次の例では、レコード シーケンスを作成し、レコードを追加し、最後にレコードを読み取ります。  
  
 [!code-csharp[FileRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/filerecordsequence/cs/filerecordsequence.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <summary>ログ レコードを <see cref="T:System.IO.Log.FileRecordSequence" />に書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
   
  
## Examples  
 このメソッドを使用してレコード シーケンスを作成する方法を次の例に示します。  
  
 [!code-csharp[IRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#3)] 
 [!code-vb[IRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#3)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>以前にシーケンスに予約された領域を使用して、<see cref="T:System.IO.Log.FileRecordSequence" /> にログ レコードを書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 追加されたレコードは、`reservations` パラメーターにより指定された予約を使用して以前に予約された領域を消費します。 この追加処理が成功すると、データを格納できる最も小さな予約領域が消費され、その予約領域がコレクションから削除されます。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>以前にシーケンスに予約された領域を使用して、<see cref="T:System.IO.Log.FileRecordSequence" /> にログ レコードを書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 追加されたレコードは、`reservations` パラメーターにより指定された予約を使用して以前に予約された領域を消費します。 この追加処理が成功すると、データを格納できる最も小さな予約領域が消費され、その予約領域がコレクションから削除されます。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.IO.Log.FileRecordSequence" /> 内の最初の有効なレコードのシーケンス番号を取得します。</summary>
        <value><see cref="T:System.IO.Log.FileRecordSequence" /> 内の有効なレコードに対応する下限のシーケンス番号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有効なシーケンス番号は、<xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> 以上、<xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> 未満です。 その他のシーケンス番号はすべて無効です。  
  
 このプロパティの値は、<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> メソッドまたは <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> メソッドを呼び出すことにより変更できます。  
  
   
  
## Examples  
 ループ内で <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> を使用する方法を次の例に示します。  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期の追加操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 追加されたレコードは、`reservations` パラメーターにより指定された予約を使用して以前に予約された領域を消費します。 この追加処理が成功すると、データを格納できる最も小さな予約領域が消費され、その予約領域がコレクションから削除されます。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 追加されたレコードは、`reservations` パラメーターにより指定された予約を使用して以前に予約された領域を消費します。 この追加処理が成功すると、データを格納できる最も小さな予約領域が消費され、その予約領域がコレクションから削除されます。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (sequenceNumber As SequenceNumber, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">書き込む必要のある最新レコードのシーケンス番号。 <see cref="T:System.IO.Log.SequenceNumber" /> が無効な場合、すべてのレコードを書き込む必要があります。</param>
        <param name="callback">フラッシュの完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期フラッシュ要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期のフラッシュ操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期のフラッシュ操作を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> メソッドに渡すことにより、フラッシュが完了し、リソースが適切に解放されたことを確認する必要があります。 非同期フラッシュ中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 このメソッドを呼び出すことにより、<xref:System.IO.Log.FileRecordSequence> に追加されたすべてのレコードが永続的に書き込まれたことを確認します。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I/O 要求時にディスク障害が発生した場合など、非同期フラッシュ要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndFlush%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">1 つ以上の引数が無効です。  
  
 <paramref name="sequenceNumber" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。</exception>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期の予約および追加操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成する予約コレクション。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の予約および追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の操作を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成する予約コレクション。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の予約および追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の操作を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期の再開領域の書き込み操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservation">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">再開領域の書き込みの完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の再開領域非同期書き込み要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の再開領域の書き込み操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の再開領域の書き込み処理を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域の書き込み処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドに渡す必要があります。 非同期の再開領域の書き込み処理中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 この操作が正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 <xref:System.IO.Log.ReservationCollection> を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が、書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
または 
新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
または 
 <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservation">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">再開領域の書き込みの完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の再開領域非同期書き込み要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の再開領域の書き込み操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の再開領域の書き込み処理を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域の書き込み処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドに渡す必要があります。 非同期の再開領域の書き込み処理中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 この操作が正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 <xref:System.IO.Log.ReservationCollection> を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が、書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
または 
新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
または 
 <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="fileRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しい <see cref="T:System.IO.Log.ReservationCollection" /> を作成します。 このメソッドは継承できません。</summary>
        <returns>新しく作成された <see cref="T:System.IO.Log.ReservationCollection" /> です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトで使用されているアンマネージ リソースを直ちに解放します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I/O リクエストへの参照。</param>
        <summary>非同期の追加操作を終了します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、I/O 操作が完了するまでブロックします。 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> の呼び出し時に、I/O 要求間のディスク障害など非同期書き込み要求中に発生したエラーが現れます。  
  
 このメソッドは、<xref:System.IAsyncResult> メソッドから返された各 <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> について正確に 1 回呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I/O リクエストへの参照。</param>
        <summary>非同期フラッシュ操作を終了します。 このメソッドは継承できません。</summary>
        <returns>最後に書き込まれたレコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、I/O 操作が完了するまでブロックします。 <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> の呼び出し時に、I/O 要求間のディスク障害など非同期フラッシュ要求中に発生したエラーが現れます。  
  
 このメソッドは、<xref:System.IAsyncResult> メソッドから返された各 <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> について正確に 1 回呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I/O リクエストへの参照。</param>
        <summary>非同期の予約および追加操作を終了します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、I/O 操作が完了するまでブロックします。 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> の呼び出し時に、I/O 要求間のディスク障害など非同期書き込み要求中に発生したエラーが現れます。  
  
 このメソッドは、<xref:System.IAsyncResult> メソッドから返された各 <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> について正確に 1 回呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I/O リクエストへの参照。</param>
        <summary>非同期の再開領域の書き込み操作を終了します。 このメソッドは継承できません。</summary>
        <returns>書き込まれたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、I/O 操作が完了するまでブロックします。 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> の呼び出し時に、I/O 要求間のディスク障害など非同期書き込み要求中に発生したエラーが現れます。  
  
 このメソッドは、<xref:System.IAsyncResult> メソッドから返された各 <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> について正確に 1 回呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>追加したレコードは永続的に書き込まれます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>追加したすべてのレコードが書き込まれたことを確認します。 このメソッドは継承できません。</summary>
        <returns>最後に書き込まれたレコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すことにより、<xref:System.IO.Log.FileRecordSequence> に追加されたすべてのレコードが永続的に書き込まれたことを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush (sequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">書き込む必要のある最新レコードのシーケンス番号。 この <see cref="T:System.IO.Log.SequenceNumber" /> が無効な場合、すべてのレコードを書き込む必要があります。</param>
        <summary>追加したすべてのレコードが書き込まれたことを確認します。 このメソッドは継承できません。</summary>
        <returns>最後に書き込まれたレコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すと、指定のシーケンス番号以下のシーケンス番号を持つすべてのレコードが永続的に書き込まれたことが確認されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> が有効ではありません。</exception>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>追加された最後のレコードのシーケンス番号より大きいシーケンス番号を取得します。</summary>
        <value>追加された最後のレコードのシーケンス番号より大きいシーケンス番号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティには、最後に追加されたレコードのシーケンス番号を超えることが保証されるシーケンス番号が格納されています。 有効なシーケンス番号は、<xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> 以上、<xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> 未満です。 その他のシーケンス番号はすべて無効です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このシーケンスに対して追加または読み取りが可能な最大レコード サイズのバイト数を取得します。</summary>
        <value>このシーケンスに対して追加または読み取りが可能な最大レコード サイズのバイト数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">読み取りを開始する先頭レコードのシーケンス番号。</param>
        <param name="logRecordEnum"><see cref="T:System.IO.Log.LogRecordEnumeratorType" /> からレコードを読み取る方法 (つまり、順方向または逆方向) を指定する有効な <see cref="T:System.IO.Log.LogRecordSequence" /> 値。</param>
        <summary>シーケンス内のレコードの列挙可能なコレクションを返します。 このメソッドは継承できません。</summary>
        <returns>シーケンス内のレコードの列挙可能なコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、シーケンス内のレコードの列挙可能なコレクション。 列挙されたレコードの順序は、`logRecordEnum` パラメーター値に依存します。  
  
   
  
## Examples  
 このメソッドを使用してログ シーケンスのレコードを読み取る方法を次の例に示します。  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが書き込み専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">レコード シーケンスが破損しています。  
  
 または  
  
 レコードは、レコード シーケンスと互換性がないバージョンで書き込まれました。</exception>
        <exception cref="T:System.InvalidOperationException">列挙体が終了しています。  
  
または 
列挙体が開始されていません。 <see cref="M:System.Collections.IEnumerator.MoveNext" /> を呼び出す必要があります。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シーケンス内の再開領域の列挙可能なコレクションを返します。 このメソッドは継承できません。</summary>
        <returns>シーケンス内の再開領域の列挙可能なコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域では、シーケンス番号の逆順で (大きなシーケンス番号から小さなシーケンス番号に向かって) 列挙されます。 最後のシーケンス番号と基本シーケンス番号の間のシーケンス番号を持つ再開領域のみが列挙されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが書き込み専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">レコード シーケンスが破損しています。  
  
 または  
  
 レコードは、レコード シーケンスと互換性がないバージョンで書き込まれました。</exception>
        <exception cref="T:System.InvalidOperationException">列挙体が終了しています。  
  
または 
列挙体が開始されていません。 <see cref="M:System.Collections.IEnumerator.MoveNext" /> を呼び出す必要があります。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>単一の予約を自動的に行って、シーケンスにレコードを追加します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成するコレクションを格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <summary>単一の予約を自動的に行って、シーケンスにレコードを追加します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成する予約コレクション。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <summary>単一の予約を自動的に行って、シーケンスにレコードを追加します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>予約された合計バイト数を取得します。</summary>
        <value>このレコード シーケンス内でなされたすべての予約の合計サイズ。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>直前に書き込まれた再開領域のシーケンス番号を取得します。</summary>
        <value>直前に書き込まれた再開領域のシーケンス番号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用されます。 Common Log File System (CLFS) は、少なくとも 1 つの有効な領域が常に使用可能であることを保証するために 2 つの再開領域を維持します。 回復処理が必要な場合、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ログがいっぱいの場合に、追加を自動的に再試行するかどうかを示す値を取得または設定します。</summary>
        <value>ログがいっぱいの場合に追加の再試行を自動的に行う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="true" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値が `true` である場合で、シーケンス内に十分な領域がないために <xref:System.IO.Log.FileRecordSequence.Append%2A> の呼び出しが失敗したときは、レコード シーケンスが領域の解放を試みた後、追加の再試行を行います。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.FileRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event TailPinned As EventHandler(Of TailPinnedEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レコード シーケンスで末尾を前方に移動する必要があると判断された場合に発生します。 このメソッドは継承できません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、レコード シーケンスが領域を使い果たしたときに発行できます。 このイベントが発行されると、シーケンスの末尾 (つまり、基本シーケンス番号) が領域の解放のために前方に移動します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 バイト配列セグメント内のデータは、レコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 バイト配列セグメント内のデータは、レコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
または 
新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
または 
新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservations">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 予約を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
または 
新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
または 
 <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservations">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 予約を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
または 
新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
または 
 <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
