<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2dd140aa1734d4732b48d27b2695b87bcfcef0b6" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83953881" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>メッセージ キュー サーバーのキューにアクセスできるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージキューテクノロジを使用すると、異なるタイミングで実行されているアプリケーションが、一時的にオフラインになっている可能性のある異種ネットワークやシステム間で通信を行うことができます。 アプリケーションは、キューからメッセージを送信、受信、またはピーク (削除せずに読み取り) します。 メッセージキューは [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] および Windows NT のオプションのコンポーネントであり、個別にインストールする必要があります。  
  
 <xref:System.Messaging.MessageQueue> クラスは、メッセージキューのラッパーです。 メッセージキューには複数のバージョンがあり、<xref:System.Messaging.MessageQueue> クラスを使用すると、使用しているオペレーティングシステムによって若干異なる動作が発生する可能性があります。 各バージョンのメッセージキューの特定の機能の詳細については、MSDN のプラットフォーム SDK の「メッセージキューの新機能」を参照してください。  
  
 <xref:System.Messaging.MessageQueue> クラスは、メッセージキューのキューへの参照を提供します。 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンストラクターでパスを指定して既存のリソースに接続することも、サーバーに新しいキューを作成することもできます。 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>、<xref:System.Messaging.MessageQueue.Peek%2A>、または <xref:System.Messaging.MessageQueue.Receive%2A>を呼び出すには、<xref:System.Messaging.MessageQueue> クラスの新しいインスタンスを既存のキューに関連付ける必要があります。 その時点で、<xref:System.Messaging.MessageQueue.Category%2A> や <xref:System.Messaging.MessageQueue.Label%2A>などのキューのプロパティを操作できます。  
  
 <xref:System.Messaging.MessageQueue> では、同期と非同期の2種類のメッセージ取得がサポートされています。 同期メソッドである <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.Receive%2A>により、プロセススレッドは、新しいメッセージがキューに到着するまで、指定された時間間隔待機します。 非同期メソッド、<xref:System.Messaging.MessageQueue.BeginPeek%2A> および <xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用すると、メッセージがキューに到着するまで、メインアプリケーションタスクが別のスレッドで続行されるようにすることができます。 これらのメソッドは、コールバックオブジェクトと状態オブジェクトを使用してスレッド間で情報を伝達することによって機能します。  
  
 <xref:System.Messaging.MessageQueue> クラスの新しいインスタンスを作成しても、新しいメッセージキューのキューは作成されません。 代わりに、<xref:System.Messaging.MessageQueue.Create%28System.String%29>、<xref:System.Messaging.MessageQueue.Delete%28System.String%29>、および <xref:System.Messaging.MessageQueue.Purge%2A> の各メソッドを使用して、サーバー上のキューを管理できます。  
  
 <xref:System.Messaging.MessageQueue.Purge%2A>とは異なり、<xref:System.Messaging.MessageQueue.Create%28System.String%29> と <xref:System.Messaging.MessageQueue.Delete%28System.String%29> は `static` メンバーであるため、<xref:System.Messaging.MessageQueue> クラスの新しいインスタンスを作成せずに呼び出すことができます。  
  
 <xref:System.Messaging.MessageQueue> オブジェクトの <xref:System.Messaging.MessageQueue.Path%2A> プロパティは、表示名、<xref:System.Messaging.MessageQueue.FormatName%2A>、または <xref:System.Messaging.MessageQueue.Label%2A>の3つの名前のいずれかを使用して設定できます。 キューの <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティによって定義される表示名は、パブリックキューの <xref:System.Messaging.MessageQueue.QueueName%2A> \\<xref:System.Messaging.MessageQueue.MachineName%2A>、プライベートキューの <xref:System.Messaging.MessageQueue.MachineName%2A>\\`Private$`\\<xref:System.Messaging.MessageQueue.QueueName%2A> ます。 <xref:System.Messaging.MessageQueue.FormatName%2A> プロパティを使用すると、メッセージキューにオフラインでアクセスできます。 最後に、キューの <xref:System.Messaging.MessageQueue.Label%2A> プロパティを使用して、キューの <xref:System.Messaging.MessageQueue.Path%2A>を設定できます。  
  
 <xref:System.Messaging.MessageQueue>のインスタンスの初期プロパティ値の一覧については、<xref:System.Messaging.MessageQueue.%23ctor%2A> コンストラクターを参照してください。  
  
   
  
## Examples  
 次のコード例では、さまざまなパス名の構文型を使用して、新しい <xref:System.Messaging.MessageQueue> オブジェクトを作成します。 いずれの場合も、コンストラクターで定義されているパスを持つキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 次のコード例では、メッセージをキューに送信し、`Order`というアプリケーション固有のクラスを使用してキューからメッセージを受信します。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> メソッドだけがスレッドセーフです。</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。 パラメーターなしのコンストラクターが新しいインスタンスを初期化した後、そのインスタンスを使用する前にインスタンスの <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティを設定する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、メッセージキューサーバーのキューにすぐに関連付けられていない <xref:System.Messaging.MessageQueue> クラスの新しいインスタンスを作成します。 このインスタンスを使用する前に、<xref:System.Messaging.MessageQueue.Path%2A> プロパティを設定して、既存のメッセージキューのキューに接続する必要があります。 または、<xref:System.Messaging.MessageQueue.Create%28System.String%29> メソッドの戻り値への <xref:System.Messaging.MessageQueue> 参照を設定して、新しいメッセージキューのキューを作成することもできます。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンストラクターは、<xref:System.Messaging.MessageQueue> クラスの新しいインスタンスをインスタンス化します。新しいメッセージキューのキューは作成されません。  
  
 次の表に、<xref:System.Messaging.MessageQueue>のインスタンスのプロパティの初期値を示します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<xref:System.Messaging.DefaultPropertiesToSend> クラスのパラメーターなしのコンストラクターによって設定される値。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<xref:System.Messaging.MessagePropertyFilter> クラスのパラメーターなしのコンストラクターによって設定される値。 すべてのフィルター値が `true`に設定されます。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 次のコード例では、新しい <xref:System.Messaging.MessageQueue> を作成します。  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。</param>
        <summary>指定したパスのメッセージ キューのキューを参照する <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、新しい <xref:System.Messaging.MessageQueue> インスタンスを、パス、形式名、またはラベルがわかっている特定のメッセージキューキューに関連付ける場合に使用します。 キューを参照する最初のアプリケーションに排他アクセスを許可する場合は、<xref:System.Messaging.MessageQueue.DenySharedReceive%2A> プロパティを `true` に設定するか、読み取りアクセス制限パラメーターを渡すコンストラクターを使用する必要があります。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンストラクターは、<xref:System.Messaging.MessageQueue> クラスの新しいインスタンスをインスタンス化します。新しいメッセージキューのキューは作成されません。 メッセージキューに新しいキューを作成するには、<xref:System.Messaging.MessageQueue.Create%28System.String%29>を使用します。  
  
 `path` パラメーターの構文は、次の表に示すように、参照するキューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|マシンジャーナルキュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピュータートランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 または、次の表に示すように、<xref:System.Messaging.MessageQueue.FormatName%2A> または <xref:System.Messaging.MessageQueue.Label%2A> を使用してキューのパスを記述することもできます。  
  
|リファレンス|構文|例|  
|---------------|------------|-------------|  
|書式名|`FormatName:` [*形式名*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`;`HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [*ラベル*]|`Label:` TheLabel|  
  
 オフラインで作業するには、コンストラクターのパス名の構文ではなく、形式名の構文を使用する必要があります。 そうしないと、プライマリドメインコントローラーが形式名へのパスを解決できないため、例外がスローされます。  
  
 次の表に、<xref:System.Messaging.MessageQueue>のインスタンスのプロパティの初期値を示します。 これらの値は、`path` パラメーターによって指定されたパスを持つメッセージキューのキューのプロパティに基づいています。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<xref:System.Messaging.DefaultPropertiesToSend> クラスのパラメーターなしのコンストラクターによって設定される値。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|メッセージキューのキューのプライバシーレベルの設定が "Body" の場合、`true`ます。それ以外の場合は、`false`ます。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージキューのキューのコンピューター名プロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<xref:System.Messaging.MessagePropertyFilter> クラスのパラメーターなしのコンストラクターによって設定される値。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|コンストラクターによって設定されていない場合は <xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|コンストラクターによって設定されていない場合は <xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|メッセージキューオブジェクトのジャーナル設定が有効になっている場合は `true`。それ以外の場合は、`false`ます。|  
  
   
  
## Examples  
 次のコード例では、さまざまなパス名の構文型を使用して、新しい <xref:System.Messaging.MessageQueue> オブジェクトを作成します。 いずれの場合も、コンストラクターで定義されているパスを持つキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが無効です。プロパティが設定されていないためと考えられます。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="sharedModeDenyReceive">キューにアクセスする最初のアプリケーションに排他読み取りアクセス許可を与える場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した読み取りアクセス制限を持つ指定したパスのメッセージ キューのキューを参照する <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パス、形式名、またはラベルがわかっている特定のメッセージキューのキューに新しい <xref:System.Messaging.MessageQueue> を関連付ける場合は、このオーバーロードを使用します。 キューを参照する最初のアプリケーションに排他アクセスを許可する場合は、`sharedModeDenyReceive` パラメーターを `true`に設定します。 それ以外の場合は、`sharedModeDenyReceive` を、`path` パラメーターのみを持つコンストラクターを `false` または使用するように設定します。  
  
 `sharedModeDenyReceive` を `true` に設定すると、他のアプリケーションを含め、メッセージキューのキューにアクセスするすべてのオブジェクトに影響します。 パラメーターの効果は、このアプリケーションに限定されません。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンストラクターは、<xref:System.Messaging.MessageQueue> クラスの新しいインスタンスを作成します。新しいメッセージキューのキューは作成されません。 メッセージキューに新しいキューを作成するには、<xref:System.Messaging.MessageQueue.Create%28System.String%29>を使用します。  
  
 `path` パラメーターの構文は、キューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|マシンジャーナルキュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピュータートランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 また、メッセージキューのキューの形式名またはラベルを使用して、キューのパスを記述することもできます。  
  
|リファレンス|構文|例|  
|---------------|------------|-------------|  
|書式名|`FormatName:` [*形式名*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`;`HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [*ラベル*]|`Label:` TheLabel|  
  
 オフラインで作業するには、フレンドリ名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合は、(Active Directory が存在する) プライマリドメインコントローラーが形式名へのパスを解決できないため、例外がスローされます。  
  
 <xref:System.Messaging.MessageQueue> が `sharedModeDenyReceive` パラメーターを `true`に設定してキューを開くと、共有違反が発生したため、後でキューからの読み取りを試みたすべての <xref:System.Messaging.MessageQueue> で <xref:System.Messaging.MessageQueueException> が生成されます。 <xref:System.Messaging.MessageQueueException> は、<xref:System.Messaging.MessageQueue> が排他モードでキューにアクセスしようとしたときに、別の <xref:System.Messaging.MessageQueue> が既にキューへの非排他的アクセスを試みた場合にもスローされます。  
  
 次の表に、<xref:System.Messaging.MessageQueue>のインスタンスのプロパティの初期値を示します。 これらの値は、メッセージキューのキューのプロパティに基づいており、`path` パラメーターによって指定されたパスが使用されます。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|[https://login.microsoftonline.com/consumers/](`false`)|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0。|  
|<xref:System.Messaging.MessageQueue.Category%2A>|[https://login.microsoftonline.com/consumers/](<xref:System.Guid.Empty>)|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<xref:System.Messaging.DefaultPropertiesToSend> クラスのパラメーターなしのコンストラクターによって設定される値。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|メッセージキューのキューのプライバシーレベルの設定が "Body" の場合、`true`ます。それ以外の場合は、`false`ます。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|[https://login.microsoftonline.com/consumers/](<xref:System.Messaging.XmlMessageFormatter>)|  
|<xref:System.Messaging.MessageQueue.Label%2A>|[https://login.microsoftonline.com/consumers/](<xref:System.String.Empty>)|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージキューのキューのコンピューター名プロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|[https://login.microsoftonline.com/consumers/](<xref:System.Messaging.MessageQueue.InfiniteQueueSize>)|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|[https://login.microsoftonline.com/consumers/](<xref:System.Messaging.MessageQueue.InfiniteQueueSize>)|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<xref:System.Messaging.MessagePropertyFilter> クラスのパラメーターなしのコンストラクターによって設定される値。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|コンストラクターによって設定されていない場合は <xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|コンストラクターによって設定されていない場合は <xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` パラメーターの値。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|メッセージキューオブジェクトのジャーナル設定が有効になっている場合は `true`。それ以外の場合は、`false`ます。|  
  
   
  
## Examples  
 次のコード例では、排他アクセスを使用して新しい <xref:System.Messaging.MessageQueue> を作成し、そのパスを設定して、メッセージをキューに送信します。  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが無効です。プロパティが設定されていないためと考えられます。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか 1 つです。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="sharedModeDenyReceive">キューにアクセスする最初のアプリケーションに排他読み取りアクセス許可を与える場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="enableCache">接続キャッシュを作成し、使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、排他的読み取りアクセスと接続キャッシュを有効にした新しい <xref:System.Messaging.MessageQueue> を作成します。  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="sharedModeDenyReceive">キューにアクセスする最初のアプリケーションに排他読み取りアクセス許可を与える場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="enableCache">接続キャッシュを作成し、使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか 1 つです。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのアクセス モードを示す値を取得します。</summary>
        <value><see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか 1 つです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンストラクターを呼び出すときに特に指定しない限り、キューの既定のアクセスモードは `QueueAccessMode.SendAndReceive`ます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューが認証済みメッセージだけを受け入れるかどうかを示す値を取得または設定します。</summary>
        <value>キューが認証済みメッセージだけを受け入れる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ認証は、メッセージの整合性を確保し、メッセージを送信したユーザーを確認する手段を提供します。 送信アプリケーションは、認証を要求するために、メッセージの認証レベルを設定します。  
  
 <xref:System.Messaging.MessageQueue.Authenticate%2A> を `true`に設定すると、この <xref:System.Messaging.MessageQueue> インスタンスだけでなく、サーバー上のキューへのアクセスが制限されます。 同じメッセージキューのキューに対して動作しているすべてのクライアントが影響を受けます。  
  
 認証済みのメッセージだけを受け入れるキューは、認証されていないメッセージを拒否します。 メッセージの拒否通知を要求するには、送信側アプリケーションでメッセージの <xref:System.Messaging.Message.AcknowledgeType%2A> プロパティを設定します。 メッセージが拒否されることは他にないため、配信元のアプリケーションは、配信不能キューに送信されるように要求しない限り、メッセージを紛失する可能性があります。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.Authenticate%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワーク上でパブリック キューのメッセージを送信するためにメッセージ キューが使用する基本優先順位を取得または設定します。</summary>
        <value>パブリック キューに送信されるすべてのメッセージに適用される単一の基本優先順位。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージキューの基本優先順位によって、そのキューに送信されるメッセージをネットワーク経由で転送するときにどのように処理するかが指定されます。 <xref:System.Messaging.MessageQueue.BasePriority%2A> プロパティを設定すると、指定したキューに送信されるすべてのメッセージに対して、他のキューに送信されるメッセージよりも優先度が高いまたは低い優先順位になります。 このプロパティを設定すると、メッセージキューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは変更の影響を受けます。  
  
 メッセージキューの <xref:System.Messaging.MessageQueue.BasePriority%2A> は、メッセージの <xref:System.Messaging.Message.Priority%2A> プロパティに関連付けられていません。これは、受信メッセージがキューに配置される順序を指定します。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> は、形式名を使用してパスが指定されているパブリックキューにのみ適用されます。 プライベートキューの基本優先順位は常にゼロ (0) です。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.BasePriority%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基本優先順位に無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <summary>メッセージのピークを開始し、完了したときにイベント ハンドラーに通知するようにメッセージ キューに指示して、非同期のピーク操作を実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>タイムアウトのない非同期のピーク操作を実行します。この操作は、キューのメッセージが利用可能になるまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期処理では、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を使用して、キューでメッセージが使用可能になったときに <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は、非同期のピーク操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> を呼び出すか、<xref:System.Messaging.PeekCompletedEventArgs>を使用して結果を取得することによって、メッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューをピークすることができます。 キューを同期的にピークするには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返される <xref:System.IAsyncResult> は、メソッドが開始した非同期操作を識別します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> が `false`場合、完了イベントが発生しますが、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>を呼び出すと例外がスローされます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、`MyPeekCompleted`という名前のイベントハンドラーを作成し、それを <xref:System.Messaging.MessageQueue.PeekCompleted> イベントハンドラーデリゲートにアタッチし、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を呼び出して、パス ".\myQueue" にあるキューで非同期のピーク操作を開始します。 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生すると、この例ではメッセージをピークし、その本文を画面に書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を再度呼び出して、新しい非同期ピーク操作を開始します。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定したタイムアウトのある非同期のピーク操作を実行します。この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期処理では、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を使用して、メッセージがキューで使用可能になったとき、または指定した時間が経過したときに <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は、非同期のピーク操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> を呼び出すか、<xref:System.Messaging.PeekCompletedEventArgs>を使用して結果を取得することによって、メッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューをピークすることができます。 キューを同期的にピークするには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返される <xref:System.IAsyncResult> は、メソッドが開始した非同期操作を識別します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 このオーバーロードは、タイムアウトを指定します。`timeout` パラメーターで指定した間隔が経過すると、このコンポーネントは <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させます。 メッセージが存在しないため、後続の <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> を呼び出すと、例外がスローされます。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> が `false`場合、完了イベントが発生しますが、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>を呼び出すと例外がスローされます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューのパス ".\myQueue" を使用して、非同期のピーク操作を作成します。 イベントハンドラーを作成し、`MyPeekCompleted`して、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントハンドラーデリゲートにアタッチします。 非同期のピーク操作を開始するには、1分のタイムアウトを使用して <xref:System.Messaging.MessageQueue.BeginPeek%2A> が呼び出されます。 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生するか、タイムアウトの時間が経過すると、メッセージが存在する場合はメッセージが取得され、本文は画面に書き込まれます。 次に、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を再度呼び出して、同じタイムアウトを持つ新しい非同期ピーク操作を開始します。  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期のピーク操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期処理では、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を使用して、メッセージがキューで使用可能になったとき、または指定した時間が経過したときに <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 このオーバーロードを使用して、操作の有効期間全体にわたって保持される操作に情報を関連付けます。 イベントハンドラーは、操作に関連付けられている <xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> プロパティを参照することによって、この情報にアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は、非同期のピーク操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> を呼び出すか、<xref:System.Messaging.PeekCompletedEventArgs>を使用して結果を取得することによって、メッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューをピークすることができます。 キューを同期的にピークするには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は、メソッドが開始した非同期操作を識別する <xref:System.IAsyncResult> を返します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 このオーバーロードは、タイムアウトと状態オブジェクトを指定します。 `timeout` パラメーターで指定した間隔が経過すると、このコンポーネントは <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させます。 メッセージが存在しないため、後続の <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> を呼び出すと、例外がスローされます。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 たとえば、複数回 <xref:System.Messaging.MessageQueue.BeginPeek%2A> を呼び出して複数の操作を開始する場合は、定義した個別の状態オブジェクトを使用して各操作を識別できます。 このシナリオの図解は、「例」のセクションを参照してください。  
  
 また、state オブジェクトを使用して、プロセススレッド間で情報を渡すこともできます。 スレッドが開始されていても、コールバックが非同期シナリオの別のスレッドにある場合は、状態オブジェクトがマーシャリングされ、イベントからの情報と共に返されます。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> が `false`場合、完了イベントが発生しますが、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>を呼び出すと例外がスローされます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューのパス ".\myQueue" を使用して、非同期のピーク操作を作成します。 イベントハンドラーを作成し、`MyPeekCompleted`して、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントハンドラーデリゲートにアタッチします。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> が1分のタイムアウトで呼び出されます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> の各呼び出しには、その特定の操作を識別する一意の関連付けられた整数があります。 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生するか、タイムアウトの時間が経過すると、メッセージ (存在する場合) が取得され、その本文および操作固有の整数識別子が画面に書き込まれます。 次に、<xref:System.Messaging.MessageQueue.BeginPeek%2A> が再度呼び出され、同じタイムアウトと、完了した直前の操作の関連付けられた整数を使用して、新しい非同期ピーク操作を開始します。  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期のピーク操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用すると、メッセージがキューで利用可能になるか、指定した時間が経過したときに、callback パラメーターで指定されたコールバックが直接呼び出されます。<xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生していません。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> の他のオーバーロードは、このコンポーネントに依存して <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューをピークすることができます。 キューを同期的にピークするには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は、メソッドが開始した非同期操作を識別する <xref:System.IAsyncResult> を返します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 たとえば、複数回 <xref:System.Messaging.MessageQueue.BeginPeek%2A> を呼び出して複数の操作を開始する場合は、定義した個別の状態オブジェクトを使用して各操作を識別できます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期のピーク操作を作成します。 このコード例では、メッセージをローカルのメッセージキューに送信し、<xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>を呼び出して、10秒のタイムアウト値を渡します。特定のメッセージを識別する一意の整数。イベントハンドラー、`MyPeekCompleted`を識別する <xref:System.AsyncCallback> の新しいインスタンス。 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生すると、イベントハンドラーはメッセージをピークし、メッセージ本文と整数メッセージ識別子を画面に書き込みます。  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, cursor As Cursor, action As PeekAction, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 値のいずれか 1 つです。 キュー内の現在のメッセージと次のメッセージのどちらをピークするかを示します。</param>
        <param name="state">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトがあり、指定したカーソル、ピーク処理、および状態オブジェクトを使用する非同期のピーク操作を実行します。 状態オブジェクトは、操作の有効期間を通じて、関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用すると、メッセージがキューで使用可能になったとき、または指定した時間間隔が経過したときに、callback パラメーターで指定されたコールバックが直接呼び出されます。 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生していません。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> の他のオーバーロードは、このコンポーネントに依存して <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューをピークすることができます。 キューを同期的にピークするには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は、メソッドによって開始された非同期操作を識別する <xref:System.IAsyncResult> を返します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 たとえば、複数回 <xref:System.Messaging.MessageQueue.BeginPeek%2A> を呼び出して複数の操作を開始する場合は、定義した個別の状態オブジェクトを使用して各操作を識別できます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" /> パラメーターに <see langword="PeekAction.Current" /> または <see langword="PeekAction.Next" /> 以外の値が指定されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <summary>メッセージの受信を開始し、完了したときにイベント ハンドラーに通知するようにメッセージ キューに指示して、非同期の受信操作を実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>タイムアウトのない非同期の受信操作を実行します。この操作は、キューのメッセージが利用可能になるまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期処理では、<xref:System.Messaging.MessageQueue.BeginReceive%2A> を使用して、キューからメッセージが削除されたときに <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は、非同期の受信操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を呼び出すことによってメッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューからメッセージを受信することができます。 同期的にメッセージを受信するには、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 返される <xref:System.IAsyncResult> は、メソッドが開始した非同期操作を識別します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> が `false`場合、完了イベントが発生しますが、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を呼び出すと例外がスローされます。  
  
 トランザクションで <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期呼び出しを使用しないでください。 トランザクション非同期操作を実行する場合は、<xref:System.Messaging.MessageQueue.BeginPeek%2A>を呼び出し、トランザクションと (同期) <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを、ピーク操作用に作成したイベントハンドラー内に配置します。 イベントハンドラーには、次のコードに示すような機能が含まれている場合があり C# ます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期要求をチェーンします。 これは、"myQueue" という名前のローカルコンピューターにキューがあることを前提としています。 `Main` 関数は、`MyReceiveCompleted` ルーチンによって処理される非同期操作を開始します。 `MyReceiveCompleted` は、現在のメッセージを処理し、新しい非同期の受信操作を開始します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 次のコード例では、非同期要求をキューに置いています。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> を呼び出すと、戻り値に <xref:System.IAsyncResult.AsyncWaitHandle%2A> が使用されます。 `Main` ルーチンは、すべての非同期操作が完了するのを待ってから終了します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定したタイムアウトのある非同期の受信操作を実行します。この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期処理では、<xref:System.Messaging.MessageQueue.BeginReceive%2A> を使用して、メッセージがキューで使用可能になったとき、または指定した時間が経過したときに <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は、非同期の受信操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を呼び出すか、<xref:System.Messaging.ReceiveCompletedEventArgs>を使用して結果を取得することによって、メッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューからメッセージを受信することができます。 同期的にメッセージを受信するには、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> が `false`場合、完了イベントが発生しますが、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を呼び出すと例外がスローされます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 返される <xref:System.IAsyncResult> は、メソッドが開始した非同期操作を識別します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 このオーバーロードは、タイムアウトを指定します。`timeout` パラメーターで指定した間隔が経過すると、このコンポーネントは <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させます。 メッセージが存在しないため、後続の <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を呼び出すと、例外がスローされます。  
  
 トランザクションで <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期呼び出しを使用しないでください。 トランザクション非同期操作を実行する場合は、<xref:System.Messaging.MessageQueue.BeginPeek%2A>を呼び出し、トランザクションと (同期) <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを、ピーク操作用に作成したイベントハンドラー内に配置します。 イベントハンドラーには、次のコードに示すような機能が含まれている場合があり C# ます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期の受信操作を作成します。 このコード例では、イベントハンドラーを作成し、`MyReceiveCompleted`して、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントハンドラーデリゲートにアタッチします。 このコード例では、メッセージをローカルのメッセージキューに送信し、<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>を呼び出して、タイムアウト値を10秒に渡します。 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生すると、イベントハンドラーはメッセージを受信し、メッセージ本文を画面に書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値が無効です。負数の可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期の受信操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期処理では、<xref:System.Messaging.MessageQueue.BeginReceive%2A> を使用して、メッセージがキューで使用可能になったとき、または指定した時間が経過したときに <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 このオーバーロードを使用して、操作の有効期間全体にわたって保持される操作に情報を関連付けます。 イベントハンドラーは、操作に関連付けられている <xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> プロパティを参照して、この情報を検出できます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は、非同期の受信操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を呼び出すか、<xref:System.Messaging.ReceiveCompletedEventArgs>を使用して結果を取得することによって、メッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューからメッセージを受信することができます。 同期的にメッセージを受信するには、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 返される <xref:System.IAsyncResult> は、メソッドが開始した非同期操作を識別します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 このオーバーロードは、タイムアウトと状態オブジェクトを指定します。 `timeout` パラメーターで指定した間隔が経過すると、このコンポーネントは <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させます。 メッセージが存在しないため、後続の <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を呼び出すと、例外がスローされます。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 たとえば、複数回 <xref:System.Messaging.MessageQueue.BeginReceive%2A> を呼び出して複数の操作を開始する場合は、定義した個別の状態オブジェクトを使用して各操作を識別できます。  
  
 また、state オブジェクトを使用して、プロセススレッド間で情報を渡すこともできます。 スレッドが開始されていても、コールバックが非同期シナリオの別のスレッドにある場合は、状態オブジェクトがマーシャリングされ、イベントからの情報と共に返されます。  
  
 トランザクションで <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期呼び出しを使用しないでください。 トランザクション非同期操作を実行する場合は、<xref:System.Messaging.MessageQueue.BeginPeek%2A>を呼び出し、トランザクションと (同期) <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを、ピーク操作用に作成したイベントハンドラー内に配置します。 イベントハンドラーには、次のコードに示すような機能が含まれている場合があり C# ます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期の受信操作を作成します。 このコード例では、イベントハンドラーを作成し、`MyReceiveCompleted`して、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントハンドラーデリゲートにアタッチします。 このコード例では、メッセージをローカルのメッセージキューに送信した後、<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>を呼び出して、タイムアウト値を10秒、特定のメッセージを識別する一意の整数を渡します。 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生すると、イベントハンドラーはメッセージを受信し、メッセージ本文と整数メッセージ識別子を画面に書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期の受信操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用すると、メッセージがキューで利用可能になるか、指定した時間が経過したときに、callback パラメーターで指定されたコールバックが直接呼び出されます。<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生していません。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> の他のオーバーロードは、このコンポーネントに依存して <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は、非同期の受信操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を呼び出すか、<xref:System.Messaging.ReceiveCompletedEventArgs>を使用して結果を取得することによって、メッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューからメッセージを受信することができます。 同期的にメッセージを受信するには、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 返される <xref:System.IAsyncResult> は、メソッドが開始した非同期操作を識別します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 たとえば、複数回 <xref:System.Messaging.MessageQueue.BeginReceive%2A> を呼び出して複数の操作を開始する場合は、定義した個別の状態オブジェクトを使用して各操作を識別できます。  
  
 また、state オブジェクトを使用して、プロセススレッド間で情報を渡すこともできます。 スレッドが開始されていても、コールバックが非同期シナリオの別のスレッドにある場合は、状態オブジェクトがマーシャリングされ、イベントからの情報と共に返されます。  
  
 トランザクションで <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期呼び出しを使用しないでください。 トランザクション非同期操作を実行する場合は、<xref:System.Messaging.MessageQueue.BeginPeek%2A>を呼び出し、トランザクションと (同期) <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを、ピーク操作用に作成したイベントハンドラー内に配置します。 イベントハンドラーには、次のコードに示すような機能が含まれている場合があり C# ます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期の受信操作を作成します。 このコード例では、メッセージをローカルのメッセージキューに送信し、<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>を呼び出して、10秒のタイムアウト値を渡します。特定のメッセージを識別する一意の整数。イベントハンドラー、`MyReceiveCompleted`を識別する <xref:System.AsyncCallback> の新しいインスタンス。 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生すると、イベントハンドラーはメッセージを受信し、メッセージ本文と整数メッセージ識別子を画面に書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, cursor As Cursor, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="state">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトがあり、指定したカーソルおよび状態オブジェクトを使用する非同期の受信操作を実行します。 状態オブジェクトは、操作の有効期間を通じて、関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用すると、メッセージがキューで利用可能になるか、指定した時間が経過したときに、callback パラメーターで指定されたコールバックが直接呼び出されます。<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生していません。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> の他のオーバーロードは、このコンポーネントに依存して <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させます。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> は、メッセージが既にキューに存在する場合にも発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用するには、非同期操作の結果を処理してイベントデリゲートに関連付けるイベントハンドラーを作成します。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は、非同期の受信操作を開始します。メッセージがキューに到着すると、<xref:System.Messaging.MessageQueue> には、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントの発生時に通知されます。 <xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を呼び出すか、<xref:System.Messaging.ReceiveCompletedEventArgs>を使用して結果を取得することによって、メッセージにアクセスできます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドはすぐに制御を返しますが、非同期操作は、イベントハンドラーが呼び出されるまで完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期であるため、このメソッドを呼び出して、現在の実行スレッドをブロックせずにキューからメッセージを受信することができます。 同期的にメッセージを受信するには、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用します。  
  
 非同期操作が完了したら、イベントハンドラーで <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、通知を受け取ることができます。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 返される <xref:System.IAsyncResult> は、メソッドが開始した非同期操作を識別します。 この <xref:System.IAsyncResult> は、操作の有効期間全体を通して使用できます。ただし、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> が呼び出されるまでは通常は使用しません。 ただし、いくつかの非同期操作を開始する場合は、<xref:System.IAsyncResult> 値を配列に格納し、すべての操作または操作が完了するまで待機するかどうかを指定できます。 この場合は、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncWaitHandle%2A> プロパティを使用して、完了した操作を識別します。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 たとえば、複数回 <xref:System.Messaging.MessageQueue.BeginReceive%2A> を呼び出して複数の操作を開始する場合は、定義した個別の状態オブジェクトを使用して各操作を識別できます。  
  
 また、state オブジェクトを使用して、プロセススレッド間で情報を渡すこともできます。 スレッドが開始されていても、コールバックが非同期シナリオの別のスレッドにある場合は、状態オブジェクトがマーシャリングされ、イベントからの情報と共に返されます。  
  
 トランザクションで <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期呼び出しを使用しないでください。 トランザクション非同期操作を実行する場合は、<xref:System.Messaging.MessageQueue.BeginPeek%2A>を呼び出し、トランザクションと (同期) <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを、ピーク操作用に作成したイベントハンドラー内に配置します。 イベントハンドラーには、次のコードに示すような機能が含まれている場合があり C# ます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> を読み取ることができるかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> が存在し、アプリケーションが読み取ることができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> は、アプリケーションがキューからメッセージをピークまたは受信できるかどうかを示します。 <xref:System.Messaging.MessageQueue.CanRead%2A> が `true`場合、<xref:System.Messaging.MessageQueue> はキューからメッセージを受信またはピークできます。 それ以外の場合はできません。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> は、キューが排他読み取りアクセスで既に開いている場合 (または非排他アクセスで開かれている場合、およびこの <xref:System.Messaging.MessageQueue> 排他アクセスが要求される場合)、またはアプリケーションにアクセスするための十分な権限がない場合に `false` ます。 <xref:System.Messaging.MessageQueue.CanRead%2A> が `false`されたときにアプリケーションがキューからの読み取りを試行した場合、アクセスは拒否されます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.CanRead%2A> プロパティの値を表示します。  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> に書き込むことができるかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> が存在し、アプリケーションが書き込むことができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> は、アプリケーションがメッセージをキューに送信できるかどうかを示します。 <xref:System.Messaging.MessageQueue.CanWrite%2A> が `true`場合、<xref:System.Messaging.MessageQueue> はキューにメッセージを送信できます。 それ以外の場合はできません。  
  
 キューが排他的な書き込みアクセスで既に開かれている場合 (または、排他アクセスを使用して開いている場合、この <xref:System.Messaging.MessageQueue> 排他アクセスを要求した場合)、またはアプリケーションにアクセスするための十分な権限がない場合は、<xref:System.Messaging.MessageQueue.CanWrite%2A> が `false` ます。 <xref:System.Messaging.MessageQueue.CanWrite%2A> が `false`されたときにアプリケーションがキューに書き込もうとした場合、アクセスが拒否されます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.CanWrite%2A> プロパティの値を表示します。  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キュー カテゴリを取得または設定します。</summary>
        <value>キュー カテゴリを表す <see cref="T:System.Guid" /> (メッセージ キュー タイプ ID)。これによって、アプリケーションはキューを分類できます。 既定では、 <see langword="Guid.empty" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューカテゴリを使用すると、アプリケーションはキューを分類できます。 たとえば、すべての請求キューを1つのカテゴリに配置し、すべての注文キューを別のカテゴリに配置できます。  
  
 <xref:System.Messaging.MessageQueue.Category%2A> プロパティを使用すると、コンピューターの管理コンソールの **[キューのプロパティ]** ダイアログボックスからアクセスできる "メッセージキューの種類 ID" プロパティ (読み取り/書き込み) にアクセスできます。 新しいカテゴリを定義できます。 <xref:System.Guid.NewGuid%2A> を使用して、すべての <xref:System.Guid> 値で一意のカテゴリ値を作成することもできますが、このようなアクションは必要ありません。 カテゴリ値は、他のすべての <xref:System.Guid> 値からではなく、他のカテゴリからのみ一意である必要があります。 たとえば、{00000000-0000-0000-0000-000000000001} を1つのキューセットの <xref:System.Messaging.MessageQueue.Category%2A> として、別のセットの <xref:System.Messaging.MessageQueue.Category%2A> として {00000000-0000-0000-0000-000000000002} を割り当てることができます。  
  
 <xref:System.Messaging.MessageQueue.Category%2A>を設定する必要はありません。 値として `null`を指定できます。  
  
 このプロパティを設定すると、メッセージキューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは変更の影響を受けます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.Category%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キュー カテゴリに無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接続キャッシュを消去します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>を呼び出すと、キャッシュに格納されている形式名が削除され、キャッシュに格納されて格納されているハンドルが閉じられます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> で割り当てられたすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要に応じて、共有リソースを含め、<xref:System.Messaging.MessageQueue>に関連付けられているすべてのリソースを解放 <xref:System.Messaging.MessageQueue.Close%2A> ます。 次のコードのように、これらのリソースが引き続き使用可能な場合は、システムによって自動的に再取得されます。たとえば、次のコードに示すように、<xref:System.Messaging.MessageQueue.Send%28System.Object%29> メソッドを呼び出す場合など C# です。  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 <xref:System.Messaging.MessageQueue.Close%2A>を呼び出すと、メッセージキューのキューに直接アクセスするすべての <xref:System.Messaging.MessageQueue> プロパティがクリアされます。<xref:System.Messaging.MessageQueue.Path%2A>、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>、<xref:System.Messaging.MessageQueue.Formatter%2A>、および <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> はすべてそのまま残ります。  
  
 <xref:System.Messaging.MessageQueue.Close%2A> は、共有されている可能性があるため、キューに対して読み取りおよび書き込みハンドルを必ず解放するわけではありません。 次のいずれかの手順を実行して、<xref:System.Messaging.MessageQueue.Close%2A> が読み取りハンドルと書き込みハンドルをキューに解放できるようにすることができます。  
  
-   排他アクセスで <xref:System.Messaging.MessageQueue> を作成します。 これを行うには、<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> または <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> コンストラクターを呼び出し、`sharedModeDenyReceive` パラメーターを `true`に設定します。  
  
-   接続キャッシュを無効にして <xref:System.Messaging.MessageQueue> を作成します。 これを行うには、<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> コンストラクターを呼び出し、`enableConnectionCache` パラメーターを `false`に設定します。  
  
-   接続キャッシュを無効にします。 これを行うには、<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> プロパティを `false`に設定します。  
  
 メッセージキューサーバーのキューを削除する前に、キューの <xref:System.Messaging.MessageQueue.Close%2A> を呼び出す必要があります。 そうしないと、キューに送信されたメッセージが例外をスローしたり、配信不能キューに表示されたりする可能性があります。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージキューのキューを閉じます。  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メッセージ キュー サーバーの指定したパスに新しいキューを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <summary>指定したパスに非トランザクション メッセージ キューのキューを作成します。</summary>
        <returns>新しいキューを表す <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、非トランザクションメッセージキューのキューを作成します。  
  
 アプリケーションで <xref:System.Messaging.MessageQueue> クラスの新しいインスタンスを作成し、既存のキューにバインドするには、<xref:System.Messaging.MessageQueue.%23ctor%2A> コンストラクターを使用します。 メッセージキューに新しいキューを作成するには、<xref:System.Messaging.MessageQueue.Create%28System.String%29>を呼び出します。  
  
 `path` パラメーターの構文は、次の表に示すように、参照するキューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 ローカルコンピューターには "." を使用します。 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A> プロパティを参照してください。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、パブリックキューと専用キューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したパスには既にキューが存在します。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <param name="transactional">トランザクション キューを作成する場合は <see langword="true" />。非トランザクション キューを作成する場合は <see langword="false" />。</param>
        <summary>指定したパスに、トランザクション メッセージ キューのキューまたは非トランザクション メッセージ キューのキューを作成します。</summary>
        <returns>新しいキューを表す <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、メッセージキューでトランザクションキューを作成できます。 非トランザクションキューを作成するには、`transactional` パラメーターを `false` に設定するか、<xref:System.Messaging.MessageQueue.Create%28System.String%29>の他のオーバーロードを呼び出します。  
  
 アプリケーションで <xref:System.Messaging.MessageQueue> クラスの新しいインスタンスを作成し、既存のキューにバインドするには、<xref:System.Messaging.MessageQueue.%23ctor%2A> コンストラクターを使用します。 メッセージキューに新しいキューを作成するには、<xref:System.Messaging.MessageQueue.Create%28System.String%29>を呼び出します。  
  
 `path` パラメーターの構文は、次の表に示すように、参照するキューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 ローカルコンピューターには "." を使用します。 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A> プロパティを参照してください。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、パブリックおよびプライベートのトランザクションキューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したパスには既にキューが存在します。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のメッセージ キューの新しい <see cref="T:System.Messaging.Cursor" /> を作成します。</summary>
        <returns>現在のメッセージ キューの新しい <see cref="T:System.Messaging.Cursor" />。 このカーソルは、キューのメッセージを読み取るときに、キュー内の特定の場所を維持するために使用されます。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューがメッセージ キューに作成された時刻と日付を取得します。</summary>
        <value>キューが作成された日付と時刻を表す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> は、<xref:System.Messaging.MessageQueue> インスタンスではなく、メッセージキューサーバーのキューを指します。  
  
 キューが存在する場合、このプロパティはキューが作成された時刻を表し、キューが存在するサーバーのローカル時刻に調整されます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.CreateTime%2A> プロパティの値を表示します。  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがメッセージをキューに送信するときに既定で使用されるメッセージ プロパティ値を取得または設定します。</summary>
        <value>アプリケーションが <see cref="T:System.Messaging.DefaultPropertiesToSend" /> インスタンス以外のオブジェクトをキューに送信するときに使用する既定のメッセージ キューのメッセージ プロパティ値を含む <see cref="T:System.Messaging.Message" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message> 型ではないオブジェクトをキューに送信すると、<xref:System.Messaging.MessageQueue> はそのオブジェクトをメッセージキューメッセージに挿入します。 その時点で、<xref:System.Messaging.MessageQueue> は、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティに指定したプロパティ値をメッセージに適用します。 逆に、<xref:System.Messaging.Message> をキューに送信すると、これらのプロパティは既にインスタンス自体に対して指定されているので、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> は <xref:System.Messaging.Message>に対して無視されます。  
  
 <xref:System.Messaging.MessageQueue> オブジェクトを使用してプロパティを設定しても、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> はキュー自体ではなく、キューに送信されるメッセージのプロパティを参照します。  
  
 次の表に、プロパティの既定値を示します。  
  
|プロパティ|既定値|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|ゼロ (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|長さ0のバイト配列|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空の文字列 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージの優先度を使用して、メッセージに対して送信する既定のプロパティを決定します。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">既定のプロパティをキューに設定できませんでした。いずれかのプロパティが無効であることが原因である可能性があります。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">削除するキューの場所。</param>
        <summary>メッセージ キュー サーバーのキューを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` パラメーターの構文は、キューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A> プロパティを参照してください。  
  
 または、<xref:System.Messaging.MessageQueue.FormatName%2A> または <xref:System.Messaging.MessageQueue.Label%2A> を使用して、キューのパスを記述することもできます。  
  
|リファレンス|構文|  
|---------------|------------|  
|書式名|FormatName: [*形式名*]|  
|Label|ラベル: [*ラベル*]|  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューのキューが存在する場合は削除します。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><paramref name="path" /> パラメーターの構文が無効です。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> に、メッセージ キューのキューからメッセージを受信する排他アクセス許可が与えられているかどうかを示す値を取得または設定します。</summary>
        <value>この <see cref="T:System.Messaging.MessageQueue" /> に、キューからメッセージを受信する排他アクセス許可が与えられている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定では、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> は、この <xref:System.Messaging.MessageQueue>によって参照されるキューの共有モードを指定します。 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> を `true` に設定して、指定した <xref:System.Messaging.MessageQueue.Path%2A>を使用してキューからメッセージをピークまたは受信するために、この <xref:System.Messaging.MessageQueue> のみにアクセス権を与える必要があることを示します。 別の <xref:System.Messaging.MessageQueue> または別のアプリケーションが同じキューリソースに関連付けられている場合、そのインスタンスまたはアプリケーションはメッセージをピークまたは受信できませんが、メッセージを送信することはできます。  
  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> が `false`場合、キューはメッセージの送信、ピーク、または受信のために複数のアプリケーションで使用できます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" />で使用されていたリソース (メモリを除く) を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> を使い終わったら、<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>を呼び出します。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>メソッドによって、<xref:System.Messaging.MessageQueue> は使用不可の状態になります。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>を呼び出した後、使用していたメモリがガベージコレクションによって回収されるように、<xref:System.Messaging.MessageQueue> へのすべての参照を解放する必要があります。  
  
 <xref:System.Messaging.MessageQueue>への最後の参照を解放する前に、<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> を呼び出す必要があります。 それ以外の場合、<xref:System.Messaging.MessageQueue> が使用しているリソースは、ガベージコレクションが <xref:System.Messaging.MessageQueue> オブジェクトのデストラクターを呼び出すまで解放されません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続のキャッシュをアプリケーションで維持するかどうかを示す値を取得または設定します。</summary>
        <value>接続キャッシュを作成し、使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続キャッシュとは、キューへの読み取りまたは書き込みハンドルを含む構造体への参照の一覧です。 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> が `true`場合、<xref:System.Messaging.MessageQueue> ではは、新しいハンドルを開くのではなく、<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、<xref:System.Messaging.MessageQueue.Peek%2A>、または <xref:System.Messaging.MessageQueue.Receive%2A>を呼び出すたびにキャッシュから処理されます。 これにより、パフォーマンスが向上します。 また、接続キャッシュを使用すると、ネットワークトポロジの変更によって <xref:System.Messaging.MessageQueue> が分離されます。  
  
 接続キャッシュがいっぱいになったときにキューへの新しい接続を作成すると、<xref:System.Messaging.MessageQueue> によって、最近アクセスした構造体が新しい接続で上書きされます。 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>を呼び出すことによって、キャッシュを完全に消去できます。たとえば、使用しているキューの形式名が変更され、以前の読み取りハンドルと書き込みハンドルが無効になっている場合などです。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューが非プライベート (暗号化されていない) メッセージだけを受け入れるかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Messaging.EncryptionRequired" /> 値のいずれか 1 つです。 既定では、 <see langword="None" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューに送信されるメッセージに暗号化が必要であることを指定すると、メッセージ本文のみが暗号化されます。 その他のメンバー (たとえば、<xref:System.Messaging.Message.Label%2A> と <xref:System.Messaging.Message.SenderId%2A> のプロパティ) は暗号化できません。  
  
 このプロパティを設定すると、メッセージキューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは変更の影響を受けます。  
  
 メッセージを暗号化すると、メッセージがプライベートになります。 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> プロパティを適切に設定することによって、キューの暗号化要件を `None`、`Body`、または `Optional` に指定できます。 メッセージの <xref:System.Messaging.Message.UseEncryption%2A> 設定は、キューの暗号化要件に対応している必要があります。 メッセージが暗号化されていないが、キューによって `Body`が指定されている場合、またはメッセージが暗号化されていてもキューで `None`が指定されている場合、メッセージはキューによって拒否されます。 送信元のアプリケーションがこのイベントで否定受信確認メッセージを要求した場合、メッセージキューは、送信元アプリケーションに対するメッセージの拒否を示します。 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> プロパティが `true`場合は、暗号化に失敗したメッセージが配信不能キューに送信されます。 それ以外の場合、メッセージは失われます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">完了する非同期のピーク操作を識別する <see cref="T:System.IAsyncResult" />。ここから最終結果が取得されます。</param>
        <summary>指定した非同期のピーク操作を完了します。</summary>
        <returns>完了した非同期操作に関連付けられた <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生すると、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> は <xref:System.Messaging.MessageQueue.BeginPeek%2A> 呼び出しによって開始された操作を完了します。 これを行うには、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> がメッセージをピークします。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ではタイムアウトを指定できます。これにより、キューにメッセージが表示される前にタイムアウトが発生した場合に、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生します。 キューにメッセージが到着せずにタイムアウトが発生すると、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> の後続の呼び出しで例外がスローされます。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> は、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生する原因となったメッセージを読み取るために使用されます。  
  
 メッセージを非同期にピークする場合は、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>を呼び出した後に <xref:System.Messaging.MessageQueue.BeginPeek%2A> をもう一度呼び出すことができます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、`MyPeekCompleted`という名前のイベントハンドラーを作成し、それを <xref:System.Messaging.MessageQueue.PeekCompleted> イベントハンドラーデリゲートにアタッチし、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を呼び出して、パス ".\myQueue" にあるキューで非同期のピーク操作を開始します。 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生すると、この例ではメッセージをピークし、その本文を画面に書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を再度呼び出して、新しい非同期ピーク操作を開始します。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> パラメーターの構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">完了する非同期の受信操作を識別する <see cref="T:System.IAsyncResult" />。ここから最終結果が取得されます。</param>
        <summary>指定した非同期の受信操作を完了します。</summary>
        <returns>完了した非同期操作に関連付けられた <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生すると、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> は <xref:System.Messaging.MessageQueue.BeginReceive%2A> 呼び出しによって開始された操作を完了します。 これを行うには、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> がメッセージを受信します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ではタイムアウトを指定できます。これにより、キューにメッセージが表示される前にタイムアウトが発生した場合に、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生します。 キューにメッセージが到着せずにタイムアウトが発生すると、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> の後続の呼び出しで例外がスローされます。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> は、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントの発生原因となったメッセージの読み取り (キューからの削除) に使用されます。  
  
 引き続き非同期的にメッセージを受信する場合は、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を呼び出した後に <xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出すことができます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期要求をチェーンします。 これは、"myQueue" という名前のローカルコンピューターにキューがあることを前提としています。 `Main` 関数は、`MyReceiveCompleted` ルーチンによって処理される非同期操作を開始します。 `MyReceiveCompleted` は、現在のメッセージを処理し、新しい非同期の受信操作を開始します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> パラメーターの構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">検索するキューの場所。</param>
        <summary>指定したパスにメッセージ キューのキューが存在するかどうかを判断します。</summary>
        <returns>指定したパスにキューが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> メソッドは、指定されたパスにメッセージキューのキューが存在するかどうかを判断します。 指定された形式名のキューが存在するかどうかを判断するためのメソッドが存在しません。 形式名の構文とその他のパス構文形式の詳細については、「<xref:System.Messaging.MessageQueue.Path%2A> プロパティ」を参照してください)。  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> は負荷の高い操作です。 アプリケーション内で必要な場合にのみ使用してください。  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> メソッドでは、<xref:System.Messaging.MessageQueue.FormatName%2A> プレフィックスはサポートされていません。  
  
 `path` パラメーターの構文は、次の表に示すように、キューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
  
 リモート専用キューの存在を確認するために <xref:System.Messaging.MessageQueue.Exists%28System.String%29> を呼び出すことはできません。  
  
 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A> プロパティを参照してください。  
  
 または、<xref:System.Messaging.MessageQueue.Label%2A> を使用してキューのパスを記述することもできます。  
  
|リファレンス|構文|  
|---------------|------------|  
|Label|ラベル: [`label`]|  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューのキューが存在するかどうかを確認してから削除します。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。  
  
または 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> メソッドがリモート プライベート キューで呼び出されています。</exception>
        <exception cref="T:System.InvalidOperationException">キューの存在を確認するときに、アプリケーションが書式名構文を使用しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの作成時にメッセージ キューが生成した一意のキュー名を取得します。</summary>
        <value>ネットワークで一意なキューの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> プロパティには、キューの形式名が格納されます。 メッセージキューは、形式名を使用して、開くキューとアクセス方法を識別します。 キューの特性のほとんどと異なり、形式名はメッセージキューアプリケーションキュープロパティではないため、メッセージキュー管理ツールを使用してアクセスすることはできません。 形式名は、キューの一意の名前です。キューを作成するとき、または後でアプリケーションが生成するときに、メッセージキューによって生成されます。  
  
 キューに対して読み取りまたは書き込みを行うときに format name 構文を使用するのではなく、パス名の構文 (`myComputer\myQueue`など) を使用してパスを指定した場合、プライマリドメインコントローラー (Active Directory を使用) は、キューにアクセスする前に <xref:System.Messaging.MessageQueue.Path%2A> を関連付けられた <xref:System.Messaging.MessageQueue.FormatName%2A> に変換します。 アプリケーションがオフラインで作業している場合は、形式名の構文を使用する必要があります。そうしないと、プライマリドメインコントローラーはパス変換を実行できなくなります。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.FormatName%2A> プロパティの値を表示します。  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> が設定されていません。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューから読み取られるメッセージまたはキューに書き込まれるメッセージの本文とオブジェクトとの間でシリアル化または逆シリアル化を行うために使用する書式指定子を取得または設定します。</summary>
        <value>メッセージ本文に書き込むストリーム、またはメッセージ本文から読み取るストリームを生成する <see cref="T:System.Messaging.IMessageFormatter" />。 既定では、 <see cref="T:System.Messaging.XmlMessageFormatter" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティには、アプリケーションがキューに対して読み取りまたは書き込みを行うときにメッセージを変換するフォーマッタオブジェクトのインスタンスが含まれています。  
  
 アプリケーションがメッセージをキューに送信すると、フォーマッタはオブジェクトをストリームにシリアル化し、メッセージ本文に挿入します。 フォーマッタは、キューから読み取るときに、メッセージデータを <xref:System.Messaging.Message>の <xref:System.Messaging.Message.Body%2A> プロパティに逆シリアル化します。  
  
 <xref:System.Messaging.XmlMessageFormatter> は疎結合であるため、この形式を使用する場合、送信側と受信側で同じオブジェクト型を持つ必要はありません。 <xref:System.Messaging.ActiveXMessageFormatter> と <xref:System.Messaging.BinaryMessageFormatter> は、データをバイナリ表現にシリアル化します。 <xref:System.Messaging.ActiveXMessageFormatter> は、COM コンポーネントを送信または受信するときに使用されます。  
  
 <xref:System.Messaging.BinaryMessageFormatter> と <xref:System.Messaging.ActiveXMessageFormatter> は <xref:System.Messaging.XmlMessageFormatter>よりも高速なスループットを提供します。 <xref:System.Messaging.ActiveXMessageFormatter> では、Visual Basic 6.0 メッセージキューアプリケーションとの相互運用が可能です。  
  
 アプリケーションがメッセージをキューに送信すると、<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> は、既定のメッセージプロパティ <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>を使用するメッセージにのみ適用されます。 <xref:System.Messaging.Message> をキューに送信する場合、メッセージキューは、<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> プロパティで定義されているフォーマッタを使用して、代わりに本文をシリアル化します。  
  
 <xref:System.Messaging.MessageQueue> クラスは、キューからメッセージを受信またはピークするときに常に <xref:System.Messaging.Message> を使用します。 メッセージは、<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> プロパティを使用して逆シリアル化されます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.BinaryMessageFormatter>を使用してメッセージ本文を書式設定する方法を示しています。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 次のコード例は、<xref:System.Messaging.XmlMessageFormatter>を使用してメッセージ本文を書式設定する方法を示しています。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューにあるすべてのメッセージを返します。</summary>
        <returns>キューにあるすべてのメッセージを表す <see cref="T:System.Messaging.Message" /> 型の配列。配列の順序は、メッセージがメッセージ キューのキューに存在する順序と同じです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> は、キュー内のメッセージの静的スナップショットを返します。これらのメッセージへの動的リンクは返しません。 したがって、配列を使用してキュー内のメッセージを変更することはできません。 キューとの動的な対話 (メッセージを削除する機能など) が必要な場合は、<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> メソッドを呼び出します。このメソッドは、キュー内のメッセージの動的な一覧を返します。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> はメソッドの呼び出し時にキュー内のメッセージのコピーを返すので、配列にはキューに到着した新しいメッセージや、キューから削除されたメッセージは反映されません。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> は、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> プロパティによって除外されていないプロパティだけを取得します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetAllMessages%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューに格納されているメッセージを列挙します。 <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> は使用されなくなりました。 代わりに <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> を使用します。</summary>
        <returns>キュー内のメッセージへの動的な接続を提供する <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetEnumerator%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">キューを含むコンピューターの名前。先頭に 2 つの円記号 (\\\\) を付けません。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューが存在するコンピューターの ID を取得します。</summary>
        <returns>キューが存在するコンピューターの一意の ID を表す <see cref="T:System.Guid" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンピューターの識別子は、コンピューターのジャーナルを読み取り、セキュリティ証明書を設定するために、2つの目的で使用できます。 ただし、オフラインで作業している場合は、アプリケーションがドメインコントローラー上のディレクトリサービスにアクセスできる必要があるため、リモートコンピューターの <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> を呼び出すことはできません。  
  
 コンピューター id (またはコンピューター識別子) は、コンピューターが企業に追加されるときにメッセージキューによって作成される <xref:System.Guid> です。 メッセージキューは、コンピューター識別子と `Machine` および `Journal` キーワードを組み合わせて、`Machine=<computeridentifier>;Journal`という構文を持つマシンジャーナルの形式名を作成します。 ジャーナルキューとも呼ばれるコンピュータージャーナルは、<xref:System.Messaging.MessageQueue.UseJournalQueue%2A> プロパティが `true`場合に、アプリケーションによって生成されるメッセージのコピーを格納するシステムキューです。  
  
 ジャーナルのこの構文は、キューの形式名を構築する場合にのみ有効です。 パス名の構文は `Journal$`\\`MachineName`ます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">コンピューターの ID を取得できません。オフラインで作業しているなど、ディレクトリ サービスが利用できないことが原因である可能性があります。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューにあるすべてのメッセージに対して列挙子オブジェクトを作成します。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> は使用されなくなりました。 代わりに <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> を使用します。</summary>
        <returns>キューに含まれるメッセージを保持する <see cref="T:System.Messaging.MessageEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> は、キュー内のすべてのメッセージの動的な一覧を作成します。 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> が返す <xref:System.Messaging.MessageEnumerator> に対して <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> を呼び出すことによって、列挙子の現在位置にあるメッセージをキューから削除できます。  
  
 カーソルはキュー内のメッセージの動的な一覧に関連付けられているので、メッセージが現在のカーソル位置を超えている場合は、キュー内のメッセージに加えた変更が列挙体に反映されます。 たとえば、列挙子は、カーソルの現在位置を超えている優先順位の低いメッセージに自動的にアクセスできますが、その位置の前に挿入される優先順位の高いメッセージは自動的には表示されません。 ただし、列挙体をリセットして、<xref:System.Messaging.MessageEnumerator>の <xref:System.Messaging.MessageEnumerator.Reset%2A> を呼び出すことによって、リストの先頭にカーソルを戻すことができます。  
  
 列挙内のメッセージの順序は、キュー内のメッセージの順序に反映されます。そのため、優先順位の低いメッセージは、優先順位の低い方の前に表示されます。  
  
 キューに動的に接続するのではなく、キュー内のメッセージの静的スナップショットが必要な場合は、<xref:System.Messaging.MessageQueue.GetAllMessages%2A>を呼び出します。 このメソッドは <xref:System.Messaging.Message> オブジェクトの配列を返します。これは、メソッドが呼び出されたときのメッセージを表します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キュー内のメッセージの動的な一覧を取得し、<xref:System.Messaging.Message.Priority%2A> プロパティが <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>に設定されているすべてのメッセージをカウントします。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューにあるすべてのメッセージに対して列挙子オブジェクトを作成します。</summary>
        <returns>キューに含まれるメッセージを保持する <see cref="T:System.Messaging.MessageEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> は、キュー内のすべてのメッセージの動的な一覧を作成します。 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> が返す <xref:System.Messaging.MessageEnumerator> に対して <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> を呼び出すことによって、列挙子の現在位置にあるメッセージをキューから削除できます。  
  
 カーソルはキュー内のメッセージの動的な一覧に関連付けられているので、メッセージが現在のカーソル位置を超えている場合は、キュー内のメッセージに加えた変更が列挙体に反映されます。 たとえば、列挙子は、カーソルの現在位置を超えている優先順位の低いメッセージに自動的にアクセスできますが、その位置の前に挿入される優先順位の高いメッセージは自動的には表示されません。 ただし、列挙体をリセットして、<xref:System.Messaging.MessageEnumerator>の <xref:System.Messaging.MessageEnumerator.Reset%2A> を呼び出すことによって、リストの先頭にカーソルを戻すことができます。  
  
 列挙内のメッセージの順序は、キュー内のメッセージの順序に反映されます。そのため、優先順位の低いメッセージは、優先順位の低い方の前に表示されます。  
  
 キューに動的に接続するのではなく、キュー内のメッセージの静的スナップショットが必要な場合は、<xref:System.Messaging.MessageQueue.GetAllMessages%2A>を呼び出します。 このメソッドは <xref:System.Messaging.Message> オブジェクトの配列を返します。これは、メソッドが呼び出されたときのメッセージを表します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>列挙子オブジェクトを作成し、ネットワーク上のパブリック キューの動的リストを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソル セマンティクスをサポートします。</summary>
        <returns>ネットワーク上のすべてのパブリックメッセージ キューの動的リストを作成する <see cref="T:System.Messaging.MessageQueueEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> のオーバーロードは、ネットワーク上のすべてのパブリックキューの列挙体を返します。  
  
 カーソルは動的なリストに関連付けられているので、列挙は、カーソルの現在位置を超えて削除または追加されたキューのキューリストに加えた変更を反映します。 カーソルの現在位置より前にあるキューの追加または削除は反映されません。 たとえば、列挙子はカーソル位置を超えて追加されたキューに自動的にアクセスできますが、その位置の前には挿入されません。 ただし、列挙体をリセットして、<xref:System.Messaging.MessageQueueEnumerator>の <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> を呼び出すことによって、リストの先頭にカーソルを戻すことができます。  
  
 ネットワークにキューの順序が定義されていません。 列挙子は、コンピューター、ラベル、パブリックまたはプライベートの状態、その他のアクセス可能な条件などによって並べ替えられません。  
  
 動的に接続するのではなく、ネットワーク上のキューの静的スナップショットが必要な場合は、<xref:System.Messaging.MessageQueue.GetPublicQueues%2A> または <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>を呼び出します。 これらの2つのメソッドは <xref:System.Messaging.MessageQueue> オブジェクトの配列を返します。これは、メソッドが呼び出されたときのキューを表します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、ネットワーク内のすべてのメッセージキューを反復処理し、各キューのパスを調べます。 最後に、ネットワーク上のパブリックキューの数が表示されます。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">利用できるメッセージ キューのフィルター処理に使用する基準が格納されている <see cref="T:System.Messaging.MessageQueueCriteria" />。</param>
        <summary>指定した基準を満たすネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソル セマンティクスをサポートします。</summary>
        <returns><paramref name="criteria" /> パラメーターで指定された制約を満たすネットワーク上のパブリックメッセージ キューの動的リストを作成する <see cref="T:System.Messaging.MessageQueueEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> のオーバーロードは、アプリケーション条件で定義された条件を満たすネットワーク上のすべてのパブリックキューの一覧を返します。 キューの作成や変更時間、コンピューター名、ラベル、カテゴリ、またはこれらの組み合わせなど、含める条件を指定できます。  
  
 カーソルは動的な一覧に関連付けられているので、列挙体には、カーソルの現在位置を超えて発生するキューに対して行った変更が反映されます。 カーソルの現在位置より前にあるキューへの変更は反映されません。 たとえば、列挙子はカーソル位置を超えて追加されたキューに自動的にアクセスできますが、その位置の前には挿入されません。 ただし、列挙体をリセットして、<xref:System.Messaging.MessageQueueEnumerator>の <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> を呼び出すことによって、リストの先頭にカーソルを戻すことができます。  
  
 ネットワークにキューの順序が定義されていません。 列挙子は、コンピューター、ラベル、パブリックまたはプライベートの状態、その他のアクセス可能な条件などによって並べ替えられません。  
  
 動的に接続するのではなく、ネットワーク上のキューの静的スナップショットが必要な場合は、<xref:System.Messaging.MessageQueue.GetPublicQueues%2A> の条件を指定するか <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>を呼び出します。 これらの2つのメソッドは <xref:System.Messaging.MessageQueue> オブジェクトの配列を返します。これは、メソッドが呼び出されたときのキューを表します。 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>、または <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> を呼び出すと、それぞれ <xref:System.Messaging.MessageQueue.Category%2A>、<xref:System.Messaging.MessageQueue.Label%2A>、および <xref:System.Messaging.MessageQueue.MachineName%2A>のフィルター条件を使用して <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> を呼び出す場合と同じ結果が得られます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューを反復処理し、最後の1日に作成され、コンピューター "MyComputer" に存在する各キューのパスを表示します。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プライベート キューを取得するコンピューター。</param>
        <summary>指定したコンピューターにあるすべてのプライベート キューを取得します。</summary>
        <returns>取得されたプライベート キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 指定したコンピューター上のキューの静的スナップショットを取得します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューのリストを取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ネットワーク上のすべてのパブリックキューの完全な一覧が必要な場合は、このオーバーロードを使用します。 <xref:System.Messaging.MessageQueue.MachineName%2A>、<xref:System.Messaging.MessageQueue.Category%2A>、最終更新時刻など、特定の条件によってリストを制限する場合は、このメソッドの別のオーバーロードを使用します。 (または、<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>、<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>を使用することもできます)。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> は、キューの静的スナップショットを取得します。 キューの動的リストを操作するには、<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>を使用します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューのリストを取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">キューのフィルター処理に使用する基準が格納されている <see cref="T:System.Messaging.MessageQueueCriteria" />。</param>
        <summary>指定した基準を満たすネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ネットワーク上のすべてのパブリックキューをラベル、カテゴリ、またはコンピューター名でフィルター処理する場合、<xref:System.Messaging.MessageQueue> クラスには、その機能 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>、<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、および <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>) を提供する特定のメソッドが含まれています。 このオーバーロードを使用して、これらの条件のうちの1つ以上を満たすネットワーク上のすべてのパブリックキューの一覧を取得します (ラベルとカテゴリの両方を指定する場合など)。 <xref:System.Messaging.MessageQueue.Label%2A>、<xref:System.Messaging.MessageQueue.Category%2A>、および <xref:System.Messaging.MessageQueue.MachineName%2A>以外のメッセージ条件によってフィルター処理することもできます。 たとえば、このオーバーロードを使用して、キューの最終更新時刻でフィルター処理します。 <xref:System.Messaging.MessageQueueCriteria> クラスの新しいインスタンスを作成し、インスタンスの適切なプロパティを設定して、そのインスタンスを `criteria` パラメーターとして渡すだけです。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> は、キューの静的スナップショットを取得します。 キューの動的リストを操作するには、<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>を使用します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューのリストを取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">取得するキューのセットをグループ化する <see cref="T:System.Guid" />。</param>
        <summary>指定したカテゴリに属するネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、パブリックキューをカテゴリ別にフィルター処理します。 <xref:System.Messaging.MessageQueue.Category%2A> プロパティは、特定のキューの "メッセージキューの種類 ID" プロパティ (読み取り/書き込み) へのアクセスを提供します。 <xref:System.Guid.NewGuid%2A> を使用して、すべての <xref:System.Guid> 値で一意のカテゴリ値を作成することもできますが、必須ではありません。 カテゴリ値は、他のすべての <xref:System.Guid> 値からではなく、他のカテゴリからのみ一意である必要があります。 たとえば、{00000000-0000-0000-0000-000000000001} を1つのキューセットの <xref:System.Messaging.MessageQueue.Category%2A> として、別のセットの <xref:System.Messaging.MessageQueue.Category%2A> として {00000000-0000-0000-0000-000000000002} を割り当てることができます。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> は、キューの静的スナップショットを取得します。 キューの動的リストを操作するには、<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>を使用します。 メソッドに渡す <xref:System.Messaging.MessageQueueCriteria> の一部として、カテゴリを指定できます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューのリストを取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">取得するキューのセットをグループ化するラベル。</param>
        <summary>指定したラベルが設定されているネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、パブリックキューをラベルでフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> は、キューの静的スナップショットを取得します。 キューの動的リストを操作するには、<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>を使用します。 メソッドに渡す <xref:System.Messaging.MessageQueueCriteria> の一部として、ラベルを指定できます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューのリストを取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">取得するパブリック キューのセットが含まれているコンピューターの名前。</param>
        <summary>指定したコンピューターにあるすべてのパブリック キューを取得します。</summary>
        <returns>コンピューターのパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、コンピューター別にパブリックキューをフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> は、キューの静的スナップショットを取得します。 キューの動的リストを操作するには、<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>を使用します。 メソッドに渡す <xref:System.Messaging.MessageQueueCriteria> の一部として、コンピューター名を指定できます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカルコンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューのリストを取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この呼び出しの時点で現在のユーザーが MSMQ によって関連付けられているセキュリティ コンテキスト (スレッド ID) を取得します。</summary>
        <returns>セキュリティ コンテキストを格納している <see cref="T:System.Messaging.SecurityContext" /> オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの一意なメッセージ キュー ID を取得します。</summary>
        <value>メッセージ キュー アプリケーションが生成したメッセージ ID を表す <see cref="P:System.Messaging.MessageQueue.Id" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージキューは、キューの作成時に <xref:System.Messaging.MessageQueue.Id%2A> プロパティを設定します。 このプロパティは、パブリックキューでのみ使用できます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.Id%2A> プロパティの値を表示します。  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューにサイズ制限が存在しないことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> または <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>を設定するときによく使用されます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.InfiniteQueueSize> メンバーの使用方法を示しています。  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージをピークまたは受信するメソッドにタイムアウトが存在しないことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> では、同期と非同期の2種類のメッセージ取得がサポートされています。 同期メソッドである <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.Receive%2A>により、プロセススレッドは、新しいメッセージがキューに到着するまで、指定された時間間隔待機します。 指定した時間間隔が <xref:System.Messaging.MessageQueue.InfiniteTimeout>場合、新しいメッセージが使用可能になるまで、プロセススレッドはブロックされたままになります。 一方、<xref:System.Messaging.MessageQueue.BeginPeek%2A> と <xref:System.Messaging.MessageQueue.BeginReceive%2A> (非同期メソッド) を使用すると、メッセージがキューに到着するまで、メインアプリケーションタスクが別のスレッドで続行されるようにすることができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.InfiniteTimeout> メンバーの使用方法を示しています。  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの説明を取得または設定します。</summary>
        <value>メッセージ キューのラベル。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージキューラベルの最大長は124文字です。  
  
 <xref:System.Messaging.MessageQueue.Label%2A> プロパティは、すべてのキューで一意である必要はありません。 ただし、複数のキューが同じ <xref:System.Messaging.MessageQueue.Label%2A>を共有している場合は、<xref:System.Messaging.MessageQueue.Send%28System.Object%29> メソッドを使用して、そのすべてにメッセージをブロードキャストすることはできません。 メッセージを送信するときに <xref:System.Messaging.MessageQueue.Path%2A> プロパティのラベル構文を使用すると、<xref:System.Messaging.MessageQueue.Label%2A> が一意でない場合に例外がスローされます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.Label%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ラベルが無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのプロパティが最後に変更された時刻を取得します。</summary>
        <value>キューのプロパティが最後に変更された時刻を示す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最後の変更時刻には、キューが作成された日時と、メッセージキューのキューを変更する <xref:System.Messaging.MessageQueue> プロパティ (<xref:System.Messaging.MessageQueue.BasePriority%2A>など) が含まれます。 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> プロパティの値は、ローカルコンピューターのシステム時刻を表します。  
  
 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> プロパティを取得する前に、<xref:System.Messaging.MessageQueue.Refresh%2A> を呼び出す必要があります。それ以外の場合、この <xref:System.Messaging.MessageQueue> に関連付けられている変更時間は最新ではない可能性があります。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.LastModifyTime%2A> プロパティの値を表示します。  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューのキューが存在するコンピューターの名前を取得または設定します。</summary>
        <value>キューが存在するコンピューターの名前。 メッセージ キューの既定値は、ローカル コンピューターを表す "." です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A> は、キュー <xref:System.Messaging.MessageQueue.Path%2A>のフレンドリ名構文の整数部分です。 次の表は、表示名を使用してキューのパスを識別する場合に、指定した種類のキューに使用する構文を示しています。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|マシンジャーナルキュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピュータートランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>を指定する場合は、ローカルコンピューターに "." を使用します。 このプロパティでは、コンピューター名のみが認識されます (たとえば、`Server0`)。 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティは、IP アドレス形式をサポートしていません。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>の観点から <xref:System.Messaging.MessageQueue.Path%2A> を定義すると、パス変換にドメインコントローラーが必要になるため、アプリケーションはオフラインで作業しているときに例外をスローします。 そのため、オフラインで作業する場合は、<xref:System.Messaging.MessageQueue.Path%2A> 構文に <xref:System.Messaging.MessageQueue.FormatName%2A> を使用する必要があります。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、<xref:System.Messaging.MessageQueue.Path%2A>、および <xref:System.Messaging.MessageQueue.QueueName%2A> の各プロパティが関連付けられています。 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティを変更すると、<xref:System.Messaging.MessageQueue.Path%2A> プロパティが変更されます。 これは、新しい <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A>から構築されています。 <xref:System.Messaging.MessageQueue.Path%2A> を変更する (たとえば、形式名の構文を使用する) と、<xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A> のプロパティが新しいキューを参照するようにリセットされます。 <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティが空の場合、<xref:System.Messaging.MessageQueue.Path%2A> は指定したコンピューターのジャーナルキューに設定されます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.MachineName" /> は <see langword="null" /> です。        
または

コンピューター名が無効です。構文が間違っているためと考えられます。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>履歴キューの最大サイズを取得または設定します。</summary>
        <value>履歴キューの最大サイズ。単位は KB です。 メッセージ キューの既定値は、制限なしです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> を使用すると、メッセージキュージャーナルの記憶域の制限にアクセスできます。 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> が `true`場合にのみ関連します。 このプロパティを設定すると、メッセージキューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは変更の影響を受けます。  
  
 メッセージをジャーナルまたは配信不能キューに格納する場合は、不要になったメッセージを削除するために、定期的にキューをクリアする必要があります。 このようなキュー内のメッセージは、キューが存在するコンピューターのメッセージクォータにカウントされます。 (管理者は、コンピューターのクォータを設定します)。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大履歴キューサイズに無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの最大サイズを取得または設定します。</summary>
        <value>キューの最大サイズ。単位は KB です。 メッセージ キューの既定値は、制限なしです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> では、管理者が定義したコンピューターのメッセージクォータとは別の、メッセージキューメッセージの記憶域の制限にアクセスできます。 メッセージクォータの詳細については、「<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>」を参照してください。  
  
 このプロパティを設定すると、メッセージキューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは変更の影響を受けます。  
  
 最大キューサイズまたはコンピューターメッセージクォータを超える試行が行われた場合、メッセージが失われる可能性があります。 キュークォータに達すると、メッセージキューは、送信元アプリケーションの管理キューに、否定受信確認メッセージを返すことによってキューがいっぱいであることを通知します。 キュー内のメッセージの合計サイズが制限を下回るまで、メッセージキューは否定受信確認を送信し続けます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大キューサイズに負の値が含まれています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの受信またはピークに使用するプロパティ フィルターを取得または設定します。</summary>
        <value>メッセージごとに受信またはピークするプロパティのセットをフィルター処理するためにキューが使用する <see cref="T:System.Messaging.MessagePropertyFilter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィルターは、<xref:System.Messaging.MessageQueue> が受信またはピークするメッセージプロパティを制限するブール値のセットです。 <xref:System.Messaging.MessageQueue> は、サーバーキューからメッセージを受信またはピークするときに、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 値が `true`されているプロパティのみを取得します。  
  
 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> プロパティの初期プロパティ値を次に示します。 これらの設定は、<xref:System.Messaging.MessagePropertyFilter>で <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> を呼び出すことと同じです。  
  
|プロパティ|既定値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> を使用して、受信したメッセージプロパティを制限します。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">フィルターが <see langword="null" /> です。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 キューに関連付けられているマルチキャスト アドレスを取得または設定します。</summary>
        <value>有効なマルチキャスト アドレス (次に示す形式) を格納している <see cref="T:System.String" />、またはキューがマルチキャスト アドレスに関連付けられていないことを示す <see langword="null" />。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> プロパティは、メッセージを送信するときに使用できるマルチキャストアドレスに非トランザクションキューを関連付けるために使用されます。 トランザクションキューをマルチキャストアドレスに関連付けることはできません。 送信元アプリケーションがマルチキャストアドレスにメッセージを送信すると、メッセージキューはそのアドレスに関連付けられているすべてのキューにメッセージのコピーを送信します。  
  
 IP マルチキャストアドレスは、クラス D の範囲の 224.0.0.0 ~ 239.255.255.255 でなければなりません。これは、最初の4つの上位ビットを1110に設定した場合に対応します。 ただし、この範囲のアドレスの特定の範囲のみが予約されていないため、マルチキャストメッセージの送信に使用できません。 予約されているマルチキャストアドレスの最新の一覧については、[インターネットアドレス指定機関 (IANA) のインターネットマルチキャストアドレス](https://go.microsoft.com/fwlink/?linkid=3859)に関する Web ページを参照してください。 ポート番号に制限はありません。  
  
 複数のソースコンピューターがマルチキャストメッセージを送信しているときに、特定のキューで1つの送信元コンピューターからのメッセージのみを受信する場合は、各ソースコンピューターで、IP アドレスとポート番号の異なる組み合わせにメッセージを送信する必要があります。  
  
 マルチキャストアドレスからキューの関連付けを解除するには、<xref:System.Messaging.MessageQueue.MulticastAddress%2A> プロパティを長さ0の文字列に設定します。 `null`に設定しないでください。これにより、<xref:System.ArgumentNullException>が発生します。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのパスを取得または設定します。 <see cref="P:System.Messaging.MessageQueue.Path" /> を設定すると、<see cref="T:System.Messaging.MessageQueue" /> は新しいキューを指します。</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> が参照するキュー。 既定値は、使用する <see cref="M:System.Messaging.MessageQueue.#ctor" /> コンストラクターによって異なり、<see langword="null" /> かコンストラクターの <paramref name="path" /> パラメーターで指定された値になります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Path%2A> プロパティの構文は、次の表に示すように、が指すキューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|マシンジャーナルキュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピュータートランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 "." を使用してローカルコンピューターを表します。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、<xref:System.Messaging.MessageQueue.Path%2A>、および <xref:System.Messaging.MessageQueue.QueueName%2A> の各プロパティが関連付けられています。 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティを変更すると、<xref:System.Messaging.MessageQueue.Path%2A> プロパティが変更されます。 これは、新しい <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A>から構築されています。 <xref:System.Messaging.MessageQueue.Path%2A> を変更する (たとえば、形式名の構文を使用する) と、<xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A> のプロパティが新しいキューを参照するようにリセットされます。  
  
 または、次の表に示すように、<xref:System.Messaging.MessageQueue.FormatName%2A> または <xref:System.Messaging.MessageQueue.Label%2A> を使用してキューのパスを記述することもできます。  
  
|リファレンス|構文|例|  
|---------------|------------|-------------|  
|書式名|`FormatName:` [*形式名*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Label|`Label:` [*ラベル*]|`Label:` TheLabel|  
  
 メッセージを送信するときに <xref:System.Messaging.MessageQueue.Path%2A> プロパティのラベル構文を使用すると、<xref:System.Messaging.MessageQueue.Label%2A> が一意でない場合に例外がスローされます。  
  
 オフラインで作業するには、最初のテーブルのフレンドリ名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合は、(Active Directory が存在する) プライマリドメインコントローラーが形式名へのパスを解決できないため、例外がスローされます。  
  
 新しいパスを設定すると、メッセージキューが閉じられ、すべてのハンドルが解放されます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|はい|  
  
> [!NOTE]
>  ワークグループモードでは、専用キューのみを使用できます。 パスは、プライベートキューの構文 `MachineName`\\`Private$`\\`QueueName`を使用して指定します。  
  
   
  
## Examples  
 次のコード例では、さまざまなパス名の構文型を使用して、新しい <xref:System.Messaging.MessageQueue> オブジェクトを作成します。 いずれの場合も、コンストラクターで定義されているパスを持つキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが無効です。構文が無効であるためと考えられます。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <summary>キューにある最初のメッセージのコピーを返します。メッセージはキューから削除されません。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューにある最初のメッセージを、削除せずに返します (ピークします)。 <see cref="M:System.Messaging.MessageQueue.Peek" /> メソッドは同期メソッドであるため、メッセージが利用可能になるまで、現在のスレッドをブロックします。</summary>
        <returns>キューの最初のメッセージを表す <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークしたり、メッセージがキューに存在するまで待機したりするには、このオーバーロードを使用します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キューから最初のメッセージを読み取りますが、削除しません。 したがって、キューにある優先順位の高いメッセージが受信されない限り、<xref:System.Messaging.MessageQueue.Peek%2A> を繰り返し呼び出すと、同じメッセージが返されます。 一方、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューから最初のメッセージを読み取り、削除します。 このため、<xref:System.Messaging.MessageQueue.Receive%2A>を繰り返し呼び出すと、異なるメッセージが返されます。  
  
 メッセージキューは、優先度と到着時刻に従ってキュー内のメッセージを並べ替えます。 新しいメッセージは、優先順位が高い場合にのみ、古いものよりも前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 このオーバーロードではタイムアウトが指定されていないため、アプリケーションは無制限に待機する場合があります。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。 または、タイムアウトを指定する <xref:System.Messaging.MessageQueue.Peek%2A> のオーバーロードを使用して、メッセージがキューに到着するまでのタイムアウトを指定することもできます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次の例では、キューに対して <xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。  
  
 最初の例では、アプリケーションはメッセージがキューで使用可能になるまで待機します。 最初の例では、受信したメッセージにアクセスしないことに注意してください。メッセージが到着するまで、処理を一時停止するだけです。 メッセージが既にキューに存在する場合は、直ちに返されます。  
  
 2番目の例では、アプリケーションによって定義された `Order` クラスを含むメッセージがキューに送信され、キューからピークされます。  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">キューにメッセージが格納されるまで待機する最大時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューにある最初のメッセージを、削除せずに返します (ピークします)。 <see cref="M:System.Messaging.MessageQueue.Peek" /> メソッドは同期メソッドであるため、メッセージが利用可能になるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns>キューの最初のメッセージを表す <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークする場合、またはキューにメッセージが存在するまで指定した期間待機する場合は、このオーバーロードを使用します。 メッセージが既にキューに存在する場合、メソッドは直ちにを返します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キューから最初のメッセージを読み取りますが、削除しません。 したがって、キューにある優先順位の高いメッセージが受信されない限り、<xref:System.Messaging.MessageQueue.Peek%2A> を繰り返し呼び出すと、同じメッセージが返されます。 一方、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューから最初のメッセージを読み取り、削除します。 このため、<xref:System.Messaging.MessageQueue.Receive%2A>を繰り返し呼び出すと、異なるメッセージが返されます。  
  
 メッセージキューは、優先度と到着時刻に従ってキュー内のメッセージを並べ替えます。 新しいメッセージは、優先順位が高い場合にのみ、古いものよりも前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 スレッドは、指定された期間にわたってブロックされるか、または <xref:System.Messaging.MessageQueue.InfiniteTimeout>を指定した場合は無期限にブロックされます。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを0のタイムアウトと共に使用して、キューが空かどうかを確認します。  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan, cursor As Cursor, action As PeekAction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">キューにメッセージが格納されるまで待機する最大時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 値のいずれか 1 つです。 キュー内の現在のメッセージと次のメッセージのどちらをピークするかを示します。</param>
        <summary>指定されたカーソルを使用して、キュー内の現在のメッセージまたは次のメッセージを、削除せずに返します (ピークします)。 <see cref="M:System.Messaging.MessageQueue.Peek" /> メソッドは同期メソッドであるため、メッセージが利用可能になるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns>キュー内のメッセージを表す <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークする場合、またはキューにメッセージが存在するまで指定した期間待機する場合は、このオーバーロードを使用します。 メッセージが既にキューに存在する場合、メソッドは直ちにを返します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キューからメッセージを読み取りますが、削除しません。 一方、<xref:System.Messaging.MessageQueue.Receive%2A> メソッドでは、キューからメッセージを読み取り、削除することができます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 スレッドは、指定された期間にわたってブロックされるか、または <xref:System.Messaging.MessageQueue.InfiniteTimeout>を指定した場合は無期限にブロックされます。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" /> パラメーターに <see langword="PeekAction.Current" /> または <see langword="PeekAction.Next" /> 以外の値が指定されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。 <paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> より小さい値か、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> より大きい値である可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した相関 ID と一致するメッセージをピークします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">ピークするメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>指定した相関 ID と一致するメッセージをピークします。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照されるキューを検索します。 `correlationID` パラメーターと一致するメッセージが見つからない場合は、例外がスローされます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キュー内のメッセージをピークすることができます。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用して、一意の識別子を指定することによってメッセージを取得します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューとの間で注文を含むメッセージを送受信します。 これは、元のメッセージがキューに到達するか、キューから取得されるときに肯定受信確認を要求します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">ピークするメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定した相関 ID と一致するメッセージをピークします。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトが経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照されるキューを検索します。 `correlationID` パラメーターと一致するメッセージが見つからず、`timeout` パラメーターで指定された期間内に新しいメッセージがキューに到着しなかった場合は、例外がスローされます。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.CorrelationId%2A> を調べて、`correlationId` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.CorrelationId%2A> が `correlationId` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キュー内のメッセージをピークすることができます。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用して、一意の識別子を指定することによってメッセージを取得します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前にメッセージが到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したメッセージ ID を持つメッセージのコピーを返します。メッセージはキューから削除されません。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">ピークするメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>メッセージ ID が <paramref name="id" /> パラメーターと一致するメッセージをピークします。</summary>
        <returns><paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> を使用すると、既知のメッセージ識別子を持つメッセージをキューから削除せずに読み取ることができます。 メッセージの識別子はメッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターと一致するメッセージがキューに1つだけ存在します。 現在、キューにメッセージが含まれていない場合、このオーバーロードは例外をスローします。  
  
 2つの追加のメソッドを使用すると、キュー内のメッセージをピークすることができます。 <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キュー内の最初のメッセージを返します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> は、メッセージがキューに送信された結果として作成された、受信確認、レポート、またはアプリケーションで生成された応答メッセージを返します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージが存在しません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">ピークするメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>メッセージ ID が <paramref name="id" /> パラメーターと一致するメッセージをピークします。 メッセージがキューに出現するか、タイムアウトが発生するまで待機します。</summary>
        <returns><paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> を使用すると、既知のメッセージ識別子を持つメッセージをキューから削除せずに読み取ることができます。 メッセージの識別子はメッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターと一致するメッセージがキューに1つだけ存在します。 現在キューにメッセージが含まれておらず、タイムアウトが発生する前に新しいメッセージが到着しなかった場合、このオーバーロードは例外をスローします。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.Id%2A> を調べて、`id` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.Id%2A> が `id` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。  
  
 2つの追加のメソッドを使用すると、キュー内のメッセージをピークすることができます。 <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キュー内の最初のメッセージを返します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> は、メッセージがキューに送信された結果として作成された、受信確認、レポート、またはアプリケーションで生成された応答メッセージを返します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> のメッセージがキューに存在せず、<paramref name="timeout" /> パラメーターで指定した時間が経過する前にキューに到達しませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 キュー内の特定のメッセージをピークします。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">ピークするメッセージの <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キュー内の指定した参照識別子に一致するメッセージをピークします。</summary>
        <returns>渡された <paramref name="lookupId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.LookupId" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の参照識別子を持つメッセージをキューから削除せずに読み取ります。 このメソッドは、メッセージがキューに存在しない場合、すぐに例外をスローします。  
  
 メッセージの <xref:System.Messaging.Message.LookupId%2A> プロパティは、メッセージが存在するキューに対して一意であるため、指定された `lookupId` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 指定された参照識別子を持つメッセージを読み取り、キューから削除するには、<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> メソッドを使用します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">キュー内のメッセージを読み取る方法を指定する <see cref="T:System.Messaging.MessageLookupAction" /> のいずれか 1 つ。 次のいずれかを指定します。 
 <see langword="MessageLookupAction.Current" />。<paramref name="lookupId" /> で指定されたメッセージをピークします。  
  
 <see langword="MessageLookupAction.Next" />。<paramref name="lookupId" /> で指定されたメッセージの次のメッセージをピークします。  
  
 <see langword="MessageLookupAction.Previous" />。<paramref name="lookupId" /> で指定されたメッセージの前のメッセージをピークします。  
  
 <see langword="MessageLookupAction.First" />。キューの最初のメッセージをピークします。 <paramref name="lookupId" /> パラメーターは、0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />。キューの最後のメッセージをピークします。 <paramref name="lookupId" /> パラメーターは、0 に設定する必要があります。</param>
        <param name="lookupId">ピークするメッセージの <see cref="P:System.Messaging.Message.LookupId" /> か、0。 キューの最初または最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <summary>MSMQ 3.0 で導入されました。 キュー内の特定のメッセージをピークします。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
        <returns>渡された <paramref name="action" /> パラメーターおよび <paramref name="lookupId" /> パラメーターで指定された <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の参照識別子を持つメッセージをキューから削除せずに読み取ります。 このメソッドは、メッセージがキューに存在しない場合、すぐに例外をスローします。  
  
 メッセージの <xref:System.Messaging.Message.LookupId%2A> プロパティは、メッセージが存在するキューに対して一意であるため、指定された `lookupId` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 指定された id を持つメッセージを読み取り、キューから削除するには、<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> メソッドを使用します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> パラメーターが、<see cref="T:System.Messaging.MessageLookupAction" /> メンバーの 1 つではありません。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューから削除せずにメッセージを読み取ると発生します。 この発生は、非同期操作 <see cref="M:System.Messaging.MessageQueue.BeginPeek" /> の結果です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は、メッセージがキューで利用可能な場合に、非同期処理で <xref:System.Messaging.MessageQueue.PeekCompleted> イベントを発生させるために使用されます。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> は、<xref:System.Messaging.MessageQueue.BeginPeek%2A> の呼び出しによって開始される操作を完了し、<xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生したときにメッセージをピークするために使用されます。  
  
 <xref:System.Messaging.PeekCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベント ハンドラーにイベントを関連付けるには、イベントにデリゲートのインスタンスを追加します。 イベント ハンドラーは、デリゲートを削除しない限り、イベントが発生するたびに呼び出されます。 イベントハンドラーデリゲートの詳細については、「[イベントの処理と発生](/dotnet/standard/events/)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、`MyPeekCompleted`という名前のイベントハンドラーを作成し、それを <xref:System.Messaging.MessageQueue.PeekCompleted> イベントハンドラーデリゲートにアタッチし、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を呼び出して、パス ".\myQueue" にあるキューで非同期のピーク操作を開始します。 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生すると、この例ではメッセージをピークし、その本文を画面に書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginPeek%2A> を再度呼び出して、新しい非同期ピーク操作を開始します。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューに含まれるすべてのメッセージを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューを削除すると、メッセージキューによってキューの変更フラグが設定され、<xref:System.Messaging.MessageQueue.LastModifyTime%2A> のプロパティに影響します。 キューから削除されたメッセージは失われます。これらのメッセージは、配信不能キューまたはジャーナルキューには送信されません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Purge%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューを識別する表示名を取得または設定します。</summary>
        <value>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューを識別する名前。 値を <see langword="null" /> にすることはできません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.QueueName%2A> と <xref:System.Messaging.MessageQueue.MachineName%2A> を組み合わせて、キューのフレンドリ <xref:System.Messaging.MessageQueue.Path%2A> 名を作成できます。 <xref:System.Messaging.MessageQueue.Path%2A> プロパティのフレンドリ名のバリエーションの構文は、次の表に示すように、キューの種類によって異なります。  
  
|[キューの種類]|構文|  
|----------------|------------|  
|パブリックキュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
  
 "." を使用してローカルコンピューターを表します。  
  
 <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティを変更すると、<xref:System.Messaging.MessageQueue.Path%2A> プロパティに影響します。 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティを設定せずに <xref:System.Messaging.MessageQueue.QueueName%2A> を設定した場合、<xref:System.Messaging.MessageQueue.Path%2A> プロパティはになります。`QueueName`を\\します。 それ以外の場合、<xref:System.Messaging.MessageQueue.Path%2A> は `QueueName`\\`MachineName`になります。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キュー名が <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューからメッセージを読み取るときに使用するネイティブ ハンドルを取得します。</summary>
        <value>キューからメッセージをピークおよび受信するときに使用するネイティブ キューオブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> は、キューからメッセージをピークおよび受信するために使用されるメッセージキューオブジェクトへのネイティブ Windows ハンドルを提供します。 キューのパスを変更すると、ハンドルは閉じられ、新しい値で再び開かれます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <summary>キューにある最初のメッセージを受信し、キューから削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> で参照されるキューで利用できる最初のメッセージを受信します。 この呼び出しは同期呼び出しであるため、メッセージが利用可能になるまで、現在のスレッドの実行をブロックします。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、キューからメッセージを受信するか、キュー内にメッセージが存在するまで待機します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取ることができ、それによってキューからメッセージが削除されます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キューにあるメッセージ、または新しい優先順位のメッセージが返されます。  
  
 キューの最初のメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドのこのオーバーロードは無限のタイムアウトを指定するため、アプリケーションは無制限に待機する可能性があります。 メッセージを待たずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューからメッセージを受信し、そのメッセージに関する情報を画面に出力します。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> で参照されるトランザクション キューで利用できる最初のメッセージを受信します。 この呼び出しは同期呼び出しであるため、メッセージが利用可能になるまで、現在のスレッドの実行をブロックします。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transaction` パラメーターで定義された内部トランザクションコンテキストを使用してトランザクションキューからメッセージを受信するか、キュー内にメッセージが存在するまで待機します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取ることができ、それによってキューからメッセージが削除されます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キュー内の次のメッセージが返されます。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 キューの最初のメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.Peek%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.Peek%2A> によってキュー内のメッセージは削除されないため、<xref:System.Messaging.MessageQueueTransaction.Abort%2A>の呼び出しによってロールバックするものはありません。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドのこのオーバーロードは無限のタイムアウトを指定するため、アプリケーションは無制限に待機する可能性があります。 メッセージを待たずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、ローカルコンピューター上のトランザクションキューに接続し、メッセージをキューに送信します。 次に、注文を含むメッセージを受信します。 トランザクション以外のキューが検出されると、例外がスローされ、トランザクションがロールバックされます。  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。  
  
 または  
  
 キューが非トランザクション キューです。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> で参照されるキューで利用できる最初のメッセージを受信します。 この呼び出しは同期呼び出しであるため、メッセージが利用可能になるまで、現在のスレッドの実行をブロックします。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transactionType` パラメーターで定義されたトランザクションコンテキストを使用してキューからメッセージを受信するか、キュー内にメッセージが存在するまで待機します。  
  
 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取ることができ、それによってキューからメッセージが削除されます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キュー内の次のメッセージが返されます。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 キューの最初のメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.Peek%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.Peek%2A> によってキュー内のメッセージは削除されないため、<xref:System.Messaging.MessageQueueTransaction.Abort%2A>の呼び出しによってロールバックするものはありません。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドのこのオーバーロードは無限のタイムアウトを指定するため、アプリケーションは無制限に待機する可能性があります。 メッセージを待たずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> が参照するキューで利用できる最初のメッセージを受信します。キューでメッセージが利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、キューからメッセージを受信します。キューにメッセージがない場合は、指定した時間が経過した後で制御が戻ります。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取り、キューから削除できます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キューにあるメッセージ、または新しい優先順位のメッセージが返されます。  
  
 キューの最初のメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 スレッドは、指定した期間にわたってブロックされます。 `timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は、無期限にブロックされます。 メッセージを待機せずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューからメッセージを受信し、そのメッセージに関する情報を画面に出力します。 この例では、キューにメッセージが到着するのを待機している間、最大5秒間、実行を一時停止します。  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <summary>指定したカーソルを使用して、キューの現在のメッセージを受信します。 利用可能なメッセージがない場合、このメソッドは、メッセージが利用可能になるまで、またはタイムアウトが発生するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。  
  
 このオーバーロードを使用して、キューからメッセージを受信します。キューにメッセージがない場合は、指定した時間が経過した後で制御が戻ります。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> が参照するトランザクション キューで利用できる最初のメッセージを受信します。キューでメッセージが利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transaction` パラメーターで定義された内部トランザクションコンテキストを使用してトランザクションキューからメッセージを受信し、キューにメッセージがない場合は指定した時間内にを返します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取ることができ、それによってキューからメッセージが削除されます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キュー内の次のメッセージが返されます。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 キューの最初のメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.Peek%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.Peek%2A> によってキュー内のメッセージは削除されないため、<xref:System.Messaging.MessageQueueTransaction.Abort%2A>の呼び出しによってロールバックするものはありません。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 スレッドは、指定した期間にわたってブロックされます。 `timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は、無期限にブロックされます。 メッセージを待機せずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、このメソッドの使用方法を示しています。  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
 または  
  
 キューが非トランザクション キューです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> で参照されるキューで利用できる最初のメッセージを受信します。 この呼び出しは同期的に実行され、メッセージがキューで使用できるようになるか、タイムアウトが経過するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transactionType` パラメーターで定義されたトランザクションコンテキストを使用してキューからメッセージを受信し、キューにメッセージが存在しない場合は、指定された時間を返します。  
  
 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取ることができ、それによってキューからメッセージが削除されます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キュー内の次のメッセージが返されます。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 キューの最初のメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.Peek%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.Peek%2A> によってキュー内のメッセージは削除されないため、<xref:System.Messaging.MessageQueueTransaction.Abort%2A>の呼び出しによってロールバックするものはありません。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 スレッドは、指定した期間にわたってブロックされます。 `timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は、無期限にブロックされます。 メッセージを待機せずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、このメソッドの使用方法を示しています。  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>指定したカーソルを使用して、キューの現在のメッセージを受信します。 利用可能なメッセージがない場合、このメソッドは、メッセージが利用可能になるまで、またはタイムアウトが発生するまで待機します。</summary>
        <returns>キューのメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transaction` パラメーターで定義された内部トランザクションコンテキストを使用してトランザクションキューからメッセージを受信し、キューにメッセージがない場合は指定した時間内にを返します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取ることができ、それによってキューからメッセージが削除されます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キュー内の次のメッセージが返されます。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 キューからメッセージを削除せずに、キュー内のメッセージを読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.Peek%2A> によってキュー内のメッセージは削除されないため、<xref:System.Messaging.MessageQueueTransaction.Abort%2A>を呼び出すことによってロールバックするものはありません。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 スレッドは、指定された期間にわたってブロックされます。または、`timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は、無期限にブロックされます。 メッセージを待機せずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。 <paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> より小さい値か、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> より大きい値である可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
 または  
  
 キューが非トランザクション キューです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定したカーソルを使用して、キューの現在のメッセージを受信します。 利用可能なメッセージがない場合、このメソッドは、メッセージが利用可能になるまで、またはタイムアウトが発生するまで待機します。</summary>
        <returns>キューのメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transactionType` パラメーターで定義されたトランザクションコンテキストを使用してキューからメッセージを受信し、キューにメッセージが存在しない場合は、指定された時間を返します。  
  
 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用すると、メッセージを同期的に読み取ることができ、それによってキューからメッセージが削除されます。 後続の <xref:System.Messaging.MessageQueue.Receive%2A> を呼び出すと、キュー内の次のメッセージが返されます。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信されたメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 キューからメッセージを削除せずに、キュー内のメッセージを読み取るには、<xref:System.Messaging.MessageQueue.Peek%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.Peek%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.Peek%2A> によってキュー内のメッセージは削除されないため、<xref:System.Messaging.MessageQueueTransaction.Abort%2A>を呼び出すことによってロールバックするものはありません。  
  
 メッセージがキューに到着するのを待機している間に、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.Receive%2A> の呼び出しを使用します。 スレッドは、指定された期間にわたってブロックされます。または、`timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は、無期限にブロックされます。 メッセージを待機せずにアプリケーションの処理を続行する場合は、非同期メソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定された値は無効です。 <paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> より小さい値か、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> より大きい値である可能性があります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッドセーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した相関 ID と一致するメッセージを受信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>指定した相関 ID と一致するメッセージを (非トランザクション キューから) 受信します。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照される非トランザクションキューを検索します。 `correlationID` パラメーターと一致するメッセージが見つからない場合は、例外がスローされます。 それ以外の場合、メッセージはキューから削除され、アプリケーションに返されます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> メソッドは、一意の識別子を指定することによってメッセージを取得します。  
  
 指定された相関 id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューとの間で注文を含むメッセージを送受信します。 これは、元のメッセージがキューに到達するか、キューから取得されるときに肯定受信確認を要求します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>指定した相関 ID と一致するメッセージを (トランザクション キューから) 受信します。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照されるトランザクションキューを検索します。 `correlationID` パラメーターと一致するメッセージが見つからない場合は、例外がスローされます。 それ以外の場合、メッセージはキューから削除され、`transaction` パラメーターによって定義された内部トランザクションコンテキストを使用してアプリケーションに返されます。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> メソッドを使用して、一意の識別子を指定することによってメッセージを取得します。  
  
 指定された相関 id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューが非トランザクション キューです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した相関 ID と一致するメッセージを受信します。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照されるキューを検索します。 `correlationID` パラメーターと一致するメッセージが見つからない場合は、例外がスローされます。 それ以外の場合、メッセージはキューから削除され、`transactionType` パラメーターによって定義されたトランザクションコンテキストを使用してアプリケーションに返されます。  
  
 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> メソッドを使用して、一意の識別子を指定することによってメッセージを取得します。  
  
 指定された相関 id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定した相関 ID と一致するメッセージを (非トランザクション キューから) 受信します。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照される非トランザクションキューを検索します。 `correlationId` パラメーターによって指定された相関 id を持つメッセージがキューにある場合、このメソッドは直ちにを返します。 それ以外の場合、メソッドは、新しいメッセージが到着するまで、指定された期間待機します。 タイムアウトの期限が切れる前に新しいメッセージが到着しなかった場合は、例外がスローされます。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.CorrelationId%2A> を調べて、`correlationId` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.CorrelationId%2A> が `correlationId` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> メソッドを使用して、一意の識別子を指定することによってメッセージを取得します。  
  
 指定された相関 id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>指定した相関 ID と一致するメッセージを (トランザクション キューから) 受信します。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照されるトランザクションキューを検索します。 このメソッドは、`transaction` パラメーターによって定義された内部トランザクションコンテキストを使用して、`correlationId` パラメーターによって指定された相関 id を持つメッセージがキューにある場合に、直ちに戻ります。 それ以外の場合、メソッドは、新しいメッセージが到着するまで、指定された期間待機します。 タイムアウトの期限が切れる前に新しいメッセージが到着しなかった場合は、例外がスローされます。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.CorrelationId%2A> を調べて、`correlationId` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.CorrelationId%2A> が `correlationId` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> メソッドを使用して、一意の識別子を指定することによってメッセージを取得します。  
  
 指定された相関 id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。  
  
または 
キューが非トランザクション キューです。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した相関 ID と一致するメッセージを受信します。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定された `correlationId` パラメーターに一致する <xref:System.Messaging.Message.CorrelationId%2A> を持つメッセージの <xref:System.Messaging.MessageQueue> によって参照されるキューを検索します。 このメソッドは、`transactionType` パラメーターで定義されているトランザクションコンテキストを使用して、`correlationId` パラメーターによって指定された相関 id を持つメッセージがキューにある場合に、直ちに戻ります。 それ以外の場合、メソッドは、新しいメッセージが到着するまで、指定された期間待機します。 タイムアウトの期限が切れる前に新しいメッセージが到着しなかった場合は、例外がスローされます。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.CorrelationId%2A> を調べて、`correlationId` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.CorrelationId%2A> が `correlationId` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> プロパティは、キューに送信されたメッセージを、関連付けられている応答、レポート、または受信確認メッセージに関連付けるために使用されます。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返し、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> メソッドを使用して、一意の識別子を指定することによってメッセージを取得します。  
  
 指定された相関 id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した ID と一致するメッセージを受信し、キューから削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>指定した ID と一致するメッセージを非トランザクション キューから受信します。現在、指定した ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、キューから削除します。 このメソッドは、メッセージがキューに存在しない場合、すぐに例外をスローします。  
  
 メッセージの <xref:System.Messaging.Message.Id%2A> プロパティは、メッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返します。また、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、キューに送信されたメッセージの結果として作成された確認メッセージ、レポートメッセージ、またはアプリケーションで生成された応答メッセージを取得します。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>指定した ID と一致するメッセージを (トランザクション キューから) 受信します。現在、指定した ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、`transaction` パラメーターで定義された内部トランザクションコンテキストを使用してキューから削除します。 このメソッドは、メッセージがキューに存在しない場合、直ちに例外をスローします。  
  
 メッセージの <xref:System.Messaging.Message.Id%2A> プロパティは、メッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返します。また、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、キューに送信されたメッセージの結果として作成された確認メッセージ、レポートメッセージ、またはアプリケーションで生成された応答メッセージを取得します。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューが非トランザクション キューです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した ID と一致するメッセージを受信します。現在、指定した ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、キューから削除します。 このメソッドは、メッセージがキューに存在しない場合、すぐに例外をスローします。 それ以外の場合、メッセージはキューから削除され、`transactionType` パラメーターによって定義されたトランザクションコンテキストを使用してアプリケーションに返されます。  
  
 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 メッセージの <xref:System.Messaging.Message.Id%2A> プロパティは、メッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターに一致するメッセージがキューに1つだけ存在します。 指定した識別子を持つメッセージが、この <xref:System.Messaging.MessageQueue> インスタンスに関連付けられているキュー以外のキューにある場合、メッセージは見つかりません。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返します。また、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、キューに送信されたメッセージの結果として作成された確認メッセージ、レポートメッセージ、またはアプリケーションで生成された応答メッセージを取得します。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定した ID と一致するメッセージを (非トランザクション キューから) 受信します。指定した ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、キューから削除します。 `id` パラメーターによって指定された識別子を持つメッセージがキューにある場合、このメソッドは直ちにを返します。 それ以外の場合、メソッドは、新しいメッセージが到着するまで、指定された期間待機します。 タイムアウトの期限が切れる前に新しいメッセージが到着しなかった場合は、例外がスローされます。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.Id%2A> を調べて、`id` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.Id%2A> が `id` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。  
  
 メッセージの <xref:System.Messaging.Message.Id%2A> プロパティは、メッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 `timeout` パラメーターで指定されたタイムアウト期間内に新しいメッセージがキューに到着している限り、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> のこのオーバーロードを使用します。 スレッドは、少なくとも指定した期間、または `timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は無期限にブロックされます。また、`timeout` パラメーターで指定されたタイムアウト期間内に新しいメッセージがキューに到着する場合は、無制限になります。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返します。また、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、キューに送信されたメッセージの結果として作成された確認メッセージ、レポートメッセージ、またはアプリケーションで生成された応答メッセージを取得します。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、指定された <paramref name="id" /> を持つメッセージがキューに到達しませんでした。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>指定した ID と一致するメッセージを (トランザクション キューから) 受信します。指定した ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、`transaction` パラメーターで定義された内部トランザクションコンテキストを使用してキューから削除します。 `id` パラメーターによって指定された識別子を持つメッセージがキューにある場合、このメソッドは直ちにを返します。 それ以外の場合、メソッドは、新しいメッセージが到着するまで、指定された期間待機します。 タイムアウトの期限が切れる前に新しいメッセージが到着しなかった場合は、例外がスローされます。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.Id%2A> を調べて、`id` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.Id%2A> が `id` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。  
  
 メッセージの <xref:System.Messaging.Message.Id%2A> プロパティは、メッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 `timeout` パラメーターで指定されたタイムアウト期間内に新しいメッセージがキューに到着している限り、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> のこのオーバーロードを使用します。 スレッドは、少なくとも指定した期間にわたってブロックされるか、`timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は無期限にブロックされます。また、`timeout` パラメーターで指定されたタイムアウト期間内に新しいメッセージがキューに到着し続ける場合は、無期限にブロックされます。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返します。また、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、キューに送信されたメッセージの結果として作成された確認メッセージ、レポートメッセージ、またはアプリケーションで生成された応答メッセージを取得します。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、キューにある優先順位の高いメッセージが受信されない限り、後続のメソッドの呼び出しは同じメッセージを返します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、指定された <paramref name="id" /> を持つメッセージがキューに到達しませんでした。  
  
または 
キューが非トランザクション キューです。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した ID と一致するメッセージを受信します。指定した ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、キューから削除します。 このメソッドは、`transactionType` パラメーターで定義されているトランザクションコンテキストを使用して、`id` パラメーターによって指定された識別子を持つメッセージがキューにある場合に、直ちに戻ります。 それ以外の場合、メソッドは、新しいメッセージが到着するまで、指定された期間待機します。 タイムアウトの期限が切れる前に新しいメッセージが到着しなかった場合は、例外がスローされます。  
  
 `timeout` パラメーターでは、このメソッドの合計実行時間が指定されていません。 代わりに、キューに新しいメッセージが到着するまで待機する時間を指定します。 このメソッドは、新しいメッセージが到着するたびに、新しいメッセージの <xref:System.Messaging.Message.Id%2A> を調べて、`id` パラメーターと一致するかどうかを確認します。 それ以外の場合、このメソッドはタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 したがって、タイムアウト期間内に新しいメッセージが引き続き到着する場合、このメソッドは、タイムアウト期間が新しいメッセージを受信せずに期限切れになるか、または <xref:System.Messaging.Message.Id%2A> が `id` パラメーターと一致するメッセージが到着するまで、無期限に実行を継続することができます。  
  
 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 メッセージの <xref:System.Messaging.Message.Id%2A> プロパティは、メッセージキューエンタープライズ全体で一意であるため、指定された `id` パラメーターに一致するメッセージがキューに1つだけ存在します。 指定した識別子を持つメッセージが、この <xref:System.Messaging.MessageQueue> インスタンスに関連付けられているキュー以外のキューにある場合、メッセージは見つかりません。  
  
 `timeout` パラメーターで指定されたタイムアウト期間内に新しいメッセージがキューに到着している限り、現在のスレッドがブロックされてもかまわない場合は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> のこのオーバーロードを使用します。 スレッドは、少なくとも指定した期間、または `timeout` パラメーターに <xref:System.Messaging.MessageQueue.InfiniteTimeout> 値を指定した場合は無期限にブロックされます。また、`timeout` パラメーターで指定されたタイムアウト期間内に新しいメッセージがキューに到着する場合は、無制限になります。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 他の2つの方法では、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キュー内の最初のメッセージを返します。また、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、キューに送信されたメッセージの結果として作成された確認メッセージ、レポートメッセージ、またはアプリケーションで生成された応答メッセージを取得します。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドは常にキュー内の最初のメッセージを返します。そのため、後続のメソッドの呼び出しでは、優先順位の高いメッセージがキューに到着しない限り、同じメッセージが返されます。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> はキュー内のメッセージを削除しないため、トランザクションが中止された場合、ロールバックする必要はありません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、指定された <paramref name="id" /> を持つメッセージがキューに到達しませんでした。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 特定のメッセージをキューから受信します。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">受信するメッセージの <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キュー内の指定した参照識別子に一致するメッセージを受信します。</summary>
        <returns>渡された <paramref name="lookupId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.LookupId" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の参照識別子を持つメッセージを読み取り、キューから削除します。 このメソッドは、メッセージがキューに存在しない場合、すぐに例外をスローします。  
  
 メッセージの <xref:System.Messaging.Message.LookupId%2A> プロパティは、メッセージが存在するキューに対して一意であるため、指定された `lookupId` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 指定された参照識別子を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メソッドを使用します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">キュー内のメッセージを読み取る方法を指定する <see cref="T:System.Messaging.MessageLookupAction" /> のいずれか 1 つ。 次のいずれかを指定します。 
 <see langword="MessageLookupAction.Current" />。<paramref name="lookupId" /> で指定されたメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Next" />。<paramref name="lookupId" /> で指定されたメッセージの次のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Previous" />。<paramref name="lookupId" /> で指定されたメッセージの前のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.First" />。キューの最初のメッセージを受信し、キューから削除します。 <paramref name="lookupId" /> パラメーターは、0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />。キューの最後のメッセージを受信し、キューから削除します。 <paramref name="lookupId" /> パラメーターは、0 に設定する必要があります。</param>
        <param name="lookupId">受信するメッセージの <see cref="P:System.Messaging.Message.LookupId" /> か、0。 キューの最初または最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>MSMQ 3.0 で導入されました。 特定のメッセージをトランザクション キューから受信します。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
        <returns>渡された <paramref name="lookupId" /> パラメーターおよび <paramref name="action" /> パラメーターで指定された <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の参照識別子を持つメッセージを読み取り、`transaction` パラメーターで定義されたトランザクションコンテキストを使用してキューから削除します。 このメソッドは、メッセージがキューに存在しない場合、すぐに例外をスローします。  
  
 メッセージの <xref:System.Messaging.Message.LookupId%2A> プロパティは、メッセージが存在するキューに対して一意であるため、指定された `lookupId` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 このメソッドはトランザクションキューで呼び出されるため、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> はキューからメッセージを削除しないため、トランザクションが中止された場合、ロールバックすることはできません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。  
  
 または  
  
 キューが非トランザクション キューです。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> パラメーターが、<see cref="T:System.Messaging.MessageLookupAction" /> メンバーの 1 つではありません。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">キュー内のメッセージを読み取る方法を指定する <see cref="T:System.Messaging.MessageLookupAction" /> のいずれか 1 つ。 次のいずれかを指定します。 
 <see langword="MessageLookupAction.Current" />。<paramref name="lookupId" /> で指定されたメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Next" />。<paramref name="lookupId" /> で指定されたメッセージの次のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Previous" />。<paramref name="lookupId" /> で指定されたメッセージの前のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.First" />。キューの最初のメッセージを受信し、キューから削除します。 <paramref name="lookupId" /> パラメーターは、0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />。キューの最後のメッセージを受信し、キューから削除します。 <paramref name="lookupId" /> パラメーターは、0 に設定する必要があります。</param>
        <param name="lookupId">受信するメッセージの <see cref="P:System.Messaging.Message.LookupId" /> か、0。 キューの最初または最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>MSMQ 3.0 で導入されました。 トランザクション コンテキストを指定して、特定のメッセージをキューから受信します。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
        <returns>渡された <paramref name="action" /> パラメーターおよび <paramref name="lookupId" /> パラメーターで指定された <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の参照識別子を持つメッセージを読み取り、`transactionType` パラメーターで定義されたトランザクションコンテキストを使用してキューから削除します。 このメソッドは、メッセージがキューに存在しない場合、すぐに例外をスローします。  
  
 メッセージの <xref:System.Messaging.Message.LookupId%2A> プロパティは、メッセージが存在するキューに対して一意であるため、指定された `lookupId` パラメーターに一致するメッセージがキューに1つだけ存在します。  
  
 指定された id を持つメッセージをキューから削除せずに読み取るには、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メソッドを使用します。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>への呼び出しによって返されたメッセージに関連付けられたトランザクションコンテキストがありません。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> はキューからメッセージを削除しないため、トランザクションが中止された場合、ロールバックすることはできません。  
  
 メッセージの受信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして受信する場合は、`Single` を指定します。 トランザクションコンテキストの外部にあるトランザクションキューからメッセージを受信する場合は、`None` を指定できます。  
  
 トランザクションキューからメッセージを受信するためにこのメソッドが呼び出された場合、トランザクションが中止されると、受信したメッセージがキューに返されます。 トランザクションがコミットされるまで、メッセージはキューから完全に削除されません。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> パラメーターが、<see cref="T:System.Messaging.MessageLookupAction" /> メンバーの 1 つではありません。  
  
または 
<paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージがキューから削除されると発生します。 このイベントは、非同期操作 <see cref="M:System.Messaging.MessageQueue.BeginReceive" /> によって発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は、メッセージがキューで利用可能な場合に、非同期処理で <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントを発生させるために使用されます。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> は、<xref:System.Messaging.MessageQueue.BeginReceive%2A> の呼び出しによって開始される操作を完了し、<xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生したときにメッセージをピークするために使用されます。  
  
 <xref:System.Messaging.ReceiveCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベント ハンドラーにイベントを関連付けるには、イベントにデリゲートのインスタンスを追加します。 イベント ハンドラーは、デリゲートを削除しない限り、イベントが発生するたびに呼び出されます。 イベントハンドラーデリゲートの詳細については、「[イベントの処理と発生](/dotnet/standard/events/)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、`MyReceiveCompleted`という名前のイベントハンドラーを作成し、それを <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントハンドラーデリゲートにアタッチし、<xref:System.Messaging.MessageQueue.BeginReceive%2A> を呼び出して、パス ".\myQueue" にあるキューで非同期の受信操作を開始します。 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生すると、この例ではメッセージを受信し、その本文を画面に書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginReceive%2A> を再度呼び出して、新しい非同期の受信操作を開始します。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソースの現在の状態を反映するには、<see cref="T:System.Messaging.MessageQueue" /> で表されるプロパティを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> は、<xref:System.Messaging.MessageQueue> のプロパティを、関連付けられているメッセージキューサーバーリソースと同期します。 <xref:System.Messaging.MessageQueue> の作成時以降にサーバー上で <xref:System.Messaging.MessageQueue.Label%2A> や <xref:System.Messaging.MessageQueue.Category%2A>などのプロパティが変更された場合、<xref:System.Messaging.MessageQueue.Refresh%2A> は新しい情報で <xref:System.Messaging.MessageQueue> を更新します。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Refresh%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アクセス許可リストをオペレーティング システムの既定値にリセットします。 既定のリストに追加したキューのアクセス許可を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ResetPermissions%2A>を呼び出すと、アクセス許可リストが既定値に戻ります。 一般に、キュー作成者にはすべてのアクセス許可が付与され、グループには次の権限が付与されます。  
  
-   キューのプロパティを取得します。  
  
-   キューのアクセス許可を取得します。  
  
-   キューに書き込みます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ResetPermissions%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>キューにオブジェクトを送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照される非トランザクション キューにオブジェクトを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、<xref:System.Messaging.MessageQueue>によって参照されるキューに `obj` パラメーターを含むメッセージを送信します。 キューに送信するオブジェクトは、<xref:System.Messaging.Message> または任意のマネージオブジェクトにすることができます。 <xref:System.Messaging.Message>以外のオブジェクトを送信すると、オブジェクトがシリアル化され、メッセージの本文に挿入されます。  
  
 このオーバーロードを使用してトランザクションキューにメッセージを送信すると、メッセージは配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合は、パラメーターとして <xref:System.Messaging.MessageQueueTransaction> または <xref:System.Messaging.MessageQueueTransactionType> を受け取るオーバーロードを使用します。  
  
 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>を呼び出す前に <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを設定しなかった場合、フォーマッタは既定で <xref:System.Messaging.XmlMessageFormatter>に設定されます。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティは、<xref:System.Messaging.Message>以外のすべてのオブジェクトに適用されます。 たとえば、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバーを使用してラベルや優先順位を指定した場合、これらの値は、アプリケーションからキューに送信されるときに <xref:System.Messaging.Message> 型ではないオブジェクトを含むすべてのメッセージに適用されます。 <xref:System.Messaging.Message>を送信する場合、<xref:System.Messaging.Message> に設定されているプロパティ値が <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> より優先され、メッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> プロパティはキューの <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> プロパティよりも優先されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージキューに接続し、メッセージをキューに送信します。  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 次のコード例では、アプリケーションによって定義された `Order` クラスをキューに送信し、そのキューからメッセージを受信します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるトランザクション キューにオブジェクトを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transaction` パラメーターで定義された内部トランザクションコンテキストを使用して、<xref:System.Messaging.MessageQueue>によって参照されるトランザクションキューに `obj` パラメーターを含むメッセージを送信します。 キューに送信するオブジェクトは、<xref:System.Messaging.Message> または任意のマネージオブジェクトにすることができます。 <xref:System.Messaging.Message>以外のオブジェクトを送信すると、オブジェクトがシリアル化され、メッセージの本文に挿入されます。  
  
 このオーバーロードを使用して非トランザクションキューにメッセージを送信すると、例外をスローすることなく、メッセージが配信不能キューに送信される可能性があります。  
  
 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>を呼び出す前に <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを設定しなかった場合、フォーマッタは既定で <xref:System.Messaging.XmlMessageFormatter>に設定されます。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティは、<xref:System.Messaging.Message>以外のすべてのオブジェクトに適用されます。 たとえば、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバーを使用してラベルや優先順位を指定した場合、これらの値は、アプリケーションからキューに送信されるときに <xref:System.Messaging.Message> 型ではないオブジェクトを含むすべてのメッセージに適用されます。 <xref:System.Messaging.Message>を送信する場合、<xref:System.Messaging.Message> に設定されているプロパティ値が <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> より優先され、メッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> プロパティはキューの <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> プロパティよりも優先されます。  
  
 <xref:System.Messaging.MessageQueueTransaction> はスレッドアパートメントに対応しているため、アパートメント状態が `STA`場合は、複数のスレッドでトランザクションを使用することはできません。 Visual Basic は、メインスレッドの状態を `STA`に設定するため、<xref:System.MTAThreadAttribute> を `Main` サブルーチンに適用する必要があります。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 次のフラグメントを使用して、<xref:System.MTAThreadAttribute> を適用します。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、トランザクションキューに文字列を送信し、そのキューからメッセージを受信します。  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
または 
メッセージ キュー アプリケーションが、トランザクションの使用が正しくないことを示しました。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるキューにオブジェクトを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transactionType` パラメーターで定義されているトランザクションコンテキストを使用し、<xref:System.Messaging.MessageQueue>によって参照されるキューに `obj` パラメーターを含むメッセージを送信します。 メッセージの送信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして送信する場合は、`Single` を指定します。 トランザクションメッセージを非トランザクションスレッドに送信する場合は、`None` を指定できます。  
  
 キューに送信するオブジェクトは、<xref:System.Messaging.Message> または任意のマネージオブジェクトにすることができます。 <xref:System.Messaging.Message>以外のオブジェクトを送信すると、オブジェクトがシリアル化され、メッセージの本文に挿入されます。  
  
 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>を呼び出す前に <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを設定しなかった場合、フォーマッタは既定で <xref:System.Messaging.XmlMessageFormatter>に設定されます。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティは、<xref:System.Messaging.Message>以外のすべてのオブジェクトに適用されます。 たとえば、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバーを使用してラベルや優先順位を指定した場合、これらの値は、アプリケーションからキューに送信されるときに <xref:System.Messaging.Message> 型ではないオブジェクトを含むすべてのメッセージに適用されます。 <xref:System.Messaging.Message>を送信する場合、<xref:System.Messaging.Message> に設定されているプロパティ値が <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> より優先され、メッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> プロパティはキューの <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> プロパティよりも優先されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベル。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照される非トランザクション キューにオブジェクトを送信し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、<xref:System.Messaging.MessageQueue>によって参照されるキューに `obj` パラメーターを含むメッセージを送信します。 このオーバーロードを使用すると、メッセージを識別する文字列ラベルを指定できます。 キューに送信するオブジェクトには、<xref:System.Messaging.Message>、構造体、データオブジェクト、または任意のマネージオブジェクトを指定できます。 <xref:System.Messaging.Message>以外のオブジェクトを送信すると、オブジェクトがシリアル化され、メッセージの本文に挿入されます。  
  
 メッセージラベルは、メッセージキューのラベルとは異なりますが、どちらもアプリケーションに依存し、メッセージキューに対しては意味を継承しません。  
  
 このオーバーロードを使用してトランザクションキューにメッセージを送信すると、メッセージは配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合は、パラメーターとして <xref:System.Messaging.MessageQueueTransaction> または <xref:System.Messaging.MessageQueueTransactionType> を受け取るオーバーロードを使用します。  
  
 メッセージを送信する前に、この <xref:System.Messaging.MessageQueue> インスタンスの <xref:System.Messaging.MessageQueue.Path%2A> プロパティを指定する必要があります。 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>を呼び出す前に <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを設定しなかった場合、フォーマッタは既定で <xref:System.Messaging.XmlMessageFormatter>に設定されます。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティは、<xref:System.Messaging.Message>以外のすべてのオブジェクトに適用されます。 たとえば、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバーを使用してラベルや優先順位を指定した場合、これらの値は、アプリケーションからキューに送信されるときに <xref:System.Messaging.Message> 型ではないオブジェクトを含むすべてのメッセージに適用されます。 <xref:System.Messaging.Message>を送信する場合、<xref:System.Messaging.Message> に設定されているプロパティ値が <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> より優先され、メッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> プロパティはキューの <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> プロパティよりも優先されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベル。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクトです。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるトランザクション キューにオブジェクトを送信し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transaction` パラメーターで定義された内部トランザクションコンテキストを使用して、<xref:System.Messaging.MessageQueue>によって参照されるトランザクションキューに `obj` パラメーターを含むメッセージを送信します。 このオーバーロードを使用すると、メッセージを識別する文字列ラベルを指定できます。 キューに送信するオブジェクトには、<xref:System.Messaging.Message>、構造体、データオブジェクト、または任意のマネージオブジェクトを指定できます。 <xref:System.Messaging.Message>以外のオブジェクトを送信すると、オブジェクトがシリアル化され、メッセージの本文に挿入されます。  
  
 メッセージラベルは、メッセージキューのラベルとは異なりますが、どちらもアプリケーションに依存し、メッセージキューに対しては意味を継承しません。  
  
 このオーバーロードを使用して非トランザクションキューにメッセージを送信すると、例外をスローすることなく、メッセージが配信不能キューに送信される可能性があります。  
  
 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>を呼び出す前に <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを設定しなかった場合、フォーマッタは既定で <xref:System.Messaging.XmlMessageFormatter>に設定されます。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティは、<xref:System.Messaging.Message>以外のすべてのオブジェクトに適用されます。 たとえば、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバーを使用してラベルや優先順位を指定した場合、これらの値は、アプリケーションからキューに送信されるときに <xref:System.Messaging.Message> 型ではないオブジェクトを含むすべてのメッセージに適用されます。 <xref:System.Messaging.Message>を送信する場合、<xref:System.Messaging.Message> に設定されているプロパティ値が <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> より優先され、メッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> プロパティはキューの <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> プロパティよりも優先されます。  
  
 <xref:System.Messaging.MessageQueueTransaction> はスレッドアパートメントに対応しているため、アパートメント状態が `STA`場合は、複数のスレッドでトランザクションを使用することはできません。 Visual Basic は、メインスレッドの状態を `STA`に設定するため、<xref:System.MTAThreadAttribute> を `Main` サブルーチンに適用する必要があります。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 次のフラグメントを使用して、<xref:System.MTAThreadAttribute> を適用します。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
または 
メッセージ キュー アプリケーションが、トランザクションの使用方法が間違っていることを示しました。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベル。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるキューにオブジェクトを送信し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、`transactionType` パラメーターで定義されているトランザクションコンテキストを使用し、<xref:System.Messaging.MessageQueue>によって参照されるキューに `obj` パラメーターを含むメッセージを送信します。 メッセージの送信に使用するスレッドに既に外部トランザクションコンテキストがアタッチされている場合は、`transactionType` パラメーターに `Automatic` を指定します。 メッセージを1つの内部トランザクションとして送信する場合は、`Single` を指定します。 トランザクションメッセージを非トランザクションスレッドに送信する場合は、`None` を指定できます。  
  
 キューに送信するオブジェクトは、<xref:System.Messaging.Message> または任意のマネージオブジェクトにすることができます。 <xref:System.Messaging.Message>以外のオブジェクトを送信すると、オブジェクトがシリアル化され、メッセージの本文に挿入されます。 このオーバーロードを使用すると、メッセージを識別する文字列ラベルを指定できます。  
  
 メッセージラベルは、メッセージキューのラベルとは異なりますが、どちらもアプリケーションに依存し、メッセージキューに対しては意味を継承しません。  
  
 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>を呼び出す前に <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを設定しなかった場合、フォーマッタは既定で <xref:System.Messaging.XmlMessageFormatter>に設定されます。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティは、<xref:System.Messaging.Message>以外のすべてのオブジェクトに適用されます。 たとえば、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバーを使用してラベルや優先順位を指定した場合、これらの値は、アプリケーションからキューに送信されるときに <xref:System.Messaging.Message> 型ではないオブジェクトを含むすべてのメッセージに適用されます。 <xref:System.Messaging.Message>を送信する場合、<xref:System.Messaging.Message> に設定されているプロパティ値は <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>より優先され、メッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> プロパティはキューの <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> プロパティよりも優先されます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">メッセージ キュー アプリケーションが、トランザクションの使用方法が間違っていることを示しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
または 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のセットにアクセス許可を追加します。 キューのプロパティとキューのメッセージにアクセスできるユーザーを制御します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">トラスティと付与するアクセス許可を指定する 1 つ以上のアクセス制御エントリを含む <see cref="T:System.Messaging.AccessControlList" />。</param>
        <summary>アクセス制御リストの内容に基づいてアクセス権をキューに割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 権限の許可、拒否、または取り消しを行うには、このオーバーロードを使用して、トラスティおよびアクセス許可情報を指定するアクセス制御エントリのコレクションを使用します。 これは、たとえば、複数のユーザーに同時にアクセス許可を付与するために使用されます。  
  
 `ace` パラメーターを構築するときに指定するトラスティは、個々のユーザー、ユーザーのグループ、またはコンピューターです。 トラスティが個人の場合は、`DOMAIN`\\`user`の形式を使用します。 トラスティがローカルコンピューターを示す場合は、"." を指定できます。  
  
 によって割り当てられたアクセス許可 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 既存の一覧に権限を追加します。 既定では、パブリックキューまたは専用キューの作成者にはフルコントロールがあり、ドメイングループのすべてのユーザーは、キュープロパティの取得、アクセス許可の取得、およびキューへの書き込みを行う権限を持っています。 <xref:System.Messaging.MessageQueue.SetPermissions%2A>を呼び出すと、ユーザーと権限の情報が既存のリストの下部に追加されます。  
  
 システムは、次のいずれかのイベントが発生するまで、各 <xref:System.Messaging.AccessControlEntry> を順番に検証します。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> は、スレッドのアクセストークンに示されているいずれかのトラスティに対して、要求されたアクセス権を明示的に拒否します。  
  
-   スレッドのアクセストークンに一覧表示されているトラスティの <xref:System.Messaging.AccessControlEntry> 項目1つ以上に、要求されたすべてのアクセス権が明示的に付与されます。  
  
-   すべての <xref:System.Messaging.AccessControlEntry> 項目がチェックされ、明示的に許可されていないアクセス権が少なくとも1つ存在します。この場合、アクセスは暗黙的に拒否されます。  
  
 `dacl` パラメーターを構築する場合は、<xref:System.Messaging.AccessControlEntry> インスタンスを <xref:System.Messaging.AccessControlList> コレクションに追加します。 各アクセス制御エントリを作成するときに、汎用または標準のアクセス権を指定できます。 キューに対する権限は、次の任意の組み合わせにすることができます。  
  
-   削除  
  
-   セキュリティの読み取り  
  
-   書き込みセキュリティ  
  
-   同期  
  
-   所有者の変更  
  
-   Read  
  
-   Write  
  
-   実行  
  
-   必須  
  
-   All  
  
-   なし  
  
 これらの権限は、ビットフラグのセットであり、またはビットごとの演算子を使用して組み合わせることができます。  
  
-   フル コントロール  
  
-   メッセージの削除  
  
-   メッセージの受信  
  
-   メッセージのピーク  
  
-   ジャーナルメッセージの受信  
  
-   キューのプロパティを取得する  
  
-   キューのプロパティの設定  
  
-   アクセス許可の取得  
  
-   アクセス許可を設定する  
  
-   キューの所有権を取得する  
  
-   メッセージの書き込み  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> の使用方法を示します。      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">ユーザー、アクセスの種類、およびアクセス許可の種類を指定する <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />。</param>
        <summary>アクセス制御エントリの内容に基づいてアクセス権をキューに割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 権限を許可、拒否、または取り消すには、アクセス制御エントリを使用してトラスティと権限情報を指定します。  
  
 `ace` パラメーターを構築するときに指定するトラスティは、個々のユーザー、ユーザーのグループ、またはコンピューターです。 トラスティが個人の場合は、`DOMAIN`\\`user`の形式を使用します。 トラスティがローカルコンピューターを示す場合は、"." を指定できます。  
  
 によって割り当てられたアクセス許可 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 既存の一覧に権限を追加します。 既定では、パブリックキューまたは専用キューの作成者にはフルコントロールがあり、ドメイングループのすべてのユーザーは、キュープロパティの取得、アクセス許可の取得、およびキューへの書き込みを行う権限を持っています。 <xref:System.Messaging.MessageQueue.SetPermissions%2A>を呼び出すと、ユーザーと権限の情報が既存のリストの下部に追加されます。  
  
 システムは、次のいずれかのイベントが発生するまで、各 <xref:System.Messaging.AccessControlEntry> を順番に検証します。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> は、スレッドのアクセストークンに示されているいずれかのトラスティに対して、要求されたアクセス権を明示的に拒否します。  
  
-   スレッドのアクセストークンに一覧表示されているトラスティの <xref:System.Messaging.AccessControlEntry> 項目1つ以上に、要求されたすべてのアクセス権が明示的に付与されます。  
  
-   すべての <xref:System.Messaging.AccessControlEntry> 項目がチェックされ、明示的に許可されていないアクセス権が少なくとも1つ存在します。この場合、アクセスは暗黙的に拒否されます。  
  
 <xref:System.Messaging.MessageQueueAccessControlEntry>を構築するときに `rights` パラメーターで指定するキューに対する権限は、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージの削除  
  
-   メッセージの受信  
  
-   メッセージのピーク  
  
-   ジャーナルメッセージの受信  
  
-   キューのプロパティを取得する  
  
-   キューのプロパティの設定  
  
-   アクセス許可の取得  
  
-   アクセス許可を設定する  
  
-   キューの所有権を取得する  
  
-   メッセージの書き込み  
  
 `ace` パラメーターのコンストラクターで指定する `rights` パラメーターは <xref:System.Messaging.MessageQueueAccessRights> 列挙型のフラグです。 ビットフラグのセットを表します。これは、ビットごとの演算子を使用して、または `rights` パラメーターを作成するときに組み合わせることができます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">キューに対する追加のアクセス権を取得するそれぞれのユーザー、グループ、またはコンピューター。</param>
        <param name="rights">メッセージ キューが <paramref name="user" /> に割り当てるキューに対するアクセス権のセットを示す <see cref="T:System.Messaging.MessageQueueAccessRights" />。</param>
        <summary>コンピューター、グループ、またはユーザーに指定したアクセス権を与えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、指定した権限を個々のユーザーに付与します。 ユーザーは、個々のユーザー、ユーザーグループ、またはコンピューターを含む任意の有効なトラスティにすることができます。 ユーザーが個人の場合は、`user` パラメーターに `user` `DOMAIN`\\の形式を使用します。 `user` パラメーターに "." を指定すると、ローカルコンピューターを示すことができます。  
  
 によって割り当てられたアクセス許可 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 既存の一覧に権限を追加します。 既定では、パブリックキューまたは専用キューの作成者にはフルコントロールがあり、ドメイングループのすべてのユーザーは、キュープロパティの取得、アクセス許可の取得、およびキューへの書き込みを行う権限を持っています。 <xref:System.Messaging.MessageQueue.SetPermissions%2A>を呼び出すと、ユーザーと権限の情報が既存のリストの下部に追加されます。  
  
 システムは、次のいずれかのイベントが発生するまで、各 <xref:System.Messaging.AccessControlEntry> を順番に検証します。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> は、スレッドのアクセストークンに示されているいずれかのトラスティに対して、要求されたアクセス権を明示的に拒否します。  
  
-   スレッドのアクセストークンに一覧表示されているトラスティの <xref:System.Messaging.AccessControlEntry> 項目1つ以上に、要求されたすべてのアクセス権が明示的に付与されます。  
  
-   すべての <xref:System.Messaging.AccessControlEntry> 項目がチェックされ、明示的に許可されていないアクセス権が少なくとも1つ存在します。この場合、アクセスは暗黙的に拒否されます。  
  
 `rights` パラメーターで指定するキューに対する権限は、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージの削除  
  
-   メッセージの受信  
  
-   メッセージのピーク  
  
-   ジャーナルメッセージの受信  
  
-   キューのプロパティを取得する  
  
-   キューのプロパティの設定  
  
-   アクセス許可の取得  
  
-   アクセス許可を設定する  
  
-   キューの所有権を取得する  
  
-   メッセージの書き込み  
  
 <xref:System.Messaging.MessageQueueAccessRights> 列挙体はビットフラグのセットを表します。ビットフラグは、ビットごとの演算子を使用して組み合わせることも、`rights` パラメーターを構築することもできます。  
  
 このオーバーロードでは、アクセス許可のみを付与できます。これらのユーザーは、取り消したり拒否したりすることはできません。 `Allow`以外の <xref:System.Messaging.AccessControlEntryType> を明示的に付与するには、別のオーバーロードを使用する必要があります。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">キューに対する追加のアクセス権を取得するそれぞれのユーザー、グループ、またはコンピューター。</param>
        <param name="rights">メッセージ キューが <paramref name="user" /> に割り当てるキューに対するアクセス権のセットを示す <see cref="T:System.Messaging.MessageQueueAccessRights" />。</param>
        <param name="entryType"><paramref name="rights" /> パラメーターで指定したアクセス許可で、付与、拒否、取り消しのどの操作を実行するかを指定する <see cref="T:System.Messaging.AccessControlEntryType" />。</param>
        <summary>アクセス制御の種類 (許可、拒否、取り消し、またはセット) からいずれかを指定して、コンピューター、グループ、またはユーザーに指定したアクセス権を付与します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、個々のユーザーに対して指定された権限を許可、拒否、または取り消すことができます。 ユーザーは、個々のユーザー、ユーザーグループ、またはコンピューターを含む任意の有効なトラスティにすることができます。 ユーザーが個人の場合は、`user` パラメーターに `user` `DOMAIN`\\の形式を使用します。 `user` パラメーターに "." を指定すると、ローカルコンピューターを示すことができます。  
  
 によって割り当てられたアクセス許可 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 既存の一覧に権限を追加します。 既定では、パブリックキューまたは専用キューの作成者にはフルコントロールがあり、ドメイングループのすべてのユーザーは、キュープロパティの取得、アクセス許可の取得、およびキューへの書き込みを行う権限を持っています。 <xref:System.Messaging.MessageQueue.SetPermissions%2A>を呼び出すと、ユーザーと権限の情報が既存のリストの下部に追加されます。  
  
 システムは、次のいずれかのイベントが発生するまで、各 <xref:System.Messaging.AccessControlEntry> を順番に検証します。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> は、スレッドのアクセストークンに示されているいずれかのトラスティに対して、要求されたアクセス権を明示的に拒否します。  
  
-   スレッドのアクセストークンに一覧表示されているトラスティの <xref:System.Messaging.AccessControlEntry> 項目1つ以上に、要求されたすべてのアクセス権が明示的に付与されます。  
  
-   すべての <xref:System.Messaging.AccessControlEntry> 項目がチェックされ、明示的に許可されていないアクセス権が少なくとも1つ存在します。この場合、アクセスは暗黙的に拒否されます。  
  
 `rights` パラメーターで指定するキューに対する権限は、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージの削除  
  
-   メッセージの受信  
  
-   メッセージのピーク  
  
-   ジャーナルメッセージの受信  
  
-   キューのプロパティを取得する  
  
-   キューのプロパティの設定  
  
-   アクセス許可の取得  
  
-   アクセス許可を設定する  
  
-   キューの所有権を取得する  
  
-   メッセージの書き込み  
  
 <xref:System.Messaging.MessageQueueAccessRights> 列挙体はビットフラグのセットを表します。ビットフラグは、ビットごとの演算子を使用して組み合わせることも、`rights` パラメーターを構築することもできます。  
  
 次の表に、この方法をさまざまなワークグループモードで使用できるかどうかを示します。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> イベントまたは <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> イベントによって発生したイベント ハンドラー呼び出しをマーシャリングするオブジェクトを取得または設定します。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" /> イベントまたは <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> イベントによって発生したイベント ハンドラー呼び出しをマーシャリングするオブジェクトを表す <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />。 既定では、 <see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> または <xref:System.Messaging.MessageQueue.PeekCompleted> イベントは、それぞれ <xref:System.Messaging.MessageQueue.BeginReceive%2A> または <xref:System.Messaging.MessageQueue.BeginPeek%2A> の要求から特定のスレッドに発生します。 通常、<xref:System.Messaging.MessageQueue.SynchronizingObject%2A> は、関連するコンポーネントがコントロールまたはフォーム内に配置されている場合に設定されます。これは、これらのコンポーネントが特定のスレッドにバインドされるためです。  
  
 通常、同期オブジェクトは、メソッド呼び出しを1つのスレッドにマーシャリングします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューがトランザクションだけを受け入れるかどうかを示す値を取得します。</summary>
        <value>キューがトランザクションの一部として送信されるメッセージだけを受け入れる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トランザクションメッセージングとは、複数の関連するメッセージを1つのトランザクションに結合したものです。 トランザクションの一部としてメッセージを送信すると、メッセージが順番に配信され、1回だけ配信され、送信先キューから正常に取得されるようになります。  
  
 キューがトランザクションである場合は、トランザクションの一部として送信されたメッセージのみが受け入れられます。 ただし、トランザクション <xref:System.Messaging.MessageQueueTransaction.Begin%2A>、<xref:System.Messaging.MessageQueueTransaction.Commit%2A>、および <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 構文を明示的に使用せずに、ローカルトランザクションキューから非トランザクションメッセージを送受信できます。 トランザクションキューに非トランザクションメッセージが送信された場合、このコンポーネントは、直接形式名を使用してリモートコンピューター上のキューを参照する場合を除いて、そのメッセージの単一メッセージトランザクションを作成します。 この場合、メッセージの送信時にトランザクションコンテキストを指定しないと、メッセージは作成されず、メッセージは配信不能キューに送信されます。  
  
 トランザクションキューに非トランザクションメッセージを送信すると、例外が発生した場合にメッセージをロールバックすることはできません。  
  
 <xref:System.Messaging.MessageQueueTransaction> はスレッドアパートメントに対応しているため、アパートメント状態が `STA`場合は、複数のスレッドでトランザクションを使用することはできません。 Visual Basic は、メインスレッドの状態を `STA`に設定するため、<xref:System.MTAThreadAttribute> を `Main` サブルーチンに適用する必要があります。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 次のフラグメントを使用して、<xref:System.MTAThreadAttribute> を適用します。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.Transactional%2A> プロパティの値を表示します。  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信したメッセージを履歴キューにコピーするかどうかを示す値を取得または設定します。</summary>
        <value>キューから受信したメッセージを履歴キューにコピーする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージキューアプリケーションは、新しいアプリケーションキューを作成するときに、関連付けられたジャーナルキューを同じ場所に自動的に作成します。 ジャーナルキューは、キューから削除されたメッセージを追跡するために使用されます。 このプロパティを設定すると、メッセージキューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは変更の影響を受けます。  
  
 ジャーナルキューは、キューから削除されたメッセージを追跡しません。これは、メッセージキューディレクトリサービス (インフォメーションストアまたは Active Directory) を使用して、キューから削除されたメッセージを追跡しないためです。  
  
 アプリケーションは、ジャーナルキューにメッセージを送信できません。これらのキューの読み取り専用アクセスに制限されています。 さらに、メッセージキューは、ジャーナルキューからメッセージを削除しません。 キューを使用するアプリケーションでは、メッセージを受信するか、キューを削除することによって、これらのメッセージをクリアする必要があります。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージキューの <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> プロパティの値を取得して設定します。  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューにメッセージを送信するときに使用するネイティブ ハンドルを取得します。</summary>
        <value>キューにメッセージを送信するときに使用するネイティブ キューオブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> は、キューにメッセージを送信するために使用されるメッセージキューオブジェクトへのネイティブ Windows ハンドルを提供します。 キューのパスを変更すると、ハンドルは閉じられ、新しい値で再び開かれます。  
  
 次の表は、このプロパティがさまざまなワークグループモードで使用できるかどうかを示しています。  
  
|ワークグループモード|利用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカルコンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモートコンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">このメッセージ キューには書き込みができません。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
