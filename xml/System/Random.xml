<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2aed1b5714a0e6455015939efe3b502c6bcff582" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83537832" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Random extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>擬似乱数ジェネレーターを表します。これは、乱数についての特定の統計的な要件を満たす数値系列を生成するアルゴリズムです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擬似乱数は、少数の数値から等しい確率で選択されます。 選択した数値は、数学的アルゴリズムを使用して選択するため、完全にはランダムではありませんが、実用的な目的では十分にランダムです。 <xref:System.Random> クラスの現在の実装は、Donald クヌースの減法乱数ジェネレーターアルゴリズムの変更されたバージョンに基づいています。 詳細については、「d. e.」を参照してください。 クヌース. *コンピュータープログラミングの Art、Volume 2: Seminumerical アルゴリズム*。 Addison-Wesley、読み取り、MA、第3版、1997。  
  
 ランダムなパスワードの作成に適したランダムな乱数を生成するには、<xref:System.Security.Cryptography.RNGCryptoServiceProvider> クラスを使用するか、<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>からクラスを派生させます。  
  
 このトピックの内容:  
  
 [乱数ジェネレーターのインスタンス](#Instantiate)化   
 [複数のインスタンス](#Multiple)化の回避   
 [Random クラスとスレッドセーフ](#ThreadSafety)   
 [さまざまな種類の乱数の生成](#Functionality)   
 [独自のアルゴリズムを使用して](#Overriding)   
 [使用する方法を](#Operations)教えてください。   
 [同じランダムな値のシーケンスを取得します。](#Same)  
 [ランダムな値の一意のシーケンスを取得する](#Unique)  
 [指定された範囲の整数を取得します。](#Range)  
 [指定された桁数の整数を取得します](#Digits)  
 [指定された範囲の浮動小数点値を取得します。](#Floats)  
 [ランダムなブール値の生成](#Boolean)  
 [ランダムな64ビット整数の生成](#Long)  
 [指定した範囲のバイトを取得します。](#Bytes)  
 [配列またはコレクションからランダムに要素を取得する](#Array)  
 [配列またはコレクションから一意の要素を取得する](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>乱数ジェネレーターのインスタンス化  
 乱数ジェネレーターをインスタンス化するには、シード値 (疑似乱数生成アルゴリズムの開始値) を <xref:System.Random.%23ctor%2A> クラスコンストラクターに渡します。  シード値は、明示的または暗黙的に指定できます。  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターは、明示的に指定したシード値を使用します。  
  
-   <xref:System.Random.%23ctor> コンストラクターは、既定のシード値を使用します。 これは、乱数ジェネレーターをインスタンス化する最も一般的な方法です。  
  
 .NET Framework では、既定のシード値は時間に依存します。 .NET Core では、既定のシード値は、スレッド静的、擬似乱数ジェネレーターによって生成されます。
  
 同じシードが個別の <xref:System.Random> オブジェクトに使用されている場合は、同じ一連の乱数が生成されます。 これは、ランダムな値を処理するテストスイートを作成する場合や、ランダムな数値からデータを派生するゲームを再生する場合に便利です。 ただし、異なるバージョンの .NET Framework で実行されているプロセス内の <xref:System.Random> オブジェクトは、同じシード値を使用してインスタンス化されている場合でも、異なる一連の乱数を返す可能性があることに注意してください。  
  
 乱数の異なるシーケンスを生成するには、シード値を時間に依存するようにします。これにより、<xref:System.Random>の新しいインスタンスごとに異なる系列が生成されます。 パラメーター化された <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターは、現在の時刻のタイマー刻み数に基づいて <xref:System.Int32> 値を受け取ることができます。一方、パラメーターなしの <xref:System.Random.%23ctor> コンストラクターは、システムクロックを使用してシード値を生成します。 ただし、.NET Framework についてのみ、時計には有限の解決があるため、パラメーターなしのコンストラクターを使用して、連続して複数の <xref:System.Random> オブジェクトを作成すると、ランダムな数値のシーケンスを生成する乱数ジェネレーターが作成されます。 次の例は、.NET Framework アプリケーションで連続してインスタンス化される2つの <xref:System.Random> オブジェクトが、同一の一連の乱数を生成する方法を示しています。 ほとんどの Windows システムでは、15ミリ秒以内に作成された <xref:System.Random> オブジェクトのシード値が同一である可能性があります。  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp-interactive[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
この問題を回避するには、複数のオブジェクトではなく、単一の <xref:System.Random> オブジェクトを作成します。 .NET Core の `Random` クラスには、このような制限がないことに注意してください。
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>複数のインスタンス化の回避  
 .NET Framework では、2つの乱数ジェネレーターを密ループで初期化するか、高速連続で初期化すると、2つの乱数ジェネレーターが作成され、同一の乱数シーケンスを生成することができます。 ほとんどの場合、これは開発者の意図ではなく、ランダムな数値ジェネレーターのインスタンス化と初期化は比較的コストのかかるプロセスであるため、パフォーマンスの問題が発生する可能性があります。  
  
 パフォーマンスを向上させ、同一の数値シーケンスを生成する個別の乱数ジェネレーターが誤って作成されないようにするために、1つの <xref:System.Random> オブジェクトを作成し、1つの乱数を生成する新しい <xref:System.Random> オブジェクトを作成するのではなく、時間をかけて多数の乱数を生成することをお勧めします。  
  
 ただし、<xref:System.Random> クラスはスレッドセーフではありません。 複数のスレッドから <xref:System.Random> メソッドを呼び出す場合は、次のセクションで説明するガイドラインに従ってください。  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Random クラスとスレッドセーフ  
 個々の <xref:System.Random> オブジェクトをインスタンス化するのではなく、1つの <xref:System.Random> インスタンスを作成して、アプリに必要なすべての乱数を生成することをお勧めします。 ただし、<xref:System.Random> オブジェクトはスレッドセーフではありません。 アプリが複数のスレッドから <xref:System.Random> メソッドを呼び出す場合は、同期オブジェクトを使用して、一度に1つのスレッドだけが乱数ジェネレーターにアクセスできるようにする必要があります。 <xref:System.Random> オブジェクトがスレッドセーフな方法でアクセスされることを保証しない場合、乱数を返すメソッドを呼び出すと0が返されます。  
  
 次の例ではC# 、 [lock ステートメント](~/docs/csharp/language-reference/keywords/lock-statement.md)と Visual Basic [SyncLock ステートメント](~/docs/visual-basic/language-reference/statements/synclock-statement.md)を使用して、スレッドセーフな方法で、1つのランダムな数値ジェネレーターが11個のスレッドによってアクセスされるようにします。 各スレッドは、200万の乱数を生成し、生成された乱数の数をカウントし、合計を計算した後、実行が終了したときにすべてのスレッドの合計を更新します。  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 この例では、次の方法でスレッドセーフを確保します。  
  
-   <xref:System.ThreadStaticAttribute> 属性は、生成された乱数の合計数と各スレッドの合計を追跡するスレッドローカル変数を定義するために使用されます。  
  
-   ロック (のC# `lock` ステートメントと Visual Basic の `SyncLock` ステートメント) によって、すべてのスレッドで生成されたすべてのランダムな数値の合計数と合計の変数へのアクセスが保護されます。  
  
-   セマフォ (<xref:System.Threading.CountdownEvent> オブジェクト) は、他のすべてのスレッドが実行を完了するまで、メインスレッドがブロックされるようにするために使用されます。  
  
-   この例では、乱数生成メソッドの2回の連続呼び出しが0を返すかどうかを判断することによって、乱数ジェネレーターが破損しているかどうかを確認します。 破損が検出された場合、この例では、<xref:System.Threading.CancellationTokenSource> オブジェクトを使用して、すべてのスレッドをキャンセルする必要があることを通知します。  
  
-   各スレッドは、ランダムな数値を生成する前に、<xref:System.Threading.CancellationToken> オブジェクトの状態を確認します。 キャンセルが要求された場合、この例では、<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> メソッドを呼び出してスレッドをキャンセルします。  
  
 次の例は、最初の例と同じですが、<xref:System.Threading.Thread> オブジェクトではなく、<xref:System.Threading.Tasks.Task> オブジェクトとラムダ式を使用している点が異なります。  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 これは、次の方法の最初の例とは異なります。  
  
-   生成される乱数の数と各タスクの合計を追跡する変数は、タスクに対してローカルであるため、<xref:System.ThreadStaticAttribute> 属性を使用する必要はありません。  
  
-   静的 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドは、すべてのタスクが完了する前にメインスレッドが完了しないようにするために使用されます。 <xref:System.Threading.CountdownEvent> オブジェクトは必要ありません。  
  
-   タスクのキャンセルによって生成される例外は、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドに表示されます。 前の例では、各スレッドによって処理されます。  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>さまざまな種類の乱数を生成する  
 乱数ジェネレーターには、次の種類の乱数を生成できるメソッドが用意されています。  
  
-   一連の <xref:System.Byte> 値。 バイト値の数を決定するには、メソッドが <xref:System.Random.NextBytes%2A> メソッドに返す要素の数に初期化された配列を渡します。 次の例では、20バイトが生成されます。  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp-interactive[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   単一の整数。 <xref:System.Random.Next> メソッド、<xref:System.Random.Next%28System.Int32%29> メソッドを呼び出すことによって0から特定の値までの整数、または <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すことによって値の範囲内の整数を呼び出すことによって、0から最大値 (<xref:System.Int32.MaxValue?displayProperty=nameWithType>-1) までの整数を使用するかどうかを選択できます。 パラメーター化されたオーバーロードでは、指定された最大値は排他的です。つまり、生成される実際の最大数は、指定された値より1だけ少なくなります。  
  
     次の例では、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出して、-10 ~ 10 の10個の乱数を生成します。 メソッドの2番目の引数は、メソッドによって返されるランダム値の範囲の排他的上限を指定することに注意してください。 言い換えると、メソッドが返すことができる最大の整数は、この値より1小さい値になります。  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp-interactive[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <xref:System.Random.NextDouble%2A> メソッドを呼び出すことによって、0.0 ~ 1.0 未満の1つの浮動小数点値。 メソッドによって返される乱数の排他的上限は1であるため、実際の上限は0.99999999999999978 です。 次の例では、10個のランダムな浮動小数点数が生成されます。  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp-interactive[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを使用すると、返される乱数値の範囲を指定できます。 ただし、返される上限の数値を指定する `maxValue` パラメーターは、包含的な値ではなく、排他的です。 つまり、メソッド呼び出し `Next(0, 100)` は 0 ~ 99 の範囲の値を返し、0と100の間では返されません。  
  
 <xref:System.Random> クラスは、[ランダムな T:System.Boolean 値](#Boolean)の生成、 [0 から1以外の範囲を持つランダム浮動小数点値](#Floats)の生成、[ランダムな64ビット整数](#Long)の生成、[配列またはコレクションからの一意の要素のランダムな取得](#UniqueArray)などのタスクにも使用できます。 これらのタスクおよびその他の一般的なタスクについては、「 [How to use The Random to..](#Operations) . 下.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>独自のアルゴリズムを使用する  
 <xref:System.Random> クラスから継承し、乱数生成アルゴリズムを提供することで、独自の乱数ジェネレーターを実装できます。 独自のアルゴリズムを提供するには、乱数生成アルゴリズムを実装する <xref:System.Random.Sample%2A> メソッドをオーバーライドする必要があります。 また、<xref:System.Random.Next>、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>、および <xref:System.Random.NextBytes%2A> メソッドをオーバーライドして、オーバーライドされた <xref:System.Random.Sample%2A> メソッドを呼び出すようにする必要があります。 <xref:System.Random.Next%28System.Int32%29> および <xref:System.Random.NextDouble%2A> メソッドをオーバーライドする必要はありません。  
  
 <xref:System.Random> クラスから派生し、既定の擬似乱数ジェネレーターを変更する例については、<xref:System.Random.Sample%2A> リファレンスページを参照してください。  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>使用する方法を教えてください。  
 以下のセクションでは、アプリで乱数を使用するいくつかの方法のサンプルコードについて説明します。  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>同じランダムな値のシーケンスを取得します。  
 ソフトウェアテストシナリオとゲームプレイで、同じ乱数シーケンスを生成することが必要になる場合があります。 乱数の同じシーケンスを使用してテストすることで、回帰を検出し、バグ修正を確認することができます。 ゲームで同じ乱数シーケンスを使用すると、以前のゲームを再生できます。  
  
 同じシード値を <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターに渡すことによって、同じシーケンスの乱数を生成できます。 シード値は、擬似乱数生成アルゴリズムの開始値を提供します。 次の例では、任意のシード値として100100を使用して <xref:System.Random> オブジェクトをインスタンス化し、20個のランダムな浮動小数点値を表示して、シード値を保持します。 次に、シード値を復元し、新しい乱数ジェネレーターをインスタンス化し、同じ20個のランダムな浮動小数点値を表示します。  この例では、異なるバージョンの .NET Framework で実行した場合に、異なる乱数シーケンスが生成される可能性があることに注意してください。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb" id="Snippet12":::
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>ランダムな数値の一意のシーケンスを取得する  
 <xref:System.Random> クラスのインスタンスに異なるシード値を指定すると、各乱数ジェネレーターによって異なる値のシーケンスが生成されます。 シード値は、<xref:System.Random.%23ctor%28System.Int32%29> コンストラクターを呼び出すことによって明示的に指定することも、<xref:System.Random.%23ctor> コンストラクターを呼び出すことによって暗黙的に指定することもできます。 ほとんどの開発者は、システムクロックを使用するパラメーターなしのコンストラクターを呼び出します。 次の例では、この方法を使用して、2つの <xref:System.Random> インスタンスをインスタンス化します。 各インスタンスには、10個のランダムな整数が表示されます。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp" id="Snippet13":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb" id="Snippet13":::

 ただし、このような制限があるため、システムクロックでは、約15ミリ秒未満の時間差は検出されません。 したがって、コードが .NET Framework の <xref:System.Random.%23ctor> オーバーロードを呼び出して、2つの <xref:System.Random> オブジェクトを連続してインスタンス化する場合、誤ってシード値を持つオブジェクトを提供することがあります。 (.NET Core の <xref:System.Random> クラスには、このような制限はありません)。前の例でこれを確認するには、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドの呼び出しをコメントアウトし、この例をもう一度コンパイルして実行します。  
  
 これが起こらないようにするために、複数のオブジェクトではなく、単一の <xref:System.Random> オブジェクトをインスタンス化することをお勧めします。 ただし、<xref:System.Random> はスレッドセーフではないため、複数のスレッドから <xref:System.Random> インスタンスにアクセスする場合は、同期デバイスを使用する必要があります。詳細については、このトピックで前述し[た「ランダムクラスとスレッドセーフ](#ThreadSafety)」を参照してください。 または、前の例で使用した <xref:System.Threading.Thread.Sleep%2A> メソッドなどの遅延メカニズムを使用して、インスタンス化が15ミリ秒以上離れていることを確認することもできます。  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>指定された範囲の整数を取得します。  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すことによって、指定した範囲の整数を取得できます。これにより、乱数ジェネレーターが返す数値の下限と上限の両方を指定できます。 上限は、包含的な値ではなく、排他的です。 つまり、メソッドによって返される値の範囲には含まれません。 次の例では、このメソッドを使用して、-10 ~ 10 の間のランダムな整数を生成します。 ここでは、メソッド呼び出しの `maxValue` 引数の値として、目的の値より1つ大きい値である11を指定していることに注意してください。  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp-interactive[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>指定された桁数の整数を取得します  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すと、指定された桁数の数値を取得できます。 たとえば、次の例に示すように、4桁の数字 (つまり、1000から9999の範囲の数値) を取得するには、`minValue` の値1000と1万の `maxValue` 値を指定して <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出します。  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp-interactive[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>指定された範囲の浮動小数点値を取得します。  
 <xref:System.Random.NextDouble%2A> メソッドは、0から1未満の範囲のランダム浮動小数点値を返します。 ただし、多くの場合、他の範囲でランダムな値を生成することをお勧めします。  
  
 最小値と最大値の間の間隔が1の場合は、目的の開始間隔と0に <xref:System.Random.NextDouble%2A> メソッドによって返される数値の差を加算できます。 次の例では、-1 から0までの10個の乱数を生成します。  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp-interactive[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 下限が0で、上限が1より大きい (負の値の場合、下限が-1 より小さく、上限が0である) ランダム浮動小数点数を生成するには、0以外の値で乱数を乗算します。 次の例では、0から <xref:System.Int64.MaxValue?displayProperty=nameWithType>までの範囲で、2000万のランダムな浮動小数点数を生成します。 では、メソッドによって生成されるランダム値の分布も表示されます。  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp-interactive[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 整数の <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドのように、任意の2つの値の間にランダムな浮動小数点数を生成するには、次の式を使用します。  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 次の例では、10.0 から11.0 までの範囲の100万乱数を生成し、それらの分布を表示します。  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp-interactive[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>ランダムなブール値の生成  
 <xref:System.Random> クラスには、<xref:System.Boolean> 値を生成するメソッドが用意されていません。 ただし、独自のクラスまたはメソッドを定義して、それを行うことができます。 次の例では、1つのメソッド、`NextBoolean`を使用して、クラス `BooleanGenerator`を定義しています。 `BooleanGenerator` クラスは、<xref:System.Random> オブジェクトをプライベート変数として格納します。 `NextBoolean` メソッドは、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出し、その結果を <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> メソッドに渡します。 2を引数として使用して、乱数の上限を指定することに注意してください。 これは排他的な値であるため、メソッドの呼び出しは0または1のいずれかを返します。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp" id="Snippet8":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb" id="Snippet8":::
  
 ランダム <xref:System.Boolean> 値を生成するために個別のクラスを作成するのではなく、単に1つのメソッドを定義するだけで済みます。 ただし、この場合、<xref:System.Random> オブジェクトはクラスレベルの変数として定義されている必要があります。これは、各メソッドの呼び出しで新しい <xref:System.Random> インスタンスをインスタンス化しないようにするためです。 Visual Basic では、`NextBoolean` メソッドで、ランダムインスタンスを[静的](~/docs/visual-basic/language-reference/modifiers/static.md)変数として定義できます。  次の例は、の実装を示しています。  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp-interactive[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>ランダムな64ビット整数の生成  
 <xref:System.Random.Next%2A> メソッドのオーバーロードは、32ビットの整数を返します。 ただし、場合によっては、64ビットの整数を使用する必要があります。 これは、次のようにして行うことができます。  
  
1.  <xref:System.Random.NextDouble%2A> メソッドを呼び出して、倍精度浮動小数点値を取得します。  
  
2.  この値を <xref:System.Int64.MaxValue?displayProperty=nameWithType>で乗算します。  
  
 次の例では、この手法を使用して、2000万のランダムな長整数を生成し、10個の等しいグループに分類しています。 次に、各グループの数値を0から <xref:System.Int64.MaxValue?displayProperty=nameWithType>にカウントすることで、ランダムな数値の分布を評価します。 この例の出力に示すように、数値は長整数の範囲によってより均等に分布されます。  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp-interactive[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 ビット操作を使用する別の手法では、真の乱数は生成されません。 この手法では、<xref:System.Random.Next> を呼び出して2つの整数を生成し、32ビットずつ左シフトして、それらをまとめています。 この手法には、次の2つの制限があります。  
  
1.  ビット31は符号ビットであるため、結果として得られる長整数のビット31の値は常に0になります。  これを解決するには、ランダムな0または1を生成し、31ビットを左にシフトして、それを元のランダム長整数にします。  
  
2.  さらに真剣には、<xref:System.Random.Next> によって返される値が0になる確率があるため、範囲 0x0 ~ 0x00000000FFFFFFFF に乱数がある場合は数が少なくなります。  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>指定した範囲のバイトを取得します。  
 <xref:System.Random.Next%2A> メソッドのオーバーロードでは、乱数の範囲を指定できますが、<xref:System.Random.NextBytes%2A> メソッドでは指定できません。 次の例では、返されるバイトの範囲を指定できるようにする `NextBytes` メソッドを実装しています。 <xref:System.Random> から派生し、その `NextBytes` メソッドをオーバーロードする `Random2` クラスを定義します。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb" id="Snippet9":::

 `NextBytes(Byte[], Byte, Byte)` メソッドは、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドの呼び出しをラップし、バイト配列で返される最小値と最大値 (この場合は0および 101) を指定します。 <xref:System.Random.Next%2A> メソッドによって返される整数値は <xref:System.Byte> データ型の範囲内であることが確実であるため、(でC#は) それらを安全にキャストするか、(Visual Basic) 整数からバイトに変換することができます。  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>配列またはコレクションからランダムに要素を取得する  
 ランダムな数値は、多くの場合、配列またはコレクションから値を取得するためのインデックスとして機能します。 ランダムインデックス値を取得するには、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出し、配列の下限をその `minValue` 引数の値として使用し、`maxValue` 引数の値として配列の上限を超えて使用します。 0から始まる配列の場合、これは <xref:System.Array.Length%2A> プロパティと同じか、または <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> メソッドによって返される値よりも1つ大きい値になります。 次の例では、都市の配列から米国にある市区町村の名前をランダムに取得します。  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp-interactive[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>配列またはコレクションから一意の要素を取得する  
 乱数ジェネレーターは、常に重複する値を返すことができます。 数値の範囲が小さくなるか、生成される値の数が多いほど、重複の可能性が大きくなります。 ランダムな値を一意にする必要がある場合は、重複を補正するためにより多くの数値が生成されるため、パフォーマンスが低下します。  
  
 このシナリオに対処するための手法がいくつかあります。 一般的な解決策の1つは、取得する値を格納する配列またはコレクション、およびランダムな浮動小数点数を含む並列配列を作成することです。 2番目の配列には、最初の配列が作成された時点で乱数が格納されます。また、<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> メソッドを使用して、並列配列の値を使用して最初の配列を並べ替えます。  
  
 たとえば、ソリティアゲームを開発している場合は、各カードが1回だけ使用されていることを確認する必要があります。 カードを取得するために乱数を生成する代わりに、カードが既に処理されているかどうかを追跡するには、デッキの並べ替えに使用できるランダムな数値の並列配列を作成します。 デッキが並べ替えられると、アプリは、デッキの次のカードのインデックスを示すポインターを維持できます。  
  
 このアプローチの例を次に示します。 再生カードを表す `Card` クラスと、シャッフルされたカードのデッキを扱う `Dealer` クラスを定義します。 `Dealer` クラスコンストラクターは、2つの配列 (クラススコープを持ち、デッキ内のすべてのカードを表す `deck` 配列) を設定します。と、`deck` 配列と同じ数の要素を持ち、ランダムに生成された <xref:System.Double> 値が設定されたローカル `order` 配列。  次に、<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> メソッドを呼び出して、`order` 配列の値に基づいて `deck` 配列を並べ替えます。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp" id="Snippet11":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb" id="Snippet11":::
  
## Examples  

 次の例では、乱数ジェネレーターを1つ作成し、その <xref:System.Random.NextBytes%2A>、<xref:System.Random.Next%2A>、および <xref:System.Random.NextDouble%2A> メソッドを呼び出して、異なる範囲内のランダムな数値のシーケンスを生成します。  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp-interactive[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>.NET Framework 1.0 および1.1 では、<see cref="T:System.Random" /> から派生したクラスの最小実装で、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドして、乱数を生成するための新しいアルゴリズムまたは変更されたアルゴリズムを定義する必要があります。 派生クラスは、<see cref="M:System.Random.Next" />、<see cref="M:System.Random.Next(System.Int32)" />、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />、<see cref="M:System.Random.NextBytes(System.Byte[])" />、および <see cref="M:System.Random.NextDouble" /> メソッドの基本クラスの実装に依存して、<see cref="M:System.Random.Sample" /> メソッドの派生クラスの実装を呼び出すことができます。  
  
.NET Framework 2.0 以降では、これらのメソッドが <see cref="M:System.Random.Sample" /> メソッドの派生クラスの実装を呼び出すことがないように、<see cref="M:System.Random.Next" />、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />、および <see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッドの動作が変更されました。 結果として、.NET Framework 2.0 以降を対象とする <see cref="T:System.Random" /> から派生したクラスでも、これら3つのメソッドをオーバーライドする必要があります。</para></block>
    <block subset="none" type="usage"><para><see cref="T:System.Random" /> クラスでの乱数ジェネレーターの実装は、.NET Framework のメジャーバージョン間で同じままであることは保証されていません。 その結果、同じシードによって、.NET Framework の異なるバージョンで同じ擬似ランダムシーケンスが生成されるとは限りません。</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>既定のシード値を使用して <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
.NET Framework では、既定のシード値は、有限の解決を持つシステムクロックから派生します。 結果として、パラメーターなしのコンストラクターの呼び出しによって連続して作成された異なる <xref:System.Random> オブジェクトは、同じ既定のシード値を持つため、同じセットの乱数を生成します。 この問題を回避するには、単一の <xref:System.Random> オブジェクトを使用してすべての乱数を生成します。 また、独自のランダムシード値を生成し、それを <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターに渡すことによって回避することもできます。 詳細については、<xref:System.Random.%23ctor%28System.Int32%29> コンストラクターを参照してください。 

.NET Core では、既定のシード値はスレッド静的擬似乱数ジェネレーターによって生成されるため、前述の制限は適用されません。 連続して作成された <xref:System.Random> オブジェクトの数が異なると、.NET Core では異なる乱数セットが生成されます。
  
 乱数ジェネレーターでランダムな数値シーケンスを生成する場合は、このコンストラクターを呼び出します。 異なる乱数ジェネレーターに対して同じである固定シーケンスの乱数を生成するには、固定のシード値を使用して <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターを呼び出します。 この <xref:System.Random> コンストラクターオーバーロードは、ランダムな数値を使用するアプリをテストするときによく使用されます。  
  
 乱数ジェネレーターをインスタンス化したら、<xref:System.Random.Next> や <xref:System.Random.NextDouble>などの個々の <xref:System.Random> メソッドを呼び出して、乱数を生成します。  
  
   
  
## Examples

次の例では、パラメーターなしのコンストラクターを使用して、3つの <xref:System.Random> オブジェクトをインスタンス化し、それぞれに対して5つのランダムな整数のシーケンスを表示します。 最初の2つの <xref:System.Random> オブジェクトが連続して作成されるため、.NET Framework で実行される場合は、システムクロックに基づいて同一のシード値を使用してインスタンス化されます。したがって、同じシーケンスの乱数が生成されます。 一方、3番目の <xref:System.Random> オブジェクトのパラメーターなしのコンストラクターは、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドの呼び出しによって発生する2秒の遅延の後に呼び出されます。 これにより、3つ目の <xref:System.Random> オブジェクトに対して異なるシード値が生成されるため、異なる乱数のシーケンスが生成されます。  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">擬似乱数系列の開始値を計算するために使用する数値。 負数を指定した場合、その数値の絶対値が使用されます。</param>
        <summary>指定したシード値を使用して <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なる <xref:System.Random> オブジェクトに同一のシード値を指定すると、各インスタンスで同一の乱数シーケンスが生成されます。 これは、ランダムな数値ジェネレーターに依存するアプリをテストする場合によく行われます。  
  
 アプリケーションで異なる乱数シーケンスが必要な場合は、別のシード値を使用してこのコンストラクターを繰り返し呼び出します。 一意のシード値を生成する方法の1つは、時間に依存するようにすることです。 たとえば、<xref:System.Random.%23ctor> のオーバーロードと同じように、システムクロックからシード値を派生させます。 ただし、システムクロックには、別のシード値を持つこのコンストラクターの異なる呼び出しを提供するための十分な解決策がない可能性があります。 この .NET Framework では、次の例の最初の2つの <xref:System.Random> オブジェクトに示すように、擬似乱数の同じシーケンスを生成する乱数ジェネレーターが生成されます。 これを回避するには、各呼び出しのシード値を区別するためのアルゴリズムを適用するか、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドを呼び出して、各コンストラクターに異なるシード値を指定していることを確認します。  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 もう1つのオプションは、アプリケーションのすべての乱数を生成するために使用する単一の <xref:System.Random> オブジェクトをインスタンス化することです。 乱数ジェネレーターのインスタンス化にはかなりのコストがかかるため、パフォーマンスが若干向上します。  
  
   
  
## Examples  
 次の例では、シードパラメーターを受け取り、ランダムな整数と倍精度のシーケンスを生成するクラスコンストラクターを使用して <xref:System.Random> オブジェクトを作成します。 この例では、コンストラクターとシードパラメーターを使用して <xref:System.Random> オブジェクトを再作成するときに、同じシーケンスが生成されることを示しています。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ランダムな整数を返します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0 以上のランダムな整数を返します。</summary>
        <returns>0 以上で <see cref="F:System.Int32.MaxValue" /> より小さい 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> は、値の範囲が 0 ~ <xref:System.Int32.MaxValue?displayProperty=nameWithType>未満の乱数を生成します。 値の範囲が 0 ~ 他の正の数値の乱数を生成するには、<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> メソッドのオーバーロードを使用します。 異なる範囲内の乱数を生成するには、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドオーバーロードを使用します。  
  
   
  
## Examples  
 次の例では、<xref:System.Random.Next%2A> メソッドを繰り返し呼び出して、ユーザーによって要求された特定の数の乱数を生成します。 <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> メソッドは、顧客の入力を取得するために使用されます。  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 次の例では、<xref:System.Random> からクラスを派生させることにより、基本クラスの <xref:System.Random.Sample%2A> メソッドによって生成される一様分布とは異なる分布を持つランダムな数値のシーケンスを生成します。 <xref:System.Random.Sample%2A> メソッドをオーバーライドしてランダムな数値の分布を指定し、<xref:System.Random.Next%2A?displayProperty=nameWithType> メソッドをオーバーライドして一連の乱数を使用します。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Sample" /> メソッドの派生クラス実装によって提供される分布は、<see cref="M:System.Random.Next" /> メソッドの基本クラス実装の呼び出しでは使用されません。 代わりに、基本 <see cref="T:System.Random" /> クラスによって返される一様分布が使用されます。 この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。 派生クラスで <see cref="M:System.Random.Sample" /> メソッドを呼び出すようにこの動作を変更するには、<see cref="M:System.Random.Next" /> メソッドもオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">生成される乱数の排他的上限値。 <paramref name="maxValue" /> は 0 以上にする必要があります。</param>
        <summary>指定した最大値より小さい 0 以上のランダムな整数を返します。</summary>
        <returns>0 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付き整数。つまり、通常は戻り値の範囲に 0 は含まれますが、<paramref name="maxValue" /> は含まれません。 ただし、<paramref name="maxValue" /> が 0 の場合は、<paramref name="maxValue" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29> のオーバーロードは、0 ~ `maxValue`-1 の範囲のランダムな整数を返します。 ただし、`maxValue` が0の場合、メソッドは0を返します。  
  
   
  
## Examples  
 次の例では、<xref:System.Random.Next%2A> メソッドのさまざまなオーバーロードを使用して、ランダムな整数を生成します。  

 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp-interactive[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。 配列の最大インデックスはその長さよりも小さいので、<xref:System.Array.Length%2A?displayProperty=nameWithType> プロパティの値は `maxValue` パラメーターとして指定されます。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">返される乱数の包括的下限値。</param>
        <param name="maxValue">返される乱数の排他的上限値。 <paramref name="maxValue" /> は <paramref name="minValue" /> 以上である必要があります。</param>
        <summary>指定した範囲内のランダムな整数を返します。</summary>
        <returns><paramref name="minValue" /> 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付整数。つまり、戻り値の範囲に <paramref name="minValue" /> は含まれますが <paramref name="maxValue" /> は含まれません。 <paramref name="minValue" /> が <paramref name="maxValue" /> と等しい場合は、<paramref name="minValue" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> のオーバーロードは、`minValue` から `maxValue`-1 までの範囲のランダムな整数を返します。 ただし `maxValue` が `minValue`に等しい場合、メソッドは `minValue`を返します。  
  
 負でない値のみを返す <xref:System.Random.Next%2A> メソッドの他のオーバーロードとは異なり、このメソッドは負の整数を返すことができます。  
  
   
  
## Examples  
 次の例では、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを使用して、3つの異なる範囲を持つランダムな整数を生成します。 この例の正確な出力は、<xref:System.Random> クラスコンストラクターに渡されるシステム指定のシード値によって異なります。  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp-interactive[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。 配列の最大インデックスはその長さよりも小さいので、<xref:System.Array.Length%2A?displayProperty=nameWithType> プロパティの値は `maxValue` パラメーターとして指定されます。  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp-interactive[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" /> が <paramref name="maxValue" /> より大きくなっています。</exception>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> パラメーターと <paramref name="minValue" /> パラメーターの差が <paramref name="maxValue" /> よりも大きい場合、<see cref="F:System.Int32.MaxValue" />メソッドオーバーロードの基底クラス実装によっ <see cref="M:System.Random.Sample" /> て提供される分布では使用されません。 代わりに、基本 <see cref="T:System.Random" /> クラスによって返される一様分布が使用されます。 この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。 派生クラスで <see cref="M:System.Random.Sample" /> メソッドを呼び出すようにこの動作を変更するには、<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> メソッドのオーバーロードもオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">乱数が格納される配列。</param>
        <summary>指定したバイト配列の要素に乱数を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バイト配列の各要素には、0以上、<xref:System.Byte.MaxValue>以下の乱数が設定されています。  
  
 たとえば、ランダムなパスワードの作成に適した暗号的に保護されたランダムな数値を生成するには、<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>などのメソッドを使用します。  
  
   
  
## Examples

 次の例は、<xref:System.Random.NextBytes%2A> メソッドを使用して、バイト配列にランダムバイト値を格納する方法を示しています。  
 
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Sample" /> メソッドの派生クラス実装によって提供される分布は、<see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッドの基本クラス実装の呼び出しでは使用されません。 代わりに、基本 <see cref="T:System.Random" /> クラスによって返される一様分布が使用されます。 この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。 派生クラスで <see cref="M:System.Random.Sample" /> メソッドを呼び出すようにこの動作を変更するには、<see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッドもオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">乱数が格納される配列。</param>
        <summary>指定したバイト範囲の要素に乱数を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

バイトの範囲の各要素には、0以上 <xref:System.Byte.MaxValue>以下の乱数が設定されます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 以上 1.0 未満のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される乱数の実際の上限は0.99999999999999978 です。  
  
 0.0 および1.0 以外の範囲内のランダムな浮動小数点値を取得するには、<xref:System.Random> クラスのトピックの「指定された範囲の浮動小数点値を取得する」セクションを参照してください。  
  
 このメソッドは、保護されたメソッドのパブリックバージョンであり、<xref:System.Random.Sample%2A>ます。  
  
   
  
## Examples  

 次の例では、<xref:System.Random.NextDouble%2A> メソッドを使用して、ランダムな倍精度のシーケンスを生成します。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 次の例では、<xref:System.Random.NextDouble%2A> メソッドを呼び出して、100の乱数を生成し、その頻度分布を表示します。  
  
 [!code-csharp-interactive[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 と 1.0 の間のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なるランダム分布または異なる乱数ジェネレーターの原則を生成するには、<xref:System.Random> クラスからクラスを派生させ、<xref:System.Random.Sample%2A> メソッドをオーバーライドします。  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A> メソッドは `protected`であり、<xref:System.Random> クラスとその派生クラス内でのみアクセス可能であることを意味します。 <xref:System.Random> インスタンスから0と1の間の乱数を生成するには、<xref:System.Random.NextDouble%2A> メソッドを呼び出します。  
  
   
  
## Examples  
 次の例では、<xref:System.Random> からクラスを派生し、<xref:System.Random.Sample%2A> メソッドをオーバーライドして、乱数の分布を生成します。 この分布は、基本クラスの <xref:System.Random.Sample%2A> メソッドによって生成される均一分布とは異なります。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Sample" /> メソッドの派生クラス実装によって提供される分布は、次のメソッドの基本クラス実装の呼び出しでは使用されません。 
-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッド。  
  
-   <see cref="M:System.Random.Next" /> メソッド。  
  
-(<paramref name="maxValue" /> - <paramref name="minValue" />) の場合、<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> メソッドは <see cref="F:System.Int32.MaxValue" />を超えています。  
  
代わりに、基本 <see cref="T:System.Random" /> クラスによって提供される一様分布が使用されます。 この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。 この動作を変更して、派生クラスの <see cref="M:System.Random.Sample" /> メソッドの実装を呼び出すには、これら3つのメンバーの動作をオーバーライドする必要もあります。 具体的な例を次に示します。</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
