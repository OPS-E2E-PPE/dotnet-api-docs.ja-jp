<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65ecae8ea9a178625a30bd6f92a4ac720d13c07f" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83965919" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Random extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="649f7-101">擬似乱数ジェネレーターを表します。これは、乱数についての特定の統計的な要件を満たす数値系列を生成するアルゴリズムです。</span><span class="sxs-lookup"><span data-stu-id="649f7-101">Represents a pseudo-random number generator, which is an algorithm that produces a sequence of numbers that meet certain statistical requirements for randomness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-102">擬似乱数は、少数の数値から等しい確率で選択されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="649f7-103">選択した数値は、数学的アルゴリズムを使用して選択するため、完全にはランダムではありませんが、実用的な目的では十分にランダムです。</span><span class="sxs-lookup"><span data-stu-id="649f7-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="649f7-104"><xref:System.Random> クラスの現在の実装は、Donald クヌースの減法乱数ジェネレーターアルゴリズムの変更されたバージョンに基づいています。</span><span class="sxs-lookup"><span data-stu-id="649f7-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="649f7-105">詳細については、「d. e.」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-105">For more information, see D. E.</span></span> <span data-ttu-id="649f7-106">クヌース.</span><span class="sxs-lookup"><span data-stu-id="649f7-106">Knuth.</span></span> <span data-ttu-id="649f7-107">*コンピュータープログラミングの Art、Volume 2: Seminumerical アルゴリズム*。</span><span class="sxs-lookup"><span data-stu-id="649f7-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="649f7-108">Addison-Wesley、読み取り、MA、第3版、1997。</span><span class="sxs-lookup"><span data-stu-id="649f7-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="649f7-109">ランダムなパスワードの作成に適したランダムな乱数を生成するには、<xref:System.Security.Cryptography.RNGCryptoServiceProvider> クラスを使用するか、<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>からクラスを派生させます。</span><span class="sxs-lookup"><span data-stu-id="649f7-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="649f7-110">このトピックの内容:</span><span class="sxs-lookup"><span data-stu-id="649f7-110">In this topic:</span></span>  
  
 <span data-ttu-id="649f7-111">[乱数ジェネレーターのインスタンス](#Instantiate)化 </span><span class="sxs-lookup"><span data-stu-id="649f7-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="649f7-112">[複数のインスタンス](#Multiple)化の回避 </span><span class="sxs-lookup"><span data-stu-id="649f7-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="649f7-113">[Random クラスとスレッドセーフ](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="649f7-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="649f7-114">[さまざまな種類の乱数の生成](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="649f7-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="649f7-115">[独自のアルゴリズムを使用して](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="649f7-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="649f7-116">[使用する方法を](#Operations)教えてください。 </span><span class="sxs-lookup"><span data-stu-id="649f7-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="649f7-117">同じランダムな値のシーケンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="649f7-118">ランダムな値の一意のシーケンスを取得する</span><span class="sxs-lookup"><span data-stu-id="649f7-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="649f7-119">指定された範囲の整数を取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="649f7-120">指定された桁数の整数を取得します</span><span class="sxs-lookup"><span data-stu-id="649f7-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="649f7-121">指定された範囲の浮動小数点値を取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="649f7-122">ランダムなブール値の生成</span><span class="sxs-lookup"><span data-stu-id="649f7-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="649f7-123">ランダムな64ビット整数の生成</span><span class="sxs-lookup"><span data-stu-id="649f7-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="649f7-124">指定した範囲のバイトを取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="649f7-125">配列またはコレクションからランダムに要素を取得する</span><span class="sxs-lookup"><span data-stu-id="649f7-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="649f7-126">配列またはコレクションから一意の要素を取得する</span><span class="sxs-lookup"><span data-stu-id="649f7-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="649f7-127">乱数ジェネレーターのインスタンス化</span><span class="sxs-lookup"><span data-stu-id="649f7-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="649f7-128">乱数ジェネレーターをインスタンス化するには、シード値 (疑似乱数生成アルゴリズムの開始値) を <xref:System.Random.%23ctor%2A> クラスコンストラクターに渡します。</span><span class="sxs-lookup"><span data-stu-id="649f7-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="649f7-129">シード値は、明示的または暗黙的に指定できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="649f7-130"><xref:System.Random.%23ctor%28System.Int32%29> コンストラクターは、明示的に指定したシード値を使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="649f7-131"><xref:System.Random.%23ctor> コンストラクターは、既定のシード値を使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-131">The <xref:System.Random.%23ctor> constructor uses the default seed value.</span></span> <span data-ttu-id="649f7-132">これは、乱数ジェネレーターをインスタンス化する最も一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="649f7-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="649f7-133">.NET Framework では、既定のシード値は時間に依存します。</span><span class="sxs-lookup"><span data-stu-id="649f7-133">In .NET Framework, the default seed value is time-dependent.</span></span> <span data-ttu-id="649f7-134">.NET Core では、既定のシード値は、スレッド静的、擬似乱数ジェネレーターによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-134">In .NET Core, the default seed value is produced by the thread-static, pseudo-random number generator.</span></span>
  
 <span data-ttu-id="649f7-135">同じシードが個別の <xref:System.Random> オブジェクトに使用されている場合は、同じ一連の乱数が生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-135">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="649f7-136">これは、ランダムな値を処理するテストスイートを作成する場合や、ランダムな数値からデータを派生するゲームを再生する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="649f7-136">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="649f7-137">ただし、異なるバージョンの .NET Framework で実行されているプロセス内の <xref:System.Random> オブジェクトは、同じシード値を使用してインスタンス化されている場合でも、異なる一連の乱数を返す可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-137">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="649f7-138">乱数の異なるシーケンスを生成するには、シード値を時間に依存するようにします。これにより、<xref:System.Random>の新しいインスタンスごとに異なる系列が生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-138">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="649f7-139">パラメーター化された <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターは、現在の時刻のタイマー刻み数に基づいて <xref:System.Int32> 値を受け取ることができます。一方、パラメーターなしの <xref:System.Random.%23ctor> コンストラクターは、システムクロックを使用してシード値を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-139">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="649f7-140">ただし、.NET Framework についてのみ、時計には有限の解決があるため、パラメーターなしのコンストラクターを使用して、連続して複数の <xref:System.Random> オブジェクトを作成すると、ランダムな数値のシーケンスを生成する乱数ジェネレーターが作成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-140">However, on the .NET Framework only, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="649f7-141">次の例は、.NET Framework アプリケーションで連続してインスタンス化される2つの <xref:System.Random> オブジェクトが、同一の一連の乱数を生成する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="649f7-141">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession in a .NET Framework application generate an identical series of random numbers.</span></span> <span data-ttu-id="649f7-142">ほとんどの Windows システムでは、15ミリ秒以内に作成された <xref:System.Random> オブジェクトのシード値が同一である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-142">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp-interactive[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
<span data-ttu-id="649f7-143">この問題を回避するには、複数のオブジェクトではなく、単一の <xref:System.Random> オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-143">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span> <span data-ttu-id="649f7-144">.NET Core の `Random` クラスには、このような制限がないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-144">Note that the `Random` class in .NET Core does not have this limitation.</span></span>
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="649f7-145">複数のインスタンス化の回避</span><span class="sxs-lookup"><span data-stu-id="649f7-145">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="649f7-146">.NET Framework では、2つの乱数ジェネレーターを密ループで初期化するか、高速連続で初期化すると、2つの乱数ジェネレーターが作成され、同一の乱数シーケンスを生成することができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-146">On the .NET Framework, initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="649f7-147">ほとんどの場合、これは開発者の意図ではなく、ランダムな数値ジェネレーターのインスタンス化と初期化は比較的コストのかかるプロセスであるため、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-147">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="649f7-148">パフォーマンスを向上させ、同一の数値シーケンスを生成する個別の乱数ジェネレーターが誤って作成されないようにするために、1つの <xref:System.Random> オブジェクトを作成し、1つの乱数を生成する新しい <xref:System.Random> オブジェクトを作成するのではなく、時間をかけて多数の乱数を生成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="649f7-148">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="649f7-149">ただし、<xref:System.Random> クラスはスレッドセーフではありません。</span><span class="sxs-lookup"><span data-stu-id="649f7-149">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="649f7-150">複数のスレッドから <xref:System.Random> メソッドを呼び出す場合は、次のセクションで説明するガイドラインに従ってください。</span><span class="sxs-lookup"><span data-stu-id="649f7-150">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="649f7-151">Random クラスとスレッドセーフ</span><span class="sxs-lookup"><span data-stu-id="649f7-151">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="649f7-152">個々の <xref:System.Random> オブジェクトをインスタンス化するのではなく、1つの <xref:System.Random> インスタンスを作成して、アプリに必要なすべての乱数を生成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="649f7-152">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="649f7-153">ただし、<xref:System.Random> オブジェクトはスレッドセーフではありません。</span><span class="sxs-lookup"><span data-stu-id="649f7-153">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="649f7-154">アプリが複数のスレッドから <xref:System.Random> メソッドを呼び出す場合は、同期オブジェクトを使用して、一度に1つのスレッドだけが乱数ジェネレーターにアクセスできるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-154">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="649f7-155"><xref:System.Random> オブジェクトがスレッドセーフな方法でアクセスされることを保証しない場合、乱数を返すメソッドを呼び出すと0が返されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-155">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="649f7-156">次の例ではC# 、 [lock ステートメント](/dotnet/csharp/language-reference/keywords/lock-statement)と Visual Basic [SyncLock ステートメント](/dotnet/visual-basic/language-reference/statements/synclock-statement)を使用して、スレッドセーフな方法で、1つのランダムな数値ジェネレーターが11個のスレッドによってアクセスされるようにします。</span><span class="sxs-lookup"><span data-stu-id="649f7-156">The following example uses the C# [lock Statement](/dotnet/csharp/language-reference/keywords/lock-statement) and the Visual Basic [SyncLock statement](/dotnet/visual-basic/language-reference/statements/synclock-statement) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="649f7-157">各スレッドは、200万の乱数を生成し、生成された乱数の数をカウントし、合計を計算した後、実行が終了したときにすべてのスレッドの合計を更新します。</span><span class="sxs-lookup"><span data-stu-id="649f7-157">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="649f7-158">この例では、次の方法でスレッドセーフを確保します。</span><span class="sxs-lookup"><span data-stu-id="649f7-158">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="649f7-159"><xref:System.ThreadStaticAttribute> 属性は、生成された乱数の合計数と各スレッドの合計を追跡するスレッドローカル変数を定義するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-159">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="649f7-160">ロック (のC# `lock` ステートメントと Visual Basic の `SyncLock` ステートメント) によって、すべてのスレッドで生成されたすべてのランダムな数値の合計数と合計の変数へのアクセスが保護されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-160">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="649f7-161">セマフォ (<xref:System.Threading.CountdownEvent> オブジェクト) は、他のすべてのスレッドが実行を完了するまで、メインスレッドがブロックされるようにするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-161">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="649f7-162">この例では、乱数生成メソッドの2回の連続呼び出しが0を返すかどうかを判断することによって、乱数ジェネレーターが破損しているかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="649f7-162">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="649f7-163">破損が検出された場合、この例では、<xref:System.Threading.CancellationTokenSource> オブジェクトを使用して、すべてのスレッドをキャンセルする必要があることを通知します。</span><span class="sxs-lookup"><span data-stu-id="649f7-163">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="649f7-164">各スレッドは、ランダムな数値を生成する前に、<xref:System.Threading.CancellationToken> オブジェクトの状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="649f7-164">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="649f7-165">キャンセルが要求された場合、この例では、<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> メソッドを呼び出してスレッドをキャンセルします。</span><span class="sxs-lookup"><span data-stu-id="649f7-165">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="649f7-166">次の例は、最初の例と同じですが、<xref:System.Threading.Thread> オブジェクトではなく、<xref:System.Threading.Tasks.Task> オブジェクトとラムダ式を使用している点が異なります。</span><span class="sxs-lookup"><span data-stu-id="649f7-166">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="649f7-167">これは、次の方法の最初の例とは異なります。</span><span class="sxs-lookup"><span data-stu-id="649f7-167">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="649f7-168">生成される乱数の数と各タスクの合計を追跡する変数は、タスクに対してローカルであるため、<xref:System.ThreadStaticAttribute> 属性を使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="649f7-168">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="649f7-169">静的 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドは、すべてのタスクが完了する前にメインスレッドが完了しないようにするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-169">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="649f7-170"><xref:System.Threading.CountdownEvent> オブジェクトは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="649f7-170">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="649f7-171">タスクのキャンセルによって生成される例外は、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドに表示されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-171">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="649f7-172">前の例では、各スレッドによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-172">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="649f7-173">さまざまな種類の乱数を生成する</span><span class="sxs-lookup"><span data-stu-id="649f7-173">Generating different types of random numbers</span></span>  
 <span data-ttu-id="649f7-174">乱数ジェネレーターには、次の種類の乱数を生成できるメソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="649f7-174">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="649f7-175">一連の <xref:System.Byte> 値。</span><span class="sxs-lookup"><span data-stu-id="649f7-175">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="649f7-176">バイト値の数を決定するには、メソッドが <xref:System.Random.NextBytes%2A> メソッドに返す要素の数に初期化された配列を渡します。</span><span class="sxs-lookup"><span data-stu-id="649f7-176">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="649f7-177">次の例では、20バイトが生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-177">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp-interactive[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="649f7-178">単一の整数。</span><span class="sxs-lookup"><span data-stu-id="649f7-178">A single integer.</span></span> <span data-ttu-id="649f7-179"><xref:System.Random.Next> メソッド、<xref:System.Random.Next%28System.Int32%29> メソッドを呼び出すことによって0から特定の値までの整数、または <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すことによって値の範囲内の整数を呼び出すことによって、0から最大値 (<xref:System.Int32.MaxValue?displayProperty=nameWithType>-1) までの整数を使用するかどうかを選択できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-179">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="649f7-180">パラメーター化されたオーバーロードでは、指定された最大値は排他的です。つまり、生成される実際の最大数は、指定された値より1だけ少なくなります。</span><span class="sxs-lookup"><span data-stu-id="649f7-180">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="649f7-181">次の例では、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出して、-10 ~ 10 の10個の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-181">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="649f7-182">メソッドの2番目の引数は、メソッドによって返されるランダム値の範囲の排他的上限を指定することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-182">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="649f7-183">言い換えると、メソッドが返すことができる最大の整数は、この値より1小さい値になります。</span><span class="sxs-lookup"><span data-stu-id="649f7-183">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp-interactive[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="649f7-184"><xref:System.Random.NextDouble%2A> メソッドを呼び出すことによって、0.0 ~ 1.0 未満の1つの浮動小数点値。</span><span class="sxs-lookup"><span data-stu-id="649f7-184">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="649f7-185">メソッドによって返される乱数の排他的上限は1であるため、実際の上限は0.99999999999999978 です。</span><span class="sxs-lookup"><span data-stu-id="649f7-185">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="649f7-186">次の例では、10個のランダムな浮動小数点数が生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-186">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp-interactive[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="649f7-187"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを使用すると、返される乱数値の範囲を指定できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-187">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="649f7-188">ただし、返される上限の数値を指定する `maxValue` パラメーターは、包含的な値ではなく、排他的です。</span><span class="sxs-lookup"><span data-stu-id="649f7-188">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="649f7-189">つまり、メソッド呼び出し `Next(0, 100)` は 0 ~ 99 の範囲の値を返し、0と100の間では返されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-189">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="649f7-190"><xref:System.Random> クラスは、[ランダムな T:System.Boolean 値](#Boolean)の生成、 [0 から1以外の範囲を持つランダム浮動小数点値](#Floats)の生成、[ランダムな64ビット整数](#Long)の生成、[配列またはコレクションからの一意の要素のランダムな取得](#UniqueArray)などのタスクにも使用できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-190">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="649f7-191">これらのタスクおよびその他の一般的なタスクについては、「 [How to use The Random to..](#Operations) .</span><span class="sxs-lookup"><span data-stu-id="649f7-191">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="649f7-192">下.</span><span class="sxs-lookup"><span data-stu-id="649f7-192">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="649f7-193">独自のアルゴリズムを使用する</span><span class="sxs-lookup"><span data-stu-id="649f7-193">Substituting your own algorithm</span></span>  
 <span data-ttu-id="649f7-194"><xref:System.Random> クラスから継承し、乱数生成アルゴリズムを提供することで、独自の乱数ジェネレーターを実装できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-194">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="649f7-195">独自のアルゴリズムを提供するには、乱数生成アルゴリズムを実装する <xref:System.Random.Sample%2A> メソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-195">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="649f7-196">また、<xref:System.Random.Next>、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>、および <xref:System.Random.NextBytes%2A> メソッドをオーバーライドして、オーバーライドされた <xref:System.Random.Sample%2A> メソッドを呼び出すようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-196">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="649f7-197"><xref:System.Random.Next%28System.Int32%29> および <xref:System.Random.NextDouble%2A> メソッドをオーバーライドする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="649f7-197">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="649f7-198"><xref:System.Random> クラスから派生し、既定の擬似乱数ジェネレーターを変更する例については、<xref:System.Random.Sample%2A> リファレンスページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-198">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="649f7-199">使用する方法を教えてください。</span><span class="sxs-lookup"><span data-stu-id="649f7-199">How do you use System.Random to…</span></span>  
 <span data-ttu-id="649f7-200">以下のセクションでは、アプリで乱数を使用するいくつかの方法のサンプルコードについて説明します。</span><span class="sxs-lookup"><span data-stu-id="649f7-200">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="649f7-201">同じランダムな値のシーケンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-201">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="649f7-202">ソフトウェアテストシナリオとゲームプレイで、同じ乱数シーケンスを生成することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-202">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="649f7-203">乱数の同じシーケンスを使用してテストすることで、回帰を検出し、バグ修正を確認することができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-203">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="649f7-204">ゲームで同じ乱数シーケンスを使用すると、以前のゲームを再生できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-204">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="649f7-205">同じシード値を <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターに渡すことによって、同じシーケンスの乱数を生成できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-205">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="649f7-206">シード値は、擬似乱数生成アルゴリズムの開始値を提供します。</span><span class="sxs-lookup"><span data-stu-id="649f7-206">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="649f7-207">次の例では、任意のシード値として100100を使用して <xref:System.Random> オブジェクトをインスタンス化し、20個のランダムな浮動小数点値を表示して、シード値を保持します。</span><span class="sxs-lookup"><span data-stu-id="649f7-207">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="649f7-208">次に、シード値を復元し、新しい乱数ジェネレーターをインスタンス化し、同じ20個のランダムな浮動小数点値を表示します。</span><span class="sxs-lookup"><span data-stu-id="649f7-208">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="649f7-209">この例では、異なるバージョンの .NET Framework で実行した場合に、異なる乱数シーケンスが生成される可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-209">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb" id="Snippet12":::
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="649f7-210">ランダムな数値の一意のシーケンスを取得する</span><span class="sxs-lookup"><span data-stu-id="649f7-210">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="649f7-211"><xref:System.Random> クラスのインスタンスに異なるシード値を指定すると、各乱数ジェネレーターによって異なる値のシーケンスが生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-211">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="649f7-212">シード値は、<xref:System.Random.%23ctor%28System.Int32%29> コンストラクターを呼び出すことによって明示的に指定することも、<xref:System.Random.%23ctor> コンストラクターを呼び出すことによって暗黙的に指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="649f7-212">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="649f7-213">ほとんどの開発者は、システムクロックを使用するパラメーターなしのコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="649f7-213">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="649f7-214">次の例では、この方法を使用して、2つの <xref:System.Random> インスタンスをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="649f7-214">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="649f7-215">各インスタンスには、10個のランダムな整数が表示されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-215">Each instance displays a series of 10 random integers.</span></span>  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp" id="Snippet13":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb" id="Snippet13":::

 <span data-ttu-id="649f7-216">ただし、このような制限があるため、システムクロックでは、約15ミリ秒未満の時間差は検出されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-216">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="649f7-217">したがって、コードが .NET Framework の <xref:System.Random.%23ctor> オーバーロードを呼び出して、2つの <xref:System.Random> オブジェクトを連続してインスタンス化する場合、誤ってシード値を持つオブジェクトを提供することがあります。</span><span class="sxs-lookup"><span data-stu-id="649f7-217">Therefore, if your code calls the <xref:System.Random.%23ctor> overload on the .NET Framework to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="649f7-218">(.NET Core の <xref:System.Random> クラスには、このような制限はありません)。前の例でこれを確認するには、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドの呼び出しをコメントアウトし、この例をもう一度コンパイルして実行します。</span><span class="sxs-lookup"><span data-stu-id="649f7-218">(The <xref:System.Random> class in .NET Core does not have this limitation.) To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="649f7-219">これが起こらないようにするために、複数のオブジェクトではなく、単一の <xref:System.Random> オブジェクトをインスタンス化することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="649f7-219">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="649f7-220">ただし、<xref:System.Random> はスレッドセーフではないため、複数のスレッドから <xref:System.Random> インスタンスにアクセスする場合は、同期デバイスを使用する必要があります。詳細については、このトピックで前述し[た「ランダムクラスとスレッドセーフ](#ThreadSafety)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-220">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="649f7-221">または、前の例で使用した <xref:System.Threading.Thread.Sleep%2A> メソッドなどの遅延メカニズムを使用して、インスタンス化が15ミリ秒以上離れていることを確認することもできます。</span><span class="sxs-lookup"><span data-stu-id="649f7-221">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="649f7-222">指定された範囲の整数を取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-222">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="649f7-223"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すことによって、指定した範囲の整数を取得できます。これにより、乱数ジェネレーターが返す数値の下限と上限の両方を指定できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-223">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="649f7-224">上限は、包含的な値ではなく、排他的です。</span><span class="sxs-lookup"><span data-stu-id="649f7-224">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="649f7-225">つまり、メソッドによって返される値の範囲には含まれません。</span><span class="sxs-lookup"><span data-stu-id="649f7-225">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="649f7-226">次の例では、このメソッドを使用して、-10 ~ 10 の間のランダムな整数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-226">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="649f7-227">ここでは、メソッド呼び出しの `maxValue` 引数の値として、目的の値より1つ大きい値である11を指定していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-227">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp-interactive[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="649f7-228">指定された桁数の整数を取得します</span><span class="sxs-lookup"><span data-stu-id="649f7-228">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="649f7-229"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すと、指定された桁数の数値を取得できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-229">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="649f7-230">たとえば、次の例に示すように、4桁の数字 (つまり、1000から9999の範囲の数値) を取得するには、`minValue` の値1000と1万の `maxValue` 値を指定して <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="649f7-230">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp-interactive[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="649f7-231">指定された範囲の浮動小数点値を取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-231">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="649f7-232"><xref:System.Random.NextDouble%2A> メソッドは、0から1未満の範囲のランダム浮動小数点値を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-232">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="649f7-233">ただし、多くの場合、他の範囲でランダムな値を生成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="649f7-233">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="649f7-234">最小値と最大値の間の間隔が1の場合は、目的の開始間隔と0に <xref:System.Random.NextDouble%2A> メソッドによって返される数値の差を加算できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-234">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="649f7-235">次の例では、-1 から0までの10個の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-235">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp-interactive[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="649f7-236">下限が0で、上限が1より大きい (負の値の場合、下限が-1 より小さく、上限が0である) ランダム浮動小数点数を生成するには、0以外の値で乱数を乗算します。</span><span class="sxs-lookup"><span data-stu-id="649f7-236">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="649f7-237">次の例では、0から <xref:System.Int64.MaxValue?displayProperty=nameWithType>までの範囲で、2000万のランダムな浮動小数点数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-237">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="649f7-238">では、メソッドによって生成されるランダム値の分布も表示されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-238">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp-interactive[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="649f7-239">整数の <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドのように、任意の2つの値の間にランダムな浮動小数点数を生成するには、次の式を使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-239">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 <span data-ttu-id="649f7-240">次の例では、10.0 から11.0 までの範囲の100万乱数を生成し、それらの分布を表示します。</span><span class="sxs-lookup"><span data-stu-id="649f7-240">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp-interactive[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="649f7-241">ランダムなブール値の生成</span><span class="sxs-lookup"><span data-stu-id="649f7-241">Generate random Boolean values</span></span>  
 <span data-ttu-id="649f7-242"><xref:System.Random> クラスには、<xref:System.Boolean> 値を生成するメソッドが用意されていません。</span><span class="sxs-lookup"><span data-stu-id="649f7-242">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="649f7-243">ただし、独自のクラスまたはメソッドを定義して、それを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-243">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="649f7-244">次の例では、1つのメソッド、`NextBoolean`を使用して、クラス `BooleanGenerator`を定義しています。</span><span class="sxs-lookup"><span data-stu-id="649f7-244">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="649f7-245">`BooleanGenerator` クラスは、<xref:System.Random> オブジェクトをプライベート変数として格納します。</span><span class="sxs-lookup"><span data-stu-id="649f7-245">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="649f7-246">`NextBoolean` メソッドは、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出し、その結果を <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="649f7-246">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="649f7-247">2を引数として使用して、乱数の上限を指定することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-247">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="649f7-248">これは排他的な値であるため、メソッドの呼び出しは0または1のいずれかを返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-248">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp" id="Snippet8":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb" id="Snippet8":::
  
 <span data-ttu-id="649f7-249">ランダム <xref:System.Boolean> 値を生成するために個別のクラスを作成するのではなく、単に1つのメソッドを定義するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="649f7-249">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="649f7-250">ただし、この場合、<xref:System.Random> オブジェクトはクラスレベルの変数として定義されている必要があります。これは、各メソッドの呼び出しで新しい <xref:System.Random> インスタンスをインスタンス化しないようにするためです。</span><span class="sxs-lookup"><span data-stu-id="649f7-250">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="649f7-251">Visual Basic では、`NextBoolean` メソッドで、ランダムインスタンスを[静的](/dotnet/visual-basic/language-reference/modifiers/static)変数として定義できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-251">In Visual Basic, the Random instance can be defined as a [Static](/dotnet/visual-basic/language-reference/modifiers/static) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="649f7-252">次の例は、の実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="649f7-252">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp-interactive[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="649f7-253">ランダムな64ビット整数の生成</span><span class="sxs-lookup"><span data-stu-id="649f7-253">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="649f7-254"><xref:System.Random.Next%2A> メソッドのオーバーロードは、32ビットの整数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-254">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="649f7-255">ただし、場合によっては、64ビットの整数を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-255">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="649f7-256">これは、次のようにして行うことができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-256">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="649f7-257"><xref:System.Random.NextDouble%2A> メソッドを呼び出して、倍精度浮動小数点値を取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-257">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="649f7-258">この値を <xref:System.Int64.MaxValue?displayProperty=nameWithType>で乗算します。</span><span class="sxs-lookup"><span data-stu-id="649f7-258">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="649f7-259">次の例では、この手法を使用して、2000万のランダムな長整数を生成し、10個の等しいグループに分類しています。</span><span class="sxs-lookup"><span data-stu-id="649f7-259">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="649f7-260">次に、各グループの数値を0から <xref:System.Int64.MaxValue?displayProperty=nameWithType>にカウントすることで、ランダムな数値の分布を評価します。</span><span class="sxs-lookup"><span data-stu-id="649f7-260">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="649f7-261">この例の出力に示すように、数値は長整数の範囲によってより均等に分布されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-261">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp-interactive[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="649f7-262">ビット操作を使用する別の手法では、真の乱数は生成されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-262">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="649f7-263">この手法では、<xref:System.Random.Next> を呼び出して2つの整数を生成し、32ビットずつ左シフトして、それらをまとめています。</span><span class="sxs-lookup"><span data-stu-id="649f7-263">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="649f7-264">この手法には、次の2つの制限があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-264">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="649f7-265">ビット31は符号ビットであるため、結果として得られる長整数のビット31の値は常に0になります。</span><span class="sxs-lookup"><span data-stu-id="649f7-265">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="649f7-266">これを解決するには、ランダムな0または1を生成し、31ビットを左にシフトして、それを元のランダム長整数にします。</span><span class="sxs-lookup"><span data-stu-id="649f7-266">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="649f7-267">さらに真剣には、<xref:System.Random.Next> によって返される値が0になる確率があるため、範囲 0x0 ~ 0x00000000FFFFFFFF に乱数がある場合は数が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="649f7-267">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="649f7-268">指定した範囲のバイトを取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-268">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="649f7-269"><xref:System.Random.Next%2A> メソッドのオーバーロードでは、乱数の範囲を指定できますが、<xref:System.Random.NextBytes%2A> メソッドでは指定できません。</span><span class="sxs-lookup"><span data-stu-id="649f7-269">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="649f7-270">次の例では、返されるバイトの範囲を指定できるようにする `NextBytes` メソッドを実装しています。</span><span class="sxs-lookup"><span data-stu-id="649f7-270">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="649f7-271"><xref:System.Random> から派生し、その `NextBytes` メソッドをオーバーロードする `Random2` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="649f7-271">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb" id="Snippet9":::

 <span data-ttu-id="649f7-272">`NextBytes(Byte[], Byte, Byte)` メソッドは、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドの呼び出しをラップし、バイト配列で返される最小値と最大値 (この場合は0および 101) を指定します。</span><span class="sxs-lookup"><span data-stu-id="649f7-272">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="649f7-273"><xref:System.Random.Next%2A> メソッドによって返される整数値は <xref:System.Byte> データ型の範囲内であることが確実であるため、(でC#は) それらを安全にキャストするか、(Visual Basic) 整数からバイトに変換することができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-273">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="649f7-274">配列またはコレクションからランダムに要素を取得する</span><span class="sxs-lookup"><span data-stu-id="649f7-274">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="649f7-275">ランダムな数値は、多くの場合、配列またはコレクションから値を取得するためのインデックスとして機能します。</span><span class="sxs-lookup"><span data-stu-id="649f7-275">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="649f7-276">ランダムインデックス値を取得するには、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを呼び出し、配列の下限をその `minValue` 引数の値として使用し、`maxValue` 引数の値として配列の上限を超えて使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-276">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="649f7-277">0から始まる配列の場合、これは <xref:System.Array.Length%2A> プロパティと同じか、または <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> メソッドによって返される値よりも1つ大きい値になります。</span><span class="sxs-lookup"><span data-stu-id="649f7-277">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="649f7-278">次の例では、都市の配列から米国にある市区町村の名前をランダムに取得します。</span><span class="sxs-lookup"><span data-stu-id="649f7-278">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp-interactive[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="649f7-279">配列またはコレクションから一意の要素を取得する</span><span class="sxs-lookup"><span data-stu-id="649f7-279">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="649f7-280">乱数ジェネレーターは、常に重複する値を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-280">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="649f7-281">数値の範囲が小さくなるか、生成される値の数が多いほど、重複の可能性が大きくなります。</span><span class="sxs-lookup"><span data-stu-id="649f7-281">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="649f7-282">ランダムな値を一意にする必要がある場合は、重複を補正するためにより多くの数値が生成されるため、パフォーマンスが低下します。</span><span class="sxs-lookup"><span data-stu-id="649f7-282">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="649f7-283">このシナリオに対処するための手法がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="649f7-283">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="649f7-284">一般的な解決策の1つは、取得する値を格納する配列またはコレクション、およびランダムな浮動小数点数を含む並列配列を作成することです。</span><span class="sxs-lookup"><span data-stu-id="649f7-284">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="649f7-285">2番目の配列には、最初の配列が作成された時点で乱数が格納されます。また、<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> メソッドを使用して、並列配列の値を使用して最初の配列を並べ替えます。</span><span class="sxs-lookup"><span data-stu-id="649f7-285">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="649f7-286">たとえば、ソリティアゲームを開発している場合は、各カードが1回だけ使用されていることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-286">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="649f7-287">カードを取得するために乱数を生成する代わりに、カードが既に処理されているかどうかを追跡するには、デッキの並べ替えに使用できるランダムな数値の並列配列を作成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-287">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="649f7-288">デッキが並べ替えられると、アプリは、デッキの次のカードのインデックスを示すポインターを維持できます。</span><span class="sxs-lookup"><span data-stu-id="649f7-288">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="649f7-289">このアプローチの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="649f7-289">The following example illustrates this approach.</span></span> <span data-ttu-id="649f7-290">再生カードを表す `Card` クラスと、シャッフルされたカードのデッキを扱う `Dealer` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="649f7-290">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="649f7-291">`Dealer` クラスコンストラクターは、2つの配列 (クラススコープを持ち、デッキ内のすべてのカードを表す `deck` 配列) を設定します。と、`deck` 配列と同じ数の要素を持ち、ランダムに生成された <xref:System.Double> 値が設定されたローカル `order` 配列。</span><span class="sxs-lookup"><span data-stu-id="649f7-291">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="649f7-292">次に、<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> メソッドを呼び出して、`order` 配列の値に基づいて `deck` 配列を並べ替えます。</span><span class="sxs-lookup"><span data-stu-id="649f7-292">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp" id="Snippet11":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb" id="Snippet11":::
  
## Examples  

 <span data-ttu-id="649f7-293">次の例では、乱数ジェネレーターを1つ作成し、その <xref:System.Random.NextBytes%2A>、<xref:System.Random.Next%2A>、および <xref:System.Random.NextDouble%2A> メソッドを呼び出して、異なる範囲内のランダムな数値のシーケンスを生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-293">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp-interactive[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="649f7-294">次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-294">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="649f7-295">.NET Framework 1.0 および1.1 では、<see cref="T:System.Random" /> から派生したクラスの最小実装で、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドして、乱数を生成するための新しいアルゴリズムまたは変更されたアルゴリズムを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-295">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span></span> <span data-ttu-id="649f7-296">派生クラスは、<see cref="M:System.Random.Next" />、<see cref="M:System.Random.Next(System.Int32)" />、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />、<see cref="M:System.Random.NextBytes(System.Byte[])" />、および <see cref="M:System.Random.NextDouble" /> メソッドの基本クラスの実装に依存して、<see cref="M:System.Random.Sample" /> メソッドの派生クラスの実装を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-296">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span>  
  
<span data-ttu-id="649f7-297">.NET Framework 2.0 以降では、これらのメソッドが <see cref="M:System.Random.Sample" /> メソッドの派生クラスの実装を呼び出すことがないように、<see cref="M:System.Random.Next" />、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />、および <see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッドの動作が変更されました。</span><span class="sxs-lookup"><span data-stu-id="649f7-297">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span> <span data-ttu-id="649f7-298">結果として、.NET Framework 2.0 以降を対象とする <see cref="T:System.Random" /> から派生したクラスでも、これら3つのメソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-298">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span></span></para></block>
    <block subset="none" type="usage"><para><span data-ttu-id="649f7-299"><see cref="T:System.Random" /> クラスでの乱数ジェネレーターの実装は、.NET Framework のメジャーバージョン間で同じままであることは保証されていません。</span><span class="sxs-lookup"><span data-stu-id="649f7-299">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span></span> <span data-ttu-id="649f7-300">その結果、同じシードによって、.NET Framework の異なるバージョンで同じ擬似ランダムシーケンスが生成されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="649f7-300">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="649f7-301"><see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="649f7-301">Initializes a new instance of the <see cref="T:System.Random" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="649f7-302">既定のシード値を使用して <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="649f7-302">Initializes a new instance of the <see cref="T:System.Random" /> class using a default seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
<span data-ttu-id="649f7-303">.NET Framework では、既定のシード値は、有限の解決を持つシステムクロックから派生します。</span><span class="sxs-lookup"><span data-stu-id="649f7-303">In .NET Framework, the default seed value is derived from the system clock, which has finite resolution.</span></span> <span data-ttu-id="649f7-304">結果として、パラメーターなしのコンストラクターの呼び出しによって連続して作成された異なる <xref:System.Random> オブジェクトは、同じ既定のシード値を持つため、同じセットの乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-304">As a result, different <xref:System.Random> objects that are created in close succession by a call to the parameterless constructor have identical default seed values and, therefore, produce identical sets of random numbers.</span></span> <span data-ttu-id="649f7-305">この問題を回避するには、単一の <xref:System.Random> オブジェクトを使用してすべての乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-305">You can avoid this problem by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="649f7-306">また、独自のランダムシード値を生成し、それを <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターに渡すことによって回避することもできます。</span><span class="sxs-lookup"><span data-stu-id="649f7-306">You can also work around it by generating your own random seed value and passing it to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="649f7-307">詳細については、<xref:System.Random.%23ctor%28System.Int32%29> コンストラクターを参照してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-307">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> 

<span data-ttu-id="649f7-308">.NET Core では、既定のシード値はスレッド静的擬似乱数ジェネレーターによって生成されるため、前述の制限は適用されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-308">In .NET Core, the default seed value is produced by the thread-static, pseudo-random number generator, so the previously described limitation does not apply.</span></span> <span data-ttu-id="649f7-309">連続して作成された <xref:System.Random> オブジェクトの数が異なると、.NET Core では異なる乱数セットが生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-309">Different <xref:System.Random> objects created in close succession produce different sets of random numbers in .NET Core.</span></span>
  
 <span data-ttu-id="649f7-310">乱数ジェネレーターでランダムな数値シーケンスを生成する場合は、このコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="649f7-310">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="649f7-311">異なる乱数ジェネレーターに対して同じである固定シーケンスの乱数を生成するには、固定のシード値を使用して <xref:System.Random.%23ctor%28System.Int32%29> コンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="649f7-311">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value.</span></span> <span data-ttu-id="649f7-312">この <xref:System.Random> コンストラクターオーバーロードは、ランダムな数値を使用するアプリをテストするときによく使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-312">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="649f7-313">乱数ジェネレーターをインスタンス化したら、<xref:System.Random.Next> や <xref:System.Random.NextDouble>などの個々の <xref:System.Random> メソッドを呼び出して、乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-313">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples

<span data-ttu-id="649f7-314">次の例では、パラメーターなしのコンストラクターを使用して、3つの <xref:System.Random> オブジェクトをインスタンス化し、それぞれに対して5つのランダムな整数のシーケンスを表示します。</span><span class="sxs-lookup"><span data-stu-id="649f7-314">The following example uses the parameterless constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="649f7-315">最初の2つの <xref:System.Random> オブジェクトが連続して作成されるため、.NET Framework で実行される場合は、システムクロックに基づいて同一のシード値を使用してインスタンス化されます。したがって、同じシーケンスの乱数が生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-315">If it is run on .NET Framework, because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="649f7-316">一方、3番目の <xref:System.Random> オブジェクトのパラメーターなしのコンストラクターは、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドの呼び出しによって発生する2秒の遅延の後に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-316">On the other hand, the parameterless constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="649f7-317">これにより、3つ目の <xref:System.Random> オブジェクトに対して異なるシード値が生成されるため、異なる乱数のシーケンスが生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-317">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed"><span data-ttu-id="649f7-318">擬似乱数系列の開始値を計算するために使用する数値。</span><span class="sxs-lookup"><span data-stu-id="649f7-318">A number used to calculate a starting value for the pseudo-random number sequence.</span></span> <span data-ttu-id="649f7-319">負数を指定した場合、その数値の絶対値が使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-319">If a negative number is specified, the absolute value of the number is used.</span></span></param>
        <summary><span data-ttu-id="649f7-320">指定したシード値を使用して <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="649f7-320">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-321">異なる <xref:System.Random> オブジェクトに同一のシード値を指定すると、各インスタンスで同一の乱数シーケンスが生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-321">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="649f7-322">これは、ランダムな数値ジェネレーターに依存するアプリをテストする場合によく行われます。</span><span class="sxs-lookup"><span data-stu-id="649f7-322">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="649f7-323">アプリケーションで異なる乱数シーケンスが必要な場合は、別のシード値を使用してこのコンストラクターを繰り返し呼び出します。</span><span class="sxs-lookup"><span data-stu-id="649f7-323">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="649f7-324">一意のシード値を生成する方法の1つは、時間に依存するようにすることです。</span><span class="sxs-lookup"><span data-stu-id="649f7-324">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="649f7-325">たとえば、<xref:System.Random.%23ctor> のオーバーロードと同じように、システムクロックからシード値を派生させます。</span><span class="sxs-lookup"><span data-stu-id="649f7-325">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="649f7-326">ただし、システムクロックには、別のシード値を持つこのコンストラクターの異なる呼び出しを提供するための十分な解決策がない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-326">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="649f7-327">この .NET Framework では、次の例の最初の2つの <xref:System.Random> オブジェクトに示すように、擬似乱数の同じシーケンスを生成する乱数ジェネレーターが生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-327">On the .NET Framework, this results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="649f7-328">これを回避するには、各呼び出しのシード値を区別するためのアルゴリズムを適用するか、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドを呼び出して、各コンストラクターに異なるシード値を指定していることを確認します。</span><span class="sxs-lookup"><span data-stu-id="649f7-328">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="649f7-329">もう1つのオプションは、アプリケーションのすべての乱数を生成するために使用する単一の <xref:System.Random> オブジェクトをインスタンス化することです。</span><span class="sxs-lookup"><span data-stu-id="649f7-329">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="649f7-330">乱数ジェネレーターのインスタンス化にはかなりのコストがかかるため、パフォーマンスが若干向上します。</span><span class="sxs-lookup"><span data-stu-id="649f7-330">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="649f7-331">次の例では、シードパラメーターを受け取り、ランダムな整数と倍精度のシーケンスを生成するクラスコンストラクターを使用して <xref:System.Random> オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-331">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="649f7-332">この例では、コンストラクターとシードパラメーターを使用して <xref:System.Random> オブジェクトを再作成するときに、同じシーケンスが生成されることを示しています。</span><span class="sxs-lookup"><span data-stu-id="649f7-332">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="649f7-333">ランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-333">Returns a random integer.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="649f7-334">0 以上のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-334">Returns a non-negative random integer.</span></span></summary>
        <returns><span data-ttu-id="649f7-335">0 以上で <see cref="F:System.Int32.MaxValue" /> より小さい 32 ビット符号付き整数。</span><span class="sxs-lookup"><span data-stu-id="649f7-335">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-336"><xref:System.Random.Next%2A?displayProperty=nameWithType> は、値の範囲が 0 ~ <xref:System.Int32.MaxValue?displayProperty=nameWithType>未満の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-336"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="649f7-337">値の範囲が 0 ~ 他の正の数値の乱数を生成するには、<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> メソッドのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-337">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="649f7-338">異なる範囲内の乱数を生成するには、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-338">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="649f7-339">次の例では、<xref:System.Random.Next%2A> メソッドを繰り返し呼び出して、ユーザーによって要求された特定の数の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-339">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="649f7-340"><xref:System.Console.ReadLine%2A?displayProperty=nameWithType> メソッドは、顧客の入力を取得するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-340">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="649f7-341">次の例では、<xref:System.Random> からクラスを派生させることにより、基本クラスの <xref:System.Random.Sample%2A> メソッドによって生成される一様分布とは異なる分布を持つランダムな数値のシーケンスを生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-341">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="649f7-342"><xref:System.Random.Sample%2A> メソッドをオーバーライドしてランダムな数値の分布を指定し、<xref:System.Random.Next%2A?displayProperty=nameWithType> メソッドをオーバーライドして一連の乱数を使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-342">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="649f7-343">.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Sample" /> メソッドの派生クラス実装によって提供される分布は、<see cref="M:System.Random.Next" /> メソッドの基本クラス実装の呼び出しでは使用されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-343">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span></span> <span data-ttu-id="649f7-344">代わりに、基本 <see cref="T:System.Random" /> クラスによって返される一様分布が使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-344">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="649f7-345">この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="649f7-345">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="649f7-346">派生クラスで <see cref="M:System.Random.Sample" /> メソッドを呼び出すようにこの動作を変更するには、<see cref="M:System.Random.Next" /> メソッドもオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-346">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue"><span data-ttu-id="649f7-347">生成される乱数の排他的上限値。</span><span class="sxs-lookup"><span data-stu-id="649f7-347">The exclusive upper bound of the random number to be generated.</span></span> <span data-ttu-id="649f7-348"><paramref name="maxValue" /> は 0 以上にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-348"><paramref name="maxValue" /> must be greater than or equal to 0.</span></span></param>
        <summary><span data-ttu-id="649f7-349">指定した最大値より小さい 0 以上のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-349">Returns a non-negative random integer that is less than the specified maximum.</span></span></summary>
        <returns><span data-ttu-id="649f7-350">0 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付き整数。つまり、通常は戻り値の範囲に 0 は含まれますが、<paramref name="maxValue" /> は含まれません。</span><span class="sxs-lookup"><span data-stu-id="649f7-350">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="649f7-351">ただし、<paramref name="maxValue" /> が 0 の場合は、<paramref name="maxValue" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-351">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-352"><xref:System.Random.Next%28System.Int32%29> のオーバーロードは、0 ~ `maxValue`-1 の範囲のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-352">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` - 1.</span></span> <span data-ttu-id="649f7-353">ただし、`maxValue` が0の場合、メソッドは0を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-353">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="649f7-354">次の例では、<xref:System.Random.Next%2A> メソッドのさまざまなオーバーロードを使用して、ランダムな整数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-354">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  

 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp-interactive[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="649f7-355">次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-355">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="649f7-356">配列の最大インデックスはその長さよりも小さいので、<xref:System.Array.Length%2A?displayProperty=nameWithType> プロパティの値は `maxValue` パラメーターとして指定されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-356">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="649f7-357"><paramref name="maxValue" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="649f7-357"><paramref name="maxValue" /> is less than 0.</span></span></exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue"><span data-ttu-id="649f7-358">返される乱数の包括的下限値。</span><span class="sxs-lookup"><span data-stu-id="649f7-358">The inclusive lower bound of the random number returned.</span></span></param>
        <param name="maxValue"><span data-ttu-id="649f7-359">返される乱数の排他的上限値。</span><span class="sxs-lookup"><span data-stu-id="649f7-359">The exclusive upper bound of the random number returned.</span></span> <span data-ttu-id="649f7-360"><paramref name="maxValue" /> は <paramref name="minValue" /> 以上である必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-360"><paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span></span></param>
        <summary><span data-ttu-id="649f7-361">指定した範囲内のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-361">Returns a random integer that is within a specified range.</span></span></summary>
        <returns><span data-ttu-id="649f7-362"><paramref name="minValue" /> 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付整数。つまり、戻り値の範囲に <paramref name="minValue" /> は含まれますが <paramref name="maxValue" /> は含まれません。</span><span class="sxs-lookup"><span data-stu-id="649f7-362">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="649f7-363"><paramref name="minValue" /> が <paramref name="maxValue" /> と等しい場合は、<paramref name="minValue" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-363">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-364"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> のオーバーロードは、`minValue` から `maxValue`-1 までの範囲のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-364">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` - 1.</span></span> <span data-ttu-id="649f7-365">ただし `maxValue` が `minValue`に等しい場合、メソッドは `minValue`を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-365">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="649f7-366">負でない値のみを返す <xref:System.Random.Next%2A> メソッドの他のオーバーロードとは異なり、このメソッドは負の整数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="649f7-366">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="649f7-367">次の例では、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを使用して、3つの異なる範囲を持つランダムな整数を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-367">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="649f7-368">この例の正確な出力は、<xref:System.Random> クラスコンストラクターに渡されるシステム指定のシード値によって異なります。</span><span class="sxs-lookup"><span data-stu-id="649f7-368">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp-interactive[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="649f7-369">次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-369">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="649f7-370">配列の最大インデックスはその長さよりも小さいので、<xref:System.Array.Length%2A?displayProperty=nameWithType> プロパティの値は `maxValue` パラメーターとして指定されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-370">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp-interactive[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="649f7-371"><paramref name="minValue" /> が <paramref name="maxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="649f7-371"><paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="649f7-372">.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> パラメーターと <paramref name="minValue" /> パラメーターの差が <paramref name="maxValue" /> よりも大きい場合、<see cref="F:System.Int32.MaxValue" />メソッドオーバーロードの基底クラス実装によっ <see cref="M:System.Random.Sample" /> て提供される分布では使用されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-372">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span></span> <span data-ttu-id="649f7-373">代わりに、基本 <see cref="T:System.Random" /> クラスによって返される一様分布が使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-373">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="649f7-374">この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="649f7-374">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="649f7-375">派生クラスで <see cref="M:System.Random.Sample" /> メソッドを呼び出すようにこの動作を変更するには、<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> メソッドのオーバーロードもオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-375">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="649f7-376">乱数が格納される配列。</span><span class="sxs-lookup"><span data-stu-id="649f7-376">The array to be filled with random numbers.</span></span></param>
        <summary><span data-ttu-id="649f7-377">指定したバイト配列の要素に乱数を格納します。</span><span class="sxs-lookup"><span data-stu-id="649f7-377">Fills the elements of a specified array of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-378">バイト配列の各要素には、0以上、<xref:System.Byte.MaxValue>以下の乱数が設定されています。</span><span class="sxs-lookup"><span data-stu-id="649f7-378">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="649f7-379">たとえば、ランダムなパスワードの作成に適した暗号的に保護されたランダムな数値を生成するには、<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="649f7-379">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples

 <span data-ttu-id="649f7-380">次の例は、<xref:System.Random.NextBytes%2A> メソッドを使用して、バイト配列にランダムバイト値を格納する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="649f7-380">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
 
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="649f7-381"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="649f7-381"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="649f7-382">.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Sample" /> メソッドの派生クラス実装によって提供される分布は、<see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッドの基本クラス実装の呼び出しでは使用されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-382">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span> <span data-ttu-id="649f7-383">代わりに、基本 <see cref="T:System.Random" /> クラスによって返される一様分布が使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-383">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="649f7-384">この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="649f7-384">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="649f7-385">派生クラスで <see cref="M:System.Random.Sample" /> メソッドを呼び出すようにこの動作を変更するには、<see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッドもオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="649f7-385">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="649f7-386">乱数が格納される配列。</span><span class="sxs-lookup"><span data-stu-id="649f7-386">The array to be filled with random numbers.</span></span></param>
        <summary><span data-ttu-id="649f7-387">指定したバイト範囲の要素に乱数を格納します。</span><span class="sxs-lookup"><span data-stu-id="649f7-387">Fills the elements of a specified span of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="649f7-388">バイトの範囲の各要素には、0以上 <xref:System.Byte.MaxValue>以下の乱数が設定されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-388">Each element of the span of bytes is set to a random number greater than or equal to 0 and less than or equal to <xref:System.Byte.MaxValue>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="649f7-389">0.0 以上 1.0 未満のランダムな浮動小数点数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-389">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span></span></summary>
        <returns><span data-ttu-id="649f7-390">0.0 以上 1.0 未満の倍精度浮動小数点数。</span><span class="sxs-lookup"><span data-stu-id="649f7-390">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-391">このメソッドによって返される乱数の実際の上限は0.99999999999999978 です。</span><span class="sxs-lookup"><span data-stu-id="649f7-391">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="649f7-392">0.0 および1.0 以外の範囲内のランダムな浮動小数点値を取得するには、<xref:System.Random> クラスのトピックの「指定された範囲の浮動小数点値を取得する」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="649f7-392">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="649f7-393">このメソッドは、保護されたメソッドのパブリックバージョンであり、<xref:System.Random.Sample%2A>ます。</span><span class="sxs-lookup"><span data-stu-id="649f7-393">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  

 <span data-ttu-id="649f7-394">次の例では、<xref:System.Random.NextDouble%2A> メソッドを使用して、ランダムな倍精度のシーケンスを生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-394">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="649f7-395">次の例では、<xref:System.Random.NextDouble%2A> メソッドを呼び出して、100の乱数を生成し、その頻度分布を表示します。</span><span class="sxs-lookup"><span data-stu-id="649f7-395">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp-interactive[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="649f7-396">0.0 と 1.0 の間のランダムな浮動小数点数を返します。</span><span class="sxs-lookup"><span data-stu-id="649f7-396">Returns a random floating-point number between 0.0 and 1.0.</span></span></summary>
        <returns><span data-ttu-id="649f7-397">0.0 以上 1.0 未満の倍精度浮動小数点数。</span><span class="sxs-lookup"><span data-stu-id="649f7-397">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="649f7-398">異なるランダム分布または異なる乱数ジェネレーターの原則を生成するには、<xref:System.Random> クラスからクラスを派生させ、<xref:System.Random.Sample%2A> メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="649f7-398">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="649f7-399"><xref:System.Random.Sample%2A> メソッドは `protected`であり、<xref:System.Random> クラスとその派生クラス内でのみアクセス可能であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="649f7-399">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="649f7-400"><xref:System.Random> インスタンスから0と1の間の乱数を生成するには、<xref:System.Random.NextDouble%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="649f7-400">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="649f7-401">次の例では、<xref:System.Random> からクラスを派生し、<xref:System.Random.Sample%2A> メソッドをオーバーライドして、乱数の分布を生成します。</span><span class="sxs-lookup"><span data-stu-id="649f7-401">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="649f7-402">この分布は、基本クラスの <xref:System.Random.Sample%2A> メソッドによって生成される均一分布とは異なります。</span><span class="sxs-lookup"><span data-stu-id="649f7-402">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="649f7-403">.NET Framework バージョン2.0 以降では、<see cref="T:System.Random" /> からクラスを派生し、<see cref="M:System.Random.Sample" /> メソッドをオーバーライドした場合、<see cref="M:System.Random.Sample" /> メソッドの派生クラス実装によって提供される分布は、次のメソッドの基本クラス実装の呼び出しでは使用されません。</span><span class="sxs-lookup"><span data-stu-id="649f7-403">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span></span> 
<span data-ttu-id="649f7-404">-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッド。</span><span class="sxs-lookup"><span data-stu-id="649f7-404">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span>  
  
<span data-ttu-id="649f7-405">-   <see cref="M:System.Random.Next" /> メソッド。</span><span class="sxs-lookup"><span data-stu-id="649f7-405">-   The <see cref="M:System.Random.Next" /> method.</span></span>  
  
<span data-ttu-id="649f7-406">-(<paramref name="maxValue" /> - <paramref name="minValue" />) の場合、<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> メソッドは <see cref="F:System.Int32.MaxValue" />を超えています。</span><span class="sxs-lookup"><span data-stu-id="649f7-406">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span></span>  
  
<span data-ttu-id="649f7-407">代わりに、基本 <see cref="T:System.Random" /> クラスによって提供される一様分布が使用されます。</span><span class="sxs-lookup"><span data-stu-id="649f7-407">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="649f7-408">この動作により、<see cref="T:System.Random" /> クラスの全体的なパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="649f7-408">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="649f7-409">この動作を変更して、派生クラスの <see cref="M:System.Random.Sample" /> メソッドの実装を呼び出すには、これら3つのメンバーの動作をオーバーライドする必要もあります。</span><span class="sxs-lookup"><span data-stu-id="649f7-409">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span></span> <span data-ttu-id="649f7-410">具体的な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="649f7-410">The example provides an illustration.</span></span></para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
