<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9cca51947031d1c00924ff36666a4a51c24b2be2" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82495436" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IEquatable(Of Double), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>倍精度浮動小数点数を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double> 値型は、負の 1.79769313486232 e308 から正の 1.79769313486232 e308 までの値を持つ倍精度64ビット数値を表します。また、正または負の0、<xref:System.Double.PositiveInfinity>、<xref:System.Double.NegativeInfinity>、および非数 (<xref:System.Double.NaN>) を表します。 これは、非常に大きな値 (惑星または galaxies 間の距離など) または非常に小さい値 (キログラムの物質の分子質量など) を表すことを目的としており、多くの場合、(地球から別の太陽システムへの距離など) 不正確になることがあります。 <xref:System.Double> 型は、バイナリ浮動小数点演算の IEC 60559:1989 (IEEE 754) 標準に準拠しています。  
  
 このトピックは、次のセクションで構成されています。  
  
-   [浮動小数点表現と有効桁数](#Precision)  
  
-   [等しいかどうかのテスト](#Equality)  
  
-   [浮動小数点値と例外](#Exceptions)  
  
-   [型変換と Double 構造体](#Conversions)  
  
-   [浮動小数点機能](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>浮動小数点表現と有効桁数  
 <xref:System.Double> データ型では、次の表に示すように、倍精度浮動小数点値が64ビットのバイナリ形式で格納されます。  
  
|要素|Bits|  
|----------|----------|  
|有効桁または仮数|0-51|  
|Exponent|52-62|  
|符号 (0 = 正、1 = 負)|63|  
  
 10分の分数では、一部の小数部 (1/3 や <xref:System.Math.PI?displayProperty=nameWithType>など) を正確に表すことができないのと同様に、バイナリの分数では小数部の値を表すことができません。 たとえば、小数点として .1 によって正確に表される1/10 は、001100110011によって "0011" というパターンで無限大として表現されます。 この場合、浮動小数点値は、それが表す数値の不正確な表現を提供します。 多くの場合、元の浮動小数点値に対して追加の数学演算を実行すると、精度が低下する傾向があります。 たとえば、0.1 を10に乗算した結果を比較し、.1 を. 1 9 回追加した場合、その加算には8個の操作が含まれているため、精度が低下していることがわかります。 この不均衡は、"R"[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)を使用して2つの <xref:System.Double> 値を表示した場合にのみ表示されます。必要に応じて、<xref:System.Double> の種類でサポートされているすべての17桁の有効桁数が表示されます。  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 一部の数値は小数部のバイナリ値として正確に表すことができないため、浮動小数点数は実数のみを概数にすることができます。  
  
 すべての浮動小数点数には、有効桁数も制限されています。これにより、浮動小数点値が実数を近似する精度も決まります。   <xref:System.Double> 値の有効桁数は最大15桁ですが、内部的には最大17桁が保持されます。 これは、浮動小数点演算によっては、浮動小数点値を変更するための有効桁数が不足している場合があることを意味します。 次に例を示します。 非常に大きな浮動小数点値を定義し、<xref:System.Double.Epsilon?displayProperty=nameWithType> の製品と1つの quadrillion を追加します。 ただし、この製品では、元の浮動小数点値を変更することはできません。 最下位桁は1000桁ですが、製品の最上位桁は 10<sup>-309</sup>です。  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 浮動小数点数の有効桁数には、次のような結果があります。  
  
-   特定の有効桁数で等しく見える 2 つの浮動小数点数が、最小有効数字が異なっているために等しくない場合があります。 次の例では、一連の数値が加算され、それらの合計が予想される合計と比較されます。 2つの値は同じように見えますが、`Equals` メソッドを呼び出すと、その値がではないことが示されます。  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> ステートメントの書式項目を `{0}` と `{1}` から `{0:R}` および `{1:R}` に変更して、2つの <xref:System.Double> 値のすべての有効桁を表示すると、加算演算中に精度が低下するため、2つの値が等しくないことが明らかになります。 この場合は、<xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出して、比較を実行する前に <xref:System.Double> 値を目的の精度に丸めることによって、問題を解決できます。  
  
-   浮動小数点数を使用する数学的演算または比較演算では、10進数が使用されている場合、同じ結果が得られないことがあります。これは、バイナリ浮動小数点数が10進数と等しくない可能性があるためです。 前の例では、0.1 を10で乗算し、を1回追加した結果を表示しています。  
  
     小数値を持つ数値演算の精度が重要な場合は、<xref:System.Double> 型ではなく、<xref:System.Decimal> を使用できます。 <xref:System.Int64> 型または <xref:System.UInt64> 型の範囲を超える整数値を持つ数値演算の精度が重要な場合は、<xref:System.Numerics.BigInteger> 型を使用します。  
  
-   浮動小数点数が含まれている場合、値はラウンドトリップしない可能性があります。 操作が元の浮動小数点数を別の形式に変換した場合、逆の演算で変換後の形式が浮動小数点数に変換され、最後の浮動小数点数が元の浮動小数点数と等しくない場合、値はラウンドトリップと呼ばれます。 変換で1つ以上の有効桁が失われたり、変更されたりすると、ラウンドトリップが失敗する可能性があります。 次の例では、3つの <xref:System.Double> 値が文字列に変換され、ファイルに保存されます。 ただし、出力に示されているように、値が同一であるように見える場合でも、復元された値は元の値と同じではありません。  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     この場合、次の例に示すように、"G17"[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)を使用して、<xref:System.Double> 値の完全な有効桁数を保持することで、値を正常にラウンドトリップできます。  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  <xref:System.Double> 値と共に使用する場合、場合によっては、"R" 書式指定子が元の値のラウンドトリップに失敗することがあります。 <xref:System.Double> 値が確実にラウンドトリップするようにするには、"G17" 書式指定子を使用します。

-   <xref:System.Single> 値は <xref:System.Double> 値よりも精度が低くなります。 一見同等の <xref:System.Double> に変換される <xref:System.Single> 値は、精度が異なるため <xref:System.Double> 値と等しくないことがよくあります。 次の例では、同じ除算演算の結果が <xref:System.Double> と <xref:System.Single> 値に割り当てられています。 <xref:System.Single> 値が <xref:System.Double>にキャストされた後、2つの値の比較によって等しくないことが示されます。  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     この問題を回避するには、<xref:System.Single> データ型の代わりに <xref:System.Double> を使用するか、<xref:System.Math.Round%2A> メソッドを使用して両方の値の有効桁数を同じにします。  
  
 また、<xref:System.Double> 値を持つ算術演算と代入演算の結果は、<xref:System.Double> 型の有効桁数が失われるため、プラットフォームによって若干異なる場合があります。 たとえば、リテラル <xref:System.Double> 値を代入した結果が、32ビットバージョンと64ビットバージョンの .NET Framework で異なる場合があります。 次の例は、リテラル値 4.42330604244772 E-305 と、値が-4.42330604244772 E-305 の変数が <xref:System.Double> 変数に割り当てられている場合の違いを示しています。 この場合の <xref:System.Double.Parse%28System.String%29> メソッドの結果は、精度の低下による影響を受けないことに注意してください。  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>等しいかどうかのテスト  
 等しいと見なされるためには、2つの <xref:System.Double> 値が同一の値を表す必要があります。 ただし、値間の精度が異なるため、または1つまたは両方の値によって精度が低下していることが原因で、浮動小数点値が同一であることが予想される場合は、少なくとも有効桁数が異なるために等しくならないことがあります。 その結果、<xref:System.Double.Equals%2A> メソッドを呼び出して、2つの値が等しいかどうかを判断したり、2つの <xref:System.Double> 値間のリレーションシップを決定するために <xref:System.Double.CompareTo%2A> メソッドを呼び出したりすると、多くの場合、予期しない結果が発生します。 これは、次の例では明らかです。2つの一見等しい <xref:System.Double> 値は、最初の精度が15桁で、2番目の値が17であるため、等しくないことになります。  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 異なるコードパスに従い、異なる方法で操作される計算値は、多くの場合、等しくないことが証明されます。 次の例では、1つの <xref:System.Double> 値が2乗され、平方根が計算されて元の値が復元されます。 結果の平方根が3.51 で除算され、元の値が復元される前に、2番目の <xref:System.Double> に3.51 と二乗が乗算されます。 2つの値は同一であるように見えますが、<xref:System.Double.Equals%28System.Double%29> メソッドを呼び出すと、それらの値が等しくないことが示されます。 "R" 標準書式指定文字列を使用して、各 Double 値のすべての有効桁数を表示する結果文字列を返すと、2番目の値が .0000000000001 未満であることが示されます。  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 精度の低下が比較の結果に影響する可能性がある場合は、次のいずれかの方法を使用して、<xref:System.Double.Equals%2A> または <xref:System.Double.CompareTo%2A> メソッドを呼び出すことができます。  
  
-   <xref:System.Math.Round%2A?displayProperty=nameWithType> メソッドを呼び出して、両方の値の有効桁数が同じであることを確認します。 次の例では、この方法を使用するように前の例を変更し、2つの小数部の値が等価になるようにしています。  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     ただし、精度の問題は、中間値の丸めにも適用されることに注意してください。 詳細については、<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> メソッドを参照してください。  
  
-   等価ではなく、おおよその等価性をテストします。 そのためには、2つの値が異なる一方でも同じである必要がある絶対金額を定義するか、小さい値が大きな値から逸脱する相対的な量を定義する必要があります。  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> は、等しいかどうかをテストするときに2つの <xref:System.Double> 値の間の距離の絶対測定値として使用されることがあります。  ただし <xref:System.Double.Epsilon?displayProperty=nameWithType> は、値がゼロである <xref:System.Double> に加算または減算できる最小値を測定します。 正および負の <xref:System.Double> 値の場合、<xref:System.Double.Epsilon?displayProperty=nameWithType> の値が小さすぎて検出できません。 したがって、値がゼロの場合を除いて、等しいかどうかのテストでは使用しないことをお勧めします。  
  
     次の例では、後者の方法を使用して、2つの値の相対的な差をテストする `IsApproximatelyEqual` メソッドを定義しています。 また、`IsApproximatelyEqual` メソッドと <xref:System.Double.Equals%28System.Double%29> メソッドの呼び出しの結果も比較します。  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>浮動小数点値と例外  
 オーバーフローや0による除算などの無効な操作で例外をスローする整数型の操作とは異なり、浮動小数点値を持つ演算では、例外はスローされません。 代わりに、例外的な状況では、浮動小数点演算の結果は0、正の無限大、負の無限大、または非数 (NaN) のようになります。  
  
-   浮動小数点演算の結果が変換先の形式に対して小さすぎる場合、結果は0になります。 これは、次の例に示すように、2つの非常に小さい数値が乗算された場合に発生する可能性があります。  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   浮動小数点演算の結果の大きさが変換先の形式の範囲を超える場合、演算の結果は、結果の符号に応じて、<xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity>になります。 <xref:System.Double.MaxValue?displayProperty=nameWithType> オーバーフローする操作の結果は <xref:System.Double.PositiveInfinity>、次の例に示すように、<xref:System.Double.MinValue?displayProperty=nameWithType> オーバーフローする操作の結果は <xref:System.Double.NegativeInfinity>になります。  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> は、0で正の被除数を除算した結果も得られます。また、0による除算の結果は負の被除数で <xref:System.Double.NegativeInfinity> ます。  
  
-   浮動小数点演算が無効な場合は、演算の結果が <xref:System.Double.NaN>されます。 たとえば、次の操作の結果を <xref:System.Double.NaN> ます。  
  
    -   被除数が0の0による除算。 0による除算の場合は、<xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity>のいずれかになります。  
  
-   無効な入力を持つ任意の浮動小数点演算。 たとえば、負の値を指定して <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> メソッドを呼び出すと <xref:System.Double.NaN>が返されます。これは、1より大きい値または負の値を持つ <xref:System.Math.Acos%2A?displayProperty=nameWithType> メソッドを呼び出す場合と同じです。  
  
-   値が <xref:System.Double.NaN?displayProperty=nameWithType>である引数を持つ操作。  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>型変換と Double 構造体  
 <xref:System.Double> 構造体では、明示的または暗黙的な変換演算子は定義されません。代わりに、変換はコンパイラによって実装されます。  
  
 任意のプリミティブ数値型の値から <xref:System.Double> への変換は拡大変換であるため、コンパイラが明示的に要求する場合を除き、明示的なキャスト演算子や、変換メソッドの呼び出しを必要としません。 たとえば、 C#コンパイラは <xref:System.Decimal> から <xref:System.Double>への変換にキャスト演算子を必要としますが、Visual Basic コンパイラでは変換されません。 次の例では、その他のプリミティブ数値型の最小値または最大値を <xref:System.Double>に変換します。  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 また、<xref:System.Single> 値 <xref:System.Single.NaN?displayProperty=nameWithType>、<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>、および <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> は、それぞれ <xref:System.Double.NaN?displayProperty=nameWithType>、<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>、および <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>に変換されます。  
  
 数値型の値を <xref:System.Double> 値に変換すると、精度が失われる可能性があることに注意してください。 例に示すように、<xref:System.Decimal>、<xref:System.Int64>、<xref:System.Single>、および <xref:System.UInt64> の値を <xref:System.Double> 値に変換する場合、精度が低下する可能性があります。  
  
 <xref:System.Double> 値から他のプリミティブ数値データ型の値への変換は縮小変換であり、キャスト演算子 (でC#は)、変換メソッド (Visual Basic)、または <xref:System.Convert> メソッドの呼び出しが必要です。 対象のデータ型の範囲外の値 (対象の型の `MinValue` と `MaxValue` のプロパティで定義されている値) は、次の表に示すように動作します。  
  
|[対象になる種類]|結果|  
|-----------------|------------|  
|任意の整数型|Checked コンテキストで変換が発生した場合の <xref:System.OverflowException> 例外。<br /><br /> 変換が unchecked コンテキスト (のC#既定値) で行われる場合、変換操作は成功しますが、値はオーバーフローします。|  
|<xref:System.Decimal>|<xref:System.OverflowException> 例外。|  
|<xref:System.Single>|負の値の <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>。<br /><br /> 正の値の <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>。|  
  
 さらに、<xref:System.Double.NaN?displayProperty=nameWithType>、<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>、および <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> は checked コンテキストで整数への変換のための <xref:System.OverflowException> をスローしますが、これらの値は unchecked コンテキストで整数に変換されるとオーバーフローします。 <xref:System.Decimal>への変換では、常に <xref:System.OverflowException>をスローします。 <xref:System.Single>への変換では、<xref:System.Single.NaN?displayProperty=nameWithType>、<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>、および <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>にそれぞれ変換されます。  
  
 有効桁数が失われると、<xref:System.Double> 値が別の数値型に変換される可能性があることに注意してください。 整数以外の <xref:System.Double> 値を変換する場合、例の出力が示すように、<xref:System.Double> の値が丸められるか (Visual Basic のように)、切り捨てられたとき (のC#ように)、小数部分は失われます。 <xref:System.Decimal> および <xref:System.Single> 値への変換では、<xref:System.Double> 値は、対象のデータ型で正確な表現を持つことはできません。  
  
 次の例では、<xref:System.Double> の値の数を他のいくつかの数値型に変換します。 変換は、Visual Basic (既定) のチェックされたコンテキストと、 C# ( [checked](~/docs/csharp/language-reference/keywords/checked.md)キーワードによって) で行われます。 この例の出力は、チェックされていないコンテキストでの変換の結果を示しています。 `/removeintchecks+` コンパイラスイッチを使用してコンパイルし、でC# `checked` ステートメントをコメントアウトすることで、Visual Basic の unchecked コンテキストで変換を実行できます。  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 数値型の変換の詳細については、「.NET Framework および[型変換テーブル](~/docs/standard/base-types/conversion-tables.md)の[型変換](~/docs/standard/base-types/type-conversion.md)」を参照してください。  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>浮動小数点機能  
 <xref:System.Double> 構造体と関連する型には、次の領域で操作を実行するメソッドが用意されています。  
  
-   **値の比較**。 <xref:System.Double.Equals%2A> メソッドを呼び出して、2つの <xref:System.Double> 値が等しいかどうかを判断したり、2つの値の間のリレーションシップを決定する <xref:System.Double.CompareTo%2A> メソッドを呼び出したりできます。  
  
     <xref:System.Double> 構造体は、比較演算子の完全なセットもサポートしています。 たとえば、等値または非等値をテストしたり、一方の値がもう一方の値以上かどうかを調べたりすることができます。 オペランドの1つが <xref:System.Double>以外の数値型の場合は、比較を実行する前に <xref:System.Double> に変換されます。  
  
    > [!WARNING]
    >  精度が異なるため、2つの <xref:System.Double> 値が等しいと予想される場合は、等しくないと見なされ、比較の結果に影響します。 2つの <xref:System.Double> 値の比較の詳細については、「[等値のテスト](#Equality)」を参照してください。  
  
     <xref:System.Double.IsNaN%2A>、<xref:System.Double.IsInfinity%2A>、<xref:System.Double.IsPositiveInfinity%2A>、および <xref:System.Double.IsNegativeInfinity%2A> の各メソッドを呼び出して、これらの特殊な値をテストすることもできます。  
  
-   **算術演算**。 加算、減算、乗算、除算などの一般的な算術演算は、<xref:System.Double> メソッドではなく、言語コンパイラおよび共通中間言語 (CIL) 命令によって実装されます。 算術演算のオペランドの1つが <xref:System.Double>以外の数値型である場合、演算を実行する前に <xref:System.Double> に変換されます。 操作の結果は、<xref:System.Double> 値でもあります。  
  
     その他の算術演算は、<xref:System.Math?displayProperty=nameWithType> クラスの `static` (Visual Basic で`Shared`) メソッドを呼び出すことによって実行できます。 これには、算術演算 (<xref:System.Math.Abs%2A?displayProperty=nameWithType>、<xref:System.Math.Sign%2A?displayProperty=nameWithType>、<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>など)、geometry (<xref:System.Math.Cos%2A?displayProperty=nameWithType> や <xref:System.Math.Sin%2A?displayProperty=nameWithType>など)、微積分 (<xref:System.Math.Log%2A?displayProperty=nameWithType>など) で一般的に使用される追加のメソッドが含まれます。  
  
     <xref:System.Double> 値の個々のビットを操作することもできます。 <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> メソッドは、<xref:System.Double> 値のビットパターンを64ビット整数で保持します。 <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> メソッドは、バイト配列でそのビットパターンを返します。  
  
-   **丸め**。 丸めは、浮動小数点表現と精度の問題によって生じる値の違いを減らすための手法としてよく使用されます。 <xref:System.Math.Round%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Double> 値を丸めることができます。  
  
-   **書式設定**。 <xref:System.Double.ToString%2A> メソッドを呼び出すか、または複合書式指定機能を使用して、<xref:System.Double> 値を文字列形式に変換できます。 書式指定文字列による浮動小数点値の文字列形式の制御方法の詳細については、「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
-   **文字列を解析**しています。 <xref:System.Double.Parse%2A> または <xref:System.Double.TryParse%2A> メソッドを呼び出すことによって、浮動小数点値の文字列形式を <xref:System.Double> 値に変換できます。 解析操作が失敗した場合、<xref:System.Double.Parse%2A> メソッドは例外をスローし、<xref:System.Double.TryParse%2A> メソッドは `false`を返します。  
  
-   **型変換**。 <xref:System.Double> 構造体は、任意の2つの標準 .NET Framework データ型間の変換をサポートする <xref:System.IConvertible> インターフェイスの明示的なインターフェイスの実装を提供します。 言語コンパイラでは、他のすべての標準数値型の値から <xref:System.Double> 値への暗黙的な変換もサポートされています。 任意の標準数値型の値から <xref:System.Double> への変換は拡大変換であり、キャスト演算子または変換メソッドのユーザーを必要としません。  
  
     ただし、<xref:System.Int64> と <xref:System.Single> の値を変換すると、精度が失われる可能性があります。 次の表は、これらの各型の有効桁数の違いを示しています。  
  
    |種類|最大有効桁数|内部精度|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19桁の10進数|19桁の10進数|  
    |<xref:System.Single>|7桁の10進数|9桁の10進数|  
  
     精度の問題は、<xref:System.Double> 値に変換される <xref:System.Single> 値に最も頻繁に影響します。 次の例では、同じ除算演算によって生成される2つの値が等しくありません。値の1つが <xref:System.Double>に変換された単精度浮動小数点値であるためです。  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double>の使用方法を示しています。  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型のすべてのメンバーは、スレッドセーフです。 インスタンスの状態を変更するように見えるメンバーは、実際には新しい値で初期化された新しいインスタンスを返します。 他の型と同様に、この型のインスタンスを含む共有変数の読み取りと書き込みは、スレッドセーフを保証するためにロックによって保護される必要があります。</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-cs/">サンプル: .NET Core WinForms 書式指定ユーティリティC#()</related>
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-vb/">サンプル: .NET Core WinForms の書式設定ユーティリティ (Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスと指定したオブジェクトまたは <see cref="T:System.Double" /> オブジェクトを比較し、このインスタンスの値が指定したオブジェクトまたは <see cref="T:System.Double" /> オブジェクトの値よりも小さいか、同じか、または大きいかを示す整数を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の倍精度浮動小数点数。</param>
        <summary>このインスタンスと指定した倍精度浮動小数点数を比較し、このインスタンスの値が指定した倍精度浮動小数点数の値よりも小さいか、同じか、または大きいかを示す整数を返します。</summary>
        <returns>このインスタンスと <paramref name="value" /> の相対値を示す符号付き数値。  
  
 <list type="table"><listheader><term> 戻り値 
 </term><description> 説明 
 </description></listheader><item><term> ゼロより小さい 
 </term><description> このインスタンスは <paramref name="value" /> よりも小さくなっています。  
  
または 
このインスタンスは非数 (<see cref="F:System.Double.NaN" />) で、<paramref name="value" /> は数値です。  
  
 </description></item><item><term> ゼロ 
 </term><description> このインスタンスは <paramref name="value" /> と同じ値です。  
  
または 
このインスタンスと <paramref name="value" /> は、どちらも非数 (<see cref="F:System.Double.NaN" />)、<see cref="F:System.Double.PositiveInfinity" />、または <see cref="F:System.Double.NegativeInfinity" /> です。  
  
 </description></item><item><term> ゼロより大きい 
 </term><description> このインスタンスは <paramref name="value" /> よりも大きくなっています。  
  
または 
このインスタンスは数値で、<paramref name="value" /> は非数 (<see cref="F:System.Double.NaN" />) です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 等しいと見なされるためには、値が同一である必要があります。 特に浮動小数点値が複数の数値演算に依存している場合は、有効桁数が失われ、その値が最下位の数字を除いてほぼ同じであることが一般的です。 このため、<xref:System.Double.CompareTo%2A> メソッドの戻り値は、驚くように思えるかもしれません。 たとえば、特定の値による乗算の後に同じ値による除算が行われると、元の値が生成されます。 ただし、次の例では、計算値は元の値よりも大きい値になります。 "R"[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)を使用して、2つの値のすべての有効桁数を表示すると、計算された値が最下位桁の元の値と異なることを示します。 このような比較の処理の詳細については、<xref:System.Double.Equals%28System.Double%29> メソッドの「解説」を参照してください。  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 このメソッドは、<xref:System.IComparable%601?displayProperty=nameWithType> インターフェイスを実装し、`value` パラメーターをオブジェクトに変換する必要がないため、<xref:System.Double.CompareTo%2A?displayProperty=nameWithType> メソッドよりも若干優れています。  
  
 値が <xref:System.Double.NaN> されているオブジェクトは、その値が <xref:System.Double.NaN> である別のオブジェクト (自体も含む) と同じとは見なされませんが、<xref:System.IComparable%601> インターフェイスでは、`A.CompareTo(A)` が0を返す必要があります。  
  
## <a name="widening-conversions"></a>拡大変換  
 プログラミング言語によっては、パラメーターの型がインスタンスの型よりも少ない (幅が狭い) <xref:System.Double.CompareTo%2A> メソッドをコーディングすることができます。 これが可能なのは、一部のプログラミング言語では、インスタンスと同数のビットを持つ型として、パラメーターを表す暗黙的な拡大変換が実行されるためです。  
  
 たとえば、インスタンスの型が <xref:System.Double> で、パラメーターの型が <xref:System.Int32>であるとします。 Microsoft C#コンパイラは、パラメーターの値を <xref:System.Double> オブジェクトとして表す命令を生成し、インスタンスの値とパラメーターの拡張表現を比較する <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> メソッドを生成します。  
  
 プログラミング言語のドキュメントを参照して、コンパイラが数値型の暗黙的な拡大変換を実行するかどうかを判断します。 詳細については、「[型変換の表](~/docs/standard/base-types/conversion-tables.md)」を参照してください。  
  
## <a name="precision-in-comparisons"></a>比較における精度  
 ドキュメント化された有効桁数を超える浮動小数点数の有効桁数は、.NET Framework の実装とバージョンに固有です。 その結果、数値の内部表現の有効桁数が変更される可能性があるため、2つの特定の数値の比較が .NET Framework のバージョン間で変わる可能性があります。  
  
   
  
## Examples  
 次のコード例は、いくつかの値および参照型について、<xref:System.Double.CompareTo%2A> メソッドのジェネリックおよび非ジェネリックバージョンを示しています。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">比較対象のオブジェクト、または <see langword="null" />。</param>
        <summary>このインスタンスと指定したオブジェクトを比較し、このインスタンスの値が指定したオブジェクトの値よりも小さいか、同じか、または大きいかを示す整数を返します。</summary>
        <returns>このインスタンスと <paramref name="value" /> の相対値を示す符号付き数値。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 説明 
 </description></listheader><item><term> 負の整数 
 </term><description> このインスタンスは <paramref name="value" /> よりも小さくなっています。  
  
または 
このインスタンスは非数 (<see cref="F:System.Double.NaN" />) で、<paramref name="value" /> は数値です。  
  
 </description></item><item><term> ゼロ 
 </term><description> このインスタンスは <paramref name="value" /> と同じ値です。  
  
または 
このインスタンスと <paramref name="value" /> は、どちらも <see langword="Double.NaN" />、<see cref="F:System.Double.PositiveInfinity" />、または <see cref="F:System.Double.NegativeInfinity" /> です。</description></item><item><term> 正の整数 
 </term><description> このインスタンスは <paramref name="value" /> よりも大きくなっています。  
  
または 
このインスタンスは数値で、<paramref name="value" /> は非数 (<see cref="F:System.Double.NaN" />) です。  
  
または 
 <paramref name="value" /> が <see langword="null" /> です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` パラメーターは、`null` または `Double`のインスタンスである必要があります。それ以外の場合は、例外がスローされます。 <xref:System.Double>のインスタンスは、その値に関係なく、`null`よりも大きいと見なされます。  
  
 等しいと見なされるためには、値が同一である必要があります。 特に浮動小数点値が複数の数値演算に依存している場合は、有効桁数が失われ、その値が最下位の数字を除いてほぼ同じであることが一般的です。 このため、<xref:System.Double.CompareTo%2A> メソッドの戻り値は、驚くように思えるかもしれません。 たとえば、特定の値による乗算の後に同じ値による除算が行われると、元の値が生成されます。 ただし、次の例では、計算値は元の値よりも大きい値になります。 "R"[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)を使用して、2つの値のすべての有効桁数を表示すると、計算された値が最下位桁の元の値と異なることを示します。 このような比較の処理の詳細については、<xref:System.Double.Equals%28System.Double%29> メソッドの「解説」を参照してください。  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 このメソッドは、<xref:System.IComparable> インターフェイスをサポートするために実装されています。 <xref:System.Double.NaN> は別の <xref:System.Double.NaN> (それ自体も含む) とは見なされませんが、<xref:System.IComparable> インターフェイスでは、`A.CompareTo(A)` が0を返す必要があります。  
  
## <a name="precision-in-comparisons"></a>比較における精度  
 ドキュメント化された有効桁数を超える浮動小数点数の有効桁数は、.NET Framework の実装とバージョンに固有です。 その結果、数値の内部表現の有効桁数が変更される可能性があるため、2つの特定の数値の比較が .NET Framework のバージョン間で変わる可能性があります。  
  
   
  
## Examples  
 次のコード例は、`Double`のコンテキストでの `CompareTo` の使用方法を示しています。  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が <see cref="T:System.Double" /> ではありません。</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>ゼロより大きい最小の <see cref="T:System.Double" /> 値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Epsilon> プロパティの値は、<xref:System.Double> インスタンスの値が0の場合に数値演算または比較に有意な最小の正 <xref:System.Double> 値を反映します。 たとえば、次のコードは、0と <xref:System.Double.Epsilon> が等しくない値であると見なされ、<xref:System.Double.Epsilon> の0と半分の値は等しいと見なされることを示しています。  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 より正確には、浮動小数点形式は、符号、52ビットの仮数または有効桁、および11ビットの指数で構成されます。 次の例に示すように、0の指数は-1022、仮数は0です。 <xref:System.Double.Epsilon> の指数は-1022、仮数は1です。 これは、<xref:System.Double.Epsilon> が0よりも大きい最小の正の <xref:System.Double> 値であり、可能な最小値を表し、指数が-1022 の <xref:System.Double> に対して可能な最小のインクリメントであることを意味します。  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 ただし、<xref:System.Double.Epsilon> プロパティは、<xref:System.Double> 型の有効桁数の一般的な尺度ではありません。この値は、0または-1022 の指数を持つ <xref:System.Double> インスタンスにのみ適用されます。  
  
> [!NOTE]
>  <xref:System.Double.Epsilon> プロパティの値は、浮動小数点演算における丸め処理による相対誤差の上限を表すコンピューターイプシロンと等価ではありません。  
  
 この定数の値は 4.94065645841247 e-324 です。  
  
 意味が低い2つの浮動小数点数は、少なくとも有効桁数が異なるため、等しいと比較できない場合があります。 たとえば、 C#式の `(double)1/3 == (double)0.33333`は、左辺の除算演算には最大有効桁数があり、右側の定数は指定された桁数だけであるため、等しいかどうかを比較しません。 2つの浮動小数点数を等しいと見なすことができるかどうかを決定するカスタムアルゴリズムを作成する場合は、アルゴリズムを <xref:System.Double.Epsilon> 定数の値に基づいて、2つの値が等しいと見なされるために許容される絶対余白を設定することをお勧めしません。  (通常、この余白の差は <xref:System.Double.Epsilon>よりも多くの回数になります)。2つの倍精度浮動小数点値の比較の詳細については、「<xref:System.Double>」と「<xref:System.Double.Equals%28System.Double%29>」を参照してください。  
  
## <a name="platform-notes"></a>プラットフォームに関する注意事項  
 ARM システムでは、<xref:System.Double.Epsilon> 定数の値が小さすぎて検出できないため、0になります。 代わりに、2.2250738585072014 E-308 と等しい別のイプシロン値を定義できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Double" /> の 2 つのインスタンスが同じ値を表しているかどうかを示す値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較する <see cref="T:System.Double" /> オブジェクト。</param>
        <summary>このインスタンスと指定した <see cref="T:System.Double" /> オブジェクトが同じ値を表しているかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> がこのインスタンスと等しい場合は <paramref name="obj" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.IEquatable%601?displayProperty=nameWithType> インターフェイスを実装し、`obj` パラメーターをオブジェクトに変換する必要がないため、<xref:System.Double.Equals%2A> よりもわずかにパフォーマンスが向上します。  
  
## <a name="widening-conversions"></a>拡大変換  
 プログラミング言語によっては、パラメーターの型がインスタンスの型よりも少ない (幅が狭い) <xref:System.Double.Equals%2A> メソッドをコーディングすることができます。 これが可能なのは、一部のプログラミング言語では、インスタンスと同数のビットを持つ型として、パラメーターを表す暗黙的な拡大変換が実行されるためです。  
  
 たとえば、インスタンスの型が <xref:System.Double> で、パラメーターの型が <xref:System.Int32>であるとします。 Microsoft C#コンパイラは、パラメーターの値を <xref:System.Double> オブジェクトとして表す命令を生成し、インスタンスの値とパラメーターの拡張表現を比較する <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> メソッドを生成します。  
  
 プログラミング言語のドキュメントを参照して、コンパイラが数値型の暗黙的な拡大変換を実行するかどうかを判断します。 詳細については、「[型変換の表](~/docs/standard/base-types/conversion-tables.md)」を参照してください。  
  
## <a name="precision-in-comparisons"></a>比較における精度  
 2つの値の有効桁数が異なるため、2つの意味のある値は等しくない可能性があるため、<xref:System.Double.Equals%2A> メソッドは注意して使用する必要があります。 次の例では、<xref:System.Double> 値333333と、1を3で割ることによって返される <xref:System.Double> 値が等しくないことを報告しています。  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 1つの手法では、等しいかどうかを比較するのではなく、2つの値の差に許容される相対余白を定義します (1 つの値の .001% など)。 2つの値の差の絶対値がその余白以下の場合は、精度の違いによって違いが生じる可能性が高いため、値が等しい可能性があります。 次の例では、この手法を使用して33333と1/3 を比較しています。これは、前のコード例の2つの <xref:System.Double> 値が等しくないことを示しています。 この場合、値は等しいと見なされます。  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  <xref:System.Double.Epsilon> は、範囲がゼロ付近の正の値の最小式を定義するため、2つの類似する値の差の余白は <xref:System.Double.Epsilon>よりも大きくする必要があります。 通常、<xref:System.Double.Epsilon>よりも多くの回数になります。 このため、<xref:System.Double> 値が等しいかどうかを比較する場合は、<xref:System.Double.Epsilon> を使用しないことをお勧めします。  
  
 2番目の手法では、2つの浮動小数点数の差を絶対値で比較します。 差分値がその絶対値以下の場合、数値は等しいと見なされます。 値が大きい場合、数値は等しくありません。 別の方法として、絶対値を任意に選択する方法があります。 ただし、これは問題になります。これは、許容される差の余白が <xref:System.Double> 値の大きさによって異なるためです。 2番目の代替手段は、浮動小数点形式のデザイン機能を利用します。2つの浮動小数点値の整数表現の差は、浮動小数点値を区切る可能性のある浮動小数点値の数を示します。 たとえば、0.0 と <xref:System.Double.Epsilon> の差は1です。これは、値がゼロである <xref:System.Double> を操作するときに、<xref:System.Double.Epsilon> が最も小さい表現可能な値であるためです。 次の例では、この手法を使用して33333と1/3 を比較しています。これは、前のコード例で <xref:System.Double.Equals%28System.Double%29> メソッドを使用した場合と等しくないことが判明した2つの <xref:System.Double> 値です。 この例では、<xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> メソッドを使用して、倍精度浮動小数点値を整数表現に変換します。  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 ドキュメント化された有効桁数を超える浮動小数点数の有効桁数は、.NET Framework の実装とバージョンに固有です。 その結果、数値の内部表現の有効桁数が変更される可能性があるため、2つの特定の数値の比較が .NET Framework のバージョン間で変わる可能性があります。  
  
 <xref:System.Double.Equals%2A> メソッドを呼び出すことによって2つの <xref:System.Double.NaN?displayProperty=nameWithType> 値が等しいかどうかをテストした場合、メソッドは `true`を返します。 ただし、等値演算子を使用して2つの <xref:System.Double.NaN> 値が等しいかどうかをテストした場合、演算子は `false`を返します。 <xref:System.Double> の値が非数 (NaN) であるかどうかを判断するには、別の方法として、<xref:System.Double.IsNaN%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>コンパイラのオーバーロードの解決では、2つの <see cref="M:System.Double.Equals(System.Object)" /> メソッドオーバーロードの動作の明らかな違いが考慮されます。 <paramref name="obj" /> 引数と <see cref="T:System.Double" /> の間の暗黙的な変換が定義されていて、引数が <see cref="T:System.Object" />として型指定されていない場合、コンパイラは暗黙的な変換を実行して <see cref="M:System.Double.Equals(System.Double)" /> メソッドを呼び出す可能性があります。 それ以外の場合は、<see cref="M:System.Double.Equals(System.Object)" /> メソッドを呼び出します。このメソッドは、<paramref name="obj" /> 引数が <see cref="T:System.Double" /> 値でない場合は常に <see langword="false" /> を返します。 次の例は、2つのメソッドオーバーロード間の動作の違いを示しています。 <see cref="T:System.Decimal" /> とのを除くすべてのプリミティブ数値型の場合C#、コンパイラは、自動的に拡大変換を実行して <see cref="M:System.Double.Equals(System.Double)" /> メソッドを呼び出します。一方、2番目の <see langword="false" /> 比較では、コンパイラが <see cref="M:System.Double.Equals(System.Object)" /> メソッドを呼び出すため、<see langword="true" /> が返されます。  
  
[! code-csharp[# 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)][! code-vb system.string[# 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較するオブジェクトです。</param>
        <summary>このインスタンスが指定したオブジェクトと同一であるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="obj" /> のインスタンスで、このインスタンスの値に等しい場合は <see cref="T:System.Double" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2つの値の有効桁数が異なるため、2つの意味のある値は等しくない可能性があるため、<xref:System.Double.Equals%2A> メソッドは注意して使用する必要があります。 次の例では、<xref:System.Double> 値3333と、1を3で除算して返された <xref:System.Double> が等しくないことを報告しています。  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 <xref:System.Double.Equals%2A> メソッドを呼び出す方法の代替手段については、<xref:System.Double.Equals%28System.Double%29> のオーバーロードに関するドキュメントを参照してください。  
  
> [!NOTE]
>  <xref:System.Double.Epsilon> は、範囲がゼロ付近の正の値の最小式を定義するため、2つの類似する値の差の余白は <xref:System.Double.Epsilon>よりも大きくする必要があります。 通常、<xref:System.Double.Epsilon>よりも多くの回数になります。  
  
 ドキュメント化された有効桁数を超える浮動小数点数の有効桁数は、.NET Framework の実装とバージョンに固有です。 その結果、数値の内部表現の有効桁数が変更される可能性があるため、2つの特定の数値の比較が .NET Framework のバージョン間で変わる可能性があります。  
  
 <xref:System.Double.Equals%2A> メソッドを呼び出すことによって2つの <xref:System.Double.NaN?displayProperty=nameWithType> 値が等しいかどうかをテストした場合、メソッドは `true`を返します。 ただし、等値演算子を使用して2つの <xref:System.Double.NaN> 値が等しいかどうかをテストした場合、演算子は `false`を返します。 <xref:System.Double> の値が非数 (NaN) であるかどうかを判断するには、別の方法として、<xref:System.Double.IsNaN%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>コンパイラのオーバーロードの解決では、2つの <see cref="M:System.Double.Equals(System.Object)" /> メソッドオーバーロードの動作の明らかな違いが考慮されます。 <paramref name="obj" /> 引数と <see cref="T:System.Double" /> の間の暗黙的な変換が定義されていて、引数が <see cref="T:System.Object" />として型指定されていない場合、コンパイラは暗黙的な変換を実行して <see cref="M:System.Double.Equals(System.Double)" /> メソッドを呼び出す可能性があります。 それ以外の場合は、<see cref="M:System.Double.Equals(System.Object)" /> メソッドを呼び出します。このメソッドは、<paramref name="obj" /> 引数が <see cref="T:System.Double" /> 値でない場合は常に <see langword="false" /> を返します。 次の例は、2つのメソッドオーバーロード間の動作の違いを示しています。 <see cref="T:System.Decimal" /> とのを除くすべてのプリミティブ数値型の場合C#、コンパイラは、自動的に拡大変換を実行して <see cref="M:System.Double.Equals(System.Double)" /> メソッドを呼び出します。一方、2番目の <see langword="false" /> 比較では、コンパイラが <see cref="M:System.Double.Equals(System.Object)" /> メソッドを呼び出すため、<see langword="true" /> が返されます。  
  
[! code-csharp[# 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)][! code-vb system.string[# 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビットの符号付き整数のハッシュ コードです。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.TypeCode" /> 値型の <see cref="T:System.Double" /> を返します。</summary>
        <returns>列挙型定数 <see cref="F:System.TypeCode.Double" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定の値が有限 (ゼロ、非正規、または正規) かどうかを判断します。</summary>
        <returns>値が有限 (ゼロ、非正規、または正規) の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した数値が負または正の無限大と評価されるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="d" /> または <see cref="F:System.Double.PositiveInfinity" /> と評価される場合は <see cref="F:System.Double.NegativeInfinity" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮動小数点演算は、オーバーフロー状態を通知するために <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> を返します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.IsInfinity%2A>の使用方法を示しています。  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した値が非数値 (<see cref="F:System.Double.NaN" />) かどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="d" /> と評価される場合は <see cref="F:System.Double.NaN" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮動小数点演算は、演算の結果が未定義であることを通知するために <xref:System.Double.NaN> を返します。 たとえば、0.0 を0.0 で割ると <xref:System.Double.NaN>になります。  
  
> [!NOTE]
>  <xref:System.Double> 値が <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity>の場合、<xref:System.Double.IsNaN%2A> は `false` を返します。 これらの値をテストするには、<xref:System.Double.IsInfinity%2A>、<xref:System.Double.IsPositiveInfinity%2A>、および <xref:System.Double.IsNegativeInfinity%2A> メソッドを使用します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.IsNaN%2A>の使用方法を示しています。  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した値が負かどうかを判断します。</summary>
        <returns>値が負の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した数値が負の無限大と評価されるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="d" /> と評価される場合は <see cref="F:System.Double.NegativeInfinity" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮動小数点演算は、オーバーフロー状態を通知するために <xref:System.Double.NegativeInfinity> を返します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.IsNegativeInfinity%2A>の使用方法を示しています。  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した値が正規かどうかを判断します。</summary>
        <returns>値が正規の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した数値が正の無限大と評価されるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="d" /> と評価される場合は <see cref="F:System.Double.PositiveInfinity" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮動小数点演算は、オーバーフロー状態を通知するために <xref:System.Double.PositiveInfinity> を返します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.IsPositiveInfinity%2A>の使用方法を示しています。  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した値が非正規かどうかを判断します。</summary>
        <returns>値が非正規の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary><see cref="T:System.Double" /> の最大有効値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この定数の値は、正の 1.7976931348623157 E + 308 です。  
  
 <xref:System.Double.MaxValue?displayProperty=nameWithType> を超える演算の結果は <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>ます。 次の例では、結果が <xref:System.Double.MaxValue?displayProperty=nameWithType>を超えた場合に加算、乗算、および指数演算の結果を <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ます。  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.MaxValue?displayProperty=nameWithType>の使用方法を示しています。  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary><see cref="T:System.Double" /> の最小有効値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この定数の値は、負の 1.7976931348623157 E + 308 です。  
  
 <xref:System.Double.MinValue?displayProperty=nameWithType> よりも小さい演算の結果は <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。 次の例では、結果が <xref:System.Double.MinValue?displayProperty=nameWithType>より小さい場合に、減算および乗算演算の結果を <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> ます。  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.MinValue?displayProperty=nameWithType>の使用方法を示しています。  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>非数 (<see langword="NaN" />) の値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドまたは演算子は、演算の結果が未定義の場合に <xref:System.Double.NaN> を返します。 たとえば、次の例に示すように、0を0で除算した結果は <xref:System.Double.NaN>になります。 (ただし、0以外の数値を0で除算すると、除数の符号に応じて <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity>のいずれかが返されます)。  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 また、次の例に示すように、<xref:System.Double.NaN> 値を持つメソッド呼び出しまたは <xref:System.Double.NaN> 値に対する操作は <xref:System.Double.NaN>を返します。  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 値が数値でないかどうかを判断するには、<xref:System.Double.IsNaN%2A> メソッドを使用します。 <xref:System.Double.op_Equality%2A> 演算子は、2つの <xref:System.Double.NaN> 値が互いに等しくないと見なします。 一般に、<xref:System.Double> 演算子を使用して <xref:System.Double.NaN?displayProperty=nameWithType> を他の <xref:System.Double> 値と比較することはできませんが、比較メソッド (<xref:System.Double.Equals%2A> や <xref:System.Double.CompareTo%2A>など) は使用できます。 次の例は、<xref:System.Double> の比較演算子とメソッド間の動作の違いを示しています。  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 <xref:System.Double.NaN> の使用例を次に示します。  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>負の無限大を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この定数の値は、負の数を0で除算した結果です。  
  
 この定数は、演算の結果が <xref:System.Double.MinValue?displayProperty=nameWithType>よりも小さい場合に返されます。  
  
 値が負の無限大と評価されるかどうかを判断するには、<xref:System.Double.IsNegativeInfinity%2A> を使用します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.NegativeInfinity>の使用方法を示しています。  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した 2 つの <see cref="T:System.Double" /> 値が等しいかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> と <paramref name="left" /> が等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Equality%2A> メソッドは、<xref:System.Double> 値の等値演算子を定義します。  
  
 等値演算子を使用して2つの <xref:System.Double.NaN?displayProperty=nameWithType> 値が等しいかどうかをテストした場合、結果は `false`になります。2つの <xref:System.Double.NaN?displayProperty=nameWithType> 値が等しいとは見なされません。 <xref:System.Double.Equals%2A> メソッドを呼び出すことによって等しいかどうかがテストされると、結果は `true`ます。  <xref:System.Double> の値が非数 (NaN) であるかどうかを判断するには、別の方法として、<xref:System.Double.IsNaN%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値より大きいかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> より大きい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThan%2A> メソッドは、<xref:System.Double> 値の大なり演算子の演算を定義します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値以上かどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> 以上の場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThanOrEqual%2A> メソッドは、<xref:System.Double> 値の大なり演算子または等号演算子の演算を定義します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した 2 つの <see cref="T:System.Double" /> 値が等しくないかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> と <paramref name="left" /> が等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Inequality%2A> メソッドは、<xref:System.Double> 値の非等値演算子を定義します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値より小さいかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> より小さい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThan%2A> メソッドは、<xref:System.Double> 値の小なり演算子の演算を定義します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値以下かどうかを示す値を返します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> 以下の場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThanOrEqual%2A> メソッドは、<xref:System.Double> 値の小なり演算子または等号演算子の演算を定義します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。</summary>
        <altmember cref="Overload:System.Double.TryParse" />
        <remarks>.NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <see cref="F:System.Double.PositiveInfinity" /> または <see cref="F:System.Double.NegativeInfinity" /> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。</summary>
        <returns><paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。

 `s` パラメーターには、現在のカルチャの <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>、または次の形式の文字列を含めることができます。  
  
 [*ws*][*sign*][*整数-数字*[*,*]]*整数の数字*[*。*[*小数点以下の桁数*]][E [*sign*]*指数数字*][*ws*]  
  
 角かっこ ([ および ]) 内の要素は省略可能です。 次の表は、それぞれの要素の説明です。  
  
|要素|説明|  
|-------------|-----------------|  
|*ws*|一連の空白文字。|  
|*sign*|負の符号記号 (-) または正の記号 (+)。 先頭の符号のみを使用できます。|  
|*整数*|数値の整数部を指定する0から9までの一連の数字。 整数部の実行は、*桁*区切り記号で分割できます。 たとえば、一部のカルチャでは、コンマ (,) は、千のグループを分離します。 文字列に*小数部*の要素が含まれている場合、*整数*部の要素は省略できます。|  
|,|カルチャ固有の桁区切り記号。|  
|。|カルチャ固有の小数点の記号。|  
|*小数点以下桁数*|数値の小数部を指定する0から9までの一連の数字。|  
|E|"E" または "E" 文字。値が指数 (科学的) 表記で表されることを示します。|  
|*指数*|指数を指定する0から9までの一連の数字。|  
  
 `s` パラメーターは、<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> と <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> フラグの組み合わせを使用して解釈されます。 これは、たとえば、通貨記号が使用できない場合などに、空白と桁区切り記号が許可されることを意味します。 解析操作が成功するために `s` で許可されるスタイル要素を細かく制御するには、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> または <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出します。  
  
 `s` パラメーターは、現在のスレッドカルチャに対して初期化された <xref:System.Globalization.NumberFormatInfo> オブジェクトの書式情報を使用して解釈されます。 詳細については、<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A> を参照してください。 他のカルチャの書式設定情報を使用して文字列を解析するには、<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> または <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出します。  
  
 通常、<xref:System.Double.ToString%2A?displayProperty=nameWithType> メソッドを呼び出すことによって作成された文字列を <xref:System.Double.Parse%2A?displayProperty=nameWithType> メソッドに渡すと、元の <xref:System.Double> 値が返されます。 ただし、.NET Framework および .NET Core 2.2 以前のバージョンでは、精度が低下しているため、値が等しくない場合があります。 さらに、<xref:System.Double.MinValue?displayProperty=nameWithType> または <xref:System.Double.MaxValue?displayProperty=nameWithType> の文字列形式を解析しようとしても、ラウンドトリップに失敗します。 .NET Framework と .NET Core 2.2 およびそれ以前のバージョンでは、<xref:System.OverflowException>がスローされます。 次に例を示します。 
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  

.NET Framework および .NET Core 2.2 以前のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、<xref:System.Double.Parse%28System.String%29> メソッドは <xref:System.OverflowException>をスローします。

.NET Core 3.0 以降のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、例外はスローされません。 ほとんどの場合、メソッドは <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> または <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>を返します。 ただし、正または負の無限大より <xref:System.Double> の最大値または最小値に近いと見なされる小さい値のセットがあります。 このような場合、メソッドは <xref:System.Double.MaxValue?displayProperty=nameWithType> または <xref:System.Double.MinValue?displayProperty=nameWithType>を返します。

解析操作中に `s` パラメーターで区切り記号が検出され、該当する通貨または数値の10進数と桁区切り記号が同じ場合、解析操作では区切り記号が桁区切り記号ではなく小数点区切りであると見なされます。 区切り記号の詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>」を参照してください。     
  
## Examples  
 <xref:System.Double.Parse%28System.String%29>メソッドの使用例を次に示します。  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> は有効な形式で数値を表していません。</exception>
        <exception cref="T:System.OverflowException">.NET Framework および .NET Core 2.2 以前のバージョンのみ: <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET での数値文字列の解析</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <param name="style"><paramref name="s" /> で使用可能なスタイル要素を示す、列挙値のビットごとの組み合わせ。 通常指定する値は、<see cref="F:System.Globalization.NumberStyles.Float" /> と <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> の組み合わせです。</param>
        <summary>数値の指定したスタイルでの文字列形式を、それと等価な倍精度浮動小数点数に変換します。</summary>
        <returns><paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。

 `style` パラメーターは、解析操作を成功させるために、`s` パラメーターで使用できるスタイル要素 (空白、桁区切り記号、通貨記号など) を定義します。 <xref:System.Globalization.NumberStyles> 列挙体のビットフラグの組み合わせである必要があります。 次の <xref:System.Globalization.NumberStyles> メンバーはサポートされていません。  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` パラメーターには、現在のカルチャの <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>、または <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>を含めることができます。 `style`の値に応じて、次の形式を使用することもできます。  
  
 [*ws*][*$*][*sign*][*整数-数字*[*,*]]*整数の数字*[*。*[*小数点以下の桁数*]][E [*sign*]*指数数字*][*ws*]  
  
 角かっこ ([ および ]) 内の要素は省略可能です。 次の表は、それぞれの要素の説明です。  
  
|要素|説明|  
|-------------|-----------------|  
|*ws*|一連の空白文字。 `style` に <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> フラグが含まれている場合、`s` の先頭に空白が表示され、`style` に <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> フラグが含まれている場合、`s` の最後に表示されることがあります。|  
|$|カルチャ固有の通貨記号。 文字列内での位置は、現在のカルチャの <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> および <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> プロパティによって定義されます。 現在のカルチャの通貨記号は、`style` に <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|*sign*|負の符号記号 (-) または正の記号 (+)。 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> フラグが `style` に含まれている場合、`s` の先頭に符号が表示されます。また、`style` に <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> フラグが含まれている場合は、`s` の最後に表示されます。 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> フラグが `style` 含まれている場合は、`s` でかっこを使用して負の値を示すことができます。|  
|*整数*|数値の整数部を指定する0から9までの一連の数字。 文字列に*小数部*の要素が含まれている場合、*整数*部の要素は省略できます。|  
|,|カルチャ固有のグループ区切り記号。 現在のカルチャの桁区切り記号は、`style` に <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|。|カルチャ固有の小数点の記号。 現在のカルチャの小数点の記号は、`style` に <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|*小数点以下桁数*|数値の小数部を指定する0から9までの一連の数字。 `style` に <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> フラグが含まれている場合、`s` に小数点以下の桁数が表示されます。|  
|E|"E" または "E" 文字。値が指数 (科学的) 表記で表されることを示します。 `s` パラメーターは、`style` に <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> フラグが含まれている場合に指数表記で数値を表すことができます。|  
|*指数*|指数を指定する0から9までの一連の数字。|  
  
> [!NOTE]
> `s` 内の終端の NUL (U + 0000) 文字は、`style` 引数の値に関係なく、解析操作によって無視されます。

 数字のみを含む文字列 (<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> スタイルに対応) は、<xref:System.Double> 型の範囲内にある場合は、常に正常に解析されます。 残りの <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> メンバーは、入力文字列に存在する必要があるが必須ではない要素を制御します。 次の表は、個々の <xref:System.Globalization.NumberStyles> フラグが `s`に存在する可能性のある要素にどのように影響するかを示しています。  
  
|NumberStyles 値|数字に加えて `s` で許可される要素|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整数の数字*の要素のみ。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 (*.*) と*小数部の桁*の要素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|指数表記を示す "e" または "E" 文字。 このフラグ*では、**数字*の形式で値がサポートされます。そのような要素を含む文字列を、正または負の記号や小数点の記号として正常に解析するには、追加のフラグが必要です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|`s`の先頭にある*ws*要素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|`s`の末尾の*ws*要素。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|`s`の先頭にある*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|`s`の末尾の*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|数値を囲むかっこ形式の*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|桁区切り記号 (,) 要素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Currency ($) 要素。|  
|<xref:System.Globalization.NumberStyles.Currency>|すべての要素。 ただし、`s` は、16進数または指数表記の数値を表すことはできません。|  
|<xref:System.Globalization.NumberStyles.Float>|`s`の先頭または末尾にある*ws*要素、`s`の先頭に*符号*、小数点 (.) 記号。 `s` パラメーターでは、指数表記を使用することもできます。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、`sign`、桁区切り記号 (、)、および小数点 (.) の要素。|  
|<xref:System.Globalization.NumberStyles.Any>|すべての要素。 ただし、`s` は16進数を表すことはできません。|  
  
 `s` パラメーターは、現在のシステムカルチャに対して初期化された <xref:System.Globalization.NumberFormatInfo> オブジェクトの書式情報を使用して解析されます。 詳細については、<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A> を参照してください。  
  
 通常、<xref:System.Double.ToString%2A?displayProperty=nameWithType> メソッドを呼び出すことによって作成された文字列を <xref:System.Double.Parse%2A?displayProperty=nameWithType> メソッドに渡すと、元の <xref:System.Double> 値が返されます。 ただし、精度が低下しているため、値が等しくない可能性があります。 さらに、<xref:System.Double.MinValue?displayProperty=nameWithType> または <xref:System.Double.MaxValue?displayProperty=nameWithType> の文字列形式を解析しようとしても、ラウンドトリップに失敗します。 .NET Framework と .NET Core 2.2 およびそれ以前のバージョンでは、<xref:System.OverflowException>がスローされます。 .NET Core 3.0 以降のバージョンでは、<xref:System.Double.MaxValue?displayProperty=nameWithtype>を解析しようとした場合に <xref:System.Double.MinValue?displayProperty=nameWithtype> または <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> を解析しようとすると <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> が返されます。 次に例を示します。 
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]   

.NET Framework および .NET Core 2.2 以前のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> メソッドは <xref:System.OverflowException>をスローします。

.NET Core 3.0 以降のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、例外はスローされません。 ほとんどの場合、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> メソッドは <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> または <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>を返します。 ただし、正または負の無限大より <xref:System.Double> の最大値または最小値に近いと見なされる小さい値のセットがあります。 このような場合、メソッドは <xref:System.Double.MaxValue?displayProperty=nameWithType> または <xref:System.Double.MinValue?displayProperty=nameWithType>を返します。

解析操作中に `s` パラメーターで区切り記号が検出され、該当する通貨または数値の10進数と桁区切り記号が同じ場合、解析操作では区切り記号が桁区切り記号ではなく小数点区切りであると見なされます。 区切り記号の詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>」を参照してください。   
  
## Examples  
 次の例では、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> メソッドを使用して、en-us カルチャを使用して <xref:System.Double> 値の文字列形式を解析します。  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> は有効な形式で数値を表していません。</exception>
        <exception cref="T:System.OverflowException">.NET Framework および .NET Core 2.2 以前のバージョンのみ: <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> が <see cref="T:System.Globalization.NumberStyles" /> 値ではありません。  
  
または 
 <paramref name="style" /> には値 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> が含まれています。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET での数値文字列の解析</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <param name="provider"><paramref name="s" /> に関するカルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>指定したカルチャに固有の書式による数値の文字列形式を、それと等価な倍精度浮動小数点数に変換します。</summary>
        <returns><paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。

 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> メソッドのこのオーバーロードは、通常、さまざまな方法で書式設定できるテキストを <xref:System.Double> の値に変換するために使用されます。 たとえば、ユーザーが入力したテキストを HTML テキストボックスに数値に変換するために使用できます。  
  
 `s` パラメーターは、<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> と <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> フラグの組み合わせを使用して解釈されます。 `s` パラメーターには、`provider`によって指定されたカルチャの <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>、または <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> を含めることができます。また、次の形式の文字列を含めることもできます。  
  
 [*ws*][*sign*]*整数の数字*[*。*[*小数点以下の桁数*]][E [*sign*]*指数数字*][*ws*]  
  
 省略可能な要素は、角かっこ ([および]) で囲まれています。 "Digits" という用語を含む要素は、0から9までの一連の数字で構成されます。  
  
|要素|説明|  
|-------------|-----------------|  
|*ws*|一連の空白文字。|  
|*sign*|負の符号記号 (-) または正の記号 (+)。|  
|*整数*|数値の整数部を指定する0から9までの一連の数字。 整数部の実行は、*桁*区切り記号で分割できます。 たとえば、一部のカルチャでは、コンマ (,) は、千のグループを分離します。 文字列に*小数部*の要素が含まれている場合、*整数*部の要素は省略できます。|  
|。|カルチャ固有の小数点の記号。|  
|*小数点以下桁数*|数値の小数部を指定する0から9までの一連の数字。|  
|E|"E" または "E" 文字。値が指数 (科学的) 表記で表されることを示します。|  
|*指数*|指数を指定する0から9までの一連の数字。|  
  
 数値書式の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。  
  
 `provider` パラメーターは、`s`の形式を解釈するために使用されるカルチャ固有の情報を提供する <xref:System.Globalization.NumberFormatInfo> オブジェクトを <xref:System.IFormatProvider.GetFormat%2A> メソッドが返す、<xref:System.IFormatProvider> の実装です。 通常は、<xref:System.Globalization.NumberFormatInfo> または <xref:System.Globalization.CultureInfo> オブジェクトです。 `provider` が `null` または <xref:System.Globalization.NumberFormatInfo> を取得できない場合は、現在のシステムカルチャの書式情報が使用されます。  
  
 通常、<xref:System.Double.ToString%2A?displayProperty=nameWithType> メソッドを呼び出すことによって作成された文字列を <xref:System.Double.Parse%2A?displayProperty=nameWithType> メソッドに渡すと、元の <xref:System.Double> 値が返されます。 ただし、精度が低下しているため、値が等しくない可能性があります。 さらに、<xref:System.Double.MinValue?displayProperty=nameWithType> または <xref:System.Double.MaxValue?displayProperty=nameWithType> の文字列形式を解析しようとしても、ラウンドトリップに失敗します。 .NET Framework と .NET Core 2.2 およびそれ以前のバージョンでは、<xref:System.OverflowException>がスローされます。 .NET Core 3.0 以降のバージョンでは、<xref:System.Double.MaxValue?displayProperty=nameWithtype>を解析しようとした場合に <xref:System.Double.MinValue?displayProperty=nameWithtype> または <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> を解析しようとすると <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> が返されます。 次に例を示します。
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  

.NET Framework および .NET Core 2.2 以前のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> メソッドは <xref:System.OverflowException>をスローします。

.NET Core 3.0 以降のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、例外はスローされません。 ほとんどの場合、<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> メソッドは <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> または <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>を返します。 ただし、正または負の無限大より <xref:System.Double> の最大値または最小値に近いと見なされる小さい値のセットがあります。 このような場合、メソッドは <xref:System.Double.MaxValue?displayProperty=nameWithType> または <xref:System.Double.MinValue?displayProperty=nameWithType>を返します。

解析操作中に `s` パラメーターで区切り記号が検出され、該当する通貨または数値の10進数と桁区切り記号が同じ場合、解析操作では区切り記号が桁区切り記号ではなく小数点区切りであると見なされます。 区切り記号の詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>」を参照してください。  
 
## Examples  
 次の例は、Web フォームのボタンクリックイベントハンドラーです。 <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> プロパティによって返される配列を使用して、ユーザーのロケールを決定します。 次に、そのロケールに対応する <xref:System.Globalization.CultureInfo> オブジェクトをインスタンス化します。 その <xref:System.Globalization.CultureInfo> オブジェクトに属する <xref:System.Globalization.NumberFormatInfo> オブジェクトを <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> メソッドに渡して、ユーザーの入力を <xref:System.Double> 値に変換します。  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> は有効な形式で数値を表していません。</exception>
        <exception cref="T:System.OverflowException">.NET Framework および .NET Core 2.2 以前のバージョンのみ: <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET での数値文字列の解析</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含む文字スパン。</param>
        <param name="style"><paramref name="s" /> で使用可能なスタイル要素を示す、列挙値のビットごとの組み合わせ。  通常指定する値は、<see cref="F:System.Globalization.NumberStyles.Float" /> と組み合わせた <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> です。</param>
        <param name="provider"><paramref name="s" /> に関するカルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>指定したスタイルおよびカルチャ固有の書式による数値の文字列表現を含む文字スパンを、等価の倍精度浮動小数点数に変換します。</summary>
        <returns><paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

.NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。

`s` が <xref:System.Double> データ型の範囲外の場合、メソッドは `s` が <xref:System.Double.MinValue?displayProperty=nameWithType> 未満の場合は <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> を返し、<xref:System.Double.PositiveInfinity?displayProperty=nameWithType> が `s` よりも大きい場合は <xref:System.Double.MaxValue?displayProperty=nameWithType>を返します。

         ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="s" /> が数値を表していません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> が <see cref="T:System.Globalization.NumberStyles" /> 値ではありません。  
  
または 
 <paramref name="style" /> は <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <param name="style"><paramref name="s" /> で使用可能なスタイル要素を示す、列挙値のビットごとの組み合わせ。 通常指定する値は、<see cref="F:System.Globalization.NumberStyles.Float" /> と組み合わせた <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> です。</param>
        <param name="provider"><paramref name="s" /> に関するカルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>指定したスタイルおよびカルチャ固有の書式での数値の文字列形式を、等価の倍精度浮動小数点数に変換します。</summary>
        <returns><paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。

 `style` パラメーターは、解析操作を成功させるために、`s` パラメーターで使用できるスタイル要素 (空白、桁区切り記号、通貨記号など) を定義します。 <xref:System.Globalization.NumberStyles> 列挙体のビットフラグの組み合わせである必要があります。 次の <xref:System.Globalization.NumberStyles> メンバーはサポートされていません。  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` パラメーターには、`provider`によって指定されたカルチャの <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>、または <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> を含めることができます。 `style`の値に応じて、次の形式を使用することもできます。  
  
 [*ws*][*$*][*sign*][*整数値*,]*整数の数字*[. [*小数点以下の桁数*]][E [*sign*]*指数数字*][*ws*]  
  
 角かっこ ([および]) で囲まれた要素は省略可能です。 次の表は、それぞれの要素の説明です。  
  
|要素|説明|  
|-------------|-----------------|  
|*ws*|一連の空白文字。 `style` に <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> フラグが含まれている場合、`s` の先頭に空白が表示され、`style` に <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> フラグが含まれている場合、`s` の最後に表示されることがあります。|  
|$|カルチャ固有の通貨記号。 文字列内での位置は、現在のカルチャの <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> および <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> プロパティによって定義されます。 現在のカルチャの通貨記号は、`style` に <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|*sign*|負の符号記号 (-) または正の記号 (+)。 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> フラグが `style` に含まれている場合、`s` の先頭に符号が表示されます。また、`style` に <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> フラグが含まれている場合は、`s` の最後に表示されます。 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> フラグが `style` 含まれている場合は、`s` でかっこを使用して負の値を示すことができます。|  
|*整数*|数値の整数部を指定する0から9までの一連の数字。 文字列に*小数部*の要素が含まれている場合、*整数*部の要素は省略できます。|  
|,|カルチャ固有のグループ区切り記号。 現在のカルチャの桁区切り記号は、`style` に <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|。|カルチャ固有の小数点の記号。 現在のカルチャの小数点の記号は、`style` に <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|*小数点以下桁数*|数値の小数部を指定する0から9までの一連の数字。 `style` に <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> フラグが含まれている場合、`s` に小数点以下の桁数が表示されます。|  
|E|"E" または "E" 文字。値が指数 (科学的) 表記で表されることを示します。 `s` パラメーターは、`style` に <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> フラグが含まれている場合に指数表記で数値を表すことができます。|  
|*指数*|指数を指定する0から9までの一連の数字。|  
  
> [!NOTE]
> `s` 内の終端の NUL (U + 0000) 文字は、`style` 引数の値に関係なく、解析操作によって無視されます。

 数字のみを含む文字列 (<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> スタイルに対応) は、<xref:System.Double> 型の範囲内にある場合は、常に正常に解析されます。 残りの <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> メンバーは、入力文字列に存在する必要があるが必須ではない要素を制御します。 次の表は、個々の <xref:System.Globalization.NumberStyles> フラグが `s`に存在する可能性のある要素にどのように影響するかを示しています。  
  
|NumberStyles 値|数字に加えて `s` で許可される要素|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整数の数字*の要素のみ。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 (*.*) と*小数部の桁*の要素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|指数表記を示す "e" または "E" 文字。 このフラグ*では、**数字*の形式で値がサポートされます。そのような要素を含む文字列を、正または負の記号や小数点の記号として正常に解析するには、追加のフラグが必要です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|`s`の先頭にある*ws*要素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|`s`の末尾の*ws*要素。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|`s`の先頭にある*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|`s`の末尾の*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|数値を囲むかっこ形式の*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|桁区切り記号 (,) 要素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Currency ($) 要素。|  
|<xref:System.Globalization.NumberStyles.Currency>|すべての要素。 ただし、`s` は、16進数または指数表記の数値を表すことはできません。|  
|<xref:System.Globalization.NumberStyles.Float>|`s`の先頭または末尾にある*ws*要素、`s`の先頭に*符号*、小数点 (.) 記号。 `s` パラメーターでは、指数表記を使用することもできます。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、`sign`、桁区切り記号 (、)、および小数点 (.) の要素。|  
|<xref:System.Globalization.NumberStyles.Any>|すべての要素。 ただし、`s` は16進数を表すことはできません。|  
  
 `provider` パラメーターは、`s`の形式を解釈するために使用されるカルチャ固有の情報を提供する <xref:System.Globalization.NumberFormatInfo> オブジェクトを <xref:System.IFormatProvider.GetFormat%2A> メソッドが返す、<xref:System.IFormatProvider> の実装です。 通常は、<xref:System.Globalization.NumberFormatInfo> または <xref:System.Globalization.CultureInfo> オブジェクトです。 `provider` が `null` または <xref:System.Globalization.NumberFormatInfo> を取得できない場合は、現在のシステムカルチャの書式情報が使用されます。  
  
 通常、<xref:System.Double.ToString%2A?displayProperty=nameWithType> メソッドを呼び出すことによって作成された文字列を <xref:System.Double.Parse%2A?displayProperty=nameWithType> メソッドに渡すと、元の <xref:System.Double> 値が返されます。 ただし、精度が低下しているため、値が等しくない可能性があります。 さらに、<xref:System.Double.MinValue?displayProperty=nameWithtype> または <xref:System.Double.MaxValue?displayProperty=nameWithType> の文字列形式を解析しようとしても、ラウンドトリップに失敗します。 .NET Framework と .NET Core 2.2 およびそれ以前のバージョンでは、<xref:System.OverflowException>がスローされます。 .NET Core 3.0 以降のバージョンでは、<xref:System.Double.MaxValue?displayProperty=nameWithtype>を解析しようとした場合に <xref:System.Double.MinValue?displayProperty=nameWithtype> または <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> を解析しようとすると <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> が返されます。 次に例を示します。   
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  

.NET Framework および .NET Core 2.2 以前のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> メソッドは <xref:System.OverflowException>をスローします。

.NET Core 3.0 以降のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、例外はスローされません。 ほとんどの場合、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> メソッドは <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> または <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>を返します。 ただし、正または負の無限大より <xref:System.Double> の最大値または最小値に近いと見なされる小さい値のセットがあります。 このような場合、メソッドは <xref:System.Double.MaxValue?displayProperty=nameWithType> または <xref:System.Double.MinValue?displayProperty=nameWithType>を返します。

解析操作中に `s` パラメーターで区切り記号が検出され、該当する通貨または数値の10進数と桁区切り記号が同じ場合、解析操作では区切り記号が桁区切り記号ではなく小数点区切りであると見なされます。 区切り記号の詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>」を参照してください。  

## Examples  
 次の例は、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> メソッドを使用して、`Temperature` オブジェクトに複数の文字列形式の気温値を割り当てる方法を示しています。  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> が数値を表していません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> が <see cref="T:System.Globalization.NumberStyles" /> 値ではありません。  
  
または 
 <paramref name="style" /> は <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 値です。</exception>
        <exception cref="T:System.OverflowException">.NET Framework および .NET Core 2.2 以前のバージョンのみ: <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET での数値文字列の解析</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>正の無限大を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この定数の値は、正の数値を0で除算した結果です。  
  
 この定数は、演算の結果が <xref:System.Double.MaxValue?displayProperty=nameWithType>よりも大きい場合に返されます。  
  
 値が正の無限大と評価されるかどうかを判断するには、<xref:System.Double.IsPositiveInfinity%2A> を使用します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Double.PositiveInfinity>の使用方法を示しています。  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="double.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">比較するオブジェクト。</param>
        <summary>現在のインスタンスを同じ型の別のオブジェクトと比較し、現在のインスタンスの並べ替え順序での位置が、比較対象のオブジェクトと比べて前か、後か、または同じかを示す整数を返します。</summary>
        <returns>比較対象オブジェクトの相対順序を示す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IComparable> インターフェイスにキャストされる場合のみ、使用できます。

戻り値の意味は次のとおりです。

| 値             | 意味                                                                 |
|-------------------|-------------------------------------------------------------------------|
| ゼロより小さい    | このインスタンスの位置が、並べ替え順序において `value` よりも前です。                       |
| ゼロ              | 並べ替え順序における、このインスタンスと `value` の位置が同じです。 |
| ゼロより大きい | このインスタンスの位置が、並べ替え順序において `value` よりも後ろです。                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="double.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インスタンスの <see cref="T:System.TypeCode" /> を返します。</summary>
        <returns>インターフェイスを実装するクラスまたは値型の <see cref="T:System.TypeCode" /> である列挙定数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="double.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在のインスタンスの値が 0 でない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="double.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.Byte" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="double.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>この変換はサポートされていません。 このメソッドを使用しようとすると、<see cref="T:System.InvalidCastException" /> がスローされます。</summary>
        <returns>この変換はサポートされていません。 値は返されません。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="double.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>この変換はサポートされていません。 このメソッドを使用しようとすると、<see cref="T:System.InvalidCastException" /> がスローされます。</summary>
        <returns>この変換はサポートされていません。 値は返されません。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="double.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.Decimal" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="double.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>変更されていない、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="double.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.Int16" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="double.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.Int32" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="double.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.Int64" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="double.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.SByte" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="double.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.Single" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="double.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">この <see cref="T:System.Double" /> 値の変換後の型。</param>
        <param name="provider">戻り値の書式に関するカルチャ固有の情報を提供する <see cref="T:System.IFormatProvider" /> の実装。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><paramref name="type" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、`static` (Visual Basic で`Shared`) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="double.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.UInt16" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="double.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.UInt32" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="double.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns><see cref="T:System.UInt64" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの数値を、それと等価な文字列形式に変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの数値を、それと等価な文字列形式に変換します。</summary>
        <returns>このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString> メソッドは、現在のカルチャの既定 ("G" または一般) 形式で <xref:System.Double> 値の書式を設定します。 異なる形式、有効桁数、またはカルチャを指定する場合は、次のように、<xref:System.Double.ToString%2A> メソッドの他のオーバーロードを使用します。  
  
|形式を使用するには|カルチャの場合|オーバーロードを使用する|  
|-------------------|-----------------|----------------------|  
|既定 ("G") 形式|特定のカルチャ|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定の形式または有効桁数|既定の (現在の) カルチャ|<xref:System.Double.ToString%28System.String%29>|  
|特定の形式または有効桁数|特定のカルチャ|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 戻り値には、<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、または形式の文字列を指定できます。  
  
 [sign] 整数桁 [. [小数点以下の桁数]] [E [sign] 指数数字]  
  
 省略可能な要素は、角かっこ ([および]) で囲まれています。 "Digits" という用語を含む要素は、0から9までの一連の数字で構成されます。 次の表に示す要素がサポートされています。  
  
|要素|説明|  
|-------------|-----------------|  
|*sign*|負の符号または正の記号。|  
|*整数*|数値の整数部を指定する一連の数字。 小数部がある場合は、整数の数字を省略できます。|  
|'*.*'|カルチャ固有の小数点の記号。|  
|*小数点以下桁数*|数値の小数部を指定する一連の数字。|  
|'*E*'|指数 (科学的) 表記を示す大文字の "E"。|  
|*指数*|指数を指定する一連の数字。|  
  
 戻り値の例としては、"100"、"-123456789"、"123.45 E + 6"、"500"、"3.1416"、"600"、"-0.123"、"-無限大" などがあります。  
  
 .NET Framework では、さまざまな書式設定がサポートされています。詳細については、次の書式設定に関するトピックを参照してください。  
  
-   数値書式指定子の詳細については、「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
-   書式設定の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、既定の <xref:System.Double.ToString?displayProperty=nameWithType> メソッドを使用して、複数の <xref:System.Double> 値の文字列形式を表示します。  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 次の例は、<xref:System.Double.ToString%2A>の使用方法を示しています。  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このインスタンスの数値を、指定したカルチャ固有の書式情報を使用して、それと等価な文字列形式に変換します。</summary>
        <returns><paramref name="provider" /> で指定された、このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.IFormatProvider%29> メソッドは、指定されたカルチャの既定 ("G" または一般) 形式で <xref:System.Double> 値の書式を設定します。 別の形式またはカルチャを指定する場合は、次のように、<xref:System.Double.ToString%2A> メソッドの他のオーバーロードを使用します。  
  
|形式を使用するには|カルチャの場合|オーバーロードを使用する|  
|-------------------|-----------------|----------------------|  
|既定 ("G") 形式|既定 (現在)|<xref:System.Double.ToString>|  
|特定の形式または有効桁数|既定の (現在の) カルチャ|<xref:System.Double.ToString%28System.String%29>|  
|特定の形式または有効桁数|特定のカルチャ|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 戻り値には、<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、または形式の文字列を指定できます。  
  
 [sign] 整数桁 [. [小数点以下の桁数]] [E [sign] 指数数字]  
  
 省略可能な要素は、角かっこ ([および]) で囲まれています。 "Digits" という用語を含む要素は、0から9までの一連の数字で構成されます。 次の表に示す要素がサポートされています。  
  
|要素|説明|  
|-------------|-----------------|  
|*sign*|負の符号または正の記号。|  
|*整数*|数値の整数部を指定する一連の数字。 小数部がある場合は、整数の数字を省略できます。|  
|'*.*'|カルチャ固有の小数点の記号。|  
|*小数点以下桁数*|数値の小数部を指定する一連の数字。|  
|'*E*'|指数 (科学的) 表記を示す大文字の "E"。|  
|*指数*|指数を指定する一連の数字。|  
  
 戻り値の例としては、"100"、"-123456789"、"123.45 E + 6"、"500"、"3.1416"、"600"、"-0.123"、"-無限大" などがあります。  
  
 このインスタンスは、一般的な数値書式指定子 ("G") で書式設定されます。  
  
 .NET Framework では、さまざまな書式設定がサポートされています。詳細については、次の書式設定に関するトピックを参照してください。  
  
-   数値書式指定子の詳細については、「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
-   書式設定の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。  
  
 `provider` パラメーターは、<xref:System.IFormatProvider.GetFormat%2A> メソッドが <xref:System.Globalization.NumberFormatInfo> オブジェクトを返す <xref:System.IFormatProvider> の実装です。 通常、`provider` は <xref:System.Globalization.CultureInfo> オブジェクトまたは <xref:System.Globalization.NumberFormatInfo> オブジェクトです。 `provider` パラメーターは、書式設定で使用されるカルチャ固有の情報を提供します。 `provider` が `null`場合、戻り値は、現在のカルチャの <xref:System.Globalization.NumberFormatInfo> オブジェクトを使用して書式設定されます。  
  
   
  
## Examples  
 次の例では、複数の異なるカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを使用して、2つの <xref:System.Double> 値の文字列形式を表示します。  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 次の例は、パラメーターとして <xref:System.String> と <xref:System.IFormatProvider> を取得する <xref:System.Double.ToString%2A>の使用方法を示しています。  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">数値書式指定文字列。</param>
        <summary>指定した書式を使用して、このインスタンスの数値を、それと等価な文字列形式に変換します。</summary>
        <returns><paramref name="format" /> で指定された、このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%29> メソッドは、現在のカルチャの規則を使用して、指定した書式で <xref:System.Double> 値を書式設定します。 別の形式またはカルチャを指定する場合は、次のように、<xref:System.Double.ToString%2A> メソッドの他のオーバーロードを使用します。  
  
|形式を使用するには|カルチャの場合|オーバーロードを使用する|  
|-------------------|-----------------|----------------------|  
|既定 ("G") 形式|既定の (現在の) カルチャ|<xref:System.Double.ToString>|  
|既定 ("G") 形式|特定のカルチャ|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定の形式または有効桁数|特定のカルチャ|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 戻り値は、`format`で指定されているように、<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、または数値の文字列形式のいずれかになります。  
  
 `format` パラメーターには、任意の有効な標準数値書式指定子を指定できます。ただし、D と X を除き、カスタム数値書式指定子の任意の組み合わせを使用できます。 `format` が `null` または空の文字列の場合、戻り値は一般的な数値書式指定子 ("G") で書式設定されます。  
  
 .NET Framework では、さまざまな書式設定がサポートされています。詳細については、次の書式設定に関するトピックを参照してください。  
  
-   数値書式指定子の詳細については、「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
-   書式設定の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。  
  
 既定では、戻り値の精度は15桁のみですが、内部的には最大17桁が保持されます。 このインスタンスの値が15桁を超える場合、<xref:System.Double.ToString%2A> は、予期された数ではなく <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> または <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> を返します。 精度をさらに高める必要がある場合は、"G17" 書式指定を使用して `format` を指定します。これは常に17桁の有効桁数を返します。 "R" は、数字を有効桁数で表すことができる場合は15桁、数字を最大有効桁数で表すことができる場合は17桁を返します。  
  
   
  
## Examples  
 次の例では、数値を定義し、"C" 標準の数値書式指定文字列を使用して通貨値として書式設定し、"N" 標準の数値書式指定文字列を使用して小数点以下3桁の数値として書式指定します。 結果の文字列は、en-us カルチャの規則を使用して書式設定されます。 数値書式指定文字列の詳細については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 次の例では、サポートされている標準数値書式指定子と3つのカスタム数値書式指定文字列を使用して、いくつかの <xref:System.Double> 値を表示します。 これらのカスタム書式指定文字列の1つは、<xref:System.Single> 値に先行ゼロを埋め込む方法を示しています。 また、この例では、"R" を除き、各標準書式指定子で精度指定子を使用します。 精度指定子の値の範囲は 0 ~ 3 です。 数値を文字列に変換するために、この例では en-us カルチャの書式指定規則を使用します。  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> が正しくありません。</exception>
        <block subset="none" type="usage"><para>場合によっては、<see cref="T:System.Double" /> スイッチまたは <see langword="/platform:x64" /> スイッチを使用してコンパイルして 64 ビット システムで実行すると、"R" 標準の数値書式指定文字列で書式設定される <see langword="/platform:anycpu" /> 値のラウンドトリップに失敗することがあります。 この問題を回避するには、"G17" 標準の数値書式指定文字列を使用して <see cref="T:System.Double" /> 値を書式設定することができます。 次の例では、ラウンドトリップに失敗する <see cref="T:System.Double" /> 値を持つ "R" 書式指定文字列を使用しています。元の値のラウンドトリップに成功する "G17" 書式指定文字列も使用しています。  
  
[! code-csharp[# 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)][! コード-vb[システム. ToString # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">方法: 数値に先行するゼロを埋め込む</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">数値書式指定文字列。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このインスタンスの数値を、指定した書式およびカルチャ固有の書式情報を使用して、それと等価な文字列形式に変換します。</summary>
        <returns><paramref name="format" /> および <paramref name="provider" /> で指定された、このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> メソッドは、指定されたカルチャの指定された書式で <xref:System.Double> 値の書式を設定します。 別の形式またはカルチャを指定する場合は、次のように、<xref:System.Double.ToString%2A> メソッドの他のオーバーロードを使用します。  
  
|形式を使用するには|カルチャの場合|オーバーロードを使用する|  
|-------------------|-----------------|----------------------|  
|既定 ("G") 形式|既定の (現在の) カルチャ|<xref:System.Double.ToString>|  
|既定 ("G") 形式|特定のカルチャ|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定の形式または有効桁数|既定の (現在の) カルチャ|<xref:System.Double.ToString%28System.String%29>|  
  
 戻り値は、`format`で指定されているように、<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、または数値の文字列形式のいずれかになります。  
  
 `format` パラメーターには、任意の有効な標準数値書式指定子を指定できます。ただし、D と X を除き、カスタム数値書式指定子の任意の組み合わせを使用できます。 `format` が `null` または空の文字列の場合、このインスタンスの戻り値は、一般的な数値書式指定子 ("G") で書式設定されます。  
  
 .NET Framework では、さまざまな書式設定がサポートされています。詳細については、次の書式設定に関するトピックを参照してください。  
  
-   数値書式指定子の詳細については、「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
-   書式設定の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。  
  
 `provider` パラメーターは、<xref:System.IFormatProvider.GetFormat%2A> メソッドが <xref:System.Globalization.NumberFormatInfo> オブジェクトを返す <xref:System.IFormatProvider> の実装です。 通常、`provider` は <xref:System.Globalization.CultureInfo> オブジェクトまたは <xref:System.Globalization.NumberFormatInfo> オブジェクトです。 `provider` パラメーターは、書式設定で使用されるカルチャ固有の情報を提供します。 `provider` が `null`場合、戻り値は、現在のカルチャの <xref:System.Globalization.NumberFormatInfo> オブジェクトを使用して書式設定されます。  
  
 既定では、戻り値の精度は15桁のみですが、内部的には最大17桁が保持されます。 このインスタンスの値が15桁を超える場合、<xref:System.Double.ToString%2A> は、予期された数ではなく <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> または <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> を返します。 精度をさらに高める必要がある場合は、"G17" 書式指定を使用して `format` を指定します。これは常に17桁の有効桁数を返します。 "R" は、数字を有効桁数で表すことができる場合は15桁、数字を最大有効桁数で表すことができる場合は17桁を返します。  
  
   
  
## Examples  
 次の例では、複数の異なるカルチャに対してサポートされている各標準数値書式指定子を使用して、<xref:System.Double> 値を表示します。  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 次の例は、パラメーターとして <xref:System.String> と <xref:System.IFormatProvider> を取得する <xref:System.Double.ToString%2A>の使用方法を示しています。  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>場合によっては、<see cref="T:System.Double" /> スイッチまたは <see langword="/platform:x64" /> スイッチを使用してコンパイルして 64 ビット システムで実行すると、"R" 標準の数値書式指定文字列で書式設定される <see langword="/platform:anycpu" /> 値のラウンドトリップに失敗することがあります。 この問題を回避するには、"G17" 標準の数値書式指定文字列を使用して <see cref="T:System.Double" /> 値を書式設定することができます。 次の例では、ラウンドトリップに失敗する <see cref="T:System.Double" /> 値を持つ "R" 書式指定文字列を使用しています。元の値のラウンドトリップに成功する "G17" 書式指定文字列も使用しています。  
  
[! code-csharp[# 5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)][! コード-vb[システム. ToString # 5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">方法: 数値に先行するゼロを埋め込む</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-cs/">サンプル: .NET Core WinForms 書式指定ユーティリティC#()</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-vb/">サンプル: .NET Core WinForms の書式設定ユーティリティ (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">このメソッドが返すときに、文字のスパンとして書式設定されているこのインスタンスの値。</param>
        <param name="charsWritten">このメソッドが返すときに、<paramref name="destination" /> に書き込まれる文字数。</param>
        <param name="format"><paramref name="destination" /> に許容される書式を定義する、標準またはカスタムの書式指定文字列を表す文字を格納しているスパン。</param>
        <param name="provider"><paramref name="destination" /> のカルチャ固有の書式情報を指定する省略可能なオブジェクト。</param>
        <summary>現在の double 型インスタンスの値の、指定した文字スパンへの書式設定を試みます。</summary>
        <returns>書式設定が正常に実行された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。 戻り値は変換が成功したか失敗したかを示します。</summary>
        <remarks>.NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <see cref="F:System.Double.PositiveInfinity" /> または <see cref="F:System.Double.NegativeInfinity" /> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。</remarks>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値の文字列表現を含む文字スパン。</param>
        <param name="result">このメソッドから戻るとき、変換に成功した場合は、<paramref name="s" /> パラメーターに含まれている数値または記号と等価の倍精度浮動小数点数が格納されます。変換に失敗した場合は 0 が格納されます。 <paramref name="s" /> パラメーターが <see langword="null" /> または空の場合、または <paramref name="style" /> に従った形式ではない場合、変換は失敗します。 <paramref name="style" /> が <see cref="T:System.Globalization.NumberStyles" /> 列挙定数の有効な組み合わせではない場合も、変換は失敗します。 <paramref name="s" /> が <see cref="F:System.Double.MinValue" /> 未満の有効な数値である場合、<paramref name="result" /> は <see cref="F:System.Double.NegativeInfinity" /> です。 <paramref name="s" /> が <see cref="F:System.Double.MaxValue" /> より大きい有効な数値である場合、<paramref name="result" /> は <see cref="F:System.Double.PositiveInfinity" /> です。 このパラメーターは初期化されていない状態で渡されています。<paramref name="result" /> で最初に指定された任意の値が上書きされます。</param>
        <summary>指定したスタイルおよびカルチャ固有の書式による数値のスパン表現を、等価の倍精度浮動小数点数に変換します。 戻り値は変換が成功したか失敗したかを示します。</summary>
        <returns><see langword="true" /> が正常に変換された場合は <paramref name="s" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>.NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <see cref="F:System.Double.PositiveInfinity" /> または <see cref="F:System.Double.NegativeInfinity" /> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含む文字列。</param>
        <param name="result">変換が成功した場合、このメソッドから戻るときに、<paramref name="s" /> パラメーターの値と等価の倍精度浮動小数点数を格納します。変換に失敗した場合は 0 を格納します。 <paramref name="s" /> パラメーターが <see langword="null" /> または <see cref="F:System.String.Empty" /> の場合、または有効な形式の数値でない場合、変換は失敗します。 <paramref name="s" /> が <see cref="F:System.Double.MinValue" /> 未満または <see cref="F:System.Double.MaxValue" /> を超える数値を表す場合、.NET Framework および .NET Core 2.2 以前のバージョンでも失敗します。 このパラメーターは初期化されていない状態で渡されています。<paramref name="result" /> で最初に指定された任意の値が上書きされます。</param>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。 戻り値は変換が成功したか失敗したかを示します。</summary>
        <returns><see langword="true" /> が正常に変換された場合は <paramref name="s" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。

 このオーバーロードは、解析された数値を返すのではなく、解析操作が成功したかどうかを示すブール値を返すことによって、<xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> メソッドとは異なります。 これにより、`s` が無効で、正常に解析できない場合に、例外処理を使用して <xref:System.FormatException> をテストする必要がなくなります。  
  
 `s` パラメーターには、現在のカルチャの <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (文字列比較では大文字と小文字が区別されます)、または次の形式の文字列を含めることができます。  
  
 jax-wsシャープ[整数数字,] 整数桁 [. [小数点以下の桁数]] [e [sign] 指数数字] [ws]  
  
 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。  
  
|要素|説明|  
|-------------|-----------------|  
|*ws*|一連の空白文字。|  
|*sign*|負の符号または正の記号。|  
|*整数*|数値の整数部を指定する0から9までの一連の数字。 小数部がある場合は、整数の数字を省略できます。|  
|*、*|カルチャ固有のグループ区切り記号。|  
|*」を参照してください。*|カルチャ固有の小数点の記号。|  
|*小数点以下桁数*|数値の小数部を指定する0から9までの一連の数字。|  
|*E*|指数 (科学的) 表記を示す大文字または小文字の "e"。|  
|*指数*|指数を指定する0から9までの一連の数字。|  
  
 数値書式の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。  
  
 `s` パラメーターは、<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> と <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> フラグの組み合わせを使用して解釈されます。 つまり、空白と桁区切り記号は許可されますが、通貨記号は使用できません。 `s`に含まれる要素 (通貨記号、桁区切り記号、空白文字など) を明示的に定義するには、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> メソッドオーバーロードを使用します。  
  
 `s` パラメーターは、現在のシステムカルチャに対して初期化された <xref:System.Globalization.NumberFormatInfo> オブジェクトの書式情報を使用して解析されます。 詳細については、<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType> を参照してください。 他の指定したカルチャの書式情報を使用して文字列を解析するには、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> メソッドのオーバーロードを使用します。  
  
 通常、<xref:System.Double.ToString%2A?displayProperty=nameWithType> メソッドを呼び出すことによって作成された文字列を <xref:System.Double.TryParse%2A?displayProperty=nameWithType> メソッドに渡すと、元の <xref:System.Double> 値が返されます。 ただし、精度が低下しているため、値が等しくない可能性があります。 さらに、<xref:System.Double.MinValue?displayProperty=nameWithType> または <xref:System.Double.MaxValue?displayProperty=nameWithType> の文字列形式を解析しようとしても、ラウンドトリップに失敗します。 .NET Framework と .NET Core 2.2 およびそれ以前のバージョンでは、<xref:System.OverflowException>がスローされます。 .NET Core 3.0 以降のバージョンでは、<xref:System.Double.MaxValue?displayProperty=nameWithtype>を解析しようとした場合に <xref:System.Double.MinValue?displayProperty=nameWithtype> または <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> を解析しようとすると <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> が返されます。 次に例を示します。 
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  

.NET Framework および .NET Core 2.2 以前のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、<xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> メソッドは <xref:System.OverflowException>をスローします。

.NET Core 3.0 以降のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、例外はスローされません。 ほとんどの場合、<xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> メソッドは <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> または <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>の結果を計算します。 ただし、正または負の無限大より <xref:System.Double> の最大値または最小値に近いと見なされる小さい値のセットがあります。 このような場合、メソッドは <xref:System.Double.MaxValue?displayProperty=nameWithType> または <xref:System.Double.MinValue?displayProperty=nameWithType>の結果を計算します。

解析操作中に `s` パラメーターで区切り記号が検出され、小数点と桁区切り記号が同じ場合、解析操作では区切り記号が桁区切り記号ではなく小数点区切りであると見なされます。 区切り記号の詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>」を参照してください。  
  
## Examples  
 次の例では、<xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> メソッドを使用して、数値の文字列形式を <xref:System.Double> の値に変換します。 En-us が現在のカルチャであることを前提としています。  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET での数値文字列の解析</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-cs/">サンプル: .NET Core WinForms 書式指定ユーティリティC#()</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-vb/">サンプル: .NET Core WinForms の書式設定ユーティリティ (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含む読み取り専用の文字スパン。</param>
        <param name="style"><see cref="T:System.Globalization.NumberStyles" /> で使用可能な書式を示す、<paramref name="s" /> 値のビットごとの組み合わせ。 通常指定する値は、<see cref="F:System.Globalization.NumberStyles.Float" /> と組み合わせた <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> です。</param>
        <param name="provider"><paramref name="s" /> に関するカルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="result">このメソッドから戻るとき、変換が成功した場合は、<paramref name="s" /> に格納された数値または記号と等価の倍精度浮動小数点数が格納されます。 変換に失敗した場合は、0 が格納されます。 <paramref name="s" /> パラメーターが、<see langword="null" />、空の文字スパン、または <paramref name="style" /> に従った書式の数値ではない場合、変換は失敗します。 <paramref name="s" /> が <see cref="F:System.Double.MinValue" /> 未満の有効な数値である場合、<paramref name="result" /> は <see cref="F:System.Double.NegativeInfinity" /> です。 <paramref name="s" /> が <see cref="F:System.Double.MaxValue" /> より大きい有効な数値である場合、<paramref name="result" /> は <see cref="F:System.Double.PositiveInfinity" /> です。 このパラメーターは初期化されていない状態で渡されています。<paramref name="result" /> で最初に指定された任意の値が上書きされます。</param>
        <summary>指定したスタイルおよびカルチャ固有の書式による数値の文字列表現を含む文字スパンを、等価の倍精度浮動小数点数に変換します。 戻り値は変換が成功したか失敗したかを示します。</summary>
        <returns><see langword="true" /> が正常に変換された場合は <paramref name="s" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>.NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <see cref="F:System.Double.PositiveInfinity" /> または <see cref="F:System.Double.NegativeInfinity" /> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含む文字列。</param>
        <param name="style"><see cref="T:System.Globalization.NumberStyles" /> で使用可能な書式を示す、<paramref name="s" /> 値のビットごとの組み合わせ。 通常指定する値は、<see cref="F:System.Globalization.NumberStyles.Float" /> と組み合わせた <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> です。</param>
        <param name="provider"><see cref="T:System.IFormatProvider" /> に関するカルチャに固有の書式設定情報を提供する <paramref name="s" />。</param>
        <param name="result">変換が成功した場合、このメソッドから戻るときに、<paramref name="s" /> に格納された数値または記号と等価の倍精度浮動小数点数を格納します。変換に失敗した場合は 0 を格納します。 <paramref name="s" /> パラメーターが <see langword="null" /> または <see cref="F:System.String.Empty" /> の場合、<paramref name="style" /> に準拠する形式ではない場合、または <paramref name="style" /> が <see cref="T:System.Globalization.NumberStyles" /> 列挙定数の有効な組み合わせでない場合、変換は失敗します。 <paramref name="s" /> が <see cref="F:System.SByte.MinValue" /> 未満または <see cref="F:System.SByte.MaxValue" /> を超える数値を表す場合、.NET Framework または .NET Core 2.2 以前のバージョンでも失敗します。 このパラメーターは初期化されていない状態で渡されています。<paramref name="result" /> で最初に指定された任意の値が上書きされます。</param>
        <summary>指定したスタイルおよびカルチャ固有の書式での数値の文字列形式を、等価の倍精度浮動小数点数に変換します。 戻り値は変換が成功したか失敗したかを示します。</summary>
        <returns><see langword="true" /> が正常に変換された場合は <paramref name="s" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Core 3.0 以降では、表すには大きすぎる値は、IEEE 754 仕様で必要とされる <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> するように丸められます。 以前のバージョン (.NET Framework を含む) では、大きすぎる値を解析して、エラーが発生しました。

 <xref:System.Double.TryParse%2A> メソッドは <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> メソッドに似ていますが、変換に失敗した場合、このメソッドは例外をスローしません。 変換が成功した場合、戻り値は `true`、`result` パラメーターは変換の結果に設定されます。 変換に失敗した場合、戻り値は `false`、`result` パラメーターは0に設定されます。 これにより、`s` が無効で、正常に解析できない場合に、例外処理を使用して <xref:System.FormatException> をテストする必要がなくなります。  
  
 `style` パラメーターは、解析操作を成功させるために使用できる `s` パラメーターの形式を定義します。 <xref:System.Globalization.NumberStyles> 列挙体のビットフラグの組み合わせである必要があります。 次の <xref:System.Globalization.NumberStyles> メンバーはサポートされていません。  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s` パラメーターには、`provider`によって示されるカルチャの <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>、<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>、または <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> を含めることができます。 さらに、`style`の値に応じて、`s` パラメーターには次の要素を含めることができます。  
  
 jax-ws[$]シャープ[整数、] 整数の数字 [. 小数部の桁] [e [sign] 指数数字] [ws]  
  
 角かっこ ([ および ]) 内の要素は省略可能です。 次の表は、それぞれの要素の説明です。  
  
|要素|説明|  
|-------------|-----------------|  
|*ws*|省略可能な空白。 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> フラグが `style` に含まれている場合、`s` の先頭に空白が表示されることがあります。 `style` に <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> フラグが含まれている場合は、`s` の最後に表示されます。|  
|*$*|カルチャ固有の通貨記号。 文字列内の位置は、`provider` パラメーターの <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> メソッドによって返される <xref:System.Globalization.NumberFormatInfo> オブジェクトの <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> または <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> プロパティによって定義されます。 通貨記号は、`style` に <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|*sign*|省略可能な符号。 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> フラグが `style` に含まれている場合、`s` の先頭に符号が表示されます。また、`style` に <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> フラグが含まれている場合は、`s` の最後に表示されます。 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> フラグが `style` 含まれている場合は、`s` でかっこを使用して負の値を示すことができます。|  
|*整数*|数値の整数部を指定する0から9までの一連の数字。 小数部がある場合は、整数の数字を省略できます。|  
|*、*|カルチャ固有の桁区切り記号。 現在のカルチャの桁区切り記号は、`style` に <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|*」を参照してください。*|カルチャ固有の小数点の記号。 現在のカルチャの小数点の記号は、`style` に <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> フラグが含まれている場合に `s` に表示されます。|  
|*小数点以下桁数*|数値の小数部を指定する0から9までの一連の数字。 `style` に <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> フラグが含まれている場合、`s` に小数点以下の桁数が表示されます。|  
|*e*|E または E 文字。 `s` が指数表記を使用して数値を表すことができることを示します。 `s` パラメーターは、style に <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> フラグが含まれている場合に指数表記で数値を表すことができます。|  
|*指数*|指数を指定する0から9までの一連の数字。|  
  
> [!NOTE]
> `s` 内の終端の NUL (U + 0000) 文字は、`style` 引数の値に関係なく、解析操作によって無視されます。

 数字のみを含む文字列 (<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> スタイルに対応) は、<xref:System.Double> 型の範囲内にある場合は、常に正常に解析されます。 残りの <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> メンバーは、入力文字列に存在する必要があるが必須ではない要素を制御します。 次の表は、個々の <xref:System.Globalization.NumberStyles> フラグが `s`に存在する可能性のある要素にどのように影響するかを示しています。  
  
|NumberStyles 値|数字に加えてで許可される要素|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整数の数字*の要素のみ。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* と*小数部の桁*の要素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` パラメーターでは、指数表記を使用することもできます。 このフラグによって、*整数*の*指数*部からなる数値がサポートされます。正または負の記号や小数点の記号などの要素を使用して、指数表記で文字列を正常に解析するには、追加のフラグが必要です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|`s`の先頭にある*ws*要素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|`s`の末尾の*ws*要素。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|`s`の先頭にある*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|`s`の末尾の*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|数値を囲むかっこ形式の*sign*要素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|要素 *、* 要素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$* 要素。|  
|<xref:System.Globalization.NumberStyles.Currency>|すべて。 `s` パラメーターは、16進数または指数表記の数値を表すことはできません。|  
|<xref:System.Globalization.NumberStyles.Float>|`s`の先頭または末尾にある*ws* *要素、`s`の先頭にある*、および *。* 表す. `s` パラメーターでは、指数表記を使用することもできます。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、`sign`、桁区切り記号 (*、)、* および小数点 (*.*) の要素。|  
|<xref:System.Globalization.NumberStyles.Any>|`s` を除くすべてのスタイルは、16進数を表すことはできません。|  
  
 `provider` パラメーターは、<xref:System.Globalization.NumberFormatInfo> や <xref:System.Globalization.CultureInfo> オブジェクトなどの <xref:System.IFormatProvider> の実装です。 `provider` パラメーターは、解析に使用されるカルチャ固有の情報を提供します。 `provider` が `null` または <xref:System.Globalization.NumberFormatInfo> オブジェクトを取得できない場合は、現在のカルチャの書式情報が使用されます。  
  
 `s` パラメーターが `null` または数値ではない場合、`provider` パラメーターによって <xref:System.Globalization.NumberFormatInfo> オブジェクトが生成されない場合、または `style` パラメーターが <xref:System.Globalization.NumberStyles> 列挙体のビットフラグの組み合わせではない場合、変換は失敗します。  
  
 通常、<xref:System.Double.ToString%2A?displayProperty=nameWithType> メソッドを呼び出すことによって作成された文字列を <xref:System.Double.TryParse%2A?displayProperty=nameWithType> メソッドに渡すと、元の <xref:System.Double> 値が返されます。 ただし、精度が低下しているため、値が等しくない可能性があります。 さらに、<xref:System.Double.MinValue?displayProperty=nameWithType> または <xref:System.Double.MaxValue?displayProperty=nameWithType> の文字列形式を解析しようとしても、ラウンドトリップに失敗します。 .NET Framework と .NET Core 2.2 およびそれ以前のバージョンでは、<xref:System.OverflowException>がスローされます。 .NET Core 3.0 以降のバージョンでは、<xref:System.Double.MaxValue?displayProperty=nameWithtype>を解析しようとした場合に <xref:System.Double.MinValue?displayProperty=nameWithtype> または <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> を解析しようとすると <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> が返されます。 次に例を示します。
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  

.NET Framework および .NET Core 2.2 以前のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> メソッドは <xref:System.OverflowException>をスローします。

.NET Core 3.0 以降のバージョンでは、`s` が <xref:System.Double> データ型の範囲外にある場合、例外はスローされません。 ほとんどの場合、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> メソッドは <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> または <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>の結果を計算します。 ただし、正または負の無限大より <xref:System.Double> の最大値または最小値に近いと見なされる小さい値のセットがあります。 このような場合、メソッドは <xref:System.Double.MaxValue?displayProperty=nameWithType> または <xref:System.Double.MinValue?displayProperty=nameWithType>の結果を計算します。

 解析操作中に `s` パラメーターで区切り記号が検出され、該当する通貨または数値の10進数と桁区切り記号が同じ場合、解析操作では区切り記号が桁区切り記号ではなく小数点区切りであると見なされます。 区切り記号の詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、<xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>」を参照してください。   
  
## Examples  
 次の例は、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> メソッドを使用して、特定のスタイルを持つ数値の文字列形式を解析し、特定のカルチャの規則を使用して書式設定する方法を示しています。  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> が <see cref="T:System.Globalization.NumberStyles" /> 値ではありません。  
  
または 
 <paramref name="style" /> には値 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> が含まれています。</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET での数値文字列の解析</related>
      </Docs>
    </Member>
  </Members>
</Type>
