<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="59998e80c52c60ec58b5e23b14d6cac92c210b0d" /><Meta Name="ms.sourcegitcommit" Value="48fd27f6aa659b18a958a72b9c956a9db49f2d96" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/12/2020" /><Meta Name="ms.locfileid" Value="79190997" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements IList, IStructuralComparable, IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable&#xA;    interface ICloneable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ICloneable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>配列の作成、操作、検索、および並べ替えを行い、これにより共通言語ランタイムのすべての配列の基本クラスとして機能するメソッドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> クラスは、<xref:System.Collections> 名前空間の一部ではありません。 ただし、これは <xref:System.Collections.IList> インターフェイスに基づいているため、引き続きコレクションと見なされます。  
  
 <xref:System.Array> クラスは、配列をサポートする言語実装の基本クラスです。 ただし、システムとコンパイラだけを <xref:System.Array> クラスから明示的に派生させることができます。 ユーザーは、言語によって提供される配列の構造体を採用する必要があります。  
  
 要素は <xref:System.Array>内の値です。 <xref:System.Array> の長さは、格納できる要素の合計数です。 <xref:System.Array> の下限は、その最初の要素のインデックスです。 <xref:System.Array> は下限を持つことができますが、既定では下限が0になっています。 <xref:System.Array.CreateInstance%2A>を使用して <xref:System.Array> クラスのインスタンスを作成する場合は、異なる下限を定義できます。多次元 <xref:System.Array> は、ディメンションごとに異なる境界を持つことができます。 配列には、最大32次元を設定できます。  
  
 <xref:System.Collections> 名前空間のクラスとは異なり、<xref:System.Array> の容量は固定されています。 容量を増やすには、必要な容量を備えた新しい <xref:System.Array> オブジェクトを作成し、古い <xref:System.Array> オブジェクトの要素を新しいオブジェクトにコピーして、古い <xref:System.Array>を削除する必要があります。  

 配列のサイズは、合計で40億の要素に制限され、任意の次元の0X7FEFFFFF の最大インデックス (バイト配列の場合は0X7FFFFFC7、1バイト構造体の配列の場合) に制限されます。
  
 **.NET Framework のみ:** 既定では、<xref:System.Array> の最大サイズは 2 gb です。 64ビット環境では、 [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)構成要素の `enabled` 属性を実行時環境で `true` に設定することによって、サイズ制限を回避できます。
  
 1次元配列には、<xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>、および <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> ジェネリックインターフェイスが実装されています。 実装は実行時に配列に提供されます。そのため、ジェネリックインターフェイスは、<xref:System.Array> クラスの宣言構文には表示されません。 また、配列をジェネリックインターフェイス型 (明示的なインターフェイスの実装) にキャストすることによってのみアクセスできるインターフェイスメンバーに関する参照トピックはありません。 これらのインターフェイスのいずれかに配列をキャストするときに注意すべき重要な点は、要素を追加、挿入、または削除するメンバーが <xref:System.NotSupportedException>をスローすることです。  
  
 <xref:System.Type> オブジェクトは、配列型の宣言に関する情報を提供します。 同じ配列型のオブジェクトを <xref:System.Array>、同じ <xref:System.Type> オブジェクトを共有します。  
  
 配列が型 <xref:System.Array>にキャストされる場合、結果は配列ではなくオブジェクトであるため、<xref:System.Type.IsArray%2A?displayProperty=nameWithType> と <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> では <xref:System.Array> で予期した結果が返されないことがあります。 つまり、`typeof(System.Array).IsArray` は `false`を返し、`typeof(System.Array).GetElementType` は `null`を返します。  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType> メソッドは、同じ型の配列間だけでなく、異なる型の標準配列間でも要素をコピーします。型キャストを自動的に処理します。  
  
 <xref:System.Array.CreateInstance%2A>、<xref:System.Array.Copy%2A>、<xref:System.Array.CopyTo%2A>、<xref:System.Array.GetValue%2A>、<xref:System.Array.SetValue%2A>などの一部のメソッドでは、大容量の配列に対応するために、パラメーターとして64ビット整数を受け入れるオーバーロードが提供されます。 <xref:System.Array.LongLength%2A> と <xref:System.Array.GetLongLength%2A> は、配列の長さを示す64ビット整数を返します。  
  
 <xref:System.Array> の並べ替えは保証されていません。  <xref:System.Array> を並べ替える必要がある操作 (<xref:System.Array.BinarySearch%2A>など) を実行する前に、<xref:System.Array> を並べ替える必要があります。  
  
 ネイティブコードでのポインターの <xref:System.Array> オブジェクトの使用はサポートされていないため、いくつかのメソッドに対して <xref:System.NotSupportedException> がスローされます。  
  
   
  
## Examples  

 次のコード例は、<xref:System.Array.Copy%2A?displayProperty=nameWithType> が整数型の配列と <xref:System.Object>型の配列の間で要素をコピーする方法を示しています。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 次のコード例では、<xref:System.Array> を作成して初期化し、そのプロパティとその要素を表示します。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp-interactive[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (Visual Basic では<see langword="Shared" />) なこの型のメンバーはスレッド セーフです インスタンス メンバーについては、スレッド セーフであることの保証はありません。  
  
この実装は、<see cref="T:System.Array" />に対して同期された (スレッドセーフな) ラッパーを提供しません。ただし、<see cref="T:System.Array" /> に基づく .NET Framework クラスは、<see cref="P:System.Array.SyncRoot" /> プロパティを使用して、独自に同期されたバージョンのコレクションを提供します。  
  
コレクションの列挙処理は、本質的にスレッドセーフな処理ではありません。 コレクションが同期されていても、他のスレッドがコレクションを変更する場合があり、このときは列挙子から例外がスローされます。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">配列 (C# プログラミング ガイド)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Visual Basic における配列</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパーでラップする、インデックス番号が 0 から始まる 1 次元配列。</param>
        <summary>指定した配列をラップする読み取り専用のラッパーを作成します。</summary>
        <returns>指定した配列をラップする読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列が変更されないようにするには、このラッパーを通じてのみ配列を公開します。  
  
 読み取り専用のコレクションは、単純にコレクションを変更できないようにするラッパーを含むコレクションです。したがって、基になるコレクションに変更が加えられた場合、読み取り専用コレクションにはこれらの変更が反映されます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次の例では、配列を読み取り専用の <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>にラップしています。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ サーチ アルゴリズムを使用して、並べ替え済みの 1 次元の <see cref="T:System.Array" /> 内で値を検索します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定したオブジェクトによって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 <xref:System.Array> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列の上限を超えている場合は、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 `value` または `array` のすべての要素は、<xref:System.IComparable> インターフェイスを実装する必要があります。これは、比較に使用されます。 `array` の要素は、<xref:System.IComparable> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
> [!NOTE]
>  `value` が <xref:System.IComparable> インターフェイスを実装していない場合は、検索を開始する前に `array` の要素が <xref:System.IComparable> に対してテストされません。 <xref:System.IComparable>を実装しない要素が検索で検出されると、例外がスローされます。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、`null` との比較では、例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable> 実装に `value` が渡されます。 つまり、<xref:System.IComparable> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Array.BinarySearch%2A> を使用して、<xref:System.Array>内の特定のオブジェクトを検索する方法を示します。  
  
> [!NOTE]
>  配列は、その要素を使用して昇順の並べ替え順に作成されます。 <xref:System.Array.BinarySearch%2A> メソッドでは、配列を昇順に並べ替える必要があります。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 <xref:System.Array> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列の上限を超えている場合は、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 比較子は、要素の比較方法をカスタマイズします。 たとえば、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> を比較子として使用して、大文字と小文字を区別しない文字列検索を実行できます。  
  
 `comparer` が `null`されていない場合は、指定された <xref:System.Collections.IComparer> の実装を使用して、`array` の要素が指定された値と比較されます。 `array` の要素は、`comparer`で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
 `comparer` が `null`場合は、要素自体または指定した値によって提供される <xref:System.IComparable> 実装を使用して比較が行われます。 `array` の要素は、<xref:System.IComparable> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
> [!NOTE]
>  `comparer` が `null` で、`value` が <xref:System.IComparable> インターフェイスを実装していない場合、検索が開始される前に `array` の要素は <xref:System.IComparable> に対してテストされません。 <xref:System.IComparable>を実装しない要素が検索で検出されると、例外がスローされます。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、`null` との比較では、例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable> 実装に `value` が渡されます。 つまり、<xref:System.IComparable> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, index As Integer, length As Integer, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定した値によって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 <xref:System.Array> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列の上限を超えている場合は、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 `value` または `array` のすべての要素は、<xref:System.IComparable> インターフェイスを実装する必要があります。これは、比較に使用されます。 `array` の要素は、<xref:System.IComparable> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
> [!NOTE]
>  `value` が <xref:System.IComparable> インターフェイスを実装していない場合は、検索を開始する前に `array` の要素が <xref:System.IComparable> に対してテストされません。 <xref:System.IComparable>を実装しない要素が検索で検出されると、例外がスローされます。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、`null` との比較では、例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable> 実装に `value` が渡されます。 つまり、<xref:System.IComparable> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `length`ます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
または 
 <paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, index As Integer, length As Integer, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 <xref:System.Array> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列の上限を超えている場合は、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 比較子は、要素の比較方法をカスタマイズします。 たとえば、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> を比較子として使用して、大文字と小文字を区別しない文字列検索を実行できます。  
  
 `comparer` が `null`されていない場合は、指定された <xref:System.Collections.IComparer> の実装を使用して、`array` の要素が指定された値と比較されます。 `array` の要素は、`comparer`で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
 `comparer` が `null`場合は、要素自体または指定した値によって提供される <xref:System.IComparable> 実装を使用して比較が行われます。 `array` の要素は、<xref:System.IComparable> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
> [!NOTE]
>  `comparer` が `null` で、`value` が <xref:System.IComparable> インターフェイスを実装していない場合、検索が開始される前に `array` の要素は <xref:System.IComparable> に対してテストされません。 <xref:System.IComparable>を実装しない要素が検索で検出されると、例外がスローされます。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、<xref:System.IComparable>を使用する場合、`null` との比較では例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable> 実装に `value` が渡されます。 つまり、<xref:System.IComparable> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `length`ます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
または 
 <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary><see cref="T:System.IComparable`1" /> の各要素および指定したオブジェクトによって実装されている <see cref="T:System.Array" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 `array` に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列のサイズと等しい場合、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 `T` は、比較に使用される <xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。 `array` の要素は、<xref:System.IComparable%601> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、`null` との比較では、例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable%601> 実装に `value` が渡されます。 つまり、<xref:System.IComparable%601> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、ジェネリックメソッドのオーバーロードと <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> ジェネリックメソッドのオーバーロード <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> を示しています。 文字列の配列は、特定の順序で作成されません。  
  
 配列が表示され、並べ替えられて、もう一度表示されます。 <xref:System.Array.BinarySearch%2A> メソッドを使用するには、配列を並べ替える必要があります。  
  
> [!NOTE]
>  <xref:System.Array.Sort%2A> および <xref:System.Array.BinarySearch%2A> ジェネリックメソッドへの呼び出しは、非ジェネリックメソッドの呼び出しとは異なるものではありませんC#。これC++は Visual Basic、、およびが、最初の引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 次に、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> ジェネリックメソッドオーバーロードを使用して2つの文字列を検索します。1つは配列に含まれず、もう1つはです。 <xref:System.Array.BinarySearch%2A> メソッドの配列と戻り値は、`ShowWhere` ジェネリックメソッドに渡されます。このメソッドには、文字列が見つかった場合はインデックス値が表示され、それ以外の場合は検索文字列が配列内に存在する場合は、その要素が含まれます。 文字列が配列に含まれていない場合、インデックスは負の値になります。したがって、`ShowWhere` メソッドはC#ビットごとC++の補数 (とビジュアルでは ~ 演算子、Visual Basic の `Xor`場合は-1) を取得して、検索文字列よりも大きいリスト内の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable`1" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 <xref:System.Array> に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列のサイズと等しい場合、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 比較子は、要素の比較方法をカスタマイズします。 たとえば、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> を比較子として使用して、大文字と小文字を区別しない文字列検索を実行できます。  
  
 `comparer` が `null`されていない場合は、指定された <xref:System.Collections.Generic.IComparer%601> ジェネリックインターフェイスの実装を使用して `array` の要素が指定された値と比較されます。 `array` の要素は、`comparer`で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
 `comparer` が `null`場合、`T`によって提供される <xref:System.IComparable%601> ジェネリックインターフェイスの実装を使用して比較が行われます。 `array` の要素は、<xref:System.IComparable%601> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
> [!NOTE]
>  `comparer` が `null` で `value` が <xref:System.IComparable%601> ジェネリックインターフェイスを実装していない場合、検索が開始される前に `array` の要素は <xref:System.IComparable%601> に対してテストされません。 <xref:System.IComparable%601>を実装しない要素が検索で検出されると、例外がスローされます。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、`null` との比較では、例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable%601> 実装に `value` が渡されます。 つまり、<xref:System.IComparable%601> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、ジェネリックメソッドのオーバーロードと <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドのオーバーロード <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> を示します。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>` (Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 配列が表示され、並べ替えられて、もう一度表示されます。 <xref:System.Array.BinarySearch%2A> メソッドを使用するには、配列を並べ替える必要があります。  
  
> [!NOTE]
>  <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> および <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドへの呼び出しは、非ジェネリックメソッドの呼び出しとは異なるものではありませんC#。これC++は Visual Basic、、およびが、最初の引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 次に、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドオーバーロードを使用して2つの文字列を検索します。1つは配列に含まれず、もう1つはです。 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> メソッドの配列と戻り値は、`ShowWhere` ジェネリックメソッドに渡されます。このメソッドには、文字列が見つかった場合はインデックス値が表示され、それ以外の場合は検索文字列が配列内に存在する場合は、その要素が含まれます。 文字列が配列ではない場合、インデックスは負になります。したがって、`ShowWhere` メソッドはビットごとの補数 ( C#と `Xor` C++ビジュアルでは ~ 演算子、Visual Basic では-1) を取得して、検索文字列よりも大きいリスト内の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary><see cref="T:System.IComparable`1" /> の各要素および指定した値によって実装されている <see cref="T:System.Array" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列のサイズと等しい場合、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 `T` は、比較に使用される <xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。 `array` の要素は、<xref:System.IComparable%601> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、`null` との比較では、例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable%601> 実装に `value` が渡されます。 つまり、<xref:System.IComparable%601> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `length`ます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
または 
 <paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable`1" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、負のインデックスを含む配列の検索はサポートされていません。 このメソッドを呼び出す前に、`array` を並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、メソッドは負の整数を返します。 ビットごとの補数演算子 (~ in C#、Visual Basic の `Not`) を負の結果に適用して、インデックスを生成することができます。 このインデックスが配列のサイズと等しい場合、配列内の `value` よりも大きい要素はありません。 それ以外の場合は、`value`より大きい最初の要素のインデックスです。  
  
 比較子は、要素の比較方法をカスタマイズします。 たとえば、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> を比較子として使用して、大文字と小文字を区別しない文字列検索を実行できます。  
  
 `comparer` が `null`されていない場合は、指定された <xref:System.Collections.Generic.IComparer%601> ジェネリックインターフェイスの実装を使用して `array` の要素が指定された値と比較されます。 `array` の要素は、`comparer`で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
 `comparer` が `null`場合は、型 `T`に指定された <xref:System.IComparable%601> ジェネリックインターフェイスの実装を使用して比較が行われます。 `array` の要素は、<xref:System.IComparable%601> の実装で定義されている並べ替え順序に従って、値の増加によって既に並べ替えられている必要があります。それ以外の場合は、結果が正しくない可能性があります。  
  
 重複する要素を使用できます。 <xref:System.Array> に `value`に等しい複数の要素が含まれている場合、メソッドは、1つの出現箇所だけのインデックスを返します。最初の要素ではありません。  
  
 `null` は、常に他の参照型と比較できます。したがって、<xref:System.IComparable%601>を使用する場合、`null` との比較では例外は生成されません。  
  
> [!NOTE]
>  テストされたすべての要素について、`value` が `null`場合でも、適切な <xref:System.IComparable%601> 実装に `value` が渡されます。 つまり、<xref:System.IComparable%601> の実装によって、特定の要素が `null`とどのように比較されるかが決まります。  
  
 このメソッドは、O (ログ `n`) 操作であり、`n` は `length`ます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
または 
 <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear (array As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要素を削除する必要がある配列。</param>
        <param name="index">削除する要素の範囲の開始インデックス。</param>
        <param name="length">削除する要素の数。</param>
        <summary>配列内にある要素の範囲を、各要素の型の既定値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、配列内の各要素を要素型の既定値にリセットします。 次の表に示すように、参照型の要素 (<xref:System.String> 要素を含む) を `null`に設定し、値型の要素を既定値に設定します。  
  
|種類|値|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|すべての整数型と浮動小数点数値型|0 (ゼロ)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|その他の値の型|型のフィールドの既定値|  
  
 クリアされた要素の範囲は、多次元配列の行から行にラップされます。  
  
 このメソッドは、要素の値のみをクリアします。要素自体は削除されません。 配列のサイズは固定されています。したがって、要素を追加または削除することはできません。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Clear%2A> メソッドを使用して、1次元、2次元、および3次元配列の整数値をリセットします。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 次の例では、<xref:System.TimeZoneInfo> フィールドと <xref:System.DateTimeOffset> フィールドを含む `TimeZoneTime` 構造体を定義します。 次に、<xref:System.Array.Clear%2A> メソッドを呼び出して、`TimeZoneTime` 値の2要素配列内の1つの要素をクリアします。 メソッドは、クリアされた要素の値を <xref:System.TimeZoneInfo> オブジェクト (`null`) の既定値に設定し、<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>される <xref:System.DateTimeOffset> オブジェクトの既定値に設定します。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。  
  
または 
<paramref name="index" /> と <paramref name="length" /> の合計が <paramref name="array" /> のサイズを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Clone() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Clone();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual object Clone ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Array" /> の簡易コピーを作成します。</summary>
        <returns><see cref="T:System.Array" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> の簡易コピーでは、参照型であるか値型であるかにかかわらず、<xref:System.Array>の要素のみがコピーされますが、参照が参照するオブジェクトはコピーされません。 新しい <xref:System.Array> 内の参照は、元の <xref:System.Array> で参照されているものと同じオブジェクトを指します。  
  
 これに対し、<xref:System.Array> の詳細コピーでは、要素と要素によって直接的または間接的に参照されるすべての要素がコピーされます。  
  
 複製は元の <xref:System.Array>と同じ <xref:System.Type> です。  
  
 このメソッドは O(`n`) 操作です。`n` は <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 配列を複製し、簡易コピーの動作を示します。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <paramref name="sourceArray" /> 内のインデックスを表す 32 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <paramref name="destinationArray" /> のインデックスを表す 32 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として別の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。  コピーが完全に成功しない限り、変更は一切適用されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` パラメーターと `destinationArray` パラメーターの次元数は同じである必要があります。  `sourceArray` 型は、`destinationArray` 型と同じであるか、またはその型から派生している必要があります。それ以外の場合は、<xref:System.ArrayTypeMismatchException> がスローされます。  <xref:System.Array.Copy%2A>とは異なり、<xref:System.Array.ConstrainedCopy%2A> では、操作を実行する前に配列型の互換性が確認されます。  
  
 多次元配列間でコピーを行う場合、配列は、行 (または列) が概念的にエンドツーエンドでレイアウトされる、長い1次元配列のように動作します。 たとえば、配列に4つの要素を持つ3つの行 (または列) がある場合、配列の先頭から6つの要素をコピーすると、最初の行 (または列) の4つの要素と2番目の行 (または列) の最初の2つの要素がコピーされます。 3番目の行 (または列) の2番目の要素からコピーを開始するには、`sourceIndex` 最初の行 (または列) と2番目の行の長さ (または列) に2を加算する必要があります。  
  
 `sourceArray` と `destinationArray` 重複する場合、このメソッドは `destinationArray` が上書きされる前に `sourceArray` の元の値が一時的な場所に保持されていたかのように動作します。  
  
 [C++]  
  
 このメソッドは、`memcpy`ではなく、C++標準の C/関数 `memmove`に相当します。  
  
 配列には、参照型の配列または値型の配列を指定できます。  `sourceArray` と `destinationArray` の両方が参照型の配列であるか、両方とも <xref:System.Object>型の配列である場合、簡易コピーが実行されます。 <xref:System.Array> の簡易コピーは、元の <xref:System.Array>と同じ要素への参照を含む新しい <xref:System.Array> です。 要素自体、または要素によって参照されるものはコピーされません。 これに対し、<xref:System.Array> の詳細コピーでは、要素と要素によって直接的または間接的に参照されるすべての要素がコピーされます。  
  
 コピー中にこのメソッドが例外をスローした場合、`destinationArray` は変更されません。そのため、<xref:System.Array.ConstrainedCopy%2A> は、制約された実行領域 (<xref:System.Runtime.ConstrainedExecution.Cer>) 内で使用できます。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> が <see langword="null" /> です。  
  
または 
 <paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> はどちらも同じでもなく、<paramref name="destinationArray" /> 型から派生したものでもありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  
  
または 
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
または 
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">元の配列要素の型。</typeparam>
        <typeparam name="TOutput">変換後の配列要素の型。</typeparam>
        <param name="array">変換元となる、インデックス番号が 0 から始まる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="converter">各要素の型を変換するための <see cref="T:System.Converter`2" />。</param>
        <summary>ある型の配列を別の型の配列に変換します。</summary>
        <returns>要素の型を変換した後の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> は、オブジェクトを対象の型に変換するメソッドへのデリゲートです。  `array` の要素は、個別に <xref:System.Converter%602>に渡され、変換された要素は新しい配列に保存されます。  
  
 ソース `array` は変更されません。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Drawing.PointF> 構造体を <xref:System.Drawing.Point> 構造体に変換する `PointFToPoint` という名前のメソッドを定義します。 次に、<xref:System.Drawing.PointF> 構造体の配列を作成し、`PointFToPoint` メソッドを表す `Converter<PointF, Point>` デリゲート (Visual Basic で`Converter(Of PointF, Point)`) を作成し、そのデリゲートを <xref:System.Array.ConvertAll%2A> メソッドに渡します。 <xref:System.Array.ConvertAll%2A> メソッドは、入力リストの各要素を `PointFToPoint` メソッドに渡し、変換された要素を <xref:System.Drawing.Point> 構造体の新しいリストに格納します。 両方のリストが表示されます。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="converter" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>一方の <see cref="T:System.Array" /> の要素範囲を他方の <see cref="T:System.Array" /> にコピーし、必要に応じて型キャストとボックス化を実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` パラメーターと `destinationArray` パラメーターの次元数は同じである必要があります。 さらに、`destinationArray` は既に次元が設定されている必要があり、コピーしたデータを格納するために十分な数の要素が必要です。  
  
 多次元配列間でコピーを行う場合、配列は長い1次元配列のように動作します。この配列では、行 (または列) が概念的にエンドツーエンドに配置されます。 たとえば、配列に4つの要素を持つ3つの行 (または列) がある場合、配列の先頭から6つの要素をコピーすると、最初の行 (または列) の4つの要素と2番目の行 (または列) の最初の2つの要素がコピーされます。  
  
 `sourceArray` と `destinationArray` 重複する場合、このメソッドは `destinationArray` が上書きされる前に `sourceArray` の元の値が一時的な場所に保持されていたかのように動作します。  
  
 [C++]  
  
 このメソッドは、`memcpy`ではなく、C++標準の C/関数 `memmove`に相当します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 必要に応じて、型ダウンキャストが実行されます。  
  
-   参照型の配列から値型の配列にコピーする場合、各要素のボックス化が解除されてからコピーされます。 値型の配列から参照型の配列にコピーする場合、各要素はボックス化された後にコピーされます。  
  
-   参照型または値型の配列から <xref:System.Object> 配列にコピーする場合、各値または参照を保持してコピーした <xref:System.Object> が作成されます。 <xref:System.Object> 配列から参照型または値型の配列にコピーするときに、割り当てができない場合は、<xref:System.InvalidCastException> がスローされます。  
  
-   `sourceArray` と `destinationArray` の両方が参照型の配列であるか、両方とも <xref:System.Object>型の配列である場合、簡易コピーが実行されます。 <xref:System.Array> の簡易コピーは、元の <xref:System.Array>と同じ要素への参照を含む新しい <xref:System.Array> です。 要素自体、または要素によって参照されるものはコピーされません。 これに対し、<xref:System.Array> の詳細コピーでは、要素と要素によって直接的または間接的に参照されるすべての要素がコピーされます。  
  
 配列が互換性のない型である場合、<xref:System.ArrayTypeMismatchException> がスローされます。 型の互換性は次のように定義されます。  
  
-   型は、それ自体と互換性があります。  
  
-   値型は、<xref:System.Object> およびその値型によって実装されるインターフェイス型と互換性があります。 値型は、インターフェイスを直接実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断された型には互換性がありません。  
  
-   ソース型から変換先の型へのコピーが拡大変換である場合、2つの組み込み (定義済み) 値型には互換性があります。 拡大変換によって情報が失われることはありませんが、縮小変換によって情報が失われる可能性があります。 たとえば、32ビット符号付き整数から64ビット符号付き整数への変換は拡大変換であり、64ビット符号付き整数から32ビット符号付き整数への変換は縮小変換です。 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
-   非組み込み型 (ユーザー定義) の値型は、それ自体と互換性があるだけです。  
  
-   列挙型には、<xref:System.Enum> およびその基になる型への暗黙的な変換があります。  
  
 `sourceArray` のすべての要素にダウンキャストが必要な場合 (たとえば、基本クラスから派生クラス、またはインターフェイスからオブジェクトへのキャスト)、1つ以上の要素を `destinationArray`の対応する型にキャストできない場合は <xref:System.InvalidCastException> がスローされます。  
  
 コピー中にこのメソッドが例外をスローした場合、`destinationArray` の状態は未定義になります。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> が <see langword="null" /> です。  
  
または 
 <paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  
  
または 
 <paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> (この値を含む) の間である必要があります。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` パラメーターと `destinationArray` パラメーターの次元数は同じである必要があります。 さらに、`destinationArray` は既に次元が設定されている必要があり、コピーしたデータを格納するために十分な数の要素が必要です。  
  
 多次元配列間でコピーを行う場合、配列は長い1次元配列のように動作します。この配列では、行 (または列) が概念的にエンドツーエンドに配置されます。 たとえば、配列に4つの要素を持つ3つの行 (または列) がある場合、配列の先頭から6つの要素をコピーすると、最初の行 (または列) の4つの要素と2番目の行 (または列) の最初の2つの要素がコピーされます。  
  
 `sourceArray` と `destinationArray` 重複する場合、このメソッドは `destinationArray` が上書きされる前に `sourceArray` の元の値が一時的な場所に保持されていたかのように動作します。  
  
 [C++]  
  
 このメソッドは、`memcpy`ではなく、C++標準の C/関数 `memmove`に相当します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 必要に応じて、型ダウンキャストが実行されます。  
  
-   参照型の配列から値型の配列にコピーする場合、各要素のボックス化が解除されてからコピーされます。 値型の配列から参照型の配列にコピーする場合、各要素はボックス化された後にコピーされます。  
  
-   参照型または値型の配列から <xref:System.Object> 配列にコピーする場合、各値または参照を保持してコピーした <xref:System.Object> が作成されます。 <xref:System.Object> 配列から参照型または値型の配列にコピーするときに、割り当てができない場合は、<xref:System.InvalidCastException> がスローされます。  
  
-   `sourceArray` と `destinationArray` の両方が参照型の配列であるか、両方とも <xref:System.Object>型の配列である場合、簡易コピーが実行されます。 <xref:System.Array> の簡易コピーは、元の <xref:System.Array>と同じ要素への参照を含む新しい <xref:System.Array> です。 要素自体、または要素によって参照されるものはコピーされません。 これに対し、<xref:System.Array> の詳細コピーでは、要素と要素によって直接的または間接的に参照されるすべての要素がコピーされます。  
  
 配列が互換性のない型である場合、<xref:System.ArrayTypeMismatchException> がスローされます。 型の互換性は次のように定義されます。  
  
-   型は、それ自体と互換性があります。  
  
-   値型は、<xref:System.Object> およびその値型によって実装されるインターフェイス型と互換性があります。 値型は、インターフェイスを直接実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断された型には互換性がありません。  
  
-   ソース型から変換先の型へのコピーが拡大変換である場合、2つの組み込み (定義済み) 値型には互換性があります。 拡大変換によって情報が失われることはありませんが、縮小変換によって情報が失われる可能性があります。 たとえば、32ビット符号付き整数から64ビット符号付き整数への変換は拡大変換であり、64ビット符号付き整数から32ビット符号付き整数への変換は縮小変換です。 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
-   非組み込み型 (ユーザー定義) の値型は、それ自体と互換性があるだけです。  
  
-   列挙型には、<xref:System.Enum> およびその基になる型への暗黙的な変換があります。  
  
 `sourceArray` のすべての要素にダウンキャストが必要な場合 (たとえば、基本クラスから派生クラス、またはインターフェイスからオブジェクトへのキャスト)、1つ以上の要素を `destinationArray`の対応する型にキャストできない場合は <xref:System.InvalidCastException> がスローされます。  
  
 コピー中にこのメソッドが例外をスローした場合、`destinationArray` の状態は未定義になります。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> が <see langword="null" /> です。  
  
または 
 <paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  
  
または 
 <paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <paramref name="sourceArray" /> 内のインデックスを表す 32 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <paramref name="destinationArray" /> のインデックスを表す 32 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として別の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、32 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` パラメーターと `destinationArray` パラメーターの次元数は同じである必要があります。 さらに、`destinationArray` は既に次元になっている必要があり、コピーされたデータを格納するために、`destinationIndex` 位置から十分な数の要素を持つ必要があります。  
  
 多次元配列間でコピーを行う場合、配列は、行 (または列) が概念的にエンドツーエンドでレイアウトされる、長い1次元配列のように動作します。 たとえば、配列に4つの要素を持つ3つの行 (または列) がある場合、配列の先頭から6つの要素をコピーすると、最初の行 (または列) の4つの要素と2番目の行 (または列) の最初の2つの要素がコピーされます。 3番目の行 (または列) の2番目の要素からコピーを開始するには、`sourceIndex` 最初の行 (または列) と2番目の行の長さ (または列) に2を加算する必要があります。  
  
 `sourceArray` と `destinationArray` 重複する場合、このメソッドは `destinationArray` が上書きされる前に `sourceArray` の元の値が一時的な場所に保持されていたかのように動作します。  
  
 [C++]  
  
 このメソッドは、`memcpy`ではなく、C++標準の C/関数 `memmove`に相当します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 必要に応じて、型ダウンキャストが実行されます。  
  
-   参照型の配列から値型の配列にコピーする場合、各要素のボックス化が解除されてからコピーされます。 値型の配列から参照型の配列にコピーする場合、各要素はボックス化された後にコピーされます。  
  
-   参照型または値型の配列から <xref:System.Object> 配列にコピーする場合、各値または参照を保持してコピーした <xref:System.Object> が作成されます。 <xref:System.Object> 配列から参照型または値型の配列にコピーするときに、割り当てができない場合は、<xref:System.InvalidCastException> がスローされます。  
  
-   `sourceArray` と `destinationArray` の両方が参照型の配列であるか、両方とも <xref:System.Object>型の配列である場合、簡易コピーが実行されます。 <xref:System.Array> の簡易コピーは、元の <xref:System.Array>と同じ要素への参照を含む新しい <xref:System.Array> です。 要素自体、または要素によって参照されるものはコピーされません。 これに対し、<xref:System.Array> の詳細コピーでは、要素と要素によって直接的または間接的に参照されるすべての要素がコピーされます。  
  
 配列が互換性のない型である場合、<xref:System.ArrayTypeMismatchException> がスローされます。 型の互換性は次のように定義されます。  
  
-   型は、それ自体と互換性があります。  
  
-   値型は、<xref:System.Object> およびその値型によって実装されるインターフェイス型と互換性があります。 値型は、インターフェイスを直接実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断された型には互換性がありません。  
  
-   ソース型から変換先の型へのコピーが拡大変換である場合、2つの組み込み (定義済み) 値型には互換性があります。 拡大変換によって情報が失われることはありませんが、縮小変換によって情報が失われる可能性があります。 たとえば、32ビット符号付き整数から64ビット符号付き整数への変換は拡大変換であり、64ビット符号付き整数から32ビット符号付き整数への変換は縮小変換です。 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
-   非組み込み型 (ユーザー定義) の値型は、それ自体と互換性があるだけです。  
  
-   列挙型には、<xref:System.Enum> およびその基になる型への暗黙的な変換があります。  
  
 `sourceArray` のすべての要素にダウンキャストが必要な場合 (たとえば、基本クラスから派生クラス、またはインターフェイスからオブジェクトへのキャスト)、1つ以上の要素を `destinationArray`の対応する型にキャストできない場合は <xref:System.InvalidCastException> がスローされます。  
  
 コピー中にこのメソッドが例外をスローした場合、`destinationArray` の状態は未定義になります。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Object> 型の1つの <xref:System.Array> から integer 型の別の <xref:System.Array> にコピーする方法を示しています。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> が <see langword="null" /> です。  
  
または 
 <paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  
  
または 
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
または 
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <paramref name="sourceArray" /> 内のインデックスを表す 64 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <paramref name="destinationArray" /> のインデックスを表す 64 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> (この値を含む) の間である必要があります。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として別の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` パラメーターと `destinationArray` パラメーターの次元数は同じである必要があります。 さらに、`destinationArray` は既に次元になっている必要があり、コピーされたデータを格納するために、`destinationIndex` 位置から十分な数の要素を持つ必要があります。  
  
 多次元配列間でコピーを行う場合、配列は、行 (または列) が概念的にエンドツーエンドでレイアウトされる、長い1次元配列のように動作します。 たとえば、配列に4つの要素を持つ3つの行 (または列) がある場合、配列の先頭から6つの要素をコピーすると、最初の行 (または列) の4つの要素と2番目の行 (または列) の最初の2つの要素がコピーされます。 3番目の行 (または列) の2番目の要素からコピーを開始するには、`sourceIndex` 最初の行 (または列) と2番目の行の長さ (または列) に2を加算する必要があります。  
  
 `sourceArray` と `destinationArray` 重複する場合、このメソッドは `destinationArray` が上書きされる前に `sourceArray` の元の値が一時的な場所に保持されていたかのように動作します。  
  
 [C++]  
  
 このメソッドは、`memcpy`ではなく、C++標準の C/関数 `memmove`に相当します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 必要に応じて、型ダウンキャストが実行されます。  
  
-   参照型の配列から値型の配列にコピーする場合、各要素のボックス化が解除されてからコピーされます。 値型の配列から参照型の配列にコピーする場合、各要素はボックス化された後にコピーされます。  
  
-   参照型または値型の配列から <xref:System.Object> 配列にコピーする場合、各値または参照を保持してコピーした <xref:System.Object> が作成されます。 <xref:System.Object> 配列から参照型または値型の配列にコピーするときに、割り当てができない場合は、<xref:System.InvalidCastException> がスローされます。  
  
-   `sourceArray` と `destinationArray` の両方が参照型の配列であるか、両方とも <xref:System.Object>型の配列である場合、簡易コピーが実行されます。 <xref:System.Array> の簡易コピーは、元の <xref:System.Array>と同じ要素への参照を含む新しい <xref:System.Array> です。 要素自体、または要素によって参照されるものはコピーされません。 これに対し、<xref:System.Array> の詳細コピーでは、要素と要素によって直接的または間接的に参照されるすべての要素がコピーされます。  
  
 配列が互換性のない型である場合、<xref:System.ArrayTypeMismatchException> がスローされます。 型の互換性は次のように定義されます。  
  
-   型は、それ自体と互換性があります。  
  
-   値型は、<xref:System.Object> およびその値型によって実装されるインターフェイス型と互換性があります。 値型は、インターフェイスを直接実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断された型には互換性がありません。  
  
-   ソース型から変換先の型へのコピーが拡大変換である場合、2つの組み込み (定義済み) 値型には互換性があります。 拡大変換によって情報が失われることはありませんが、縮小変換によって情報が失われる可能性があります。 たとえば、32ビット符号付き整数から64ビット符号付き整数への変換は拡大変換であり、64ビット符号付き整数から32ビット符号付き整数への変換は縮小変換です。 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
-   非組み込み型 (ユーザー定義) の値型は、それ自体と互換性があるだけです。  
  
-   列挙型には、<xref:System.Enum> およびその基になる型への暗黙的な変換があります。  
  
 `sourceArray` のすべての要素にダウンキャストが必要な場合 (たとえば、基本クラスから派生クラス、またはインターフェイスからオブジェクトへのキャスト)、1つ以上の要素を `destinationArray`の対応する型にキャストできない場合は <xref:System.InvalidCastException> がスローされます。  
  
 コピー中にこのメソッドが例外をスローした場合、`destinationArray` の状態は未定義になります。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Object> 型の1つの <xref:System.Array> から integer 型の別の <xref:System.Array> にコピーする方法を示しています。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> が <see langword="null" /> です。  
  
または 
 <paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
または 
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の 1 次元配列のすべての要素を、指定した 1 次元配列にコピーします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Array, index As Integer)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (array As Array, index As Integer)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">コピーを開始する <paramref name="array" /> のインデックスを表す 32 ビット整数。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インデックス `index`を開始位置として、現在の配列インスタンスのすべての要素を `array` コピー先の配列にコピーします。 `array` のコピー先の配列は、既に次元が設定されている必要があります。コピーされた要素を格納するには、十分な数の要素が必要です。 そうしないと、例外がスローされます。  
  
 このメソッドは、<xref:System.Collections.ICollection?displayProperty=nameWithType> インターフェイスをサポートしています。 <xref:System.Collections.ICollection?displayProperty=nameWithType> を実装する必要がない場合は、<xref:System.Array.Copy%2A> を使用して追加の間接参照を回避します。  
  
 コピー中にこのメソッドが例外をスローした場合、`array` の状態は未定義になります。  
  
 このメソッドは O (`n`) 操作であり、`n` は <xref:System.Array.Length%2A>ます。簡易コピーのみを実行します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array> を別の <xref:System.Array>にコピーする方法を示しています。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例は、0以外の下限を持つ別の <xref:System.Array> に <xref:System.Array> をコピーする方法を示しています。 ターゲット <xref:System.Array>内の既存の要素を上書きする空の要素を含めて、ソース <xref:System.Array> 全体がコピーされることに注意してください。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> に多次元配列が設定されています。  
  
または 
コピー元配列の要素数が、コピー先 <paramref name="index" /> の <paramref name="array" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストできません。</exception>
        <exception cref="T:System.RankException">ソース配列が多次元配列です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Array, index As Long)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (array As Array, index As Long)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int64 -&gt; unit&#xA;override this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">コピーを開始する <paramref name="array" /> のインデックスを表す 64 ビット整数。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 インデックスは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インデックス `index`を開始位置として、現在の配列インスタンスのすべての要素を `array` コピー先の配列にコピーします。 `array` のコピー先の配列は、既に次元が設定されている必要があります。コピーされた要素を格納するには、十分な数の要素が必要です。 そうしないと、例外がスローされます。  
  
 このメソッドは、<xref:System.Collections.ICollection?displayProperty=nameWithType> インターフェイスをサポートしています。 <xref:System.Collections.ICollection?displayProperty=nameWithType> を実装する必要がない場合は、<xref:System.Array.Copy%2A> を使用して追加の間接参照を回避します。  
  
 コピー中にこのメソッドが例外をスローした場合、`array` の状態は未定義になります。  
  
 このメソッドは O (`n`) 操作であり、`n` は <xref:System.Array.Length%2A>ます。簡易コピーのみを実行します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array> を別の <xref:System.Array>にコピーする方法を示しています。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例は、0以外の下限を持つ別の <xref:System.Array> に <xref:System.Array> をコピーする方法を示しています。 ターゲット <xref:System.Array>内の既存の要素を上書きする空の要素を含めて、ソース <xref:System.Array> 全体がコピーされることに注意してください。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> に多次元配列が設定されています。  
  
または 
コピー元配列の要素数が、コピー先 <paramref name="index" /> の <paramref name="array" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストできません。</exception>
        <exception cref="T:System.RankException">コピー元の <see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Array" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Type" /> の <see cref="T:System.Array" />。</param>
        <param name="length">作成する <see cref="T:System.Array" /> のサイズ。</param>
        <summary><see cref="T:System.Array" /> と長さを指定して、0 から始まるインデックス番号を持つ 1 次元の <see cref="T:System.Type" /> を作成します。</summary>
        <returns>長さを指定した、0 から始まるインデックス番号を使用する指定した <see cref="T:System.Array" /> の新しい 1 次元の <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり、<xref:System.Array> は、遅延バインディングアクセスを可能にするために、パブリックコンストラクターの代わりに <xref:System.Array.CreateInstance%2A> メソッドを提供します。  
  
 参照型の要素は `null`に初期化されます。 値型の要素は0に初期化されます。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
   
  
## Examples  
 次のコード例は、1次元の <xref:System.Array>を作成し、初期化する方法を示しています。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> はサポートされません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
または 
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> に 0 より小さい値が指定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Type" /> の <see cref="T:System.Array" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを表す 32 ビット整数の配列。</param>
        <summary><see cref="T:System.Array" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ多次元の <see cref="T:System.Type" /> を作成します。 次元の長さは、32 ビット整数の配列で指定します。</summary>
        <returns>各次元が指定した長さで、インデックス番号が 0 から始まる、指定した <see cref="T:System.Array" /> の新しい多次元 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり、<xref:System.Array> は、遅延バインディングアクセスを可能にするために、パブリックコンストラクターの代わりに <xref:System.Array.CreateInstance%2A> メソッドを提供します。  
  
 `lengths` 配列内の要素の数は、新しい <xref:System.Array>の次元数と同じである必要があります。 `lengths` 配列の各要素は、新しい <xref:System.Array>内の対応する次元の長さを指定する必要があります。  
  
 参照型の要素は `null`に初期化されます。 値型の要素は0に初期化されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `lengths`のすべての値の積です。  
  
   
  
## Examples  
 次のコード例は、多次元 <xref:System.Array>を作成および初期化する方法を示しています。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> が <see langword="null" /> です。  
  
または 
 <paramref name="lengths" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
または 
<paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> はサポートされません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
または 
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 内の値が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Type" /> の <see cref="T:System.Array" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを表す 64 ビット整数の配列。 配列内の各整数はゼロから <see cref="F:System.Int32.MaxValue" /> までの値であることが必要です。</param>
        <summary><see cref="T:System.Array" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ多次元の <see cref="T:System.Type" /> を作成します。 次元の長さは、64 ビット整数の配列で指定します。</summary>
        <returns>各次元が指定した長さで、インデックス番号が 0 から始まる、指定した <see cref="T:System.Array" /> の新しい多次元 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり、<xref:System.Array> は、遅延バインディングアクセスを可能にするために、パブリックコンストラクターの代わりに <xref:System.Array.CreateInstance%2A> メソッドを提供します。  
  
 `lengths` 配列内の要素の数は、新しい <xref:System.Array>の次元数と同じである必要があります。 `lengths` 配列の各要素は、新しい <xref:System.Array>内の対応する次元の長さを指定する必要があります。  
  
 参照型の要素は `null`に初期化されます。 値型の要素は0に初期化されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `lengths`のすべての値の積です。  
  
   
  
## Examples  
 次のコード例は、多次元 <xref:System.Array>を作成および初期化する方法を示しています。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> が <see langword="null" /> です。  
  
または 
 <paramref name="lengths" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
または 
<paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> はサポートされません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
または 
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> のすべての値が 0 未満であるか、<see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Type" /> の <see cref="T:System.Array" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <summary><see cref="T:System.Array" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ 2 次元の <see cref="T:System.Type" /> を作成します。</summary>
        <returns>指定した <see cref="T:System.Array" /> の、次元ごとに指定した長さの、0 から始まるインデックス番号を持つ新しい 2 次元の <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり、<xref:System.Array> は、遅延バインディングアクセスを可能にするために、パブリックコンストラクターの代わりに <xref:System.Array.CreateInstance%2A> メソッドを提供します。  
  
 参照型の要素は `null`に初期化されます。 値型の要素は0に初期化されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `length1` と `length2`の積です。  
  
   
  
## Examples  
 次のコード例は、2次元の <xref:System.Array>を作成し、初期化する方法を示しています。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> はサポートされません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
または 
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="length2" /> に 0 より小さい値が指定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Type" /> の <see cref="T:System.Array" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを格納する 1 次元配列。</param>
        <param name="lowerBounds">作成する <see cref="T:System.Array" /> の各次元の下限 (開始インデックス) を格納する 1 次元配列。</param>
        <summary>指定した <see cref="T:System.Array" /> と次元の長さの、指定した下限を持つ多次元の <see cref="T:System.Type" /> を作成します。</summary>
        <returns>次元ごとに指定した長さと下限を持つ、指定した <see cref="T:System.Array" /> の新しい多次元の <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり、<xref:System.Array> は、遅延バインディングアクセスを可能にするために、パブリックコンストラクターの代わりに <xref:System.Array.CreateInstance%2A> メソッドを提供します。  
  
 `lengths` 配列と `lowerBounds` 配列には、同じ数の要素が含まれている必要があります。 `lengths` 配列内の要素の数は、新しい <xref:System.Array>の次元数と同じである必要があります。  
  
 `lengths` 配列の各要素は、新しい <xref:System.Array>内の対応する次元の長さを指定する必要があります。  
  
 `lowerBounds` 配列の各要素は、新しい <xref:System.Array>内の対応する次元の下限を指定する必要があります。 一般に、.NET Framework クラスライブラリと多くのプログラミング言語では、0以外の下限は処理されません。  
  
 参照型の要素は `null`に初期化されます。 値型の要素は0に初期化されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `lengths`のすべての値の積です。  
  
> [!NOTE]
> すべての言語で、下限が0以外の配列がサポートされているわけではないため、0以外の <xref:System.Array> のインスタンスを言語の配列型にキャストできない場合があります。 たとえば、下限が6の1次元整数配列を `int[]` 型にC#キャストすることはできません。 この <xref:System.InvalidCastException> 結果、実行時には、"型 ' system.string [] ' のオブジェクトを*型 ' system.string [] '." に*キャストできません。ここで、アスタリスク () は0以外のインデックスを意味します。 ただし、<xref:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])> で作成された任意のランクの0から始まる配列を、言語の配列にキャストできます。 たとえば、このメソッドで作成された2次元ゼロベースの整数配列を `int[,]` 型C#にキャストできます。

## Examples  
 次のコード例は、指定された下限で多次元 <xref:System.Array> を作成し、初期化する方法を示しています。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> が <see langword="null" /> です。  
  
または 
 <paramref name="lengths" /> が <see langword="null" /> です。  
  
または 
 <paramref name="lowerBounds" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
または 
<paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。  
  
または 
<paramref name="lengths" /> と <paramref name="lowerBounds" /> の配列に含まれている要素の数が異なります。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> はサポートされません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
または 
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 内の値が 0 未満です。  
  
または 
<paramref name="lowerBounds" /> 内に非常に大きな値があり、ディメンションの下限の境界と長さの合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Type" /> の <see cref="T:System.Array" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <param name="length3">作成する <see cref="T:System.Array" /> の 3 番目の次元のサイズ。</param>
        <summary><see cref="T:System.Array" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ 3 次元の <see cref="T:System.Type" /> を作成します。</summary>
        <returns>指定した <see cref="T:System.Array" /> の、次元ごとに指定した長さの、0 から始まるインデックス番号を持つ新しい 3 次元の <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり、<xref:System.Array> は、遅延バインディングアクセスを可能にするために、パブリックコンストラクターの代わりに <xref:System.Array.CreateInstance%2A> メソッドを提供します。  
  
 参照型の要素は `null`に初期化されます。 値型の要素は0に初期化されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `length1`、`length2`、および `length3`の積です。  
  
   
  
## Examples  
 次のコード例は、3次元の <xref:System.Array>を作成し、初期化する方法を示しています。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> はサポートされません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
または 
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="length2" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="length3" /> に 0 より小さい値が指定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <summary>空の配列を返します。</summary>
        <returns>空の配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された配列に、指定された述語によって定義された条件と一致する要素が含まれているかどうかを判断します。</summary>
        <returns>指定された述語によって定義された条件と一致する 1 つ以上の要素が <see langword="true" /> に存在する場合は、<paramref name="array" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡され、一致が見つかったときに処理が停止されます。  
  
> [!NOTE]
>  およびC# Visual Basic では、<xref:System.Predicate%601> デリゲートを明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、ラムダ式を使用して <xref:System.Array.Exists%2A> メソッドの一致条件を指定し、地球が特定の文字で始まるか、または指定された配列に地球があるかどうかを確認します。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 次の例では、<xref:System.Array.Exists%2A> メソッドを使用して、文字列配列内のいずれかの名前が指定された文字で始まるかどうかを示します。 この例では、検索する文字列をクラスコンストラクターに渡すことによって、`StringSearcher` オブジェクトをインスタンス化します。 `StringSearcher.StartsWith` メソッドには、<xref:System.Predicate%601> デリゲートと同じシグネチャがあります。 <xref:System.Array.Exists%2A> メソッドが呼び出されると、配列の各メンバーは、`true` を返すか、配列内のすべての要素を反復処理するまで、デリゲートに渡されます。  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 また、ラムダ式を使用することもできます。これは、シグネチャがデリゲートのメソッドに対応するメソッドを明示的に定義するのではなく、 次の例では、`StringSearcher` クラスとその `StartsWith` メソッドをラムダ式で置き換えます。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">ラムダ式 (C# プログラミング ガイド)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">ラムダ式 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列内の要素の型。</typeparam>
        <param name="array">入力対象の配列。</param>
        <param name="value">各配列要素に割り当てる値。</param>
        <summary><paramref name="value" /> 型の指定された <typeparamref name="T" /> を、指定された<paramref name="array" /> の各要素に割り当てます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">入力する <see cref="T:System.Array" />。</param>
        <param name="value">指定された範囲内にある要素に対する新しい値。</param>
        <param name="startIndex">入力を開始する <see cref="T:System.Array" /> 内のインデックスを表す 32 ビット整数。</param>
        <param name="count">コピーする要素の数。</param>
        <summary><paramref name="value" /> 型の指定された <typeparamref name="T" /> を、指定された<paramref name="array" /> の要素に割り当てます。これらの要素は、<paramref name="startIndex" /> (包含) および次の <paramref name="count" /> 個のインデックスの範囲内にあります。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="match">検索する要素の条件を定義する述語。</param>
        <summary>指定された述語によって定義された条件と一致する要素を検索し、<see cref="T:System.Array" /> 全体の中で最もインデックス番号の小さい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最初の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、メソッドまたはラムダ式へのデリゲートで、渡されたオブジェクトがデリゲートまたはラムダ式で定義された条件に一致する場合に `true` を返します。  `array` の要素は、最初の要素から最後の要素まで、<xref:System.Predicate%601>に個別に渡されます。  一致が見つかった場合、処理は停止されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Find%2A> ジェネリックメソッドと共に <xref:System.Predicate%601> デリゲートを使用して、<xref:System.Drawing.Point> 構造体の配列を検索します。 デリゲートが表すメソッド `ProductGT10`、X フィールドと Y フィールドの積が10万より大きい場合、`true` を返します。 <xref:System.Array.Find%2A> メソッドは、配列の各要素に対してデリゲートを呼び出し、テスト条件を満たす最初のポイントを返します。  
  
> [!NOTE]
>  Visual Basic とC#ユーザーは、デリゲートを明示的に作成したり、ジェネリックメソッドの型引数を指定したりする必要はありません。 コンパイラは、指定したメソッド引数から必要な型を決定します。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 必要なシグネチャを使用してメソッドを明示的に定義し、<xref:System.Predicate%601> デリゲートをインスタンス化して、デリゲートを <xref:System.Array.Find%2A> メソッドに渡すのではなく、ラムダ式を使用するのが慣例です。 次の例は、前の例と同じですが、ラムダ式を `match` 引数として使用している点が異なります。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された述語によって定義された条件と一致するすべての要素を取得します。</summary>
        <returns>指定した述語によって定義される条件に一致する要素が見つかった場合は、そのすべての要素を格納する <see cref="T:System.Array" />。それ以外の場合は、空の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡され、条件に一致する要素が返された配列に保存されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、0 ~ 1000 の範囲の値を持つ50乱数値の配列を作成します。 次に、300 ~ 600 の範囲の値を返すラムダ式を使用して、<xref:System.Array.FindAll%2A> メソッドを呼び出します。 ラムダ式には `x`という名前のパラメーターが渡されることに注意してください。 これは、<xref:System.Predicate%601>に渡される個々の配列メンバーを表します。 また、ローカルの `lBound` 変数と `uBound` 変数は、ラムダ式内でアクセスできることにも注意してください。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 次のコード例は、<xref:System.Array.Find%2A>、<xref:System.Array.FindLast%2A>、および <xref:System.Array.FindAll%2A> のジェネリックメソッドを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.Find%2A> ジェネリックメソッドは、配列を最初から走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが要素 "Amargasaurus" の `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A> のジェネリックメソッドを使用して、配列を末尾から後方に検索します。 位置5で要素 "Dilophosaurus" を検索します。 <xref:System.Array.FindAll%2A> のジェネリックメソッドを使用して、"saurus" で終わるすべての要素を含む配列を返します。 要素が表示されます。  
  
 このコード例では、<xref:System.Array.Exists%2A> と <xref:System.Array.TrueForAll%2A> ジェネリックメソッドも示しています。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> またはその一部分を対象に検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は、最初の要素から最後の要素まで順に検索されます。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.FindIndex%2A> ジェネリックメソッドの3つのオーバーロードすべてを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> メソッドオーバーロードは、最初から配列を走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが位置1の要素に対して `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、配列内の位置2から配列の末尾までの範囲を検索します。 位置5にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、位置2から始まる3つの要素の範囲を検索します。 この範囲には、"saurus" で終わる恐竜の名前がないため、-1 が返されます。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> の指定したインデックスから最後の要素までの範囲内で、指定した述語にで定義される条件に一致する要素を検索し、最初に見つかった 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は、`startIndex` から最後の要素までの順に検索されます。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `startIndex` から `array`の最後までの要素の数です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.FindIndex%2A> ジェネリックメソッドの3つのオーバーロードすべてを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> メソッドオーバーロードは、最初から配列を走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが位置1の要素に対して `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、配列内の位置2から配列の末尾までの範囲を検索します。 位置5にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、位置2から始まる3つの要素の範囲を検索します。 この範囲には、"saurus" で終わる恐竜の名前がないため、-1 が返されます。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> のうち、指定したインデックスから始まり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は `startIndex` から順に検索され、`startIndex` プラス `count`-1 (`count` が0を超える場合) が終わります。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡されます。  
  
 このメソッドは O(`n`) 操作です。`n` は `count` です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.FindIndex%2A> ジェネリックメソッドの3つのオーバーロードすべてを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> メソッドオーバーロードは、最初から配列を走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが位置1の要素に対して `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、配列内の位置2から配列の末尾までの範囲を検索します。 位置5にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、位置2から始まる3つの要素の範囲を検索します。 この範囲には、"saurus" で終わる恐竜の名前がないため、-1 が返されます。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> 全体を対象に検索し、最もインデックス番号の大きい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最後の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、<xref:System.Predicate%601>に個別に渡され、<xref:System.Array>内を後方に移動します。最後の要素から始まり、最初の要素で終わります。  一致が見つかった場合、処理は停止されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.Find%2A>、<xref:System.Array.FindLast%2A>、および <xref:System.Array.FindAll%2A> のジェネリックメソッドを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.Find%2A> ジェネリックメソッドは、配列を最初から走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが要素 "Amargasaurus" の `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A> のジェネリックメソッドを使用して、配列を末尾から後方に検索します。 位置5で要素 "Dilophosaurus" を検索します。 <xref:System.Array.FindAll%2A> のジェネリックメソッドを使用して、"saurus" で終わるすべての要素を含む配列を返します。 要素が表示されます。  
  
 このコード例では、<xref:System.Array.Exists%2A> と <xref:System.Array.TrueForAll%2A> ジェネリックメソッドも示しています。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> またはその一部分を対象に検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は、最後の要素から後方に検索され、最初の要素で終了します。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.FindLastIndex%2A> ジェネリックメソッドの3つのオーバーロードすべてを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードは、配列を末尾からさかのぼって走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが位置5の要素に対して `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、配列の位置が4から始まり、配列の先頭に向かって後方に向かって検索します。 位置1にある要素を検索します。 最後に、<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、3つの要素の範囲のうち、位置4から後方に向かって (つまり、要素4、3、および 2) を検索します。 この範囲には、"saurus" で終わる恐竜の名前がないため、-1 が返されます。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> のうち、先頭の要素から指定したインデックスまでの範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は `startIndex` から後方に検索され、最初の要素で終了します。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array` の先頭から `startIndex`までの要素の数です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.FindLastIndex%2A> ジェネリックメソッドの3つのオーバーロードすべてを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードは、配列を末尾からさかのぼって走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが位置5の要素に対して `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、配列の位置が4から始まり、配列の先頭に向かって後方に向かって検索します。 位置1にある要素を検索します。 最後に、<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、3つの要素の範囲のうち、位置4から後方に向かって (つまり、要素4、3、および 2) を検索します。 この範囲には、"saurus" で終わる恐竜の名前がないため、-1 が返されます。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> の指定したインデックスで終わる指定した要素数の範囲内で、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は、`startIndex` から後方に検索され、`count` が0よりも大きい場合は `startIndex` からマイナス `count` になります。  
  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に `true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡されます。  
  
 このメソッドは O(`n`) 操作です。`n` は `count` です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.FindLastIndex%2A> ジェネリックメソッドの3つのオーバーロードすべてを示しています。 文字列の配列が作成されます。これには8つの恐竜の名前が含まれ、そのうちの2つ (位置1と 5) の末尾が "saurus" になります。 また、このコード例では、文字列パラメーターを受け取り、入力文字列が "saurus" で終わるかどうかを示すブール値を返す、`EndsWithSaurus`という名前の検索述語メソッドも定義します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードは、配列を末尾からさかのぼって走査し、各要素を `EndsWithSaurus` メソッドに渡します。 `EndsWithSaurus` メソッドが位置5の要素に対して `true` を返すと、検索は停止します。  
  
> [!NOTE]
>  およびC# Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、配列の位置が4から始まり、配列の先頭に向かって後方に向かって検索します。 位置1にある要素を検索します。 最後に、<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバーロードを使用して、3つの要素の範囲のうち、位置4から後方に向かって (つまり、要素4、3、および 2) を検索します。 この範囲には、"saurus" で終わる恐竜の名前がないため、-1 が返されます。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">要素に処理を実行する、インデックス番号が 0 から始まる 1 次元の <see cref="T:System.Array" />。</param>
        <param name="action"><see cref="T:System.Action`1" /> の各要素に対して実行する <paramref name="array" />。</param>
        <summary>指定された配列内の各要素に対して、指定された処理を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> は、渡されたオブジェクトに対してアクションを実行するメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Action%601>に渡されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.ForEach%2A> を使用して、整数配列の各要素の二乗を表示する方法を示します。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="action" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" /> を返します。</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、 C#]  
  
 C# 言語の `foreach` ステートメント (C++ では `for each`、Visual Basic では `For Each`) では、列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初、列挙子はコレクションの先頭の要素の前に位置付けられます。 また、<xref:System.Collections.IEnumerator.Reset%2A> メソッドは、列挙子を最初の位置に戻します。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> は未定義です。 したがって、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して、列挙子をコレクションの先頭の要素に進めておく必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に進めます。  
  
 <xref:System.Collections.IEnumerator.MoveNext%2A> がコレクションの末尾を通過した場合、列挙子がコレクション内の最後の要素の後に配置され、<xref:System.Collections.IEnumerator.MoveNext%2A> は `false` を返します。 列挙子がこの位置にある場合、後続の <xref:System.Collections.IEnumerator.MoveNext%2A> 呼び出しも `false` を返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> の最後の呼び出しが `false`を返した場合、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。 コレクションの先頭の要素に再び <xref:System.Collections.IEnumerator.Current%2A> を設定するには、先に <xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 列挙子は、コレクションが変更されない限り有効です。 コレクションに対して変更 (要素の追加、変更、削除など) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子には、コレクションへの排他アクセスがありません。したがって、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するために、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.GetEnumerator%2A> を使用して配列の要素を一覧表示する方法を示しています。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">長さを指定する必要がある <see cref="T:System.Array" /> の 0 から始まる次元。</param>
        <summary><see cref="T:System.Array" /> の指定した次元にある要素の数を表す 32 ビット整数を取得します。</summary>
        <returns>指定した次元にある要素の数を表す 32 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLength%2A> の例は `GetLength(0)`であり、<xref:System.Array>の最初の次元にある要素の数を返します。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLength%2A> を使用して、異なるランクを持つ2つの配列のディメンションを表示する方法を示します。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="dimension" /> に <see cref="P:System.Array.Rank" /> 以上の値が指定されています。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dimension">長さを指定する必要がある <see cref="T:System.Array" /> の 0 から始まる次元。</param>
        <summary><see cref="T:System.Array" /> の指定した次元にある要素の数を表す 64 ビット整数を取得します。</summary>
        <returns>指定した次元にある要素の数を表す 64 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLongLength%2A> の例は `GetLongLength(0)`であり、<xref:System.Array>の最初の次元にある要素の数を返します。  
  
 このメソッドは、O(1) 操作です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="dimension" /> に <see cref="P:System.Array.Rank" /> 以上の値が指定されています。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">開始インデックスを指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最初の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の、最初の要素のインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` は配列の最初の次元の開始インデックスを返し、`GetLowerBound(Rank - 1)` は配列の最後の次元の開始インデックスを返します。  
  
 <xref:System.Array.GetLowerBound%2A> メソッドは、配列が空の場合でも、配列の下限のインデックスを示す値を常に返します。  
  
 .NET Framework のほとんどの配列はゼロから始まりますが (つまり、<xref:System.Array.GetLowerBound%2A> メソッドは配列の各次元に対して0を返します)、.NET Framework は0から始まらない配列をサポートします。 このような配列は <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> メソッドを使用して作成でき、アンマネージコードからも返すことができます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドを使用して、1次元配列と2次元配列の境界を表示し、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="dimension" /> に <see cref="P:System.Array.Rank" /> 以上の値が指定されています。</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">上限を指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最後の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の最後の要素のインデックス、または指定した次元が空の場合は -1 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` は配列の最初の次元の最後のインデックスを返し、`GetUpperBound(Rank - 1)` は配列の最後の次元の最後のインデックスを返します。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドを使用して、1次元配列と2次元配列の境界を表示し、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="dimension" /> に <see cref="P:System.Array.Rank" /> 以上の値が指定されています。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Array" /> 内の指定した要素の値を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">取得する <see cref="T:System.Array" /> 要素の位置を表す 32 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドは、`index` の値が範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> は現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">取得する <see cref="T:System.Array" /> 要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <returns>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indices` 内の要素の数は、<xref:System.Array>内の次元の数と同じである必要があります。 `indices` 配列内のすべての要素は、多次元 <xref:System.Array>内の目的の要素の位置を総称して指定する必要があります。  
  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index">取得する <see cref="T:System.Array" /> 要素の位置を表す 64 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数値として指定します。</summary>
        <returns>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドは、`index` の値が範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">取得する <see cref="T:System.Array" /> 要素の位置を指定するインデックスを表す 64 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <returns>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indices` 内の要素の数は、<xref:System.Array>内の次元の数と同じである必要があります。 `indices` 配列内のすべての要素は、多次元 <xref:System.Array>内の目的の要素の位置を総称して指定する必要があります。  
  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が 2 次元ではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数として指定します。</summary>
        <returns>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が 2 次元ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index3">取得する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> に設定されている次元が 3 つではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />、<paramref name="index2" /> または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の正しいインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index3">取得する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数として指定します。</summary>
        <returns>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 このメソッドは、O(1) 操作です。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> に設定されている次元が 3 つではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />、<paramref name="index2" /> または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の正しいインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたオブジェクトを 1 次元の配列または配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf (array As Array, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns><paramref name="value" /> で <paramref name="array" /> が見つかった場合は、最初に見つかった位置のインデックス。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1次元配列のすべての要素の `value`を検索します。 `value` が `array`に存在するかどうかを判断するために、メソッドは、一致するものが見つかるまで各要素の `Equals` メソッドを呼び出すことによって等価比較を実行します。 これは、要素が <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドすると、そのオーバーライドが呼び出されることを意味します。  
  
 ほとんどの配列は下限が0であるため、このメソッドは通常、`value` が見つからない場合は-1 を返します。 配列の下限が <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と等しく、`value` が見つからないまれなケースでは、このメソッドは <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) を返します。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 この例では、文字列配列内の文字列のインデックスを検索するために、<xref:System.Array.IndexOf%2A> メソッドの次の3つのオーバーロードを呼び出します。  
  
-   文字列配列内で最初に出現する文字列 "the" を特定するために <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>します。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列配列の4番目の要素の最後に出現する文字列 "the" を確認します。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、最後に見つかった配列の末尾との一致の後にある要素の文字列配列内で最初に出現する文字列 "the" を確認します。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf (array As Array, value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns><paramref name="value" /> の <paramref name="array" /> から最後の要素までの範囲内で <paramref name="startIndex" /> が見つかった場合は、最初に見つかった位置のインデックス。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インデックス `startIndex` の要素から最後の要素までの1次元配列を検索します。 `value` が `array`に存在するかどうかを判断するために、メソッドは、一致するものが見つかるまで、すべての要素の `Equals` メソッドを呼び出すことによって等価比較を実行します。 これは、要素が <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドすると、そのオーバーライドが呼び出されることを意味します。  
  
 ほとんどの配列は下限が0であるため、このメソッドは通常、`value` が見つからない場合は-1 を返します。 配列の下限が <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と等しく、`value` が見つからないまれなケースでは、このメソッドは <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) を返します。  
  
 `startIndex` が <xref:System.Array.Length%2A?displayProperty=nameWithType>に等しい場合、このメソッドは-1 を返します。 `startIndex` が <xref:System.Array.Length%2A?displayProperty=nameWithType>より大きい場合、メソッドは <xref:System.ArgumentOutOfRangeException>をスローします。  
  
 このメソッドは O (`n`) 操作であり、`n` は `startIndex` から `array`の最後までの要素の数です。  
  
   
  
## Examples  
 この例では、文字列配列内の文字列のインデックスを検索するために、<xref:System.Array.IndexOf%2A> メソッドの次の3つのオーバーロードを呼び出します。  
  
-   文字列配列内で最初に出現する文字列 "the" を特定するために <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>します。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列配列の4番目の要素の最後に出現する文字列 "the" を確認します。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、最後に見つかった配列の末尾との一致の後にある要素の文字列配列内で最初に出現する文字列 "the" を確認します。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf (array As Array, value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <param name="count">検索する要素数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns>インデックス <paramref name="value" /> から <paramref name="array" /><paramref name="startIndex" /><paramref name="startIndex" /> - 1 までの  +  内で <paramref name="count" /> が見つかった場合は、最初に見つかった位置のインデックス。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`count` が0より大きい場合、1次元配列の要素を `startIndex` から `startIndex` プラス `count`-1 に検索します。 `value` が `array`に存在するかどうかを判断するために、メソッドは、一致するものが見つかるまで、すべての要素の `Equals` メソッドを呼び出すことによって等価比較を実行します。 これは、要素が <xref:System.Object.Equals%2A?displayProperty=nameWithType> メソッドをオーバーライドすると、そのオーバーライドが呼び出されることを意味します。  
  
 ほとんどの配列は下限が0であるため、`value` が見つからない場合、通常、このメソッドは-1 を返します。 配列の下限が <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) と等しく、`value` が見つからないまれなケースでは、このメソッドは <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) を返します。  
  
 `startindex` が <xref:System.Array.Length%2A?displayProperty=nameWithType>に等しい場合、このメソッドは-1 を返します。 `startIndex` が <xref:System.Array.Length%2A?displayProperty=nameWithType>より大きい場合、メソッドは <xref:System.ArgumentOutOfRangeException>をスローします。  
  
 このメソッドは O(`n`) 操作です。`n` は `count` です。  
  
   
  
## Examples  
 この例では、文字列配列内の文字列のインデックスを検索するために、<xref:System.Array.IndexOf%2A> メソッドの次の3つのオーバーロードを呼び出します。  
  
-   文字列配列内で最初に出現する文字列 "the" を特定するために <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>します。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列配列の4番目の要素の最後に出現する文字列 "the" を確認します。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、最後に見つかった配列の末尾との一致の後にある要素の文字列配列内で最初に出現する文字列 "the" を確認します。 `count` 引数の値を確認するには、配列の上限を開始インデックスから減算し、1を追加します。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns><paramref name="value" /> 全体を対象とする <paramref name="array" /> の検索で最初に見つかった位置のインデックス (0 から始まる)。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1次元配列のすべての要素の `value`を検索します。 `value` が `array`に存在するかどうかを判断するために、メソッドは、すべての要素に対して `T.Equals` メソッドを呼び出すことによって等価比較を実行します。 これは、`T` が <xref:System.Object.Equals%2A> メソッドをオーバーライドすると、そのオーバーライドが呼び出されることを意味します。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例は、<xref:System.Array.IndexOf%2A> メソッドの3つのジェネリックオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回出現する文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドオーバーロードは、先頭から配列を検索し、最初に見つかった文字列を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドオーバーロードを使用して、インデックス位置3で始まる配列を検索し、配列の末尾まで進み、2番目に出現する文字列を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して2つのエントリの範囲を検索します。インデックスの位置2から開始します。検索文字列のインスタンスがこの範囲内に存在しないため、-1 が返されます。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns><paramref name="value" /> の <paramref name="array" /> から最後の要素までを範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`startIndex` の要素から配列の末尾までの1次元配列を検索します。 `value` が `array`に存在するかどうかを判断するために、メソッドは、すべての要素に対して `T.Equals` メソッドを呼び出すことによって等価比較を実行します。 これは、`T` が <xref:System.Object.Equals%2A> メソッドをオーバーライドすると、そのオーバーライドが呼び出されることを意味します。  
  
 `startIndex` が <xref:System.Array.Length%2A>に等しい場合、メソッドは-1 を返します。 `startIndex` が <xref:System.Array.Length%2A?displayProperty=nameWithType>を超える場合、メソッドは <xref:System.ArgumentOutOfRangeException>をスローします。  
  
 このメソッドは O (`n`) 操作であり、`n` は `startIndex` から `array`の最後までの要素の数です。  
  
   
  
## Examples  
 次の例は、<xref:System.Array.IndexOf%2A> メソッドの3つのジェネリックオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回出現する文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドオーバーロードは、先頭から配列を検索し、最初に見つかった文字列を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドオーバーロードを使用して、インデックス位置3で始まる配列を検索し、配列の末尾まで進み、2番目に出現する文字列を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して2つのエントリの範囲を検索します。インデックスの位置2から開始します。検索文字列のインスタンスがこの範囲内に存在しないため、-1 が返されます。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns><paramref name="value" /> の <paramref name="array" /> から <paramref name="startIndex" /> 個の要素を範囲として <paramref name="count" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`count` が0より大きい場合、1次元配列の要素を `startIndex` から `startIndex` プラス `count`-1 に検索します。 `value` が `array`に存在するかどうかを判断するために、メソッドは、すべての要素に対して `T.Equals` メソッドを呼び出すことによって等価比較を実行します。 これは、`T` が <xref:System.Object.Equals%2A> メソッドをオーバーライドすると、そのオーバーライドが呼び出されることを意味します。  
  
 `startIndex` が <xref:System.Array.Length%2A?displayProperty=nameWithType>に等しい場合、このメソッドは-1 を返します。  `startIndex` が <xref:System.Array.Length%2A?displayProperty=nameWithType>より大きい場合、メソッドは <xref:System.ArgumentOutOfRangeException>をスローします。  
  
 このメソッドは O(`n`) 操作です。`n` は `count` です。  
  
   
  
## Examples  
 次の例は、<xref:System.Array.IndexOf%2A> メソッドの3つのジェネリックオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回出現する文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドオーバーロードは、先頭から配列を検索し、最初に見つかった文字列を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドオーバーロードを使用して、インデックス位置3で始まる配列を検索し、配列の末尾まで進み、2番目に出現する文字列を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して2つのエントリの範囲を検索します。インデックスの位置2から開始します。検索文字列のインスタンスがこの範囲内に存在しないため、-1 が返されます。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>値型のパラメーターなしのコンストラクターを呼び出すことで、この値型 <see cref="T:System.Array" /> の各要素を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コンパイラが値型の配列をサポートできるように設計されています。ほとんどのユーザーにはこの方法は必要ありません。 参照型の配列では使用しないでください。  
  
 <xref:System.Array> が値型 <xref:System.Array> でない場合、または値型にパラメーターなしのコンストラクターがない場合、<xref:System.Array> は変更されません。  
  
 値型 <xref:System.Array> には、下限と次元の数を含めることができます。  
  
 このメソッドは O(`n`) 操作です。`n` は <xref:System.Array.Length%2A> です。  
  
> [!CAUTION]
>  このメソッドは、コンストラクターを持つ値型に対してのみ使用できます。ただし、にC#ネイティブな値型にはコンストラクターがありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IList?displayProperty=nameWithType> インターフェイスで必要とされるため、<xref:System.Array> は <xref:System.Array.IsFixedSize%2A> プロパティを実装します。  
  
 固定サイズの配列では、配列の作成後に要素を追加または削除することはできませんが、既存の要素を変更することはできます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IList?displayProperty=nameWithType> インターフェイスで必要とされるため、<xref:System.Array> は <xref:System.Array.IsReadOnly%2A> プロパティを実装します。 読み取り専用の配列では、配列の作成後に要素を追加、削除、または変更することはできません。  
  
 読み取り専用のコレクションが必要な場合は、<xref:System.Collections.IList?displayProperty=nameWithType> インターフェイスを実装する <xref:System.Collections> クラスを使用します。  
  
 配列を <xref:System.Collections.IList> インターフェイスオブジェクトにキャストまたは変換した場合、<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> プロパティは `false`を返します。 ただし、配列を <xref:System.Collections.Generic.IList%601> インターフェイスにキャストまたは変換した場合、`IsReadOnly` プロパティは `true`を返します。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> へのアクセスが同期されるかどうか (スレッド セーフかどうか) を示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection?displayProperty=nameWithType> インターフェイスで必要とされるため、<xref:System.Array> は <xref:System.Array.IsSynchronized%2A> プロパティを実装します。  
  
 <xref:System.Array> に基づく .NET Framework クラスは、<xref:System.Array.SyncRoot%2A> プロパティを使用して、独自に同期されたバージョンのコレクションを提供します。  
  
 配列を使用するクラスは、<xref:System.Array.SyncRoot%2A> プロパティを使用して独自の同期を実装することもできます。 同期コードでは、コレクションを直接操作するのではなく、コレクションの `SyncRoot` に対して操作を行う必要があります。 こうすることにより、他のオブジェクトから派生したコレクションを適切に操作することができます。 具体的には、コレクションを同時に変更している可能性のある他のスレッドとの適切な同期を維持します。 <xref:System.Array.SyncRoot%2A> の一部の実装では、<xref:System.Array> 自体が返される場合があることに注意してください。  
  
 コレクションの列挙は、本質的にスレッド セーフな手続きではありません。 コレクションが同期されていても、他のスレッドがコレクションを変更する場合があり、このときは列挙子から例外がスローされます。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.SyncRoot%2A> プロパティを使用して、列挙体全体で配列をロックする方法を示しています。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元 <see cref="T:System.Array" /> 内または <see cref="T:System.Array" /> の範囲内で値が最後に見つかった位置のインデックス番号を返します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf (array As Array, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元の <see cref="T:System.Array" /> 全体でそのオブジェクトが最後に見つかった位置のインデックス番号を返します。</summary>
        <returns><paramref name="value" /> 全体を対象に <paramref name="array" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1次元の <xref:System.Array> は、最後の要素から順に検索され、最初の要素で終了します。  
  
 要素は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> メソッドを使用して、指定された値と比較されます。 要素の型が非組み込み (ユーザー定義) 型の場合は、その型の `Equals` 実装が使用されます。  
  
 ほとんどの配列の下限は0であるため、このメソッドは `value` が見つからない場合に通常は-1 を返します。 配列の下限が <xref:System.Int32.MinValue?displayProperty=nameWithType> と等しく、`value` が見つからないまれなケースでは、このメソッドは <xref:System.Int32.MaxValue?displayProperty=nameWithType>を返します。これは `System.Int32.MinValue - 1`です。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
 .NET Framework バージョン2.0 では、このメソッドは <xref:System.Array> の <xref:System.Object.Equals%2A> および <xref:System.IComparable.CompareTo%2A> メソッドを使用して、<xref:System.Object> パラメーターによって指定された `value` が存在するかどうかを判断します。 以前のバージョンの .NET Framework では、この決定は `value`<xref:System.Object> の <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッドを使用して行われていました。  
  
 コレクション内のオブジェクトの `item` パラメーターのメソッドを <xref:System.IComparable.CompareTo%2A> します。  
  
   
  
## Examples  
 次のコード例は、配列内の指定された要素が最後に出現する位置のインデックスを調べる方法を示しています。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf (array As Array, value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <summary>1 次元 <see cref="T:System.Array" /> の先頭の要素から、指定したインデックスまでを対象に指定したオブジェクトを検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns><paramref name="value" /> の先頭の要素から <paramref name="array" /> までを範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1次元の <xref:System.Array> は `startIndex` から後方に検索され、最初の要素で終了します。  
  
 要素は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> メソッドを使用して、指定された値と比較されます。 要素の型が非組み込み (ユーザー定義) 型の場合は、その型の `Equals` 実装が使用されます。  
  
 ほとんどの配列の下限は0であるため、このメソッドは `value` が見つからない場合に通常は-1 を返します。 配列の下限が <xref:System.Int32.MinValue?displayProperty=nameWithType> と等しく、`value` が見つからないまれなケースでは、このメソッドは <xref:System.Int32.MaxValue?displayProperty=nameWithType>を返します。これは `System.Int32.MinValue - 1`です。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array` の先頭から `startIndex`までの要素の数です。  
  
 .NET Framework バージョン2.0 では、このメソッドは <xref:System.Array> の <xref:System.Object.Equals%2A> および <xref:System.IComparable.CompareTo%2A> メソッドを使用して、<xref:System.Object> パラメーターによって指定された `value` が存在するかどうかを判断します。 以前のバージョンの .NET Framework では、この決定は `value`<xref:System.Object> の <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッドを使用して行われていました。  
  
   
  
## Examples  
 次のコード例は、配列内の指定された要素が最後に出現する位置のインデックスを調べる方法を示しています。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf (array As Array, value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを、1 次元 <see cref="T:System.Array" /> の指定したインデックス位置から、指定した要素数を範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns><paramref name="value" /> の <paramref name="array" /> から、<paramref name="count" /> で指定された要素数を範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1次元の <xref:System.Array> は `startIndex` から後方に検索され、`count` が0よりも大きい場合は `startIndex` からマイナス `count` になります。  
  
 要素は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> メソッドを使用して、指定された値と比較されます。 要素の型が非組み込み (ユーザー定義) 型の場合は、その型の`Equals` 実装が使用されます。  
  
 ほとんどの配列の下限は0であるため、このメソッドは `value` が見つからない場合に通常は-1 を返します。 配列の下限が <xref:System.Int32.MinValue?displayProperty=nameWithType> と等しく、`value` が見つからないまれなケースでは、このメソッドは <xref:System.Int32.MaxValue?displayProperty=nameWithType>を返します。これは `System.Int32.MinValue - 1`です。  
  
 このメソッドは O(`n`) 操作です。`n` は `count` です。  
  
 .NET Framework バージョン2.0 では、このメソッドは <xref:System.Array> の <xref:System.Object.Equals%2A> および <xref:System.IComparable.CompareTo%2A> メソッドを使用して、<xref:System.Object> パラメーターによって指定された `value` が存在するかどうかを判断します。 以前のバージョンの .NET Framework では、この決定は `value`<xref:System.Object> の <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッドを使用して行われていました。  
  
   
  
## Examples  
 次のコード例は、配列内の指定された要素が最後に出現する位置のインデックスを調べる方法を示しています。 <xref:System.Array.LastIndexOf%2A> メソッドは後方検索であることに注意してください。したがって、`count` は、配列の下限から1を引いた値 (`startIndex`) 以下である必要があります。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを <see cref="T:System.Array" /> 全体を対象に検索し、インデックス番号の最も大きい要素のインデックスを返します。</summary>
        <returns><paramref name="value" /> が見つかった場合は、<paramref name="array" /> 全体で最後に見つかった位置のインデックス番号 (0 から始まる)。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は、最後の要素から後方に検索され、最初の要素で終了します。  
  
 要素は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> メソッドを使用して、指定された値と比較されます。 要素の型が非組み込み (ユーザー定義) 型の場合は、その型の `Equals` 実装が使用されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.LastIndexOf%2A> メソッドの3つのジェネリックオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回出現する文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドオーバーロードは、配列全体を末尾から検索し、2番目に出現する文字列を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドオーバーロードは、インデックス位置3で配列を後方に検索し、配列の先頭まで進み、最初に見つかった文字列を検索するために使用されます。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して4つのエントリの範囲を検索します。このとき、インデックス位置4から後方に拡張します (つまり、場所4、3、2、および1の項目を検索します)。検索文字列のインスタンスがこの範囲内に存在しないため、この検索では-1 が返されます。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <summary>指定したオブジェクトを、<see cref="T:System.Array" /> の先頭の要素から、指定されたインデックス位置までを範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>最初の要素から <paramref name="value" /> までの <paramref name="array" /> 内の要素の範囲内で <paramref name="startIndex" /> が見つかった場合は、最後に見つかった位置の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は `startIndex` から後方に検索され、最初の要素で終了します。  
  
 要素は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> メソッドを使用して、指定された値と比較されます。 要素の型が非組み込み (ユーザー定義) 型の場合は、その型の `Equals` 実装が使用されます。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array` の先頭から `startIndex`までの要素の数です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.LastIndexOf%2A> メソッドの3つのジェネリックオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回出現する文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドオーバーロードは、配列全体を末尾から検索し、2番目に出現する文字列を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドオーバーロードは、インデックス位置3で配列を後方に検索し、配列の先頭まで進み、最初に見つかった文字列を検索するために使用されます。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して4つのエントリの範囲を検索します。このとき、インデックス位置4から後方に拡張します (つまり、場所4、3、2、および1の項目を検索します)。検索文字列のインスタンスがこの範囲内に存在しないため、この検索では-1 が返されます。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value"><paramref name="array" /> 内で検索するオブジェクト。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを、<see cref="T:System.Array" /> の指定したインデックス位置から、指定した要素数を範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns><paramref name="value" /> の <paramref name="array" /> から <paramref name="count" /> 個の要素を範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素の 0 から始まるインデックス番号。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> は、`startIndex` から後方に検索され、`count` が0よりも大きい場合は `startIndex` からマイナス `count` になります。  
  
 要素は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> メソッドを使用して、指定された値と比較されます。 要素の型が非組み込み (ユーザー定義) 型の場合は、その型の `Equals` 実装が使用されます。  
  
 このメソッドは O(`n`) 操作です。`n` は `count` です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.LastIndexOf%2A> メソッドの3つのジェネリックオーバーロードすべてを示しています。 インデックス位置0とインデックス位置5で、1つのエントリが2回出現する文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドオーバーロードは、配列全体を末尾から検索し、2番目に出現する文字列を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドオーバーロードは、インデックス位置3で配列を後方に検索し、配列の先頭まで進み、最初に見つかった文字列を検索するために使用されます。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバーロードを使用して4つのエントリの範囲を検索します。このとき、インデックス位置4から後方に拡張します (つまり、場所4、3、2、および1の項目を検索します)。検索文字列のインスタンスがこの範囲内に存在しないため、この検索では-1 が返されます。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
または 
 <paramref name="count" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> のすべての次元内の要素の総数を取得します。</summary>
        <value><see cref="T:System.Array" /> のすべての次元内の要素の総数。配列内に要素がない場合はゼロ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Length%2A> プロパティを使用して、配列内の要素の合計数を取得します。 また、<xref:System.Array.GetUpperBound%2A> メソッドを使用して、多次元配列の各次元に含まれる要素の数を決定します。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">配列は多次元で、<see cref="F:System.Int32.MaxValue" /> を超える要素が含まれます。</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> のすべての次元内の要素の総数を表す 64 ビット整数を取得します。</summary>
        <value><see cref="T:System.Array" /> のすべての次元内の要素の総数を表す 64 ビット整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> のランク (次元数) を取得します。 たとえば、1 次元配列は 1 を返し、2 次元配列は 2 を返すなどです。</summary>
        <value><see cref="T:System.Array" /> のランク (次元数)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、Visual Basic コード  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 およびC#コード  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 値が3の <xref:System.Array.Rank%2A> プロパティを持つ3次元の配列を作成します。  
  
 ジャグ配列 (配列の配列) は1次元配列です。<xref:System.Array.Rank%2A> プロパティの値は1です。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例では、1次元配列、2次元配列、およびジャグ配列を初期化し、それぞれの <xref:System.Array.Rank%2A> プロパティを取得します。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize : T[] * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">サイズ変更の対象となる、インデックス番号が 0 から始まる 1 次元配列。指定したサイズの新しい配列を作成する場合は <see langword="null" />。</param>
        <param name="newSize">新しい配列のサイズ。</param>
        <summary>1 次元配列の要素数を、指定した新しいサイズに変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定されたサイズの新しい配列を割り当て、古い配列の要素を新しい配列にコピーしてから、古い配列を新しい配列に置き換えます。 `array` は、1次元配列である必要があります。  
  
 `array` が `null`場合、このメソッドは指定されたサイズの新しい配列を作成します。  
  
 `newSize` が古い配列の <xref:System.Array.Length%2A> より大きい場合は、新しい配列が割り当てられ、すべての要素が古い配列から新しい配列にコピーされます。  `newSize` が古い配列の <xref:System.Array.Length%2A> より小さい場合は、新しい配列が割り当てられ、新しい配列がいっぱいになるまで古い配列から新しい配列に要素がコピーされます。古い配列内の残りの要素は無視されます。  `newSize` が古い配列の <xref:System.Array.Length%2A> と等しい場合、このメソッドは何も行いません。  
  
 このメソッドは O(`n`) 操作です。`n` は `newSize` です。  
  
 <xref:System.Array.Resize%2A> メソッドは、1次元配列のサイズを変更します。 <xref:System.Array> クラスには、多次元配列のサイズを変更するためのメソッドは含まれていません。 これを行うには、独自のコードを用意するか、サードパーティのライブラリで特別な目的のメソッドを呼び出す必要があります。 次のコードは、 *n 個*の次元の配列のサイズを変更するメソッドに対して考えられる1つの実装を示しています。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 次の例は、サイズ変更が配列に与える影響を示しています。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> に 0 より小さい値が指定されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元 <see cref="T:System.Array" /> 内または <see cref="T:System.Array" /> の一部内の要素の順序を反転させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse (array As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">反転させる 1 次元の <see cref="T:System.Array" />。</param>
        <summary>1 次元の <see cref="T:System.Array" /> 内全体の要素のシーケンスを反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出した後、`myArray[i]`の要素 (`i` は配列内の任意のインデックスで、`myArray[j]`に移動します。ここで、`j` は `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`になります。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
 次の例に示すように、<xref:System.Array.Reverse%2A> メソッドを使用してジャグ配列を反転することができます。 現在のカルチャの暦で、現在の年の各月につき1つの要素を含むジャグ配列を初期化します。 各要素には、その月と同じ数の要素を持つ配列が含まれています。 この例では、配列の内容を表示し、<xref:System.Array.Reverse%2A> メソッドを呼び出して、反転された配列の内容を表示します。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array>内の値の並べ替えを反転する方法を示しています。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse (array As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">反転させる 1 次元の <see cref="T:System.Array" />。</param>
        <param name="index">反転させる範囲の先頭位置を示すインデックス。</param>
        <param name="length">反転対象の範囲内にある要素の数。</param>
        <summary>1 次元の <see cref="T:System.Array" />内の要素のサブセットのシーケンスを反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出した後、`myArray[i]`の要素 (`i` は配列内の任意のインデックスで、`myArray[j]`に移動します。ここで、`j` は `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`になります。  
  
 <xref:System.Array.Reverse%2A> メソッドを使用して、ジャグ配列を反転させることができます。  
  
 このメソッドは O(`n`) 操作です。`n` は `length` です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array>内の要素の範囲内の値の並べ替えを反転する方法を示しています。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="array" /> の要素の型。</typeparam>
        <param name="array">反転する要素の 1 次元配列。</param>
        <summary>1 次元のジェネリック配列内の要素のシーケンスを反転させます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="array" /> の要素の型。</typeparam>
        <param name="array">反転する要素の 1 次元配列。</param>
        <param name="index">反転させる範囲の先頭位置を示すインデックス。</param>
        <param name="length">反転対象の範囲内にある要素の数。</param>
        <summary>1 次元のジェネリック配列内の要素のサブセットのシーケンスを反転させます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Array" /> 内の指定した要素を指定した値に設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index">設定する <see cref="T:System.Array" /> 要素の位置を表す 32 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドは、`index` の値が範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> は現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indices` 内の要素の数は、<xref:System.Array>内の次元の数と同じである必要があります。 `indices` 配列内のすべての要素は、多次元 <xref:System.Array>内の目的の要素の位置を総称して指定する必要があります。  
  
 <xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドは、`indices` 配列内のいずれかの値が範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index">設定する <see cref="T:System.Array" /> 要素の位置を表す 64 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドは、`index` の値が範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 64 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indices` 内の要素の数は、<xref:System.Array>内の次元の数と同じである必要があります。 `indices` 配列内のすべての要素は、多次元 <xref:System.Array>内の目的の要素の位置を総称して指定する必要があります。  
  
 <xref:System.Array.GetLowerBound%2A> メソッドと <xref:System.Array.GetUpperBound%2A> メソッドは、`indices` 配列内のいずれかの値が範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が 2 次元ではありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が 2 次元ではありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の使用可能なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index3">設定する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> に設定されている次元が 3 つではありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />、<paramref name="index2" /> または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の正しいインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index3">設定する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> および <xref:System.Array.GetUpperBound%2A> メソッドは、いずれかのインデックスが範囲外であるかどうかを判断できます。  
  
 変換の詳細については、「<xref:System.Convert>」を参照してください。  
  
 このメソッドは、O(1) 操作です。  
  
> [!NOTE]
>  値型の配列の要素に `null` を割り当てるために <xref:System.Array.SetValue%2A> を使用する場合、要素のすべてのフィールドが0に初期化されます。 要素の値は null 参照ではなく、null 参照を検索することによって見つけることができません。  
  
   
  
## Examples  
 次のコード例は、1次元配列または多次元配列で特定の値を設定して取得する方法を示しています。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> に設定されている次元が 3 つではありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> は現在の <see cref="T:System.Array" />の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />、<paramref name="index2" /> または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の正しいインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元配列の要素を並べ替えます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <summary><see cref="T:System.Array" /> の各要素の <see cref="T:System.IComparable" /> 実装を使用して、1 次元 <see cref="T:System.Array" /> 全体の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `array` の各要素は、`array`内の他のすべての要素と比較できるように、<xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例では、既定の比較子と並べ替え順序を反転するカスタム比較子を使用して、<xref:System.Array> 内の値を並べ替える方法を示します。 結果は現在の <xref:System.Globalization.CultureInfo>によって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象のキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items"><see cref="T:System.Array" /><paramref name="keys" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
または 
 <see langword="null" /><paramref name="keys" /> のみを並べ替える場合は <see cref="T:System.Array" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `keys`<xref:System.Array> の各キーは、他のすべてのキーと比較できるように <xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `keys`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、最初の配列にキーが含まれ、2番目の配列に値が格納されている2つの関連する配列を並べ替える方法を示します。 並べ替えは、既定の比較子と、並べ替え順序を反転するカスタム比較子を使用して行われます。 結果は現在の <xref:System.Globalization.CultureInfo>によって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> が多次元です。  
  
または 
<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元配列。</param>
        <param name="comparer">要素を比較する場合に使用する実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable" />。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparer` が `null`場合、`array` の各要素は、`array`内の他のすべての要素と比較できるように、<xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
 .NET Framework には、次の表に示す定義済みの <xref:System.Collections.IComparer> 実装が含まれています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|2つのオブジェクトを比較しますが、文字列の大文字と小文字を区別しない比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアントカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の既定の並べ替え順序を使用して `T` 型の2つのオブジェクトを比較します。|  
  
 独自の <xref:System.Collections.IComparer> 実装のインスタンスを `comparer` パラメーターに指定することによって、カスタムの比較をサポートすることもできます。 この例では、型のインスタンスの既定の並べ替え順序を反転し、大文字と小文字を区別しない文字列比較を実行する `ReverseComparer` クラスを定義します。  
  
   
  
## Examples  
 次の例では、既定の比較子を使用して、文字列配列内の値を並べ替えます。 また、大文字と小文字を区別しない文字列比較を実行しているときに、オブジェクトの既定の並べ替え順序を反転する `ReverseComparer` という名前のカスタム <xref:System.Collections.IComparer> 実装も定義します。 出力は、現在のカルチャによって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> であり、かつ <paramref name="array" /> 内の 1 つ以上の要素で、<see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象のキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items"><see cref="T:System.Array" /><paramref name="keys" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
または 
 <see langword="null" /><paramref name="keys" /> のみを並べ替える場合は <see cref="T:System.Array" />。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `comparer` が `null`場合、`keys`<xref:System.Array> 内の各キーは、他のすべてのキーと比較できるように、<xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 .NET Framework には、次の表に示す定義済みの <xref:System.Collections.IComparer> 実装が含まれています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|2つのオブジェクトを比較しますが、文字列の大文字と小文字を区別しない比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアントカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の既定の並べ替え順序を使用して `T` 型の2つのオブジェクトを比較します。|  
  
 独自の <xref:System.Collections.IComparer> 実装のインスタンスを `comparer` パラメーターに指定することによって、カスタムの比較をサポートすることもできます。 この例では、既定の並べ替え順序を反転し、大文字と小文字を区別しない文字列比較を実行する <xref:System.Collections.IComparer> の実装を定義します。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `keys`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、最初の配列にキーが含まれ、2番目の配列に値が格納されている2つの関連する配列を並べ替える方法を示します。 並べ替えは、既定の比較子と、並べ替え順序を反転するカスタム比較子を使用して行われます。 結果は現在の <xref:System.Globalization.CultureInfo>によって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> が多次元です。  
  
または 
<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。  
  
または 
<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary><see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable" /> を使用して、1 次元 <see cref="T:System.Array" /> のうちある要素範囲の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `array` 内の指定された要素範囲内の各要素は、`array`内の他のすべての要素と比較できるように、<xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例では、既定の比較子と並べ替え順序を反転するカスタム比較子を使用して、<xref:System.Array> 内の値を並べ替える方法を示します。 結果は現在の <xref:System.Globalization.CultureInfo>によって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象のキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items"><see cref="T:System.Array" /><paramref name="keys" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
または 
 <see langword="null" /><paramref name="keys" /> のみを並べ替える場合は <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方がキーを格納し、他方が対応する項目を格納する) の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `keys`<xref:System.Array> 内の指定された要素範囲内の各キーは、他のすべてのキーと比較できるように <xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例では、最初の配列にキーが含まれ、2番目の配列に値が格納されている2つの関連する配列を並べ替える方法を示します。 並べ替えは、既定の比較子と、並べ替え順序を反転するカスタム比較子を使用して行われます。 結果は現在の <xref:System.Globalization.CultureInfo>によって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> が多次元です。  
  
または 
<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。  
  
または 
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable" />。</param>
        <summary>1 次元 <see cref="T:System.Array" /> の要素の範囲内の要素を、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparer` が `null`場合、`array` 内の指定された要素範囲内の各要素は、`array`内の他のすべての要素と比較できるように <xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 .NET Framework には、次の表に示す定義済みの <xref:System.Collections.IComparer> 実装が含まれています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|2つのオブジェクトを比較しますが、文字列の大文字と小文字を区別しない比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアントカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の既定の並べ替え順序を使用して `T` 型の2つのオブジェクトを比較します。|  
  
 独自の <xref:System.Collections.IComparer> 実装のインスタンスを `comparer` パラメーターに指定することによって、カスタムの比較をサポートすることもできます。 この例では、型のインスタンスの既定の並べ替え順序を反転し、大文字と小文字を区別しない文字列比較を実行する `ReverseComparer` クラスを定義します。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例では、既定の比較子と並べ替え順序を反転するカスタム比較子を使用して、<xref:System.Array> 内の値を並べ替える方法を示します。 結果は現在の <xref:System.Globalization.CultureInfo>によって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> に多次元配列が設定されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
または 
<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> であり、かつ <paramref name="array" /> 内の 1 つ以上の要素で、<see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象のキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items"><see cref="T:System.Array" /><paramref name="keys" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
または 
 <see langword="null" /><paramref name="keys" /> のみを並べ替える場合は <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
または 
 各要素の <see langword="null" /> 実装を使用する場合は <see cref="T:System.IComparable" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) 内の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `comparer` が `null`場合、`keys`<xref:System.Array> 内の指定された要素範囲内の各キーは、他のすべてのキーと比較できるように、<xref:System.IComparable> インターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 .NET Framework には、次の表に示す定義済みの <xref:System.Collections.IComparer> 実装が含まれています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|2つのオブジェクトを比較しますが、文字列の大文字と小文字を区別しない比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアントカルチャの並べ替え規則を使用して、2つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の既定の並べ替え順序を使用して `T` 型の2つのオブジェクトを比較します。|  
  
 独自の <xref:System.Collections.IComparer> 実装のインスタンスを `comparer` パラメーターに指定することによって、カスタムの比較をサポートすることもできます。 この例では、既定の並べ替え順序を反転し、大文字と小文字を区別しない文字列比較を実行するカスタム <xref:System.Collections.IComparer> 実装を定義します。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例では、最初の配列にキーが含まれ、2番目の配列に値が格納されている2つの関連する配列を並べ替える方法を示します。 並べ替えは、既定の比較子と、並べ替え順序を反転するカスタム比較子を使用して行われます。 結果は現在の <xref:System.Globalization.CultureInfo>によって異なる場合があることに注意してください。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> が多次元です。  
  
または 
<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。  
  
または 
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> の有効な範囲を指定していません。  
  
または 
<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <summary><see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、<see cref="T:System.Array" /> 全体の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `array` の各要素は、`array`内の他のすべての要素と比較できるように、<xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、ジェネリックメソッドのオーバーロードと <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> ジェネリックメソッドのオーバーロード <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> を示しています。 文字列の配列は、特定の順序で作成されません。  
  
 配列が表示され、並べ替えられて、もう一度表示されます。  
  
> [!NOTE]
>  <xref:System.Array.Sort%2A> および <xref:System.Array.BinarySearch%2A> ジェネリックメソッドへの呼び出しは、非ジェネリックメソッドの呼び出しとは異なるものではありませんC#。これC++は Visual Basic、、およびが、最初の引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 次に、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> ジェネリックメソッドオーバーロードを使用して2つの文字列を検索します。1つは配列に含まれず、もう1つはです。 <xref:System.Array.BinarySearch%2A> メソッドの配列と戻り値は、`ShowWhere` ジェネリックメソッドに渡されます。このメソッドには、文字列が見つかった場合はインデックス値が表示され、それ以外の場合は検索文字列が配列内に存在する場合は、その要素が含まれます。 文字列が配列ではない場合、インデックスは負になります。したがって、`ShowWhere` メソッドはビットごとの補数 ( C#と `Xor` C++ビジュアルでは ~ 演算子、Visual Basic では-1) を取得して、検索文字列よりも大きいリスト内の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see langword="null" /> ジェネリック インターフェイスを使用する場合は <see cref="T:System.IComparable`1" />。</param>
        <summary><see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparer` が `null`場合、`array` の各要素は、`array`内の他のすべての要素と比較できるように <xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、ジェネリックメソッドのオーバーロードと <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドのオーバーロード <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> を示しています。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>` (Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 配列が表示され、並べ替えられて、もう一度表示されます。 <xref:System.Array.BinarySearch%2A> メソッドを使用するには、配列を並べ替える必要があります。  
  
> [!NOTE]
>  <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> および <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドへの呼び出しは、非ジェネリックメソッドの呼び出しとは異なるものではありませんC#。これC++は Visual Basic、、およびが、最初の引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 次に、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドオーバーロードを使用して2つの文字列を検索します。1つは配列に含まれず、もう1つはです。 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> メソッドの配列と戻り値は、`ShowWhere` ジェネリックメソッドに渡されます。このメソッドには、文字列が見つかった場合はインデックス値が表示され、それ以外の場合は検索文字列が配列内に存在する場合は、その要素が含まれます。 文字列が配列ではない場合、インデックスは負になります。したがって、`ShowWhere` メソッドはビットごとの補数 ( C#と `Xor` C++ビジュアルでは ~ 演算子、Visual Basic では-1) を取得して、検索文字列よりも大きいリスト内の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="comparison">要素を比較する場合に使用する <see cref="T:System.Comparison`1" />。</param>
        <summary><see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Comparison`1" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドは、次のように introspective sort (introsort) アルゴリズムを使用します。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> メソッドのオーバーロードを示しています。  
  
 このコード例では、`CompareDinosByLength`という名前の文字列に対して、別の比較メソッドを定義しています。 このメソッドは次のように機能します。最初に、比較対照値が`null`に対してテストされ、null 参照が null 以外の値として処理されます。 次に、文字列の長さが比較され、長い方の文字列が大きいと見なされます。 3番目の長さが等しい場合は、通常の文字列比較が使用されます。  
  
 文字列の配列が作成され、特定の順序ではなく4つの文字列が設定されます。 この一覧には、空の文字列と null 参照も含まれています。 リストが表示され、`CompareDinosByLength` メソッドを表す <xref:System.Comparison%601> 汎用デリゲートを使用して並べ替えられて、もう一度表示されます。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="comparison" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparison" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは6個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary><see cref="T:System.Array" /> の各要素の <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスの実装を使用して、<see cref="T:System.Array" /> の中のある要素範囲の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `array` 内の指定された要素範囲内の各要素は、`array`内の他のすべての要素と比較できるように、<xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例は <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ジェネリックメソッドのオーバーロードと、配列内の範囲を並べ替えるためのジェネリックメソッドオーバーロード <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> を示しています。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>` (Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 このコード例では、3つの herbivores の後に3つの carnivores (tyrannosaurids) で構成される恐竜の名前の配列を作成して表示します。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ジェネリックメソッドオーバーロードは、配列の最後の3つの要素の並べ替えに使用され、その後表示されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のジェネリックメソッドオーバーロードを `ReverseCompare` と共に使用して、最後の3つの要素を逆順に並べ替えます。 完全に混同された恐竜が再び表示されます。  
  
> [!NOTE]
>  <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> および <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドへの呼び出しは、非ジェネリックメソッドの呼び出しとは異なるものではありませんC#。これC++は Visual Basic、、およびが、最初の引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see langword="null" /> ジェネリック インターフェイスを使用する場合は <see cref="T:System.IComparable`1" />。</param>
        <summary>指定した <see cref="T:System.Array" /> ジェネリック インターフェイスを使用して、<see cref="T:System.Collections.Generic.IComparer`1" /> 内の要素の範囲内の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparer` が `null`場合、`array` 内の指定された要素範囲内の各要素は、`array`内の他のすべての要素と比較できるように <xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例は <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ジェネリックメソッドのオーバーロードと、配列内の範囲を並べ替えるためのジェネリックメソッドオーバーロード <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> を示しています。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>` (Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 このコード例では、3つの herbivores の後に3つの carnivores (tyrannosaurids) で構成される恐竜の名前の配列を作成して表示します。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ジェネリックメソッドオーバーロードは、配列の最後の3つの要素の並べ替えに使用され、その後表示されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のジェネリックメソッドオーバーロードを `ReverseCompare` と共に使用して、最後の3つの要素を逆順に並べ替えます。 完全に混同された恐竜が再び表示されます。  
  
> [!NOTE]
>  <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> および <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドへの呼び出しは、非ジェネリックメソッドの呼び出しとは異なるものではありませんC#。これC++は Visual Basic、、およびが、最初の引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
または 
<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items"><see cref="T:System.Array" /> 内のキーに対応する項目が格納されている 1 次元の <paramref name="keys" /> (インデックス番号は 0 から始まります)。<see langword="null" /> だけを並べ替える場合は <paramref name="keys" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `keys`<xref:System.Array> の各キーは、他のすべてのキーと比較できるように、<xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドのオーバーロードを示しています。これは、キーと値を表す配列のペアを並べ替えるためのものです。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>` (Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 このコード例では、恐竜の名前 (キー) と、各恐竜の最大長をメートル (値) で表す整数の配列を作成して表示します。 次に、配列が並べ替えられ、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> のオーバーロードは、最初の配列の恐竜名の順に両方の配列を並べ替えるために使用されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のオーバーロードと `ReverseCompare` のインスタンスを使用して、ペアになっている配列の並べ替え順序を逆にします。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> のオーバーロードは、両方の配列の最後の3つの要素を並べ替えるために使用されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のオーバーロードは、両方の配列の最後の3つの要素を逆順に並べ替えるために使用されます。  
  
> [!NOTE]
>  ジェネリックメソッドへの呼び出しは、それに対応する非ジェネリックメソッドの呼び出しとは異なるものにC#はなりC++ません。これは Visual Basic、、およびが、最初の2つの引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items"><see cref="T:System.Array" /> 内のキーに対応する項目が格納されている 1 次元の <paramref name="keys" /> (インデックス番号は 0 から始まります)。<see langword="null" /> だけを並べ替える場合は <paramref name="keys" />。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see langword="null" /> ジェネリック インターフェイスを使用する場合は <see cref="T:System.IComparable`1" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `comparer` が `null`場合、`keys`<xref:System.Array> 内の各キーは、他のすべてのキーと比較できるように、<xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>を示しています。 [\]、TValue\<xref: 602> %60% %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string。 IComparer% 7B %60 %600% 7D %29 >、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドのオーバーロードで、キーと値を表す配列のペアを並べ替えます。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>` (Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 このコード例では、恐竜の名前 (キー) と、各恐竜の最大長をメートル (値) で表す整数の配列を作成して表示します。 次に、配列が並べ替えられ、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> のオーバーロードは、最初の配列の恐竜名の順に両方の配列を並べ替えるために使用されます。  
  
-   [\]、TValue\<xref: 2csystem.string %60% 602> %28 %60 %600% 5B% 5D% 1>%. IComparer% 7B% の%% .% 7B %60 %600% 7D %29 > オーバーロードと `ReverseCompare` のインスタンスを使用して、ペアになっている配列の並べ替え順序を逆にします。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> のオーバーロードは、両方の配列の最後の3つの要素を並べ替えるために使用されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のオーバーロードは、両方の配列の最後の3つの要素を逆順に並べ替えるために使用されます。  
  
> [!NOTE]
>  ジェネリックメソッドへの呼び出しは、それに対応する非ジェネリックメソッドの呼び出しとは異なるものにC#はなりC++ません。これは Visual Basic、、およびが、最初の2つの引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。  
  
または 
<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> は <see langword="null" />であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items"><see cref="T:System.Array" /> 内のキーに対応する項目が格納されている 1 次元の <paramref name="keys" /> (インデックス番号は 0 から始まります)。<see langword="null" /> だけを並べ替える場合は <paramref name="keys" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `keys`<xref:System.Array> 内の指定された要素範囲内の各キーは、他のすべてのキーと比較できるように <xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、[\]、TValue\<xref: 2Csystem.string %60% 602> %28 %60 %600% 5B% 5D% 2Csystem.string %60 %601% 5B% 5D%% %29 >、および <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> ジェネリックメソッドオーバーロードを使用して、キーと値を表す配列のペアを並べ替えます。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>` (Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 このコード例では、恐竜の名前 (キー) と、各恐竜の最大長をメートル (値) で表す整数の配列を作成して表示します。 次に、配列が並べ替えられ、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> のオーバーロードは、最初の配列の恐竜名の順に両方の配列を並べ替えるために使用されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のオーバーロードと `ReverseCompare` のインスタンスを使用して、ペアになっている配列の並べ替え順序を逆にします。  
  
-   [\]、TValue\<xref: 2csystem.string %60% 602> %28 %60 %600% 5B% 5D% 1> %60 %601% 5B% 5D%% 2Csystem.string %29 > オーバーロードは、両方の配列の最後の3つの要素の並べ替えに使用されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のオーバーロードは、両方の配列の最後の3つの要素を逆順に並べ替えるために使用されます。  
  
> [!NOTE]
>  ジェネリックメソッドへの呼び出しは、それに対応する非ジェネリックメソッドの呼び出しとは異なるものにC#はなりC++ません。これは Visual Basic、、およびが、最初の2つの引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。  
  
または 
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items"><see cref="T:System.Array" /> 内のキーに対応する項目が格納されている 1 次元の <paramref name="keys" /> (インデックス番号は 0 から始まります)。<see langword="null" /> だけを並べ替える場合は <paramref name="keys" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see langword="null" /> ジェネリック インターフェイスを使用する場合は <see cref="T:System.IComparable`1" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) 内の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`<xref:System.Array> の各キーには、`items`<xref:System.Array>内の対応する項目があります。 並べ替え中にキーが移動されると、`items`<xref:System.Array> 内の対応する項目も同様に再配置されます。 したがって、`items`<xref:System.Array> は `keys`<xref:System.Array>内の対応するキーの配置に従って並べ替えられます。  
  
 `comparer` が `null`場合、`keys`<xref:System.Array> 内の指定された要素範囲内の各キーは、他のすべてのキーと比較できるように、<xref:System.IComparable%601> ジェネリックインターフェイスを実装する必要があります。  
  
 キー以外の項目がある場合は、並べ替えることができますが、対応するキーがない項目は並べ替えられません。 項目よりも多くのキーがある場合は、並べ替えることはできません。この操作を行うと、<xref:System.ArgumentException>がスローされます。  
  
 並べ替えが正常に完了しなかった場合、結果は未定義になります。  
  
 このメソッドでは、次のように introspective sort (introsort) アルゴリズムが使用されます。  
  
-   パーティションサイズが16要素以下の場合は、[挿入並べ替え](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムが使用されます。  
  
-   パーティションの数が 2 * Log<sup>N</sup>を超えている場合 ( *n*は入力配列の範囲)、 [heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムが使用されます。  
  
-   それ以外の場合は、[クイックソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムを使用します。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2つの要素が等しい場合、その順序は保持されない可能性があります。 これに対して、安定した並べ替えでは、等しい要素の順序が保持されます。  
  
 Heapsort アルゴリズムとクイックソートアルゴリズムを使用して並べ替えられた配列の場合、最悪のケースでは、このメソッドは O (`n` log `n`) 操作であり、`n` は `length`ます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および [\]を示しています。 TValue\<xref: 2Csystem.string %60% 602> %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string% 2Csystem.string% IComparer%% 7B %60 %600% 7D %29 > ジェネリックメソッドオーバーロードで、キーと値を表す配列のペアを並べ替えることができます。  
  
 このコード例では、`ReverseCompare`という名前の文字列の代替比較子を定義しています。これはC++、`IComparer<string>`(Visual Basic では`IComparer(Of String)`、`IComparer<String^>` は Visual) ジェネリックインターフェイスを実装します。 比較子は、比較対照値メソッドを <xref:System.String.CompareTo%28System.String%29> 呼び出して、文字列が低い順に並べ替えられるように、の順序を逆にします。  
  
 このコード例では、恐竜の名前 (キー) と、各恐竜の最大長をメートル (値) で表す整数の配列を作成して表示します。 次に、配列が並べ替えられ、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> のオーバーロードは、最初の配列の恐竜名の順に両方の配列を並べ替えるために使用されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> のオーバーロードと `ReverseCompare` のインスタンスを使用して、ペアになっている配列の並べ替え順序を逆にします。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> のオーバーロードは、両方の配列の最後の3つの要素を並べ替えるために使用されます。  
  
-   [\]、TValue\<xref: 2Csystem.string %60% 602> %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string% 2Csystem.string% IComparer。% 7B %60 %600% 7D %29 > オーバーロードを使用して、両方の配列の最後の3つの要素を逆順に並べ替えます。  
  
> [!NOTE]
>  ジェネリックメソッドへの呼び出しは、それに対応する非ジェネリックメソッドの呼び出しとは異なるものにC#はなりC++ません。これは Visual Basic、、およびが、最初の2つの引数の型からジェネリック型パラメーターの型を推論するためです。 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して Microsoft 中間言語 (MSIL) を調べると、ジェネリックメソッドが呼び出されていることがわかります。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
または 
 <paramref name="length" /> に 0 より小さい値が指定されています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。  
  
または 
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  
  
または 
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> の有効な範囲を指定していません。  
  
または 
<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> は <see langword="null" />であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 以前のバージョンでは、クイックソートアルゴリズムのみが使用されていました。 クイックソートは、並べ替え操作によって <see cref="T:System.IndexOutOfRangeException" /> 例外がスローされ、呼び出し元に <see cref="T:System.ArgumentException" /> 例外をスローする場合に、無効な比較子を識別します。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、挿入の並べ替えおよび heapsort アルゴリズムで無効な比較子が検出されないため、以前に <see cref="T:System.ArgumentException" /> をスローした並べ替え操作で例外がスローされない可能性があります。 ほとんどの場合、これは16個以下の要素を持つ配列に適用されます。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">カルチャの影響を受けない配列の操作の実行</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> へのアクセスの同期に使用できるオブジェクトを取得します。</summary>
        <value><see cref="T:System.Array" /> へのアクセスの同期に使用できるオブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、<xref:System.Collections.ICollection?displayProperty=nameWithType> インターフェイスを実装します。  
  
 <xref:System.Array> に基づく .NET Framework クラスは、<xref:System.Array.SyncRoot%2A> プロパティを使用して、独自に同期されたバージョンのコレクションを提供します。  
  
 配列を使用するクラスは、<xref:System.Array.SyncRoot%2A> プロパティを使用して独自の同期を実装することもできます。 同期コードでは、コレクションを直接操作するのではなく、コレクションの `SyncRoot` に対して操作を行う必要があります。 こうすることにより、他のオブジェクトから派生したコレクションを適切に操作することができます。 具体的には、コレクションを同時に変更している可能性のある他のスレッドとの適切な同期を維持します。 <xref:System.Array.SyncRoot%2A> の一部の実装では、<xref:System.Array> 自体が返される場合があることに注意してください。  
  
 コレクションの列挙は、本質的にスレッド セーフな手続きではありません。 コレクションが同期されていても、他のスレッドがコレクションを変更する場合があり、このときは列挙子から例外がスローされます。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Array.SyncRoot%2A> プロパティを使用して、列挙体全体で配列をロックする方法を示しています。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.Count : int" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> に格納されている要素の数を取得します。</summary>
        <value>コレクションに含まれる要素の数です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.ICollection> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.IsSynchronized : bool" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> へのアクセスが同期されるかどうか (スレッド セーフかどうか) を示す値を取得します。</summary>
        <value><see cref="T:System.Array" /> へのアクセスが同期される場合 (スレッドセーフの場合) は true、同期されない場合は false です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.SyncRoot : obj" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> へのアクセスの同期に使用できるオブジェクトを取得します。</summary>
        <value><see cref="T:System.Array" /> へのアクセスの同期に使用できるオブジェクトです。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Add : obj -&gt; int&#xA;override this.System.Collections.IList.Add : obj -&gt; int" Usage="array.System.Collections.IList.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Collections.IList" /> に追加するオブジェクト。</param>
        <summary>このメソッドを呼び出すと、必ず <see cref="T:System.NotSupportedException" /> 例外がスローされます。</summary>
        <returns>配列への値の追加はサポートされていません。 値は返されません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> の実装では、メンバーをコレクションに追加します。 ただし、配列は固定サイズであるため (<xref:System.Array.IsFixedSize%2A> プロパティは常に `true`を返します)、このメソッドは常に <xref:System.NotSupportedException> 例外をスローします。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Clear : unit -&gt; unit&#xA;override this.System.Collections.IList.Clear : unit -&gt; unit" Usage="array.System.Collections.IList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IList" /> からすべての項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Contains : obj -&gt; bool&#xA;override this.System.Collections.IList.Contains : obj -&gt; bool" Usage="array.System.Collections.IList.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。 参照型の場合は、検索する要素として <see langword="null" /> を指定できます。</param>
        <summary>ある要素が <see cref="T:System.Collections.IList" /> 内に存在するかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="value" /> に存在する場合は <see cref="T:System.Collections.IList" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.IndexOf : obj -&gt; int&#xA;override this.System.Collections.IList.IndexOf : obj -&gt; int" Usage="array.System.Collections.IList.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。</param>
        <summary><see cref="T:System.Collections.IList" /> 内の特定のアイテムのインデックスを示します。</summary>
        <returns>値がリストに存在する場合はそのインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Insert : int * obj -&gt; unit&#xA;override this.System.Collections.IList.Insert : int * obj -&gt; unit" Usage="array.System.Collections.IList.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><paramref name="value" /> を挿入する位置のインデックス番号。</param>
        <param name="value">挿入するオブジェクトです。</param>
        <summary>アイテムを <see cref="T:System.Collections.IList" /> 内の指定したインデックスに挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
または 
<see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> は <see cref="T:System.Collections.IList" /> の null 参照です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsFixedSize : bool" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Array" /> が固定サイズである場合は true、固定サイズではない場合は false です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsReadOnly : bool" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Array" /> が読み取り専用である場合は true、読み取り専用ではない場合は false です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.Item(int) : obj with get, set" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得または設定する要素のインデックス。</param>
        <summary>指定されたインデックス位置にある要素を取得または設定します。</summary>
        <value>指定されたインデックス位置の要素です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> に 0 より小さい値が指定されています。  
  
または 
 <paramref name="index" /> に <see cref="P:System.Collections.ICollection.Count" /> 以上の値が指定されています。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Remove : obj -&gt; unit&#xA;override this.System.Collections.IList.Remove : obj -&gt; unit" Usage="array.System.Collections.IList.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Collections.IList" /> から削除するオブジェクトです。</param>
        <summary><see cref="T:System.Collections.IList" /> から、最初に見つかった特定のオブジェクトを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
または 
<see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.RemoveAt : int -&gt; unit&#xA;override this.System.Collections.IList.RemoveAt : int -&gt; unit" Usage="array.System.Collections.IList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素のインデックス。</param>
        <summary>指定したインデックスにある <see cref="T:System.Collections.IList" /> 項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">index が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
または 
<see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IStructuralComparable.CompareTo : obj * System.Collections.IComparer -&gt; int&#xA;override this.System.Collections.IStructuralComparable.CompareTo : obj * System.Collections.IComparer -&gt; int" Usage="array.System.Collections.IStructuralComparable.CompareTo (other, comparer)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">現在のオブジェクトと <paramref name="other" /> とを比較するオブジェクト。</param>
        <summary>現在のコレクション オブジェクトの並べ替え順序での位置が、別のオブジェクトと比べて前か、後か、または同じかを判断します。</summary>
        <returns>現在のコレクション オブジェクトと他のオブジェクトとの関係を示す整数。次の表を参照してください。  
  
 <list type="table"><listheader><term> 戻り値 
 </term><description> 説明 
 </description></listheader><item><term> -1 
 </term><description> 現在のインスタンスが <paramref name="other" /> よりも前。  
  
 </description></item><item><term> 0 
 </term><description> 現在のインスタンスと <paramref name="other" /> とが等しい。  
  
 </description></item><item><term> 1 
 </term><description> 現在のインスタンスが <paramref name="other" /> よりも後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralComparable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IStructuralEquatable.Equals : obj * System.Collections.IEqualityComparer -&gt; bool&#xA;override this.System.Collections.IStructuralEquatable.Equals : obj * System.Collections.IEqualityComparer -&gt; bool" Usage="array.System.Collections.IStructuralEquatable.Equals (other, comparer)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">現在のインスタンスと <paramref name="other" /> が等しいかどうかを判断するオブジェクト。</param>
        <summary>オブジェクトが現在のインスタンスと等しいかどうかを判断します。</summary>
        <returns>2 つのオブジェクトが等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IStructuralEquatable.GetHashCode : System.Collections.IEqualityComparer -&gt; int&#xA;override this.System.Collections.IStructuralEquatable.GetHashCode : System.Collections.IEqualityComparer -&gt; int" Usage="array.System.Collections.IStructuralEquatable.GetHashCode comparer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">現在のオブジェクトのハッシュ コードを計算するオブジェクト。</param>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">条件が一致するかどうかをチェックする 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="match">要素の条件を定義する述語。</param>
        <summary>配列内のすべての要素が、指定された述語によって定義された条件と一致するかどうかを調べます。</summary>
        <returns><see langword="true" /> 内のすべての要素が、指定された述語によって定義された条件と一致する場合は <paramref name="array" />。それ以外の場合は <see langword="false" />。 配列内に要素がない場合、戻り値は <see langword="true" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> は、渡されたオブジェクトがデリゲートで定義されている条件に一致する場合に`true` を返すメソッドのデリゲートです。  `array` の要素は、個別に <xref:System.Predicate%601>に渡され、デリゲートが任意の要素に対して `false` を返すと処理が停止します。  
  
 このメソッドは O (`n`) 操作であり、`n` は `array`の <xref:System.Array.Length%2A> です。  
  
   
  
## Examples  
 次の例では、文字列配列内の各要素の最後の文字が数値であるかどうかを判断します。 2つの文字列配列を作成します。 最初の配列には、アルファベット文字で終わる文字列と、数字で終わる文字列の両方が含まれています。2番目の配列は、数字で終わる文字列のみで構成されます。 また、この例では、<xref:System.Predicate%601> デリゲートと一致するシグネチャを持つ `EndWithANumber` メソッドも定義します。 この例では、`EndsWithANumber` メソッドを表すデリゲートと共に、各配列を <xref:System.Array.TrueForAll%2A> メソッドに渡します。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 次の例は、最初の例と似ていますが、特定の配列要素が数値の文字列形式で終わるかどうかを判断するラムダ式と共に <xref:System.Array.TrueForAll%2A> メソッドに文字列配列を渡す点が異なります。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 どちらの場合も、<xref:System.Array.TrueForAll%2A> メソッドは、末尾が数値ではない最初の配列要素が見つかるとすぐに `false` を返します。 それ以外の場合は、配列内のすべての要素を反復処理した後に `true` を返します。  
  
> [!NOTE]
>  両方の例でC# 、と Visual Basic では、`Predicate<string>` デリゲート (Visual Basic で`Predicate(Of String)`) を明示的に作成する必要はありません。 これらの言語は、コンテキストから正しいデリゲートを推測し、自動的に作成します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> が <see langword="null" /> です。  
  
または 
 <paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
