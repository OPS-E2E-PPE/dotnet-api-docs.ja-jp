<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e2aa2433b61fdc394c1602ac791d097d70525c99" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74388765" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>テキストを一連の UTF-16 コード単位として表現します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 文字列は、テキストを表すために使用される文字のシーケンシャルコレクションです。 <xref:System.String> オブジェクトは、文字列を表す <xref:System.Char?displayProperty=nameWithType> オブジェクトのシーケンシャルコレクションです。<xref:System.Char?displayProperty=nameWithType> オブジェクトは UTF-16 コード単位に対応します。 <xref:System.String> オブジェクトの値は <xref:System.Char?displayProperty=nameWithType> オブジェクトのシーケンシャルコレクションの内容であり、その値は変更できません (つまり、読み取り専用です)。 文字列の不変性の詳細については、このトピックで後述する「[不変クラスと StringBuilder クラス](#Immutability)」を参照してください。 メモリ内の <xref:System.String> オブジェクトの最大サイズは 2 GB、または約10億文字です。  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 このセクションの内容:  
  
 [文字列オブジェクトのインスタンス](#Instantiation)化   
 [Char オブジェクトと Unicode 文字](#Characters)   
 [文字列と Unicode 標準](#Unicode)   
 [文字列と埋め込まれた null 文字](#EmbeddedNulls)   
 [文字列とインデックス](#Indexes)   
 [Null 文字列と空の文字列](#Nulls)   
 [不変性と StringBuilder クラス](#Immutability)   
 [序数およびカルチャに依存した操作](#CultureSensitive)   
 [正規化](#Normalization)   
 [カテゴリ別の文字列操作](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>String オブジェクトのインスタンス化  
 <xref:System.String> オブジェクトは、次の方法でインスタンス化できます。  
  
-   <xref:System.String> 変数に文字列リテラルを代入する。 これは、文字列を作成するために最もよく使用されるメソッドです。 次の例では、割り当てを使用して複数の文字列を作成します。 でC#は、円記号 (\\) はエスケープ文字なので、文字列内のリテラルの円記号はエスケープする必要があります。また、文字列全体を @-quotedする必要があります。  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   <xref:System.String> クラスコンストラクターを呼び出す。 次の例では、複数のクラスコンストラクターを呼び出すことによって文字列をインスタンス化します。 一部のコンストラクターには、パラメーターとしての文字配列または符号付きバイト配列へのポインターが含まれていることに注意してください。 Visual Basic は、これらのコンストラクターの呼び出しをサポートしていません。 <xref:System.String> コンストラクターの詳細については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   文字列連結演算子 (+ in C#および & または + in Visual Basic) を使用して、<xref:System.String> インスタンスと文字列リテラルの任意の組み合わせから1つの文字列を作成します。 次の例は、文字列連結演算子の使用方法を示しています。  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   プロパティを取得するか、文字列を返すメソッドを呼び出します。 次の例では、<xref:System.String> クラスのメソッドを使用して、より大きな文字列から部分文字列を抽出します。  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   書式指定メソッドを呼び出して、値またはオブジェクトをその文字列形式に変換する。 次の例では、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能を使用して、2つのオブジェクトの文字列形式を文字列に埋め込みます。  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char オブジェクトと Unicode 文字  
 文字列内の各文字は、unicode スカラー値 (Unicode コードポイントまたは unicode 文字の序数 (numeric) 値) によって定義されます。 各コードポイントは UTF-16 エンコーディングを使用してエンコードされ、エンコーディングの各要素の数値は <xref:System.Char> オブジェクトによって表されます。  
  
> [!NOTE]
>  <xref:System.String> インスタンスは UTF-16 コード単位のシーケンシャルコレクションで構成されているため、整形式の Unicode 文字列ではない <xref:System.String> オブジェクトを作成することができます。 たとえば、対応する上位サロゲートを持たない下位サロゲートを持つ文字列を作成できます。 <xref:System.Text> 名前空間のオブジェクトをエンコードおよびデコードするメソッドなどの一部のメソッドでは、文字列が適切な <xref:System.String> 形式であることを確認するために、文字列が適切な形式であることを確認するためのチェックが実行されます。  
  
 1つの <xref:System.Char> オブジェクトは、通常、単一のコードポイントを表します。つまり、<xref:System.Char> の数値はコードポイントと同じになります。 たとえば、文字 "a" のコードポイントは U + 0061 です。 ただし、コードポイントでは、複数のエンコードされた要素 (複数の <xref:System.Char> オブジェクト) が必要になる場合があります。 Unicode 規格では、複数の <xref:System.Char> オブジェクトに対応する2種類の文字が定義されています。 graphemes と、Unicode 補助プレーンの文字に対応する Unicode 補助コードポイントです。  
  
-   書記素は、基本文字とそれに続く1つ以上の組み合わせ文字で表されます。 たとえば、äという文字は、コードポイントが U + 0061 の後に、そのコードポイントが U + 0308 である <xref:System.Char> オブジェクトが続く <xref:System.Char> オブジェクトによって表されます。 この文字は、コードポイントが U + 00E4 の単一の <xref:System.Char> オブジェクトによって定義することもできます。 次の例に示すように、カルチャに依存した等値比較では、これら2つの表現が等しいことを示していますが、通常の序数の比較は同じではありません。 ただし、2つの文字列が正規化されている場合は、序数に基づく比較でも等しいことが示されます。 (文字列の正規化の詳細については、「[正規化](#Normalization)」セクションを参照してください)。  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode 補助コードポイント (サロゲートペア) は、コードポイントが上位サロゲートで、その後にコードポイントが下位サロゲートである <xref:System.Char> オブジェクトによって表される、<xref:System.Char> のオブジェクトによって表されます。 高いサロゲートのコード単位は、U + D800 から U + DBFF までの範囲です。 下限サロゲートのコード単位は、U + DC00 から U + DFFF までの範囲です。 サロゲートペアは、16の Unicode 補助プレーンの文字を表すために使用されます。 次の例では、サロゲート文字を作成し、それを <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> メソッドに渡して、サロゲートペアであるかどうかを判断します。  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>文字列と Unicode 標準  
 文字列内の文字は、<xref:System.Char> 値に対応する UTF-16 でエンコードされたコード単位で表されます。  
  
 文字列内の各文字には、関連付けられている Unicode 文字カテゴリがあります。これは、<xref:System.Globalization.UnicodeCategory> 列挙体によって .NET で表されます。 文字またはサロゲートペアのカテゴリは、<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> メソッドを呼び出すことによって決定できます。  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 また、.NET では、Unicode 標準に基づく文字列比較と並べ替えがサポートされています。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]を通じて .NET Framework のバージョンでは、.NET Framework は文字列データの独自のテーブルを保持します。 これは、Windows 7 で実行されている [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降の .NET Framework のバージョンにも当てはまります。 Windows オペレーティングシステムの Windows 8 以降のバージョンで実行されている [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降では、ランタイムは文字列の比較と並べ替えの操作をオペレーティングシステムに委任します。 .NET Core では、 [Unicode ライブラリの国際化コンポーネント](http://site.icu-project.org/)によって、文字列の比較と並べ替えの情報が提供されます。次の表に、.NET のバージョンと、文字の比較と並べ替えの基準となる Unicode 標準のバージョンを示します。  
  
|.NET のバージョン|Unicode 標準のバージョン|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Unicode 標準、バージョン 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|Windows 7 の [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|Windows 8 以降の windows オペレーティングシステムでの [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降|[Unicode 標準、バージョン 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (すべてのバージョン)|基になるオペレーティング システムでサポートされている Unicode 標準のバージョンによって異なります。|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>文字列と埋め込まれた null 文字  
 .NET では、<xref:System.String> オブジェクトに、文字列の長さの一部としてカウントされる埋め込み null 文字を含めることができます。 ただし、C やC++などの一部の言語では、null 文字は文字列の末尾を示します。文字列の一部とは見なされず、文字列の長さの一部としてカウントされません。 これは、c、プログラマー、またはC++ C++ c で記述されたプログラマやライブラリが、<xref:System.String>オブジェクトに適用した場合には必ずしも有効でないという一般的な仮定を意味します。  
  
-   `strlen` または `wcslen` 関数によって返される値は、必ずしも <xref:System.String.Length%2A?displayProperty=nameWithType>と同じではありません。  
  
-   `strcpy_s` または `wcscpy_s` 関数によって作成された文字列は、必ずしも <xref:System.String.Copy%2A?displayProperty=nameWithType> メソッドによって作成された文字列と同一ではありません。  
  
 <xref:System.String>オブジェクトをインスタンス化するネイティブC++ C とコード、およびプラットフォーム呼び出しによってオブジェクト<xref:System.String>渡されるコードは、埋め込まれた null 文字が文字列の末尾を示すと想定していないことを確認してください。  
  
 文字列の並べ替え (または比較) と文字列の検索時には、文字列の埋め込み null 文字も異なる方法で処理されます。 2つの文字列の間でカルチャに依存した比較を実行する場合、Null 文字は無視されます (インバリアントカルチャを使用した比較を含む)。 序数または大文字と小文字を区別しない序数比較の場合にのみ考慮されます。 一方、<xref:System.String.Contains%2A>、<xref:System.String.StartsWith%2A>、<xref:System.String.IndexOf%2A>などのメソッドを使用して文字列を検索する場合は、埋め込み null 文字が常に考慮されます。  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>文字列とインデックス  
 インデックスは、<xref:System.String>内の <xref:System.Char> オブジェクト (Unicode 文字ではない) の位置です。 インデックスは、0から始まる、負でない数値で、文字列内の最初の位置から始まります。インデックス位置は0です。 <xref:System.String.IndexOf%2A> や <xref:System.String.LastIndexOf%2A>などのいくつかの検索方法では、文字列インスタンス内の文字または部分文字列のインデックスが返されます。  
  
 <xref:System.String.Chars%2A> プロパティを使用すると、文字列内のインデックス位置によって個々の <xref:System.Char> オブジェクトにアクセスできます。 <xref:System.String.Chars%2A> プロパティは既定のプロパティ (Visual Basic) またはインデクサー (でC#は) であるため、次のようなコードを使用して、文字列内の個々の<xref:System.Char>オブジェクトにアクセスできます。 このコードでは、文字列内の空白文字または句読点を検索して、文字列に含まれる単語の数を確認します。  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <xref:System.String> クラスは <xref:System.Collections.IEnumerable> インターフェイスを実装するため、次の例に示すように、`foreach` コンストラクトを使用して文字列内の <xref:System.Char> オブジェクトを反復処理することもできます。  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Unicode 文字は複数の <xref:System.Char> オブジェクトとしてエンコードされる可能性があるため、連続したインデックス値が連続する Unicode 文字に対応しないことがあります。 特に、文字列には、基本文字で構成され、1つ以上の組み合わせ文字またはサロゲートペアによって形成される複数文字のテキスト単位を含めることができます。 <xref:System.Char> オブジェクトではなく Unicode 文字を操作するには、<xref:System.Globalization.StringInfo?displayProperty=nameWithType> クラスと <xref:System.Globalization.TextElementEnumerator> クラスを使用します。 次の例では、Unicode 文字で動作する <xref:System.Char> のオブジェクトとコードの違いについて説明します。 文の各単語の文字数またはテキスト要素を比較します。 文字列には、基本文字の2つのシーケンスの後に結合文字が含まれます。  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 この例では、<xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> メソッドと <xref:System.Globalization.TextElementEnumerator> クラスを使用して、文字列内のすべてのテキスト要素を列挙することで、テキスト要素を操作します。 <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、各テキスト要素の開始インデックスを含む配列を取得することもできます。  
  
 個々の <xref:System.Char> 値ではなく、テキスト単位を使用する方法の詳細については、<xref:System.Globalization.StringInfo> クラスを参照してください。  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Null 文字列と空の文字列  
 宣言されていても値が割り当てられていない文字列は `null`。 その文字列に対してメソッドを呼び出そうとすると、<xref:System.NullReferenceException>がスローされます。 Null 文字列は、値が "" または <xref:System.String.Empty?displayProperty=nameWithType>である文字列である空の文字列とは異なります。 場合によっては、メソッドの呼び出しで引数として null 文字列または空の文字列を渡すと、例外がスローされます。 たとえば、null 文字列を <xref:System.Int32.Parse%2A?displayProperty=nameWithType> メソッドに渡すと、<xref:System.ArgumentNullException>がスローされ、空の文字列を渡すと <xref:System.FormatException>がスローされます。 それ以外の場合、メソッドの引数には、null 文字列または空の文字列を指定できます。 たとえば、クラスの <xref:System.IFormattable> の実装を提供する場合、null 文字列と空の文字列の両方を通常の ("G") 書式指定子と等価にする必要があります。  
  
 <xref:System.String> クラスには、次の2つの便利なメソッドが含まれています。このメソッドを使用すると、文字列が `null` か空かをテストできます。  
  
-   <xref:System.String.IsNullOrEmpty%2A>。文字列が `null` か、<xref:System.String.Empty?displayProperty=nameWithType>かどうかを示します。 このメソッドにより、次のようなコードを使用する必要がなくなります。  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   文字列が `null`か、<xref:System.String.Empty?displayProperty=nameWithType>に等しいか、または空白文字だけで構成されているかを示す <xref:System.String.IsNullOrWhiteSpace%2A>。 このメソッドにより、次のようなコードを使用する必要がなくなります。  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 次の例では、カスタム `Temperature` クラスの <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> の実装で <xref:System.String.IsNullOrEmpty%2A> メソッドを使用します。 メソッドは、"G"、"C"、"F"、"K" の各書式指定文字列をサポートしています。 `null` 値がである空の書式指定文字列または書式指定文字列がメソッドに渡される場合、その値は "G" 書式指定文字列に変更されます。  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>不変性と StringBuilder クラス  
 <xref:System.String> オブジェクトは、作成後にその値を変更できないため、不変 (読み取り専用) と呼ばれます。 <xref:System.String> オブジェクトを変更するために表示されるメソッドは、実際には、変更を含む新しい <xref:System.String> オブジェクトを返します。  
  
 文字列は不変であるため、1つの文字列として表示されるものに対して繰り返しの追加や削除を実行する文字列操作ルーチンでは、パフォーマンスが大幅に低下する可能性があります。 たとえば、次のコードでは、乱数ジェネレーターを使用して、0x0001 ~ 0x052F の範囲で1000文字の文字列を作成します。 コードは、文字列の連結を使用して `str`という名前の既存の文字列に新しい文字を追加するように見えますが、実際には、連結操作ごとに新しい <xref:System.String> オブジェクトを作成します。  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 文字列の値に複数の変更を加える操作には、<xref:System.String> クラスではなく <xref:System.Text.StringBuilder> クラスを使用できます。 <xref:System.String> クラスのインスタンスとは異なり、<xref:System.Text.StringBuilder> オブジェクトは変更可能です。文字列の部分文字列を連結、追加、または削除すると、1つの文字列に対して操作が実行されます。 <xref:System.Text.StringBuilder> オブジェクトの値の変更が完了したら、その <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> メソッドを呼び出して文字列に変換できます。 次の例では、前の例で使用した <xref:System.String> を、<xref:System.Text.StringBuilder> オブジェクトを使用して0x0001 から0x052F までの範囲内のランダムな文字1000を連結しています。  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>序数およびカルチャに依存する操作  
 <xref:System.String> クラスのメンバーは、<xref:System.String> オブジェクトに対して序数またはカルチャに依存した (言語) 操作を実行します。 序数操作は、各 <xref:System.Char> オブジェクトの数値に対して作用します。 カルチャに依存する操作は <xref:System.String> オブジェクトの値に対して動作し、カルチャ固有の大文字と小文字の区別、並べ替え、書式設定、および解析の規則を考慮に入れます。 カルチャに依存する操作は、明示的に宣言されたカルチャまたは暗黙的な現在のカルチャのコンテキストで実行されます。 2種類の操作では、同じ文字列に対して実行すると、まったく異なる結果が生成される可能性があります。  
  
また、.NET では、インバリアントカルチャ (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>) を使用してカルチャを認識しない言語文字列操作をサポートしています。これは、地域に依存しない英語のカルチャ設定に厳密に基づいています。 他の <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 設定とは異なり、インバリアントカルチャの設定は、1台のコンピューター、システム間、および .NET のバージョン間で一貫して維持されることが保証されます。 インバリアントカルチャは、すべてのカルチャでの文字列比較と順序付けの安定性を確保するブラックボックスの一種として認識されます。  
  
> [!IMPORTANT]
>  アプリケーションで、ファイル名や名前付きパイプなどのシンボル識別子、または XML ファイル内のテキストベースのデータなどの永続化されたデータに関するセキュリティ上の決定を行う場合、この操作では、カルチャに依存した比較ではなく序数の比較を使用する必要があります。 これは、カルチャに依存した比較では、有効なカルチャによって異なる結果が生成される可能性があるのに対し、序数の比較は比較対象の文字のバイナリ値のみに依存するためです。  
  
> [!IMPORTANT]
>  文字列操作を実行するほとんどのメソッドには、<xref:System.StringComparison>型のパラメーターを持つオーバーロードが含まれています。これにより、メソッドが序数またはカルチャに依存する操作を実行するかどうかを指定できます。 一般に、メソッド呼び出しの意図を明確にするには、このオーバーロードを呼び出す必要があります。 文字列に対して序数およびカルチャに依存した操作を使用するためのベストプラクティスとガイダンスについては、「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 [大文字と小文字](#casing)の区別、[解析と書式設定](#parsing)、[比較と並べ替え](#comparison)、および[等しいかどう](#equality)かのテストは、序数またはカルチャに依存する操作になります。 以下のセクションでは、操作の各カテゴリについて説明します。  
  
> [!TIP]
>  常にメソッドのオーバーロードを呼び出して、メソッド呼び出しの意図を明確にする必要があります。 たとえば、現在のカルチャの規則を使用して、2つの文字列のカルチャに依存した比較を実行するために <xref:System.String.Compare%28System.String%2CSystem.String%29> メソッドを呼び出すのではなく、`comparisonType` 引数に <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> の値を指定して <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> メソッドを呼び出す必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  

Windows オペレーティング システムの並べ替え操作と比較操作で使用される文字の重みに関する情報を含む一連のテキスト ファイルである[並べ替え重みテーブル](https://www.microsoft.com/download/details.aspx?id=10921) と、Linux と macOS 用の並べ替え重みテーブルである [デフォルト Unicode 照合基本テーブル](https://www.unicode.org/Public/UCA/latest/allkeys.txt)をダウンロードできます。

<a name="casing"></a>   
### <a name="casing"></a>大文字  
 大文字と小文字の規則は、Unicode 文字の大文字と小文字を変更する方法を決定します。たとえば、小文字から大文字に変換します。 多くの場合、文字列比較の前に大文字と小文字の演算が実行されます。 たとえば、文字列を大文字に変換して、別の大文字の文字列と比較できるようにすることができます。 <xref:System.String.ToLower%2A> または <xref:System.String.ToLowerInvariant%2A> メソッドを呼び出して文字列内の文字を小文字に変換することができます。また、<xref:System.String.ToUpper%2A> または <xref:System.String.ToUpperInvariant%2A> メソッドを呼び出すことにより、文字列内の文字を大文字に変換することができます。 また、<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> メソッドを使用して、文字列を大文字に変換することもできます。  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 文字種の操作は、現在のカルチャ、指定されたカルチャ、またはインバリアントカルチャの規則に基づいて行うことができます。 大文字小文字の割り当ては使用されるカルチャによって異なる場合があるため、大文字と小文字の区別の結果はカルチャによって異なる場合があります。 大文字と小文字の違いには、次の3種類があります。  
  
-   ラテン文字の大文字 I (U + 0049)、ラテン小文字 I (U + 0069)、ラテン大文字文字 I (U + 0130)、およびラテン小文字 I (U + 0131) の大文字と小文字の対応付けには違いがあります。 Tr-TR (トルコ語) と az-Latn-AZ (アゼルバイジャン, Latin) カルチャで、tr、az、az-Latn ニュートラルカルチャでは、ラテン大文字の小文字 i はラテン文字の小文字 i で、ラテン小文字 i はという文字になります。上にドットが付いたラテン大文字 I。 インバリアントカルチャを含め、その他のすべてのカルチャでは、ラテン小文字 I とラテン大文字の I は小文字で、大文字に相当します。  
  
     次の例では、カルチャに依存した大文字と小文字の比較に依存している場合に、ファイルシステムへのアクセスを防止するように設計された文字列比較を実行する方法を示します。 (インバリアントカルチャの大文字と小文字の表記規則が使用されている必要があります)。  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   インバリアントカルチャと他のすべてのカルチャとの大文字と小文字のマッピングの違い。 このような場合、インバリアントカルチャの大文字と小文字の規則を使用して文字を大文字または小文字に変更すると、同じ文字が返されます。 他のすべてのカルチャでは、別の文字が返されます。 影響を受ける文字の一部を次の表に示します。  
  
    |文字|がに変更された場合|戻り値|  
    |---------------|-------------------|-------------|  
    |ミクロン記号 (U + 00B5)|大文字|ギリシャ文字ミューミュー (U +-39C)|  
    |上にドットが付いたラテン大文字 I (U + 0130)|小文字|ラテン小文字 I (U + 0069)|  
    |ラテン文字の小文字 I (U + 0131)|大文字|ラテン大文字 I (U + 0049)|  
    |ラテン小文字 (U + 017F)|大文字|ラテン大文字 S (U + 「0053」)|  
    |英小文字 Z がキャロン (U + 01C5) のラテン文字の大文字 D|小文字|ラテン小文字 DZ とキャロン (U + 01C6)|  
    |ギリシャ YPOGEGRAMMENI (U + 0345) の組み合わせ|大文字|ギリシャ文字イオータ (U + 0399)|  
  
-   2文字の大文字と小文字の組み合わせが ASCII 文字の範囲内にある場合の大文字と小文字のマッピングの違い。 ほとんどのカルチャでは、2文字の大文字と小文字の組み合わせは、等価の2文字の大文字または小文字のペアと等しくなります。 これは、次のカルチャにおける次の2文字のペアに対しては当てはまりません。これは、各ケースが digraph と比較されるためです。  
  
    -   hr-HR (クロアチア語) カルチャの "lJ" と "nJ"。  
  
    -   CS-CZ (チェコ語 (チェコ共和国)) および sk-SK (スロバキア語) カルチャの "cH"。  
  
    -   da-DK (デンマーク語 (デンマーク)) カルチャの "aA"。  
  
    -   "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY"、および hu-HU (ハンガリー語 (ハンガリー)) カルチャの "zS"。  
  
    -   ES_tradnl es (スペイン語 (スペイン)、従来の並べ替え)) カルチャの "cH" と "lL"。  
  
    -   vi-VN (ベトナム語) カルチャの "cH"、"gI"、"kH"、"nG" "nH"、"pH"、"qU"、"tH"、および "tR"。  
  
     ただし、これらのペアのカルチャに依存した比較によって問題が発生する状況が発生することは珍しくありません。これらのペアは、固定文字列または識別子では一般的ではありません。  
  
 次の例では、文字列を大文字に変換する場合のカルチャ間の大文字と小文字の違いについて説明します。  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>解析と書式設定  
 書式設定と解析は逆の操作です。 書式設定規則は、日付と時刻、数値などの値を文字列形式に変換する方法を決定します。一方、解析規則は、文字列形式を日付や時刻などの値に変換する方法を決定します。 書式設定規則と解析規則は、どちらもカルチャ規則に依存します。 次の例は、カルチャ固有の日付文字列を解釈するときに発生する可能性のあるあいまいさを示しています。 日付文字列の生成に使用されたカルチャの規則を理解していなければ、03/01/2011、3/1/2011、および01/03/2011 が、2011または3月1日の2011を表しているかどうかを知ることはできません。  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 同様に、次の例に示すように、1つの文字列では、解析操作で規則が使用されているカルチャに応じて異なる日付を生成できます。  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>文字列の比較と並べ替え  
 文字列の比較と並べ替えの規則は、カルチャによって異なります。 たとえば、並べ替え順序は、ふりがなまたは文字の視覚的表現に基づいている場合があります。 東アジア圏の言語では、文字が表意文字の画数と部首によって並べ替えられます。 また、並べ替えは、言語やカルチャで使用されているアルファベットの順序によっても異なります。 たとえば、デンマーク語の文字 "Æ" は、アルファベットでは "Z" の後に位置します。 また、比較では大文字と小文字を区別するか、大文字と小文字を区別しないことがあります。また、場合によっては、大文字と小文字を区別する規則も 一方、序数に基づく比較では、文字列の比較と並べ替えを行うときに、文字列内の個々の文字の Unicode コードポイントを使用します。  
  
 並べ替え規則は、Unicode 文字のアルファベット順と、2つの文字列の比較方法を決定します。 たとえば、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> メソッドは、<xref:System.StringComparison> パラメーターに基づいて2つの文字列を比較します。 パラメーター値が <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>の場合、メソッドは、現在のカルチャの規則を使用する言語的な比較を実行します。パラメーター値が <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>の場合、メソッドは序数による比較を実行します。 したがって、次の例に示すように、現在のカルチャが米国英語の場合、(カルチャに依存した比較を使用して) <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> メソッドへの最初の呼び出しでは "a" より小さい "a" と見なされますが、(序数の比較を使用して) 2 回目の呼び出しを行います。"a" より大きい "a" と見なされます。  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET では、単語、文字列、および序数の並べ替え規則がサポートされています。  
  
-   単語での並べ替えでは、英数字以外の特定の Unicode 文字には特別な重みが割り当てられる、カルチャに依存した文字列の比較が行われます。 たとえば、ハイフン (-) には非常に小さな重みが割り当てられています。そのため、並べ替えられたリスト内で "co-op" と "co-op" が横に並んで表示されることがあります。 Word の並べ替え規則を使用して2つの文字列を比較する <xref:System.String> メソッドの一覧については、「[カテゴリ別の文字列操作](#ByCategory)」セクションを参照してください。  
  
-   文字列の並べ替えでは、カルチャに依存した比較も実行されます。 これは単語の並べ替えに似ていますが、特殊なケースは存在せず、英数字以外のすべての記号はすべての英数字の Unicode 文字の前に記述されます。 文字列の並べ替え規則を使用して2つの文字列を比較するには、<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>の値が指定された `options` パラメーターを持つ <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> メソッドオーバーロードを呼び出します。 これは、文字列の並べ替え規則を使用して2つの文字列を比較するために .NET で提供される唯一の方法です。  
  
-   序数の並べ替えでは、文字列内の各 <xref:System.Char> オブジェクトの数値に基づいて文字列を比較します。 文字の小文字と大文字のバージョンには異なるコードポイントがあるため、序数による比較では大文字と小文字が自動的に区別されます。 ただし、case が重要でない場合は、大文字と小文字を区別しない序数の比較を指定できます。 これは、インバリアントカルチャを使用して文字列を大文字に変換し、その結果に対して序数に基づく比較を実行することと同じです。 序数の並べ替え規則を使用して2つの文字列を比較する <xref:System.String> メソッドの一覧については、「[カテゴリ別の文字列操作](#ByCategory)」セクションを参照してください。  
  
 カルチャに依存した比較とは、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティによって指定されたインバリアントカルチャを含む <xref:System.Globalization.CultureInfo> オブジェクトを明示的または暗黙的に使用する比較のことです。 暗黙のカルチャは、現在のカルチャであり、<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> と <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> のプロパティで指定されます。 アルファベット文字の並べ替え順序にはかなりのばらつきがあります (つまり、<xref:System.Char.IsLetter%2A?displayProperty=nameWithType> プロパティが `true`を返す文字)。 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>などの文字列比較メソッドに <xref:System.Globalization.CultureInfo> オブジェクトを指定することにより、特定のカルチャの規則を使用するカルチャに依存した比較を指定できます。 現在のカルチャの規則を使用するカルチャに依存した比較を指定できます。そのためには、<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>、<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>、または <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> または <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 以外の列挙型 <xref:System.Globalization.CompareOptions> の任意のメンバーを <xref:System.String.Compare%2A> メソッドの適切なオーバーロードに渡します。 通常、カルチャに依存した比較は並べ替えに適していますが、序数による比較は適切ではありません。 序数に基づく比較は、通常、2つの文字列が等しいかどうかを判断する (つまり、id を決定する) 場合に適していますが、カルチャに依存した比較は区別されません。  
  
 次の例は、カルチャに依存した比較と序数による比較の違いを示しています。 この例では、3つの文字列 "Apple"、"Æble"、および "AEble" を評価します。これは、序数に基づく比較と、(それぞれが <xref:System.String.Compare%2A> メソッドが呼び出された時点での既定のカルチャである) da および en-us カルチャの規則です。 デンマーク語では文字 "Æ" が個々の文字として扱われ、アルファベットの "Z" の後に並べ替えられるため、"Æble" という文字列は "Apple" よりも大きくなります。 ただし、"Æble" は "AEble" と同等とは見なされないため、"Æble" は "AEble" よりも大きくなります。 En-us カルチャでは、文字 "Æ" は含まれませんが、"AE" と等価として扱われます。 "Æble" が "Apple" より小さく、"AEble" と等しい理由を説明します。 一方、序数に基づく比較では、"Apple" は "Æble" より小さく、"Æble" は "AEble" よりも大きいと見なされます。  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 次の一般的なガイドラインを使用して、適切な並べ替えまたは文字列の比較方法を選択します。  
  
-   ユーザーのカルチャに基づいて文字列を並べ替えたい場合は、現在のカルチャの規則に基づいて文字列を並べ替える必要があります。 ユーザーのカルチャが変更された場合は、並べ替えられた文字列の順序も変わります。 たとえば、類義語辞典アプリケーションでは、ユーザーのカルチャに基づいて常に単語を並べ替える必要があります。  
  
-   特定のカルチャの規則に基づいて文字列を並べ替えたい場合は、そのカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを比較メソッドに渡すことで、文字列を並べ替える必要があります。 たとえば、特定の言語を学生に教えるように設計されたアプリケーションでは、その言語を話すカルチャのいずれかの規則に基づいて文字列を並べ替える必要があります。  
  
-   カルチャ間で文字列の順序が変更されないようにするには、インバリアントカルチャの規則に基づいて文字列を並べ替えるか、序数に基づく比較を使用する必要があります。 たとえば、序数の並べ替えを使用して、ファイル、プロセス、ミューテックス、または名前付きパイプの名前を整理します。  
  
-   セキュリティの決定 (ユーザー名が有効かどうかなど) に関する比較については、<xref:System.String.Equals%2A> メソッドのオーバーロードを呼び出すことによって、常に序数テストを実行する必要があります。  
  
> [!NOTE]
>  文字列比較で使用されるカルチャに依存した並べ替えと大文字と小文字の区別の規則は、.NET のバージョンによって異なります。 [!INCLUDE[win8](~/includes/win8-md.md)] オペレーティングシステムで実行されている .NET Framework 4.5 以降のバージョンでは、並べ替え、大文字と小文字の区別、正規化、Unicode 文字の情報が Unicode 6.0 標準に準拠しています。 その他の Windows オペレーティングシステムでは、Unicode 5.0 標準に準拠しています。 .NET Core では、基になるオペレーティングシステムでサポートされている Unicode 標準のバージョンによって異なります。 
  
 単語、文字列、および序数の並べ替え規則の詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。 各ルールを使用する場合のその他の推奨事項については、「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 通常、文字列の並べ替え順序を決定するために、<xref:System.String.Compare%2A> などの文字列比較メソッドを呼び出すことはありません。 代わりに、<xref:System.Array.Sort%2A?displayProperty=nameWithType> や <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>などの並べ替えメソッドによって比較メソッドが呼び出されます。 次の例では、文字列比較メソッドを明示的に呼び出すことなく、4つの異なる並べ替え操作 (現在のカルチャを使用した単語の並べ替え、インバリアントカルチャを使用した単語の並べ替え、インバリアントカルチャを使用した単語の並べ替え、インバリアントカルチャを使用した文字列の並べ替え) を実行します。ただし、使用する比較の種類を指定します。 各種類の並べ替えでは、配列内の文字列の一意の順序が生成されることに注意してください。  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  内部的には、.NET は並べ替えキーを使用して、カルチャに依存した文字列の比較をサポートします。 文字列内の各文字には、アルファベット順、大文字と小文字の区別、発音の区別など、さまざまなカテゴリの並べ替えウェイトが指定されます。 <xref:System.Globalization.SortKey> クラスによって表される並べ替えキーは、特定の文字列に対してこれらの重みのリポジトリを提供します。 アプリが同じ文字列セットに対して多数の検索または並べ替え操作を実行する場合、使用するすべての文字列に対して並べ替えキーを生成して格納することで、パフォーマンスを向上させることができます。 並べ替えまたは比較操作が必要な場合は、文字列の代わりに並べ替えキーを使用します。 詳細については、<xref:System.Globalization.SortKey> クラスを参照してください。  
  
 文字列比較規則を指定しない場合、<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> などの並べ替えメソッドは、カルチャに依存し、大文字と小文字を区別する文字列の並べ替えを実行します。 次の例は、現在のカルチャを変更することによって、配列内の並べ替えられた文字列の順序に影響を与える方法を示しています。 この例では、3つの文字列の配列を作成します。 最初に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを en-US に設定し、<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> メソッドを呼び出します。 これよって、英語 (米国) カルチャの並べ替え規則に基づく並べ替え順序が適用されます。 次に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを da-DK に設定し、再度 <xref:System.Array.Sort%2A?displayProperty=nameWithType> メソッドを呼び出します。 適用される並べ替え順序が en-US の並べ替え順序と異なる点に注意してください。これは、デンマーク語 (デンマーク) の並べ替え規則が使用されるためです。  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  文字列を比較する主な目的が等しいかどうかを判断するには、<xref:System.String.Equals%2A?displayProperty=nameWithType> メソッドを呼び出す必要があります。 通常、序数の比較を実行するには <xref:System.String.Equals%2A> を使用する必要があります。 <xref:System.String.Compare%2A?displayProperty=nameWithType> メソッドは、主に文字列の並べ替えを目的としています。  
  
 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> や <xref:System.String.IndexOf%2A?displayProperty=nameWithType>などの文字列検索メソッドでは、カルチャに依存した文字列の比較も実行できます。 次の例は、<xref:System.String.IndexOf%2A> メソッドを使用した、序数とカルチャに依存した比較の違いを示しています。 現在のカルチャが英語 (米国) であるカルチャに依存した検索では、部分文字列 "oe" が合字 "する。" と一致すると見なされます。 ソフトハイフン (U + 00AD) はゼロ幅の文字であるため、検索ではソフトハイフンが <xref:System.String.Empty?displayProperty=nameWithtype> と同等と見なされ、文字列の先頭で一致が検出されます。 一方、序数検索では、どちらの場合も一致が見つかりません。  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>文字列の検索  
 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> や <xref:System.String.IndexOf%2A?displayProperty=nameWithType>などの文字列検索メソッドでは、カルチャに依存した文字列比較や序数の文字列比較を実行して、指定した文字列に文字または部分文字列が見つかったかどうかを判断することもできます。  
  
 <xref:System.String.IndexOf%2A> メソッドなどの個々の文字を検索する <xref:System.String> クラスの検索メソッド、または <xref:System.String.IndexOfAny%2A> メソッドなどの文字セットのいずれかで、すべて序数検索が実行されます。 文字に対してカルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> や <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>などの <xref:System.Globalization.CompareInfo> メソッドを呼び出す必要があります。 序数とカルチャに依存した比較を使用して文字を検索した結果は、大きく異なることに注意してください。 たとえば、カルチャによっては、カルチャに応じて、"AE" (U + 041U + 0045) のように、構成済みの Unicode 文字 ("AE" (U + 041U +) など) を検索する場合は、カルチャによって異なります。 次の例は、個々の文字を検索するときの <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> と <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> メソッドの違いを示しています。 文字列 "æ" (U + 00E6) は、en-us カルチャの規則を使用する場合は文字列 "航空写真" にありますが、-DK カルチャの規則を使用する場合や序数の比較を実行する場合には見つかりません。  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 一方、検索オプションが <xref:System.StringComparison>型のパラメーターによって明示的に指定されていない場合、文字ではなく文字列を検索するクラスメソッド <xref:System.String>、カルチャに依存した検索を実行します。 唯一の例外は、序数検索を実行する <xref:System.String.Contains%2A>です。  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>等しいかどうかのテスト  
 並べ替え順序において2つの文字列の関係を確認するには、<xref:System.String.Compare%2A?displayProperty=nameWithType> メソッドを使用します。 通常、これはカルチャに依存する操作です。 これに対して、<xref:System.String.Equals%2A?displayProperty=nameWithType> メソッドを呼び出して、等しいかどうかをテストします。 通常、等しいかどうかのテストでは、ユーザー入力と、有効なユーザー名、パスワード、またはファイルシステムパスなどの既知の文字列を比較します。これは通常、序数操作です。  
  
> [!WARNING]
>  <xref:System.String.Compare%2A?displayProperty=nameWithType> メソッドを呼び出し、戻り値が0かどうかを判断することで、等しいかどうかをテストできます。 ただし、この方法は推奨されません。 2つの文字列が等しいかどうかを判断するには、<xref:System.String.Equals%2A?displayProperty=nameWithType> メソッドのオーバーロードのいずれかを呼び出す必要があります。 どちらのメソッドにも、比較の種類を明示的に指定する <xref:System.StringComparison?displayProperty=nameWithType> のパラメーターが含まれているので、呼び出すのに適したオーバーロードは、インスタンス <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> メソッドまたは静的 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> メソッドのいずれかです。  
  
 次の例は、序数を使用する必要がある場合に、カルチャに依存した比較を実行する危険性を示しています。 この場合、コードの目的は、"FILE://" という文字列の URL の先頭を大文字小文字を区別しない比較を実行することで、"FILE://" または "file://" で始まる Url からのファイルシステムアクセスを禁止することです。 ただし、カルチャに依存した比較が、"file://" で始まる URL でトルコ語 (トルコ) カルチャを使用して実行された場合、等値比較は失敗します。これは、小文字の "i" が "i" ではなく "i" であるためです。 その結果、ファイルシステムへのアクセスが誤って許可されます。 一方、序数に基づく比較を実行すると、等値比較が成功し、ファイルシステムアクセスが拒否されます。  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>正規化  
 Unicode 文字には複数の表現があります。 たとえば、次のコードポイントは、"ắ" という文字を表すことができます。  
  
-   U+1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 1つの文字に対して複数の表現を使用すると、検索、並べ替え、照合、およびその他の文字列操作が複雑になります。  
  
 Unicode 規格では、同等のバイナリ表現に対して Unicode 文字の1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化では、さまざまなルールに従って、正規化形式と呼ばれる複数のアルゴリズムを使用できます。 .NET では、Unicode 正規形 C、D、KC、および KD がサポートされています。 文字列が同じ正規化形式に正規化されている場合は、序数による比較を使用して比較できます。  
  
 序数による比較は、各文字列の対応する <xref:System.Char> オブジェクトの Unicode スカラー値のバイナリ比較です。 <xref:System.String> クラスには、次のような序数による比較を実行できるさまざまなメソッドが含まれています。  
  
-   <xref:System.String.Compare%2A>、<xref:System.String.Equals%2A>、<xref:System.String.StartsWith%2A>、<xref:System.String.EndsWith%2A>、<xref:System.String.IndexOf%2A>、および <xref:System.String.LastIndexOf%2A> パラメーターを含むメソッドのオーバーロード。<xref:System.StringComparison> このパラメーターに <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> または <xref:System.StringComparison.OrdinalIgnoreCase> の値を指定すると、メソッドによって序数の比較が実行されます。  
  
-   <xref:System.String.CompareOrdinal%2A> メソッドのオーバーロード。  
  
-   <xref:System.String.Contains%2A>、<xref:System.String.Replace%2A>、<xref:System.String.Split%2A>など、既定で序数による比較を使用するメソッド。  
  
-   <xref:System.Char> 値、または文字列インスタンス内の <xref:System.Char> 配列内の要素を検索するメソッド。 このようなメソッドには、<xref:System.String.IndexOf%28System.Char%29> や <xref:System.String.Split%28System.Char%5B%5D%29>などがあります。  
  
 <xref:System.String.IsNormalized?displayProperty=nameWithType> メソッドを呼び出すことによって文字列が正規形 C に正規化されるかどうかを判断できます。また、<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> メソッドを呼び出して、文字列が指定した正規化形式に正規化されているかどうかを判断することもできます。 また、<xref:System.String.Normalize?displayProperty=nameWithType> メソッドを呼び出して文字列を正規形 C に変換することもできます。また、<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> メソッドを呼び出して、文字列を指定した正規化形式に変換することもできます。 文字列の正規化と比較の詳細な手順については、「<xref:System.String.Normalize> メソッドと <xref:System.String.Normalize%28System.Text.NormalizationForm%29> メソッド」を参照してください。  
  
 次の簡単な例は、文字列の正規化を示しています。 この例では、3つの異なる文字列の3つの異なる方法で文字 "ố" を定義し、等値比較を使用して、各文字列が他の2つの文字列と異なることを判断します。 次に、各文字列をサポートされている正規化形式に変換し、指定された正規化形式で各文字列の序数による比較を実行します。 どちらの場合も、2番目の等しいテストでは、文字列が等しいことが示されます。  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 正規化および正規化形式の詳細については、「<xref:System.Text.NormalizationForm?displayProperty=nameWithType>」および「 [Unicode 標準の使用方法 #15: unicode の正規化形式](https://unicode.org/reports/tr15/)」および unicode.org web サイトの正規化に関する[FAQ](https://www.unicode.org/faq/normalization.html)を参照してください。  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>カテゴリ別の文字列操作  
 <xref:System.String> クラスは、文字列の比較、文字列の等価性のテスト、文字列内の文字または部分文字列の検索、文字列の変更、文字列の文字列の抽出、文字列の結合、値の書式設定、文字列のコピーなどを行うためのメンバーを提供します。文字列を正規化する。  
  
### <a name="comparing-strings"></a>文字列の比較  
 次の <xref:System.String> メソッドを使用して、文字列を比較して並べ替え順序での相対位置を決定することができます。  
  
-   <xref:System.String.Compare%2A> は、並べ替え順序における1つの文字列と2番目の文字列の関係を示す整数を返します。  
  
-   <xref:System.String.CompareOrdinal%2A> は、コードポイントの比較に基づいて、1つの文字列と2番目の文字列との関係を示す整数を返します。  
  
-   <xref:System.String.CompareTo%2A> は、並べ替え順序における現在の文字列インスタンスと2番目の文字列との関係を示す整数を返します。 <xref:System.String.CompareTo%28System.String%29> メソッドは、<xref:System.String> クラスの <xref:System.IComparable> と <xref:System.IComparable%601> の実装を提供します。  
  
### <a name="testing-strings-for-equality"></a>文字列の等価性をテストする  
 2つの文字列が等しいかどうかを判断するには、<xref:System.String.Equals%2A> メソッドを呼び出します。 インスタンス <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> と静的な <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> オーバーロードを使用すると、比較がカルチャに依存するか序数であるか、また、大文字と小文字を区別するか無視するかを指定できます。 等しいかどうかのテストは序数で、システムリソースへのアクセスを決定する等価比較 (ファイルシステムオブジェクトなど) は常に序数である必要があります。  
  
### <a name="finding-characters-in-a-string"></a>文字列内の文字の検索  
 <xref:System.String> クラスには、次の2種類の検索メソッドが含まれています。  
  
-   特定の部分文字列が文字列インスタンス内に存在するかどうかを示す <xref:System.Boolean> 値を返すメソッド。 これには、<xref:System.String.Contains%2A>、<xref:System.String.EndsWith%2A>、および <xref:System.String.StartsWith%2A> メソッドが含まれます。  
  
-   文字列インスタンス内の部分文字列の開始位置を示すメソッド。 これには、<xref:System.String.IndexOf%2A>、<xref:System.String.IndexOfAny%2A>、<xref:System.String.LastIndexOf%2A>、および <xref:System.String.LastIndexOfAny%2A> の各メソッドが含まれます。  
  
> [!WARNING]
>  特定の部分文字列ではなく特定のパターンの文字列を検索する場合は、正規表現を使用する必要があります。 詳細については、「 [.net の正規表現](~/docs/standard/base-types/regular-expressions.md)」を参照してください。  
  
### <a name="modifying-a-string"></a>文字列の変更  
 <xref:System.String> クラスには、文字列の値を変更するために表示される次のメソッドが含まれています。  
  
-   <xref:System.String.Insert%2A> は、現在の <xref:System.String> インスタンスに文字列を挿入します。  
  
-   <xref:System.String.PadLeft%2A> は、文字列の先頭に指定された文字を1回以上挿入します。  
  
-   <xref:System.String.PadRight%2A> は、文字列の末尾に指定された文字を1回以上挿入します。  
  
-   <xref:System.String.Remove%2A> は、現在の <xref:System.String> インスタンスから部分文字列を削除します。  
  
-   <xref:System.String.Replace%2A> は、現在の <xref:System.String> インスタンス内の部分文字列を別の部分文字列に置き換えます。  
  
-   <xref:System.String.ToLower%2A> と <xref:System.String.ToLowerInvariant%2A> 文字列内のすべての文字を小文字に変換します。  
  
-   <xref:System.String.ToUpper%2A> と <xref:System.String.ToUpperInvariant%2A> 文字列内のすべての文字を大文字に変換します。  
  
-   文字列の先頭と末尾からすべての文字を削除 <xref:System.String.Trim%2A> ます。  
  
-   文字列の末尾から文字のすべての出現箇所を削除 <xref:System.String.TrimEnd%2A> ます。  
  
-   文字列の先頭からすべての文字を削除 <xref:System.String.TrimStart%2A> ます。  
  
> [!IMPORTANT]
>  すべての文字列変更メソッドは、新しい <xref:System.String> オブジェクトを返します。 現在のインスタンスの値は変更されません。  
  
### <a name="extracting-substrings-from-a-string"></a>文字列からの部分文字列の抽出  
 <xref:System.String.Split%2A?displayProperty=nameWithType> メソッドは、1つの文字列を複数の文字列に分割します。 メソッドのオーバーロードを使用すると、複数の区切り記号を指定して、メソッドによって抽出される部分文字列の最大数を決定し、空の文字列 (区切り記号が隣接している場合に発生する) が返される文字列に含まれるかどうかを判断できます。  
  
### <a name="combining-strings"></a>結合 (文字列を)  
 文字列の連結には、次の <xref:System.String> メソッドを使用できます。  
  
-   <xref:System.String.Concat%2A> は、1つ以上の部分文字列を1つの文字列に結合します。  
  
-   <xref:System.String.Join%2A> 1 つ以上の部分文字列を1つの要素に連結し、各部分文字列の間に区切り記号を追加します。  
  
### <a name="formatting-values"></a>値の書式設定  
 <xref:System.String.Format%2A?displayProperty=nameWithType> メソッドは、複合書式指定機能を使用して、文字列内の1つ以上のプレースホルダーを、何らかのオブジェクトまたは値の文字列形式に置き換えます。 <xref:System.String.Format%2A> メソッドは、多くの場合、次の操作を実行するために使用されます。  
  
-   数値の文字列形式を文字列に埋め込む場合は。  
  
-   日付と時刻の値の文字列形式を文字列に埋め込む場合は。  
  
-   列挙値の文字列形式を文字列に埋め込む場合は。  
  
-   <xref:System.IFormattable> インターフェイスをサポートするオブジェクトの文字列形式を文字列に埋め込む場合は。  
  
-   より大きな文字列内のフィールド内の部分文字列を右揃えまたは左揃えにする場合は。  
  
 書式設定操作と例の詳細については、「<xref:System.String.Format%2A> のオーバーロードの概要」を参照してください。  
  
### <a name="copying-a-string"></a>文字列のコピー  
 文字列のコピーを作成するには、次の <xref:System.String> メソッドを呼び出すことができます。  
  
-   <xref:System.String.Clone%2A> は、既存の <xref:System.String> オブジェクトへの参照を返します。  
  
-   <xref:System.String.Copy%2A> 既存の文字列のコピーを作成します。  
  
-   <xref:System.String.CopyTo%2A> 文字列の一部を文字配列にコピーします。  
  
### <a name="normalizing-a-string"></a>文字列の正規化  
 Unicode では、1つの文字に複数のコードポイントを含めることができます。 正規化では、これらの同等の文字が同じバイナリ表現に変換されます。 <xref:System.String.Normalize%2A?displayProperty=nameWithType> メソッドは正規化を実行し、<xref:System.String.IsNormalized%2A?displayProperty=nameWithType> メソッドは文字列が正規化されているかどうかを判断します。  
  
 詳細と例については、このトピックで前述した「[正規化](#Normalization)」セクションを参照してください。  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921">Windows オペレーティングシステムの重みテーブルの並べ替え</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Linux および macOS 用の既定の Unicode 照合順序要素の表</related>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework で文字列を使用するためのベスト プラクティス</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このセクションの内容:  
  
 [オーバーロード](#Syntax)されたコンストラクターの構文   
 [パラメーター](#Params)   
 [例外](#Exceptions)   
 [どの方法を呼び出すか。](#Tasks)   
 [文字列の作成](#Creating_Strings)   
 [反復する文字列の処理](#Repetitive)   
 文字列のインスタンス化の例を次に示します。   
 [文字列割り当ての使用](#Ctor1_Example)  
 [文字配列の使用](#Ctor2_Example)  
 [文字配列の一部を使用して1つの文字を繰り返す](#Ctor3_Example)  
 [文字配列へのポインターの使用](#Ctor4_Example)  
 [ポインターと配列の範囲の使用](#Ctor5_Example)  
 [符号付きバイト配列へのポインターの使用](#Ctor6_Example)  
[バージョン情報](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>オーバーロードされたコンストラクターの構文  
 文字列コンストラクターは、ポインターパラメーターを持たない2つのカテゴリと、ポインターパラメーターを持つ2つのカテゴリに分類されます。 ポインターを使用するコンストラクターは CLS に準拠していません。 また、Visual Basic はポインターの使用をサポートしC#ていません。また、ポインターを使用して unsafe コンテキストで実行するコードが必要です。 詳しくは、「[unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)」をご覧ください。  
  
 オーバーロードの選択に関するその他のガイダンスについては、「[呼び出すメソッド](#Tasks)」を参照してください。  
  
 `String(Char[] value)`  
 Unicode 文字の配列によって示される値に新しいインスタンスを初期化します。 このコンストラクターは、Unicode 文字 ([例](#Ctor2_Example)) をコピーします。  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 新しいインスタンスを、Unicode 文字の配列、配列内の開始文字位置、および長さ ([例](#Ctor3_Example)) で示される値に初期化します。  
  
 `String(Char c, Int32 count)`  
 指定した回数 ([例](#Ctor3_Example)) を繰り返して、指定した Unicode 文字で示される値に新しいインスタンスを初期化します。  
  
 `String(char* value)`  
 **(CLS に準拠していません)** Null 文字 (U + 0000 または ' \ 0 ') で終わる Unicode 文字の配列を指すポインターによって示される値に新しいインスタンスを初期化します。 ([例](#Ctor4_Example))。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>には、直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(CLS に準拠していません)** Unicode 文字の配列へのポインター、配列内の開始文字位置、および長さによって示される値に、新しいインスタンスを初期化します。 コンストラクターは、インデックス `startIndex` で始まる `value` の Unicode 文字をコピーし、`startIndex` + `length`-1 ([例](#Ctor5_Example)) で終わります。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>には、直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(SByte* value)`  
 **(CLS に準拠していません)** 新しいインスタンスを、8ビット符号付き整数の配列へのポインターによって示される値に初期化します。 配列は、現在のシステムコードページ (<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>によって指定されたエンコーディング) を使用してエンコードされた文字列を表すと見なされます。 コンストラクターは、null 文字 (0x00) に到達するまでポインターによって指定された位置から始まる `value` の文字を処理します ([例](#Ctor6_Example))。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>には、直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(CLS に準拠していません)** 新しいインスタンスを、8ビット符号付き整数の配列へのポインター、配列内の開始位置、および長さによって示される値に初期化します。  配列は、現在のシステムコードページ (<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>によって指定されたエンコーディング) を使用してエンコードされた文字列を表すと見なされます。 コンストラクターは `startIndex` から始まる値の文字を処理し、`startIndex` + `length`-1 ([例](#Ctor6_Example)) で終わります。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>には、直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(CLS に準拠していません)** 新しいインスタンスを初期化し、8ビット符号付き整数の配列へのポインター、配列内の開始位置、長さ、および <xref:System.Text.Encoding> オブジェクトによって示される値に初期化します。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>には、直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
<a name="Params"></a>   
## <a name="parameters"></a>パラメーター  
 ポインターパラメーターを含まない <xref:System.String> コンストラクターによって使用されるパラメーターの完全な一覧を次に示します。 各オーバーロードによって使用されるパラメーターについては、上記のオーバーロード構文を参照してください。  
  
|パラメーター|型|説明|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Unicode 文字の配列。|  
|`c`|<xref:System.Char>|Unicode 文字。|  
|`startIndex`|<xref:System.Int32>|新しい文字列の最初の文字の `value` の開始位置。<br /><br /> 既定値: 0|  
|`length`|<xref:System.Int32>|新しい文字列に含める `value` 内の文字数。<br /><br /> 既定値: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|新しい文字列で `c` 文字が繰り返される回数。 `count` が0の場合、新しいオブジェクトの値は <xref:System.String.Empty?displayProperty=nameWithType>ます。|  
  
 ポインターパラメーターを含む <xref:System.String> コンストラクターによって使用されるパラメーターの完全な一覧を次に示します。 各オーバーロードによって使用されるパラメーターについては、上記のオーバーロード構文を参照してください。  
  
|パラメーター|型|説明|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - または -<br /><br /> <xref:System.SByte>\*|Null で終わる Unicode 文字配列または8ビット符号付き整数の配列へのポインター。 `value` が `null` または空の配列の場合、新しい文字列の値は <xref:System.String.Empty?displayProperty=nameWithType>ます。|  
|`startIndex`|<xref:System.Int32>|新しい文字列の最初の文字を定義する配列要素のインデックス。<br /><br /> 既定値: 0|  
|`length`|<xref:System.Int32>|新しい文字列を作成するために使用する配列要素の数。 Length が0の場合、コンストラクターは値が <xref:System.String.Empty?displayProperty=nameWithType>文字列を作成します。<br /><br /> 既定値: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|`value` 配列のエンコード方法を指定するオブジェクト。<br /><br /> 既定値: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>、またはシステムの現在の ANSI コードページ|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>例外  
 ポインターパラメーターを含まないコンストラクターによってスローされる例外の一覧を次に示します。  
  
|例外|条件|スロー者|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` が `null` です。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`、`length`、または `count` が0未満です。<br /><br /> - または -<br /><br /> `startIndex` と `length` の合計が、`value` にある要素の数を超えています。<br /><br /> - または -<br /><br /> `count` が 0 未満です。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 ポインターパラメーターを含むコンストラクターによってスローされる例外の一覧を次に示します。  
  
|例外|条件|スロー者|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` 無効な Unicode 文字を含む配列を指定しています。<br /><br /> - または -<br /><br /> `value` または `value` + `startIndex` が64K 未満のアドレスを指定しています。<br /><br /> - または -<br /><br /> 新しい <xref:System.String> インスタンスを `value` バイト配列から初期化できませんでした。 `value` では既定のコードページエンコーディングが使用されていません。|ポインターを持つすべてのコンストラクター。|  
|<xref:System.ArgumentNullException>|`value` が null です。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。<br /><br /> - または -<br /><br /> `startIndex` または `length` が 0 未満であるか、`value` + `startIndex` によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。<br /><br /> - または -<br /><br /> 新しい文字列の長さが大きすぎて割り当てられません。|ポインターを持つすべてのコンストラクター。|  
|<xref:System.AccessViolationException>|`value`、または `value` + `startIndex` + -1 は無効なアドレスを指定します。`length`|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>どの方法を呼び出すか。  
  
|終了|呼び出しまたは使用|  
|--------|-----------------|  
|文字列を作成します。|文字列リテラルまたは既存の文字列からの割り当て ([例](#Ctor1_Example))|  
|文字配列全体から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([例](#Ctor2_Example))|  
|文字配列の一部から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([例](#Ctor3_Example))|  
|同じ文字を複数回繰り返す文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([例](#Ctor3_Example))|  
|Unicode またはワイド文字配列へのポインターから文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|ポインターを使用して、Unicode またはワイド文字配列の一部から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|C++`char`配列から文字列を作成します。|<xref:System.String.%23ctor%28System.SByte%2A%29>、 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - または -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|ASCII 文字から文字列を作成します。|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>作成 (文字列を)  
 プログラムによって文字列を作成するために最もよく使用される手法は、[この例](#Ctor1_Example)に示すように単純な代入です。 <xref:System.String> クラスには、次の値から文字列を作成できる4種類のコンストラクターオーバーロードも含まれています。  
  
-   文字配列から (UTF-16 でエンコードされた文字の配列)。 配列全体またはその一部の文字から新しい <xref:System.String> オブジェクトを作成できます。 <xref:System.String.%23ctor%28System.Char%5B%5D%29> コンストラクターは、配列内のすべての文字を新しい文字列にコピーします。 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> コンストラクターは、インデックス `startIndex` の文字をインデックス `startIndex` + `length`-1 から新しい文字列にコピーします。 `length` が0の場合、新しい文字列の値は <xref:System.String.Empty?displayProperty=nameWithType>ます。  
  
     同じ値を持つ文字列をコードで繰り返しインスタンス化する場合は、文字列を作成する別の方法を使用して、アプリケーションのパフォーマンスを向上させることができます。 詳細については、「[反復する文字列の処理](#Repetitive)」を参照してください。  
  
-   <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> コンストラクターを使用して、0回、1回、またはそれ以上に複製された単一の文字から。 `count` が0の場合、新しい文字列の値は <xref:System.String.Empty?displayProperty=nameWithType>ます。  
  
-   <xref:System.String.%23ctor%28System.Char%2A%29> または <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> コンストラクターを使用して、null で終わる文字配列へのポインターから。 文字列を初期化するために、配列全体または指定された範囲を使用できます。 コンストラクターは、指定されたポインターまたは指定されたポインターから始まる Unicode 文字のシーケンスをコピーし、`startIndex` の配列の末尾または `length` 文字をコピーします。 `value` が null ポインターの場合、または `length` が0の場合、コンストラクターは <xref:System.String.Empty?displayProperty=nameWithType>値を持つ文字列を作成します。 コピー操作が配列の末尾に進み、配列が null で終了していない場合、コンストラクターの動作はシステムに依存します。 このような状況では、アクセス違反が発生する可能性があります。  
  
     配列に埋め込まれた null 文字 (U + 0000 または ' \ 0 ') が含まれていて、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> オーバーロードが呼び出された場合、文字列インスタンスには、埋め込み null を含む `length` 文字が含まれます。 次の例では、2つの null 文字を含む10個の要素の配列へのポインターが <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> メソッドに渡されるとどうなるかを示します。 アドレスが配列の先頭で、配列内のすべての要素が文字列に追加されるため、コンストラクターは、2つの埋め込み null を含む10文字の文字列をインスタンス化します。 一方、同じ配列が <xref:System.String.%23ctor%28System.Char%2A%29> コンストラクターに渡された場合、結果は、最初の null 文字を含まない4文字の文字列になります。  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     配列には Unicode 文字を含める必要があります。 でC++は、これは、文字配列をマネージ <xref:System.Char>[] 型またはアンマネージ`wchar_t`[] 型として定義する必要があることを意味します。  
  
     <xref:System.String.%23ctor%28System.Char%2A%29> のオーバーロードが呼び出され、配列が null で終了していない場合、または <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> のオーバーロードが呼び出され、`startIndex``length` + の場合は、文字のシーケンスに割り当てられたメモリの外側の範囲が含まれます。では、コンストラクターの動作はシステムに依存し、アクセス違反が発生する可能性があります。 また、Intel Itanium プロセッサでは、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> コンストラクターの呼び出しによって <xref:System.DataMisalignedException> 例外がスローされる場合があります。 このエラーが発生した場合は、代わりに <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> を呼び出してください。  
  
-   符号付きバイト配列へのポインターから。 文字列を初期化するために、配列全体または指定された範囲を使用できます。 バイトシーケンスは、既定のコードページエンコーディングを使用して解釈できます。また、コンストラクター呼び出しでエンコーディングを指定することもできます。 コンストラクターが、null で終わることのない配列全体からの文字列のインスタンス化を試行した場合、または `value` + の配列の範囲が `value` + `startIndex`に`startIndex` 場合、 + -1 はメモリの外にあります。配列に割り当てられます。このコンストラクターの動作はシステムに依存し、アクセス違反が発生する可能性があります。`length`  
  
     次の例に示すように、パラメーターとして符号付きバイト配列を含むC++ 3 つのコンストラクターは、主に `char` 配列を文字列に変換するように設計されています。  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     配列に null 文字 (' \ 0 ')、または値が0で <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> オーバーロードが呼び出されるバイトが含まれている場合、文字列インスタンスには、埋め込み null を含む `length` 文字が含まれます。 次の例では、2つの null 文字を含む10個の要素の配列へのポインターが <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> メソッドに渡されるとどうなるかを示します。 アドレスが配列の先頭で、配列内のすべての要素が文字列に追加されるため、コンストラクターは、2つの埋め込み null を含む10文字の文字列をインスタンス化します。 一方、同じ配列が <xref:System.String.%23ctor%28System.SByte%2A%29> コンストラクターに渡された場合、結果は、最初の null 文字を含まない4文字の文字列になります。  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <xref:System.String.%23ctor%28System.SByte%2A%29> コンストラクターと <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> コンストラクターは、既定の ANSI コードページを使用して `value` を解釈するため、同じバイト配列を持つこれらのコンストラクターを呼び出すと、異なるシステムで異なる値を持つ文字列が作成される可能性があります。  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>反復する文字列の処理  
 テキストストリームを解析またはデコードするアプリでは、多くの場合、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> コンストラクターまたは <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを使用して、文字のシーケンスを文字列に変換します。 1つの文字列を作成して再利用する代わりに、同じ値を使用して新しい文字列を繰り返し作成すると、メモリが浪費されます。 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> コンストラクターを呼び出すことによって同じ文字列値を繰り返し作成する可能性が高い場合は、その同じ文字列値を事前に把握していなくても、参照テーブルを使用できます。  
  
 たとえば、XML タグと属性を含むファイルから文字のストリームを読み取って解析したとします。 ストリームを解析すると、特定のトークン (つまり、シンボルの意味を持つ文字のシーケンス) が繰り返し発生します。 文字列 "0"、"1"、"true"、および "false" に相当するトークンは、XML ストリームで頻繁に発生する可能性があります。  
  
 各トークンを新しい文字列に変換するのではなく、一般的に発生する文字列を保持する <xref:System.Xml.NameTable?displayProperty=nameWithType> オブジェクトを作成できます。 <xref:System.Xml.NameTable> オブジェクトを使用すると、一時メモリを割り当てずに格納されている文字列を取得するため、パフォーマンスが向上します。 トークンが検出されたら、<xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを使用してテーブルからトークンを取得します。 トークンが存在する場合、メソッドは対応する文字列を返します。 トークンが存在しない場合は、<xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを使用して、トークンをテーブルに挿入し、対応する文字列を取得します。  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>例 1: 文字列割り当てを使用する  
 次の例では、文字列リテラルを割り当てることによって新しい文字列を作成します。 最初の文字列の値を割り当てることによって、2番目の文字列を作成します。 これらは、新しい <xref:System.String> オブジェクトをインスタンス化する最も一般的な2つの方法です。  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>例 2: 文字配列の使用  
 次の例は、文字配列から新しい <xref:System.String> オブジェクトを作成する方法を示しています。  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>例 3: 文字配列の一部を使用し、1つの文字を繰り返す  
 次の例では、文字配列の一部から新しい <xref:System.String> オブジェクトを作成する方法と、1つの文字の複数回の出現を含む新しい <xref:System.String> オブジェクトを作成する方法を示します。  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>例 4: 文字配列へのポインターの使用  
 次の例は、文字の配列へのポインターから新しい <xref:System.String> オブジェクトを作成する方法を示しています。 このC#例は、`/unsafe` コンパイラスイッチを使用してコンパイルする必要があります。  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>例 5: ポインターと配列の範囲からの文字列のインスタンス化  
 次の例では、ピリオドまたは感嘆符のいずれかの文字配列の要素を調べます。 見つかった場合は、区切り記号の前にある配列内の文字から文字列をインスタンス化します。 そうでない場合は、配列の内容全体を含む文字列がインスタンス化されます。 このC#例は、`/unsafe` コンパイラスイッチを使用してコンパイルする必要があります。  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>例 6: 符号付きバイト配列へのポインターから文字列をインスタンス化する  
 次の例は、<xref:System.String.%23ctor%28System.SByte%2A%29> コンストラクターを使用して <xref:System.String> クラスのインスタンスを作成する方法を示しています。  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>[バージョン情報]  
 .NET Framework  
 すべてのオーバーロードは、4.5、4、3.5、3.0、2.0、1.1、1.0 でサポートされています。  
  
 .NET Framework Client Profile  
 すべてのオーバーロードは、4、3.5 SP1 でサポートされています。  
  
 ポータブル クラス ライブラリ  
 <xref:System.SByte>`*` パラメーターのないすべてのオーバーロードがサポートされています  
  
 Windows ストア アプリ用 .NET  
 <xref:System.SByte>`*` パラメーターのないすべてのオーバーロードは、Windows 8 でサポートされています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の null で終わる配列へのポインター。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した Unicode 文字配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が正しくない Unicode 文字を含む配列を指定しているか、<paramref name="value" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを、指定した文字配列で示された Unicode 文字に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の読み取り専用スパン。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを、指定した読み取り専用スパンで示された Unicode 文字に初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">終端が null の 8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング (つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング) を使用して解釈されます。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.String" /> の新しいインスタンス を、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が ANSI でエンコードされていると想定しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> の Null 終端文字によって決定される初期化する新しい文字列の長さが、大きすぎて割り当てられません。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> に指定されたアドレスが正しくありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Unicode 文字。</param>
        <param name="count"><paramref name="c" /> の発生回数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した回数だけ繰り返した指定の Unicode 文字が示す値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列を指すポインター。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列を指す指定のポインター、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満であるか、<paramref name="value" /> + <paramref name="startIndex" /> によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が正しくない Unicode 文字を含む配列を指定しているか、<paramref name="value" /> + <paramref name="startIndex" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
<paramref name="startIndex" /> と <paramref name="length" /> の合計が、<paramref name="value" /> にある要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング (つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング) を使用して解釈されます。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
<paramref name="value" /> + <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
- または - 
初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> + <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
- または - 
<see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした (<paramref name="value" /> が ANSI でエンコードされていると想定)。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <param name="enc"><paramref name="value" /> が参照する配列のエンコード方法を指定するオブジェクト。 <paramref name="enc" /> が <see langword="null" /> の場合は、ANSI エンコーディングが指定されていると見なされます。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、長さ、および <see cref="T:System.Text.Encoding" /> オブジェクトにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターとその他の `String` コンストラクターのオーバーロードに関する例と包括的な使用方法については、「<xref:System.String.%23ctor%2A> コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
<paramref name="value" /> + <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
- または - 
初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> + <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
- または - 
<see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が <paramref name="enc" /> の指定に従ってエンコードされていると想定しています。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">現在の文字列内の位置。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の指定された位置にある <see cref="T:System.Char" /> オブジェクトを取得します。</summary>
        <value><paramref name="index" /> 位置にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` パラメーターは0から始まります。  
  
 このプロパティは、`index` パラメーターによって指定された位置にある <xref:System.Char> オブジェクトを返します。 ただし、Unicode 文字は複数の <xref:System.Char>で表される場合があります。 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> クラスを使用して、<xref:System.Char> オブジェクトではなく Unicode 文字を操作します。 詳細については、「<xref:System.String> クラスの概要」の「Char オブジェクトと Unicode 文字」セクションを参照してください。  
  
 でC#は、<xref:System.String.Chars%2A> プロパティはインデクサーです。 Visual Basic では、これは <xref:System.String> クラスの既定のプロパティです。 文字列内の各 <xref:System.Char> オブジェクトには、次のようなコードを使用してアクセスできます。  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 次の例では、ルーチンでこのインデクサーを使用して文字列を検証する方法を示します。  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> がこのオブジェクトの長さ以上か、0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.String" />インスタンスへの参照を返します。</summary>
        <returns>この <see cref="T:System.String" /> のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値は、このインスタンスの独立したコピーではありません。これは、単に同じデータの別のビューです。 <xref:System.String.Copy%2A> または <xref:System.String.CopyTo%2A> メソッドを使用して、このインスタンスと同じ値を持つ別の <xref:System.String> オブジェクトを作成します。  
  
 <xref:System.String.Clone%2A> メソッドは単に既存の文字列インスタンスを返すため、直接呼び出す理由はほとんどありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Compare%2A> メソッドのすべてのオーバーロードは、2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数を返します。  
  
|[値]|条件|  
|-----------|---------------|  
|0 より小さい値|最初の部分文字列は、並べ替え順序の2番目の部分文字列の前にあります。|  
|0|部分文字列は並べ替え順序で同じ位置で発生するか、`length` はゼロです。|  
|0 より大きい値|最初の部分文字列は、並べ替え順序において2番目の部分文字列の後に続きます。|  
  
> [!WARNING]
>  可能な限り、<xref:System.StringComparison> パラメーターを含む <xref:System.String.Compare%2A> メソッドのオーバーロードを呼び出す必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework で文字列を使用するためのベスト プラクティス</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 次の例では、<xref:System.String.Compare%28System.String%2CSystem.String%29> メソッドを呼び出して、3つの文字列セットを比較しています。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 次の例では、`ReverseStringComparer` クラスは、<xref:System.String.Compare%2A> メソッドを使用して2つの文字列を評価する方法を示しています。  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String)" /> メソッドでは、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、次のコードが [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、カルチャに依存した "animal" と "ani-正しくない" (ソフトハイフンまたは U + 00AD を使用) は、2つの文字列が等価であることを示します。  
  
[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
文字列比較で無視できる文字を認識するには、<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> メソッドを呼び出し、`comparisonType` パラメーターに <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> のいずれかの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 次の例は、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> メソッドが、文字列を比較するときに <xref:System.String.ToUpper%2A> または <xref:System.String.ToLower%2A> を使用することと同じであることを示しています。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> メソッドでは、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、次のコードが [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、カルチャに依存した大文字と小文字を区別しない "animal" と "Ani-----------0" (ソフトハイフンまたは U + 00AD を使用) は、2つの文字列が等価であることを示します。  
  
[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
文字列比較で無視できる文字を認識するには、<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> メソッドを呼び出し、<paramref name="comparisonType" /> パラメーターに <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> のいずれかの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置にあります。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` パラメーターは、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較対照値の大文字と小文字の区別を無視するか、または単語 (カルチャに依存する) または序数 (カルチャに依存しない) の並べ替え規則を使用するかを示します。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 次の例では、文字 "I" の3つのバージョンを比較しています。 結果は、カルチャの選択、case が無視されるかどうか、および序数に基づく比較が実行されるかどうかによって影響を受けます。  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.StringComparison" /> がサポートされていません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> メソッドでは、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 比較で無視できる文字を認識するには、<paramref name="comparisonType" /> パラメーターの値として <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では、`culture` パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 次の例では、カルチャが比較に与える影響について説明します。 チェコ語-チェコ共和国カルチャでは、"ch" は "d" より大きい1文字です。 ただし、英語米国カルチャでは、"ch" は2つの文字で構成され、"c" は "d" よりも小さくなります。  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> メソッドでは、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、次のコードが [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、インバリアントカルチャを使用した "animal" と "Ani-------------------------" は、2つの文字列が等価であることを示します。  
  
[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
文字列比較で無視できる文字を認識するには、<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> メソッドを呼び出し、<paramref name="options" /> パラメーターに <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> のいずれかの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="culture">カルチャ固有の比較情報を提供するカルチャ。</param>
        <param name="options">比較の実行時に使用するオプション (大文字と小文字の違いや記号を無視するなど)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、2 つの文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns><paramref name="strA" /> と <paramref name="strB" /> との構文上の関係を示す 32 ビット符号付き整数。次の表を参照してください。 
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では、`culture` パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順など、カルチャ固有の情報を取得します。 たとえば、特定のカルチャでは、特定の文字の組み合わせを1つの文字として扱うように指定したり、大文字と小文字を特定の方法で比較したり、文字の並べ替え順序が文字によって異なることを指定したりすることができます。前または後に実行します。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> メソッドは、主に並べ替え操作または alphabetizing 操作で使用するために設計されています。 メソッド呼び出しの主な目的が、2つの文字列が等価であるかどうかを判断する場合 (つまり、メソッド呼び出しの目的が0の戻り値をテストする場合) は使用しないでください。 2つの文字列が等価かどうかを判断するには、<xref:System.String.Equals%2A> メソッドを呼び出します。  
  
 比較は、<xref:System.Globalization.CompareOptions> 列挙体の1つ以上のメンバーで構成される `options` パラメーターでさらに指定できます。 ただし、このメソッドの目的はカルチャに依存した文字列比較を実行することであるため、<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> と <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> の値は効果がありません。  
  
 いずれかまたは両方の比較対照値を `null`できます。 定義上、<xref:System.String.Empty?displayProperty=nameWithType>を含む任意の文字列が null 参照よりも大きいかどうかを比較し、2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。  
  
   
  
## Examples  
 次の例では、2つの文字列を比較して、en-us カルチャの言語的な比較を使用しています。en-us カルチャでの言語的な大文字と小文字を区別する比較の使用序数による比較を使用します。 ここでは、3つの比較方法によって3つの異なる結果が生成される方法を示します。  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> が <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> メソッドでは、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 比較で無視できる文字を認識するには、<paramref name="options" /> パラメーターの値として <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> を指定します。</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA` と `indexB`での `strB` の `strA` 開始位置を比較する部分文字列。 `indexA` と `indexB` はどちらも0から始まります。つまり、`strA` と `strB` の最初の文字は0の位置にあります。 最初の部分文字列の長さは、`strA` の長さと1を `indexA` 引いた値と等しくなります。 2番目の部分文字列の長さは、`strB` の長さと1を `indexB` 引いた値と等しくなります。  
  
 比較する文字数は、2つの部分文字列の長さのうち、`length`の長さの小さい方になります。 `indexA`、`indexB`、および `length` パラメーターは、負ではない必要があります。  
  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 次の例では、2つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> メソッドは、言語またはカルチャに依存した比較を実行するときに、これらの文字を考慮しません。 比較で無視できる文字を認識するには、<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドを呼び出し、<paramref name="comparisonType" /> パラメーターに <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> の値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`の `strA` と、`indexB`の `strB` で、比較する部分文字列。 `indexA` と `indexB` はどちらも0から始まります。つまり、`strA` と `strB` の最初の文字は0の位置にあります。 最初の部分文字列の長さは、`strA` の長さと1を `indexA` 引いた値と等しくなります。 2番目の部分文字列の長さは、`strB` の長さと1を `indexB` 引いた値と等しくなります。  
  
 比較する文字数は、2つの部分文字列の長さのうち、`length`の長さの小さい方になります。 `indexA`、`indexB`、および `length` パラメーターは、負ではない必要があります。  
  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 パス名は、不変の方法で比較する必要があります。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 次の例では、大文字と小文字が異なる2つの部分文字列の2つの比較を実行します。 最初の比較では case が無視され、2番目の比較では case が考慮されます。  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> メソッドは、言語またはカルチャに依存した比較を実行するときに、これらの文字を考慮しません。 比較で無視できる文字を認識するには、<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドを呼び出し、<paramref name="comparisonType" /> パラメーターに <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> の値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置に出現するか、<paramref name="length" /> パラメーターはゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA` と `indexB`での `strB` の `strA` 開始位置を比較する部分文字列。 `indexA` と `indexB` はどちらも0から始まります。つまり、`strA` と `strB` の最初の文字は0の位置にあり、位置は配置されません。 最初の部分文字列の長さは、`strA` の長さと1を `indexA` 引いた値と等しくなります。 2番目の部分文字列の長さは、`strB` の長さと1を `indexB` 引いた値と等しくなります。  
  
 比較する文字数は、2つの部分文字列の長さのうち、`length`の長さの小さい方になります。 `indexA`、`indexB`、および `length` パラメーターは、負ではない必要があります。  
  
 `comparisonType` パラメーターは、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較対照値の大文字と小文字の区別を無視するか、または単語 (カルチャに依存する) または序数 (カルチャに依存しない) の並べ替え規則を使用するかを示します。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 次の例では、2つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドは、言語またはカルチャに依存した比較を実行するときに、これらの文字を考慮しません。 比較で無視できる文字を認識するには、<paramref name="comparisonType" /> パラメーターの値として <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`の `strA` と、`indexB`の `strB` で、比較する部分文字列。 `indexA` と `indexB` はどちらも0から始まります。つまり、`strA` と `strB` の最初の文字は0の位置にあり、位置は配置されません。 最初の部分文字列の長さは、`strA` の長さと1を `indexA` 引いた値と等しくなります。 2番目の部分文字列の長さは、`strB` の長さと1を `indexB` 引いた値と等しくなります。  
  
 比較する文字数は、2つの部分文字列の長さのうち、`length`の長さの小さい方になります。 `indexA`、`indexB`、および `length` パラメーターは、負ではない必要があります。  
  
 この比較では、`culture` パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
 1つまたは両方の比較対照値を `null`できます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 次の例では、異なるカルチャを使用して2つの部分文字列を比較し、部分文字列の大文字と小文字を区別します。 カルチャの選択は、文字 "I" の比較方法に影響します。  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> メソッドは、言語またはカルチャに依存した比較を実行するときに、これらの文字を考慮しません。 比較で無視できる文字を認識するには、<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> メソッドを呼び出し、<paramref name="options" /> パラメーターに <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> の値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の開始位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の開始位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <param name="options">比較の実行時に使用するオプション (大文字と小文字の違いや記号を無視するなど)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、2 つの部分文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの部分文字列の構文上の関係を示す整数。次の表を参照してください。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開始位置を `strA` 位置 `indexA` と位置 `indexB`にある `strB` で比較する部分文字列。 最初の部分文字列の長さは、`strA` から `indexA`を引いた長さです。 2番目の部分文字列の長さは、`strB` から `indexB`を引いた長さです。  
  
 比較する文字数は、2つの部分文字列の長さのうち、`length`の長さの小さい方になります。 `indexA`、`indexB`、および `length` パラメーターは、負ではない必要があります。  
  
 この比較では、`culture` パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順など、カルチャ固有の情報を取得します。 たとえば、特定のカルチャでは、特定の文字の組み合わせを1つの文字として扱うように指定したり、大文字と小文字を特定の方法で比較したり、文字の並べ替え順序が文字によって異なることを指定したりすることができます。前または後に実行します。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> メソッドは、主に並べ替え操作または alphabetizing 操作で使用するために設計されています。 メソッド呼び出しの主な目的が、2つの部分文字列が等しいかどうかを判断するためには使用しないでください (つまり、メソッド呼び出しの目的が0の戻り値をテストする場合)。 2つの文字列が等価かどうかを判断するには、<xref:System.String.Equals%2A> メソッドを呼び出します。  
  
 `strA` と `strB` の一方または両方を `null`できます。 定義上、<xref:System.String.Empty?displayProperty=nameWithType>を含む任意の文字列が null 参照よりも大きいかどうかを比較し、2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 列挙体の1つ以上のメンバーで構成される `options` パラメーターでさらに指定できます。 ただし、このメソッドの目的はカルチャに依存した文字列比較を実行することであるため、<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> と <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> の値は効果がありません。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
   
  
## Examples  
 次の例では、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> メソッドを使用して、2人の人の姓を比較します。 次に、アルファベット順に一覧表示します。  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> が <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> は <paramref name="strA" /><see langword=".Length" /> より大きいです。  
  
- または - 
 <paramref name="indexB" /> は <paramref name="strB" /><see langword=".Length" /> より大きいです。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> メソッドは、言語またはカルチャに依存した比較を実行するときに、これらの文字を考慮しません。 比較で無視できる文字を認識するには、<paramref name="options" /> パラメーターの値として <see cref="F:System.Globalization.CompareOptions.Ordinal" /> または <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> を指定します。</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、2 つの <see cref="T:System.Char" /> を比較します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、指定した 2 つの <see cref="T:System.Char" /> を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> は <paramref name="strB" /> より小さい値です。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> と <paramref name="strB" /> が等しい。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description><paramref name="strA" /> が <paramref name="strB" /> より大きくなっています。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数の並べ替え規則を使用して、大文字と小文字を区別した比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。 序数の並べ替え規則を使用して大文字と小文字を区別しない比較を実行するには、`comparisonType` 引数を <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>に設定して <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> メソッドを呼び出します。  
  
 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> は静的メソッドであるため、`strA` と `strB` を `null`できます。 両方の値が `null`場合、メソッドは 0 (ゼロ) を返します。これは、`strA` と `strB` が等しいことを示します。 値の1つだけが `null`の場合、メソッドは null 以外の値が大きいと見なされます。  
  
   
  
## Examples  
 次の例では、大文字と小文字が異なる2つの文字列を比較して、序数の比較を実行します。  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の開始インデックス。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の開始インデックス。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>それぞれの部分文字列の対応する <see cref="T:System.Char" /> オブジェクトの数値を評価することにより、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より小さいです。  
  
 </description></item><item><term> 0 
 </term><description> これらの部分文字列が等しいか、または <paramref name="length" /> が 0 です。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> <paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より大きいです。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`、`indexB`、および `length` パラメーターは、負ではない必要があります。  
  
 比較する文字数は、`strA` の `indexA`の長さ、`strB` `indexB`の長さ、および `length`の長さのいずれか小さい方になります。  
  
 このメソッドは、序数の並べ替え規則を使用して、大文字と小文字を区別した比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。 序数の並べ替え規則を使用して大文字と小文字を区別しない比較を実行するには、`comparisonType` 引数を <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>に設定して <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> メソッドを呼び出します。  
  
 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> は静的メソッドであるため、`strA` と `strB` を `null`できます。 両方の値が `null`場合、メソッドは 0 (ゼロ) を返します。これは、`strA` と `strB` が等しいことを示します。 値の1つだけが `null`の場合、メソッドは null 以外の値が大きいと見なされます。  
  
   
  
## Examples  
 次の例では、<xref:System.String.CompareOrdinal%2A> と <xref:System.String.Compare%2A> で異なる並べ替え順が使用されていることを示します。  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> は <see langword="null" /> でありません。また <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> を超えています。  
  
- または - 
 <paramref name="strB" /> は <see langword="null" /> でありません。また <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" />を超えています。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスと指定したオブジェクトまたは <see cref="T:System.String" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定したオブジェクトまたは <see cref="T:System.String" /> の前、後ろ、または同じのいずれであるかを示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.CompareTo%2A> メソッドの両方のオーバーロードは、カルチャに依存し、大文字と小文字を区別する比較を実行します。 このメソッドを使用して、カルチャを認識しないまたは序数による比較を実行することはできません。 コードをわかりやすくするために、<xref:System.String.CompareTo%2A> メソッドを使用せずに、代わりに <xref:System.String.Compare%2A> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.String" /> に評価されるオブジェクト。</param>
        <summary>このインスタンスと指定した <see cref="T:System.Object" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定した <see cref="T:System.Object" /> の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="value" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも前です。  
  
 </description></item><item><term> 0 
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="value" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも後ろです。  
  
- または - 
 <paramref name="value" /> は <see langword="null" />です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` は <xref:System.String> オブジェクトである必要があります。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> メソッドは、主に並べ替え操作または alphabetizing 操作で使用するように設計されています。 2つの文字列が等価かどうかを判断するために、メソッド呼び出しの主な目的がである場合は、使用しないでください。 2つの文字列が等価かどうかを判断するには、<xref:System.String.Equals%2A> メソッドを呼び出します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドの動作の詳細については、<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> メソッドの「解説」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Object>と共に <xref:System.String.CompareTo%2A> メソッドを使用します。 <xref:System.String> インスタンスを `TestClass` オブジェクトと比較しようとするため、メソッドは <xref:System.ArgumentException>をスローします。  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が <see cref="T:System.String" /> ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.CompareTo(System.Object)" /> メソッドでは、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、次のコードが [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、"animal" を "ani--------------------0" と比較すると、2つの文字列が等価であることが示されます。  
  
[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
文字列比較で無視できる文字を認識するには、<see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> メソッドを呼び出します。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::String ^ strB);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと指定した <see cref="T:System.String" /> オブジェクトとを比較し、並べ替え順序において、このインスタンスの位置が指定した文字列の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="strB" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも前です。  
  
 </description></item><item><term> 0 
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="strB" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも後ろです。  
  
- または - 
 <paramref name="strB" /> が <see langword="null" /> です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> メソッドは、主に並べ替え操作または alphabetizing 操作で使用するように設計されています。 2つの文字列が等価かどうかを判断するために、メソッド呼び出しの主な目的がである場合は、使用しないでください。 2つの文字列が等価かどうかを判断するには、<xref:System.String.Equals%2A> メソッドを呼び出します。  
  
 このメソッドの動作の詳細については、<xref:System.String.Compare%28System.String%2CSystem.String%29> メソッドの「解説」を参照してください。  
  
 このメソッドは、<xref:System.IComparable%601?displayProperty=nameWithType> インターフェイスを実装し、<xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> メソッドよりも若干優れています。これは、`strB` 引数が、ボックス化する必要がある変更可能な値型であるかどうかを判断する必要がなく、パラメーターを @no からキャストする必要がないためです。<xref:System.String>に変換します。<xref:System.Object>  
  
   
  
## Examples  
 次の例では、<xref:System.String.CompareTo%2A> メソッドを使用して、現在の文字列インスタンスを別の文字列と比較します。  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 次の例は、いくつかの値および参照型に対する CompareTo メソッドのジェネリックバージョンと非ジェネリックバージョンを示しています。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.CompareTo(System.String)" /> メソッドでは、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、次のコードが [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、"animal" を "ani--------------------0" と比較すると、2つの文字列が等価であることが示されます。  
  
[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
文字列比較で無視できる文字を認識するには、<see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> メソッドを呼び出します。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.String" /> の 1 つ以上のインスタンス、または <see cref="T:System.String" /> の 1 つ以上のインスタンスの <see cref="T:System.Object" /> 形式の値を連結します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!NOTE]
>  また、のC#`+` のような言語の文字列連結演算子を使用したり、Visual Basic で`&`および`+`して、文字列を連結したりすることもできます。 どちらのコンパイラも、連結演算子を `String.Concat`のオーバーロードの1つの呼び出しに変換します。 

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values"><see cref="T:System.Collections.Generic.IEnumerable`1" /> を実装し、ジェネリック型引数が <see cref="T:System.String" /> であるコレクション オブジェクト。</param>
        <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。</summary>
        <returns><paramref name="values" /> 内の文字列の連結結果。または、<paramref name="values" /> が空の <see langword="IEnumerable(Of String)" /> である場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは `values`内の各オブジェクトを連結します。区切り記号は追加されません。 `values`の各メンバーの間に区切り記号を指定するには、<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> メソッドを呼び出します。  
  
 <xref:System.String.Empty?displayProperty=nameWithtype> 文字列は、`values`内の null 要素の代わりに使用されます。  
  
 If `values` である場合は `IEnumerable(Of String)`の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>です。 `values` が `null`場合、メソッドは <xref:System.ArgumentNullException> 例外をスローします。  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> は、最初に要素を文字列配列に変換しなくても、`IEnumerable(Of String)` コレクション内の各要素を連結できる便利なメソッドです。 これは、統合言語クエリ (LINQ) クエリ式で特に便利です。 次の例では、アルファベットの大文字または小文字を含む `List(Of String)` オブジェクトを、特定の文字以上の文字 (例では "M") を選択するラムダ式に渡します。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> メソッドによって返される `IEnumerable(Of String)` コレクションは <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> メソッドに渡され、結果が1つの文字列として表示されます。  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 <xref:System.String>型の <xref:System.Collections.Generic.List%601> オブジェクトに結果を代入し、その後 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> メソッドに渡します。  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">表現するオブジェクトまたは <see langword="null" />。</param>
        <summary>指定されたオブジェクトの文字列形式を作成します。</summary>
        <returns><paramref name="arg0" /> の値の文字列形式。<see cref="F:System.String.Empty" /> が <paramref name="arg0" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29> メソッドは、パラメーターなしの `ToString` メソッドを呼び出すことによって、`arg0` を文字列として表します。  
  
   
  
## Examples  
 <xref:System.String.Concat%2A>メソッドの例を次に示します。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">連結する要素を格納しているオブジェクト配列。</param>
        <summary>指定された <see cref="T:System.Object" /> 配列の要素の文字列表記を連結します。</summary>
        <returns><paramref name="args" /> の各要素の値を連結した文字列表記。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、オブジェクトのパラメーターなしの `ToString` メソッドを呼び出すことによって、`args` 内の各オブジェクトを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> は、配列内の null オブジェクトの代わりに使用されます。  
  
   
  
## Examples  
 次の例は、<xref:System.Object> 配列での <xref:System.String.Concat%2A> メソッドの使用方法を示しています。  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <block subset="none" type="usage"><para>このメソッドは、コードにC++よって呼び出されません。 コンパイラC++は、<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />への呼び出しとして、4つ以上のオブジェクトパラメーターを持つ<see cref="Overload:System.String.Concat" />の呼び出しを解決します。</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">文字列インスタンスの配列。</param>
        <summary>指定した <see cref="T:System.String" /> 配列の要素を連結します。</summary>
        <returns>連結された <paramref name="values" /> の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは `values`内の各オブジェクトを連結します。区切り記号は追加されません。  
  
 配列内の null オブジェクトの代わりに、<xref:System.String.Empty?displayProperty=nameWithtype> 文字列が使用されます。  
  
   
  
## Examples  
 次の例は、<xref:System.String> 配列での <xref:System.String.Concat%2A> メソッドの使用方法を示しています。  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <summary>指定した 2 つのオブジェクトの文字列形式を連結します。</summary>
        <returns><paramref name="arg0" /> および <paramref name="arg1" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、`arg0` および `arg1`のパラメーターなしの `ToString` メソッドを呼び出すことによって、`arg0` と `arg1` を連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> は、null 引数の代わりに使用されます。  
  
 場合か、引数の配列参照は、メソッドは、そのメンバー (たとえば、"System.String[]") 代わりに、その配列を表す文字列を連結します。  
  
   
  
## Examples  
 <xref:System.String.Concat%2A>メソッドの例を次に示します。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の読み取り専用文字スパン。</param>
        <param name="str1">連結する 2 番目の読み取り専用文字スパン。</param>
        <summary>2 つの指定された読み取り専用文字スパンの文字列形式を連結します。</summary>
        <returns><paramref name="str0" /> および <paramref name="str1" /> の値の文字列形式を連結した結果。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns><paramref name="str0" /> と <paramref name="str1" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは `str0` と `str1`を連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithtype> 文字列は、null 引数の代わりに使用されます。  
  
## Examples  
 次の例では、ユーザーの姓、ミドルネーム、および姓を連結しています。  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <summary>指定した 3 つのオブジェクトの文字列形式を連結します。</summary>
        <returns><paramref name="arg0" />、<paramref name="arg1" /> および <paramref name="arg2" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、各オブジェクトのパラメーターなしの `ToString` メソッドを呼び出すことによって、`arg0`、`arg1`、および `arg2` を連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> は、null 引数の代わりに使用されます。  
  
   
  
## Examples  
 <xref:System.String.Concat%2A>メソッドの例を次に示します。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の読み取り専用文字スパン。</param>
        <param name="str1">連結する 2 番目の読み取り専用文字スパン。</param>
        <param name="str2">連結する 3 番目の読み取り専用の文字スパン。</param>
        <summary>3 つの指定された読み取り専用文字スパンの文字列形式を連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、および <paramref name="str2" /> の値の文字列形式を連結した結果。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <summary><see cref="T:System.String" /> の指定した 3 つのインスタンスを連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、および <paramref name="str2" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、`str0`、`str1`、および `str2`を連結します。区切り記号は追加されません。  
  
## Examples  
 次の例では、<xref:System.String.Concat%2A> メソッドを使用して、3つの文字列を連結し、結果を表示します。  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <param name="arg3">連結する 4 番目のオブジェクト。</param>
        <summary>4 つの指定したオブジェクトと、オプションの可変長パラメーター リストで指定した任意のオブジェクトの文字列表現を連結します。</summary>
        <returns>パラメーター リスト内の各値の文字列を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この API は、CLS に準拠していません。 CLS 準拠の代わりとして <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType> を使用できます。 およびC# Visual Basic コンパイラは、このメソッドへの呼び出しを <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>の呼び出しとして自動的に解決します。  
  
 メソッドは、パラメーターなしの `ToString` メソッドを呼び出すことによって、パラメーターリスト内の各オブジェクトを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> は、null 引数の代わりに使用されます。  
  
> [!NOTE]
>  <xref:System.String.Concat%2A> メソッドの最後のパラメーターは、連結する1つ以上の追加オブジェクトのコンマ区切りのリストです (省略可能)。  
  
   
  
## Examples  
 次の例は、<xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> メソッドを使用して、変数パラメーターの一覧を連結する方法を示しています。 この場合、メソッドは9個のパラメーターを使用して呼び出されます。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>このメソッドは <see langword="vararg" /> キーワードでマークされています。これは、可変個のパラメーターをサポートしていることを意味します。 メソッドはビジュアルC++から呼び出すことができますが、または Visual Basic C#コードから呼び出すことはできません。 およびC# Visual Basic コンパイラは、<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> の呼び出しを <see cref="M:System.String.Concat(System.Object[])" />の呼び出しとして解決します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の読み取り専用文字スパン。</param>
        <param name="str1">連結する 2 番目の読み取り専用文字スパン。</param>
        <param name="str2">連結する 3 番目の読み取り専用の文字スパン。</param>
        <param name="str3">連結する 4 番目の読み取り専用の文字スパン。</param>
        <summary>4 つの指定された読み取り専用文字スパンの文字列形式を連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" />、および <paramref name="str3" /> の値の文字列形式を連結した結果。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <param name="str3">連結する 4 番目の文字列。</param>
        <summary>指定した 4 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" />、および <paramref name="str3" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、`str0`、`str1`、`str2`、および `str3`を連結します。区切り記号は追加されません。  
  
## Examples  
 次の例では、4文字の単語の配列を定義し、それらの文字をスクランブルするために文字列配列に格納します。 次に、<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> メソッドを呼び出して、スクランブルされた単語を再アセンブルします。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> のメンバーの型。</typeparam>
        <param name="values"><see cref="T:System.Collections.Generic.IEnumerable`1" /> インターフェイスを実装するコレクション オブジェクト。</param>
        <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> 実装のメンバーを連結します。</summary>
        <returns><paramref name="values" /> 内のメンバーの連結結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは `values`内の各オブジェクトを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithtype> 文字列は、null 引数の代わりに使用されます。  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> は、最初に要素を文字列に変換することなく、<xref:System.Collections.Generic.IEnumerable%601> コレクション内の各要素を連結できる便利なメソッドです。 この例に示すように、統合言語クエリ (LINQ) クエリ式では特に便利です。 <xref:System.Collections.Generic.IEnumerable%601> コレクション内の各オブジェクトの文字列形式は、そのオブジェクトの `ToString` メソッドを呼び出すことによって取得されます。  
  
   
  
## Examples  
 次の例では、単純な `Animal` クラスを定義しています。このクラスには、動物の名前と、それが属する順序が含まれています。 次に、多数の `Animal` オブジェクトを格納する <xref:System.Collections.Generic.List%601> オブジェクトを定義します。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 拡張メソッドは、`Order` プロパティが "げっ歯類" と等しい `Animal` オブジェクトを抽出するために呼び出されます。 結果は <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドに渡され、コンソールに表示されます。  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">検索対象の文字。</param>
        <summary>指定した文字がこの文字列内に存在するかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内で発生する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定した部分文字列がこの文字列内に存在するかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内に存在するか、<paramref name="value" /> が空の文字列 ("") の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。 検索は、この文字列の最初の文字位置から開始され、最後の文字位置まで続きます。  
  
 序数による比較 (カルチャに依存した比較、または大文字と小文字を区別しない比較など) を使用して文字列に指定した部分文字列が含まれているかどうかを確認するには、カスタムメソッドを作成します。 このような方法の例を次に示します。 これは、<xref:System.StringComparison> パラメーターを含む <xref:System.String> 拡張メソッドを定義し、指定された形式の文字列比較を使用する場合に文字列に部分文字列が含まれるかどうかを示します。  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 次の例では、`Contains` 拡張メソッドを呼び出して、序数による比較と大文字と小文字を区別しない序数比較を使用する場合に、文字列内で部分文字列が見つかったかどうかを判断します。  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 現在のインスタンス内の部分文字列 `value` の位置を知りたい場合は、<xref:System.String.IndexOf%2A> メソッドを呼び出して最初に出現する位置を取得します。または、<xref:System.String.LastIndexOf%2A> メソッドを呼び出して、最後に出現する位置を取得できます。 この例では、文字列インスタンスで部分文字列が見つかった場合の <xref:System.String.IndexOf%28System.String%29> メソッドの呼び出しが含まれています。  
  
   
  
## Examples  
 次の例では、文字列 "fox" が、使い慣れた引用符の部分文字列であるかどうかを判断します。 文字列内に "fox" が見つかった場合は、その開始位置も表示されます。  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">検索対象の文字。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された比較規則を使用して、指定された文字がこの文字列内に含まれるかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内で発生する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された比較規則を使用して、指定された文字列がこの文字列内に含まれるかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内に存在するか、<paramref name="value" /> が空の文字列 ("") の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">コピーする文字列。</param>
        <summary>指定した <see cref="T:System.String" /> と同じ値を使用して、<see cref="T:System.String" /> の新しいインスタンスを作成します。</summary>
        <returns><paramref name="str" /> と同じ値を持つ新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`Copy` メソッドは、元の文字列と同じ値を持ち、別のオブジェクト参照を表す <xref:System.String> オブジェクトを返します。 これは代入演算とは異なり、既存の文字列参照を追加のオブジェクト変数に代入します。

> [!IMPORTANT]
>  .NET Core 3.0 以降では、このメソッドは互換性のために残されています。 ただし、.NET の実装では使用しないことをお勧めします。 特に、.NET Core 3.0 では文字列インターンが変更されているため、`Copy` メソッドは新しい文字列を作成せず、単に既存のインターン文字列への参照を返す場合があります。   

`Copy` メソッドを呼び出す理由に応じて、いくつかの代替手段があります。

- 文字列を変更する操作で別の文字列インスタンスを使用する場合は、元の文字列インスタンスを使用します。 文字列は不変であるため、文字列操作は新しい文字列インスタンスを作成し、元の文字列は影響を受けません。 この場合、元の文字列変数に新しい文字列参照を割り当てないでください。 具体的な例を次に示します。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]  
  
   この場合、<xref:System.String.Substring%2A> メソッドを呼び出す前に新しい文字列を作成するために `Copy` メソッドを呼び出すと、新しい文字列インスタンスが不必要に作成されます。 

- 元の文字列と同じ内容の変更可能なバッファーを作成する場合は、<xref:System.String.ToCharArray%2A?displayProperty=nameWithType> または <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> コンストラクターを呼び出します。 次に例を示します。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]  

- アンセーフコードを使用して文字列の内容を変更できるように、文字列の変更可能なコピーを作成する場合は、<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> メソッドを使用します。 次の例では、<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> メソッドを使用して、アンマネージメモリ内のコピーされた文字列の位置へのポインターを取得し、文字列内の各文字の Unicode コードポイントを1つずつインクリメントし、結果の文字列をマネージ文字列にコピーして戻します。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">コピーする、このインスタンス内の最初の文字のインデックス。</param>
        <param name="destination">このインスタンスの文字のコピー先となる Unicode 文字の配列。</param>
        <param name="destinationIndex">コピー操作を開始する <paramref name="destination" /> のインデックス。</param>
        <param name="count"><paramref name="destination" /> へコピーされるこのインスタンスの文字の数。</param>
        <summary>このインスタンスの指定位置から指定した数の文字を、Unicode 文字の配列内の指定位置へコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、このインスタンスの `sourceIndex` 位置から `count` 文字を `destination` 文字配列の `destinationIndex` 位置にコピーします。 このメソッドは `destination` 文字配列のサイズを変更しません。コピーされた文字を格納するのに十分な数の要素が必要です。または、メソッドが <xref:System.ArgumentOutOfRangeException>をスローします。  
  
 `sourceIndex` と `destinationIndex` は0から始まります。  
  
   
  
## Examples  
 <xref:System.String.CopyTo%2A>メソッドの例を次に示します。  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、 <paramref name="destinationIndex" />、または <paramref name="count" /> が負の値です。 
- または - 
 <paramref name="sourceIndex" /> が現在のインスタンス内の位置を識別していません。  
  
- または - 
 <paramref name="destinationIndex" /> が、 <paramref name="destination" /> 配列内の有効なインデックスを識別していません。  
  
- または - 
 <paramref name="count" /> は、このインスタンスの <paramref name="sourceIndex" /> から末尾までの部分文字列の長さを超えています。 
- または - 
 <paramref name="count" /> は、<paramref name="destination" /> 配列の <paramref name="destinationIndex" /> から末尾までの部分配列の長さを超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><paramref name="action" />に渡す要素の型。</typeparam>
        <param name="length">作成する文字列の長さ。</param>
        <param name="state"><paramref name="action" /> に渡す要素。</param>
        <param name="action">文字列を初期化するコールバック。</param>
        <summary>特定の長さの新しい文字列を作成し、作成後に指定したコールバックを使用してそれを初期化します。</summary>
        <returns>作成された文字列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>空の文字列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドの値は、長さが0の文字列 "" です。  
  
 アプリケーションコードでは、このフィールドは、文字列変数を空の文字列に初期化するために割り当てで最もよく使用されます。 文字列の値が `null` か <xref:System.String.Empty?displayProperty=nameWithType>かをテストするには、<xref:System.String.IsNullOrEmpty%2A> メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の文字と比較する文字。</param>
        <summary>この文字列インスタンスの末尾が、指定した文字と一致するかどうかを判断します。</summary>
        <returns>このインスタンスの末尾が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、現在のカルチャを使用して、大文字と小文字を区別し、カルチャに依存した比較を実行します。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>このインスタンスの末尾が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`value` を、このインスタンスの末尾にある `value`と同じ長さの部分文字列と比較し、等しいかどうかを示す値を返します。 同じにするには、`value` 同じインスタンスへの参照であるか、またはこのインスタンスの末尾と一致している必要があります。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。  
  
   
  
## Examples  
 次の例では、配列内の各文字列の末尾がピリオド (".") であるかどうかを示します。  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 次の例では、<xref:System.String.EndsWith%28System.String%29> メソッドを使用して、行末から HTML 終了タグを削除する `StripEndTags` メソッドを定義します。 `StripEndTags` メソッドは、行の末尾にある複数の HTML 終了タグが削除されるように、再帰的に呼び出されることに注意してください。  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの文字列比較規則を使用して文字列が特定の部分文字列で終わるかどうかを確認するには、その <paramref name="comparisonType" /> パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> 値を指定して、<see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> メソッドのオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="comparisonType">この文字列と <paramref name="value" /> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A> メソッドは、`value` パラメーターをこの文字列の末尾の部分文字列と比較し、等しいかどうかを示す値を返します。 同じにするには、`value` がこの同じ文字列への参照であるか、空の文字列 ("") であるか、またはこの文字列の末尾と一致している必要があります。 <xref:System.String.EndsWith%2A> メソッドによって実行される比較の種類は、`comparisonType` パラメーターの値によって異なります。  
  
   
  
## Examples  
 次の例では、文字列が特定の部分文字列で終わるかどうかを判断します。 結果は、カルチャの選択、case が無視されるかどうか、および序数に基づく比較が実行されるかどうかによって影響を受けます。  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">このインスタンスと <paramref name="value" /> との比較方法を決定するカルチャ情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`value` パラメーターを、`value`と同じ長さの、この文字列の末尾にある部分文字列と比較し、等しいかどうかを示す値を返します。 同じにするには、`value` この同じインスタンスへの参照であるか、またはこの文字列の末尾と一致している必要があります。  
  
 このメソッドは、指定された大文字と小文字の区別とカルチャを使用して、単語 (カルチャに依存した) 比較を実行します。  
  
   
  
## Examples  
 次の例では、文字列が別の文字列の末尾にあるかどうかを判断します。 <xref:System.String.EndsWith%2A> メソッドは、大文字と小文字の区別、大文字と小文字の区別、および検索結果に影響を与えるさまざまなカルチャを使用して、複数回呼び出されます。  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列から <see cref="T:System.Text.Rune" /> の列挙体を返します。</summary>
        <returns>文字列ルーン列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

無効なシーケンスは、<xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>によって列挙体で表されます。

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定したオブジェクトの値が同一かどうかを判断します。<see cref="T:System.String" /> オブジェクトを指定する必要があります。</summary>
        <returns><see langword="true" /> が <paramref name="obj" /> で、このインスタンスと同じ値を保持している場合は <see cref="T:System.String" />。それ以外の場合は <see langword="false" />。  <paramref name="obj" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。  
  
   
  
## Examples  
 <xref:System.String.Equals%2A>メソッドの例を次に示します。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定した別の <see cref="T:System.String" /> の値が同一かどうかを判断します。</summary>
        <returns><see langword="true" /> パラメーターの値がこのインスタンスの値と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。 <paramref name="value" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。  
  
   
  
## Examples  
 <xref:System.String.Equals%2A>メソッドの例を次に示します。 タイトルの大文字と小文字の "File" を、それと等価な単語、小文字の小文字、大文字、およびラテン小文字 I (U + 0069) ではなく、ラテン文字の小文字の I (U + 0131) を含む単語と比較します。 <xref:System.String.Equals%28System.String%29> メソッドは序数による比較を実行するため、同一の単語との比較だけが `true`を返します。  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
        <returns><paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <paramref name="a" /> と <paramref name="b" /> の両方が <see langword="null" /> の場合、メソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。  
  
   
  
## Examples  
 <xref:System.String.Equals%2A>メソッドの例を次に示します。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <param name="comparisonType">文字列の比較方法を指定する列挙値の 1 つ。</param>
        <summary>この文字列と、指定した <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns><see langword="true" /> パラメーターの値がこの文字列と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` パラメーターは、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較する2つの文字列の大文字と小文字を区別するか無視するか、または word または序数の並べ替え規則を使用するかを示します。  
  
   
  
## Examples  
 次の例では、大文字の "I"、小文字の "i"、およびドットではない "ı" で構成される文字列配列を作成します。 次に、<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> メソッドを呼び出して、考えられる各 <xref:System.StringComparison> 列挙値を使用して比較します。  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 次の例では、<xref:System.StringComparison> 列挙体の各メンバーを使用して、4つの単語セットを比較します。  この比較では、英語 (米国) カルチャとサーミ語 (Upper スウェーデン) カルチャの規則が使用されます。 文字列 "encyclopædia" および "encyclopaedia" は、en-us カルチャでは等価と見なされますが、サーミ語 (北スウェーデン) カルチャでは考慮されないことに注意してください。  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <param name="comparisonType">比較の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns><see langword="true" /> パラメーターの値が <paramref name="a" /> パラメーターの値に等しい場合は <paramref name="b" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` パラメーターは、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較する2つの文字列の大文字と小文字を区別するか無視するか、または word または序数の並べ替え規則を使用するかを示します。  
  
   
  
## Examples  
 次の例では、<xref:System.StringComparison> 列挙体の各メンバーを使用して、4つの単語セットを比較します。  この比較では、英語 (米国) カルチャとサーミ語 (Upper スウェーデン) カルチャの規則が使用されます。 文字列 "encyclopædia" および "encyclopaedia" は、en-us カルチャでは等価と見なされますが、サーミ語 (北スウェーデン) カルチャでは考慮されないことに注意してください。  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された形式に基づいてオブジェクトの値を文字列に変換し、別の文字列に挿入します。  
  
`String.Format` メソッドを初めて使用する場合は、「[Get started with the String.Format method](#Starting)」(String.Format メソッドの概要) セクションを参照して、概要をご確認ください。  
  
`String.Format` メソッドの全般的な説明については、「[Remarks](#remarks-top)」 (解説) セクションを参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 このセクションの内容:  
  
 まず[、String. Format メソッドを使用して](#Starting)   
 [どの方法を呼び出すか。](#FTaskList)   
 [Format メソッド (brief](#Format_Brief) )   
 [書式項目](#FormatItem)   
 [引数の書式設定](#HowFormatted)   
 [同じインデックスを持つ項目を書式設定](#SameIndex)   
 [書式設定とカルチャの](#Format_Culture)   
 [カスタム書式設定操作](#Format_Custom)   
 [文字列。 Q & A を書式設定します。](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>String. Format メソッドの概要  
 オブジェクト、変数、または式の値を別の文字列に挿入する必要がある場合は、<xref:System.String.Format%2A?displayProperty=nameWithType> を使用します。 たとえば、<xref:System.Decimal> 値の値を文字列に挿入して、1つの文字列としてユーザーに表示することができます。  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 また、その値の書式設定を制御することもできます。  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 書式設定だけでなく、配置や間隔を制御することもできます。  
  
 ### <a name="inserting-a-string"></a>文字列の挿入  

 <xref:System.String.Format%2A?displayProperty=nameWithType> は、書式指定文字列で始まり、その後に1つ以上のオブジェクトまたは式が文字列に変換され、書式文字列内の指定された場所に挿入されます。 次に例を示します。  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 書式指定文字列の `{0}` は、書式指定項目です。 `0` は、その位置に文字列値が挿入されるオブジェクトのインデックスです。 (インデックスは0から始まります)。挿入するオブジェクトが文字列でない場合は、そのオブジェクト `ToString` メソッドを呼び出して、結果文字列に挿入する前にそのオブジェクトを1に変換します。  
  
 2つの書式項目とオブジェクトリスト内の2つのオブジェクトを使用するもう1つの例を次に示します。  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 各書式指定項目のインデックスのオブジェクトリストに一致するオブジェクトがある限り、任意の数の書式項目と、オブジェクトリスト内のオブジェクトの数を指定できます。 また、どのオーバーロードを呼び出すかについて心配する必要もありません。適切なものがコンパイラによって選択されます。  
  
 ### <a name="controlling-formatting"></a>書式設定の制御  
 書式指定文字列を含む書式指定項目のインデックスに従うと、オブジェクトの書式設定方法を制御できます。 たとえば、`{0:d}` は、オブジェクトリストの最初のオブジェクトに "d" 書式指定文字列を適用します。 次に、1つのオブジェクトと2つの書式設定項目を使用した例を示します。  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 多くの型は、書式指定文字列をサポートしています。これには、すべての数値型 ([標準](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-numeric-format-strings.md)の書式指定文字列の両方)、すべての日付と時刻 ([標準](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-date-and-time-format-strings.md)の書式指定文字列の両方)、および時間間隔 ([標準](~/docs/standard/base-types/standard-timespan-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-timespan-format-strings.md)書式指定文字列)、すべての列挙型の[列挙](~/docs/standard/base-types/enumeration-format-strings.md)型、および[guid](https://msdn.microsoft.com/library/97af8hh4.aspx)。 書式指定文字列のサポートを独自の型に追加することもできます。  
  
 ### <a name="controlling-spacing"></a>制御 (間隔を)  
 `{0,12}`などの構文を使用して、結果文字列に挿入される文字列の幅を定義できます。これにより、12文字の文字列が挿入されます。 この場合、最初のオブジェクトの文字列表現は、12文字のフィールドでは右に並べられています。  (最初のオブジェクトの文字列表現の長さが12文字を超えている場合、優先フィールドの幅は無視され、文字列全体が結果の文字列に挿入されます)。  
  
 次の例では、文字列 "Year" といくつかの文字列を保持する6文字のフィールドと、"母集団" と "いくつかの人口データ" を格納する15文字のフィールドを定義しています。 この文字は、フィールドでは右から右に並べられていることに注意してください。  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>制御 (配置を)  
 既定では、フィールドの幅を指定した場合、文字列はフィールド内で右から右に並べられます。 フィールド内の文字列を左揃えにするには、フィールドの幅の先頭に負の符号 (`{0,-12}` など) を付けて、左揃えの12文字のフィールドを定義します。  
  
 次の例は前の例と似ていますが、ラベルとデータの両方を左揃えにしている点が異なります。  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> は、複合書式指定機能を使用します。 詳細については、「[複合書式指定](~/docs/standard/base-types/composite-formatting.md)」をご覧ください。  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>どの方法を呼び出すか。  
  
|終了|Call|  
|--------|----------|  
|現在のカルチャの規則を使用して、1つまたは複数のオブジェクトの書式を設定します。|`provider` パラメーターを含むオーバーロードを除き、残りの <xref:System.String.Format%2A> オーバーロードには、<xref:System.String> パラメーターの後に1つ以上のオブジェクトパラメーターが続きます。 このため、どの <xref:System.String.Format%2A> オーバーロードを呼び出す必要があるかを判断する必要はありません。 言語コンパイラは、引数リストに基づいて、`provider` パラメーターを持たないオーバーロードの中から適切なオーバーロードを選択します。 たとえば、引数リストに5つの引数がある場合、コンパイラは <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> メソッドを呼び出します。|  
|特定のカルチャの規則を使用して1つ以上のオブジェクトの書式を設定します。|`provider` パラメーターで始まる各 <xref:System.String.Format%2A> オーバーロードには、<xref:System.String> パラメーターと1つ以上のオブジェクトパラメーターが続きます。 このため、どの <xref:System.String.Format%2A> オーバーロードを呼び出す必要があるかを判断する必要はありません。 言語コンパイラは、引数リストに基づいて、`provider` パラメーターを持つオーバーロードの中から適切なオーバーロードを選択します。 たとえば、引数リストに5つの引数がある場合、コンパイラは <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> メソッドを呼び出します。|  
|<xref:System.ICustomFormatter> の実装または <xref:System.IFormattable> 実装を使用して、カスタム書式設定操作を実行します。|`provider` パラメーターを持つ4つのオーバーロードのいずれか。 コンパイラは、引数リストに基づいて、`provider` パラメーターを持つオーバーロードの中から適切なオーバーロードを選択します。|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Format メソッド (brief) 

 <xref:System.String.Format%2A> メソッドの各オーバーロードは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、*書式指定項目*と呼ばれる0から始まるインデックス付きプレースホルダーを複合書式指定文字列に含めます。 実行時に、各書式指定項目は、パラメーターリスト内の対応する引数の文字列形式に置き換えられます。 引数の値が `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 たとえば、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> メソッドの次の呼び出しには、3つの書式項目、{0}、{1}、および {2}を含む書式指定文字列と、3つの項目を持つ引数リストが含まれています。  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>書式項目  
 書式指定項目の構文は次のとおりです。  
  
```  
{index[,alignment][:formatString]}  
```  
 
 角かっこは省略可能な要素を表します。 左中かっこと終わりかっこが必要です。 書式指定文字列にリテラルの始めかっこまたは右中かっこを含めるには、「[複合書式指定](~/docs/standard/base-types/composite-formatting.md)」の記事の「[エスケープ中かっこ](~/docs/standard/base-types/composite-formatting.md#escaping-braces)」セクションを参照してください。  
  
 たとえば、通貨値を書式設定するための書式項目は、次のように表示されることがあります。  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 書式指定項目には、次の要素があります。  
  
 *index*  
 文字列表記が文字列内のこの位置に含まれる引数の0から始まるインデックス。 この引数が `null`場合は、文字列のこの位置に空の文字列が含まれます。  
  
 *alignment*  
 任意。 引数が挿入されるフィールドの合計長と、その引数が右揃え (正の整数) または左揃え (負の整数) であるかどうかを示す符号付き整数。 *Alignment*を省略した場合、対応する引数の文字列形式は、先頭または末尾のスペースのないフィールドに挿入されます。  
  
 *Alignment*の値が挿入する引数の長さよりも小さい場合、*アラインメント*は無視され、引数の文字列形式の長さがフィールドの幅として使用されます。  
  
 *formatString*  
 任意。 対応する引数の結果文字列の形式を指定する文字列。 *FormatString*を省略した場合、対応する引数のパラメーターなしの `ToString` メソッドが呼び出され、その文字列形式が生成されます。 *FormatString*を指定する場合、書式指定項目によって参照される引数は <xref:System.IFormattable> インターフェイスを実装する必要があります。 書式指定文字列をサポートする型は次のとおりです。  
  
-   すべての整数型と浮動小数点型。 (「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください)。  
  
-   <xref:System.DateTime> および <xref:System.DateTimeOffset>。 (「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください)。  
  
-   すべての列挙型。 (「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください)。  
  
-   <xref:System.TimeSpan> 値。 (「[標準の Timespan 書式指定文字列](~/docs/standard/base-types/standard-timespan-format-strings.md)」および「[カスタム TimeSpan 書式指定文字列](~/docs/standard/base-types/custom-timespan-format-strings.md)」を参照してください)。  
  
-   GUID。 (<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> メソッドを参照してください)。  
  
 ただし、すべてのカスタム型は、<xref:System.IFormattable> を実装することも、既存の型の <xref:System.IFormattable> 実装を拡張することもできます。  
  
 次の例では、`alignment` 引数と `formatString` 引数を使用して、書式設定された出力を生成します。  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>引数の書式設定  
 書式項目は、文字列の先頭から順番に処理されます。 各書式指定項目には、メソッドの引数リスト内のオブジェクトに対応するインデックスがあります。 <xref:System.String.Format%2A> メソッドは、引数を取得し、その文字列形式を次のように派生させることができます。  
  
-   引数が `null`の場合、メソッドは結果の文字列に <xref:System.String.Empty?displayProperty=nameWithType> を挿入します。 Null 引数の <xref:System.NullReferenceException> の処理について心配する必要はありません。 
  
-   <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> オーバーロードを呼び出し、`provider` オブジェクトの <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 実装が null 以外の <xref:System.ICustomFormatter> 実装を返す場合、引数はその <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドに渡されます。 書式指定項目に*formatString*引数が含まれている場合は、メソッドに最初の引数として渡されます。 <xref:System.ICustomFormatter> 実装が使用可能で、null 以外の文字列が生成される場合、その文字列は引数の文字列形式として返されます。それ以外の場合は、次の手順が実行されます。  
  
-   引数が <xref:System.IFormattable> インターフェイスを実装する場合、その <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> の実装が呼び出されます。  
  
-   オーバーライドするか基底クラスの実装から継承する、引数のパラメーターなしの `ToString` メソッドが呼び出されます。  
  
 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> メソッドの呼び出しをインターセプトし、<xref:System.String.Format%2A> メソッドが複合書式指定文字列の各書式指定項目の書式指定メソッドに渡す情報を確認できる例については、「[例: インターセプトプロバイダーとローマ数字」を参照してください。フォーマッタ](#Format7_Example)。  

 詳細については、「[複合書式指定](~/docs/standard/base-types/composite-formatting.md)」の「[処理順序](~/docs/standard/base-types/composite-formatting.md##processing-order)」セクションを参照してください。  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>同じインデックスを持つ項目を書式設定する  
 <xref:System.String.Format%2A> メソッドは、インデックス項目のインデックスが引数リスト内の引数の数以上の場合に、<xref:System.FormatException> 例外をスローします。 ただし、複数の書式指定項目のインデックスが同じである限り、`format` には引数よりも多くの書式項目を含めることができます。 次の例の <xref:System.String.Format%28System.String%2CSystem.Object%29> メソッドの呼び出しでは、引数リストに1つの引数がありますが、書式指定文字列には2つの書式項目が含まれています。1つは数値の10進値を表示し、もう1つは16進数値を表示します。  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>書式設定とカルチャ  
 通常、引数リスト内のオブジェクトは、現在のカルチャの規則を使用して文字列形式に変換されます。これは、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティによって返されます。 この動作を制御するには、`provider` パラメーターを含む <xref:System.String.Format%2A> のいずれかのオーバーロードを呼び出します。 `provider` パラメーターは、書式設定プロセスを中程度にするために使用されるカスタムおよびカルチャ固有の書式設定情報を提供する、<xref:System.IFormatProvider> の実装です。  
  
 <xref:System.IFormatProvider> インターフェイスには、<xref:System.IFormatProvider.GetFormat%2A>の1つのメンバーがあります。これは、書式設定情報を提供するオブジェクトを返す役割を担います。 .NET には、カルチャ固有の書式設定を提供する3つの <xref:System.IFormatProvider> 実装があります。  
  
-   <xref:System.Globalization.CultureInfo>。 <xref:System.Globalization.CultureInfo.GetFormat%2A> メソッドは、数値を書式設定するためのカルチャ固有の <xref:System.Globalization.NumberFormatInfo> オブジェクト、および日付と時刻の値を書式設定するためのカルチャ固有の <xref:System.Globalization.DateTimeFormatInfo> オブジェクトを返します。  
  
-   <xref:System.Globalization.DateTimeFormatInfo>。日付と時刻の値のカルチャに固有の書式設定に使用されます。 <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> メソッドはそれ自体を返します。  
  
-   <xref:System.Globalization.NumberFormatInfo>。数値のカルチャ固有の書式設定に使用されます。 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> プロパティはそれ自体を返します。 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>カスタムの書式設定操作  
 また、<xref:System.IFormatProvider> 型の `provider` パラメーターを持つ <xref:System.String.Format%2A> メソッドの任意のオーバーロードを呼び出して、カスタムの書式設定操作を実行することもできます。 たとえば、整数を識別番号として、または電話番号として書式設定できます。 カスタム書式設定を実行するには、`provider` 引数に <xref:System.IFormatProvider> と <xref:System.ICustomFormatter> の両方のインターフェイスを実装する必要があります。 <xref:System.String.Format%2A> メソッドに `provider` 引数として <xref:System.ICustomFormatter> の実装が渡されると、<xref:System.String.Format%2A> メソッドはその <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> の実装を呼び出し、<xref:System.ICustomFormatter>型のオブジェクトを要求します。 次に、返された <xref:System.ICustomFormatter> オブジェクトの <xref:System.ICustomFormatter.Format%2A> メソッドを呼び出して、渡された複合文字列の各書式項目を書式設定します。  
  
 カスタム書式指定ソリューションの提供の詳細については、「[方法: カスタム数値書式プロバイダーを定義および使用](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)する」および「<xref:System.ICustomFormatter>」を参照してください。 整数を書式設定されたカスタム数値に変換する例については、「[例: カスタム書式指定操作](#Format6_Example)」を参照してください。 符号なしバイトをローマ数字に変換する例については、「[例: インターセプトプロバイダーとローマ数字フォーマッタ](#Format7_Example)」を参照してください。  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>例: カスタム書式設定操作  
 この例では、整数値を、"x-xxxxx-xx" の形式で顧客アカウント番号として書式設定する書式プロバイダーを定義します。  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>例: インターセプトプロバイダーとローマ数字のフォーマッタ  
 この例では、次の2つの処理を実行するために <xref:System.ICustomFormatter> インターフェイスと <xref:System.IFormatProvider> インターフェイスを実装するカスタム書式プロバイダーを定義します。  
  
-   <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> の実装に渡されたパラメーターが表示されます。 これにより、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> メソッドが、書式設定する各オブジェクトのカスタム書式設定の実装に渡すパラメーターを確認できます。 これは、アプリケーションをデバッグしているときに便利です。  
  
-   書式設定されるオブジェクトが、"R" 標準書式指定文字列を使用して書式設定される符号なしバイト値の場合、カスタムフォーマッタは数値をローマ数字として書式設定します。  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>文字列。 Q & A を書式設定します。  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>`String.Format` メソッドの呼び出しに対して文字列補間を推奨するのはなぜですか。

文字列補間は次のとおりです。

- より柔軟です。 複合書式指定をサポートするメソッドの呼び出しを必要とせずに、任意の文字列で使用できます。 それ以外の場合は、<xref:System.String.Format%2A> メソッド、または <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> や <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>などの複合書式指定をサポートする別のメソッドを呼び出す必要があります。 

- より読みやすくなります。 文字列に挿入する式は、引数リストではなく、挿入式に含まれるので、補間文字列の方がコードや読み取りがはるかに簡単になります。 より読みやすくなっているため、補間文字列は複合書式指定メソッドの呼び出しだけでなく、より簡潔で明確なコードを生成するために文字列連結操作でも使用できます。 

次の2つのコード例は、文字列の連結と複合書式指定メソッドの呼び出しに対する補間文字列の優位性を示しています。 次の例では、複数の文字列連結演算を使用して、詳細なコードと読み取り専用のコードを作成します。

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

これに対し、次の例では、挿入文字列を使用して、文字列連結ステートメントと前の例の <xref:System.String.Format%2A> メソッドの呼び出しよりも、より明確で簡潔なコードを生成します。

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>書式項目と共に使用できる定義済みの書式指定文字列の一覧はどこで確認できますか。  
  
-   すべての整数型と浮動小数点型については、「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
-   日付と時刻の値については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。  
  
-   列挙値については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。  
  
-   <xref:System.TimeSpan> 値については、「[標準の Timespan 書式指定文字列](~/docs/standard/base-types/standard-timespan-format-strings.md)」および「[カスタム TimeSpan 書式指定文字列](~/docs/standard/base-types/custom-timespan-format-strings.md)」を参照してください。  
  
-   <xref:System.Guid> 値については、<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> リファレンスページの「解説」を参照してください。  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>書式項目を置き換える結果文字列の配置を制御操作方法には  
 書式項目の一般的な構文は次のとおりです。  
  
```  
{index[,alignment][: formatString]}  
```  
  
 *alignment*は、フィールドの幅を定義する符号付き整数です。 この値が負の場合、フィールド内のテキストは左揃えになります。 正の場合、テキストは右に固定されます。  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>小数点区切り文字の後に桁数を制御操作方法には、  
 "D" を除くすべての[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)(整数のみで使用)、"G"、"R"、および "X" を使用すると、結果文字列の小数点以下の桁数を定義する精度指定子を使用できます。 次の例では、標準の数値書式指定文字列を使用して、結果文字列の小数点以下桁数を制御します。  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 [カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)を使用している場合は、次の例に示すように、"0" 書式指定子を使用して、結果文字列の小数点以下の桁数を制御します。  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>整数の桁数を制御操作方法には  
 既定では、書式設定操作には0以外の整数の数字のみが表示されます。 整数を書式設定する場合は、"D" および "X" の標準書式指定文字列で精度指定子を使用して、桁数を制御できます。  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 次の例に示すように、"0"[カスタム数値書式指定子](~/docs/standard/base-types/custom-numeric-format-strings.md)を使用して、整数または浮動小数点数を先行ゼロで埋め込んで、指定された数の整数を含む結果文字列を生成することができます。  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>[書式] の一覧に含めることができる項目の数はいくつですか。  
 実際の制限はありません。 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> メソッドの2番目のパラメーターには、<xref:System.ParamArrayAttribute> 属性がタグ付けされます。これにより、区切り記号付きリストまたはオブジェクト配列を書式リストとして含めることができます。  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>結果の文字列にリテラルの中かっこ ("{" および "}") を含める操作方法  
 たとえば、次のメソッド呼び出しによって <xref:System.FormatException> 例外がスローされないようにするにはどうすればよいでしょうか。  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 1つの左中かっこまたは右中かっこは、書式指定項目の先頭または末尾として常に解釈されます。 文字どおりに解釈されるようにするには、エスケープする必要があります。 かっこをエスケープするには、次のメソッド呼び出しのように、別の中かっこ ("{" および "}" ではなく "{{" および "}}") を追加します。  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 ただし、エスケープされた中かっこも簡単に解釈できます。 次の例に示すように、書式設定の一覧に中かっこを含め、書式項目を使用して結果の文字列に挿入することをお勧めします。  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>FormatException メソッドを呼び出すと、そのような例外がスローされるのはなぜですか。  
 例外の最も一般的な原因として、書式項目のインデックスが [書式] リストのオブジェクトに対応していないことが挙げられます。 通常、これは、書式項目のインデックスに番号が付けられていないか、[書式] ボックスの一覧にオブジェクトが含まれていないことを示します。 エスケープされていない左または右の中かっこ文字を含めようとすると、<xref:System.FormatException>もスローされます。 場合によっては、例外が発生することがあります。たとえば、一般的な誤りは、"{" (左中かっこ) ではなく "[" (左角かっこ) を誤って間違えてしまうことです。  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Format (IFormatProvider, System.string, System.object []) メソッドがパラメーター配列をサポートしている場合、配列を使用すると、コードで例外がスローされるのはなぜですか。  
 たとえば、次のコードでは <xref:System.FormatException> 例外がスローされます。  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 これは、コンパイラのオーバーロードの解決に問題があります。 コンパイラは、整数の配列をオブジェクト配列に変換できないので、整数配列を1つの引数として扱います。したがって、<xref:System.String.Format%28System.String%2CSystem.Object%29> メソッドを呼び出します。 この例外がスローされるのは、書式指定項目が4つありますが、書式一覧に項目が1つしかないためです。  
  
 Visual Basic もC#整数配列もオブジェクト配列に変換できないため、<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> メソッドを呼び出す前に、変換を自分で実行する必要があります。 次の例では、1つの実装を示します。  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

<xref:System.String.Format%2A> メソッドを呼び出す多くの例は、この記事の「[解説](#remarks-top)」セクションに記載されています。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

また、 [dotnet/samples GitHub リポジトリ](https://github.com/dotnet/samples)から、[のC# .net core 2.0 プロジェクト](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip)と[Visual Basic 用の .net core 2.0 プロジェクト](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)が含まれている `String.Format` の例の完全なセットをダウンロードすることもできます。

記事に含まれている例の一部を次に示します。

### <a name="create-a-format-string"></a>書式指定文字列の作成

[文字列の挿入](#inserting-a-string)  
[書式項目](#the-format-item)  
[同じインデックスを持つ項目を書式設定する](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>書式設定された出力の制御

[書式設定の制御](#controlling-formatting)  
[制御 (間隔を)](#controlling-spacing)  
[制御 (配置を)](#controlling-alignment)  
[整数部の桁数を制御する](#how-do-i-control-the-number-of-integral-digits)  
[小数点区切り文字の後の桁数を制御する](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[結果の文字列にリテラルの中かっこを含める](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>書式指定文字列のカルチャを区別する

[カルチャに依存した書式設定](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>書式設定操作をカスタマイズする

[カスタムの書式設定操作](#example-a-custom-formatting-operation)  
[インターセプトプロバイダーとローマ数字フォーマッタ](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>文字列の 1 つ以上の書式項目を、指定されたオブジェクトの文字列表記に置換します。</summary>
        <returns>書式項目が <paramref name="format" /> の文字列形式に置換された <paramref name="arg0" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、式の値を文字列形式に変換し、その表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>例: 1 つの引数の書式設定  
 
 次の例では、<xref:System.String.Format%28System.String%2CSystem.Object%29> メソッドを使用して、文字列の途中に個々の年齢を埋め込みます。  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> の書式指定項目が正しくありません。  
  
- または - 
書式項目のインデックスが 0 ではありません。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>指定した文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、4つ以上の式の値を文字列形式に変換し、それらの表現を文字列に埋め込みます。 `args` パラメーターは <xref:System.ParamArrayAttribute?displayProperty=nameWithType> 属性でマークされているため、オブジェクトを個々の引数として、または <xref:System.Object> 配列としてメソッドに渡すことができます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>例: 3 つ以上の引数の書式設定  
 
 この例では、特定の日付の高および低気温に関するデータを格納する文字列を作成します。 複合書式指定文字列には、 C#例では5つの書式項目があり、Visual Basic の例では6個の書式項目があります。 2つの書式項目は、対応する値の文字列表現の幅を定義し、最初の書式指定項目には標準の日時書式指定文字列も含まれます。  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 また、オブジェクトを引数リストとしてではなく配列として渡すこともできます。  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 (ゼロ) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>指定した文字列の 1 つまたは複数の書式項目を、対応するオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="format" /> の文字列形式に置換された <paramref name="arg0" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、式の値を文字列形式に変換し、その表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 **tostring (IFormatProvider)** メソッドを呼び出すことによって `arg0` を文字列形式に変換します。または、オブジェクトの対応する書式指定項目に**tostring (string, IFormatProvider)** メソッドを呼び出して書式指定文字列を含めます。 これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列表記に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、4つ以上の式を文字列形式に変換し、それらの表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 **tostring (IFormatProvider)** メソッドを呼び出すことによって各 <xref:System.Object> 引数を文字列形式に変換します。または、オブジェクトの対応する書式指定項目に**tostring (string, IFormatProvider) を呼び出すことによって書式文字列が含まれている場合は、を呼び出します。** メソッド。 これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" /> 

### <a name="example-culture-sensitive-formatting"></a>例: カルチャに依存した書式設定

 この例では、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> メソッドを使用して、いくつかの異なるカルチャを使用して、一部の日付と時刻の値と数値の文字列形式を表示します。  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 (ゼロ) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="arg0" /> と <paramref name="arg1" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、2つの式の値を文字列形式に変換し、それらの表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>例: 2 つの引数の書式設定  
 
 この例では、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> メソッドを使用して、ジェネリック <xref:System.Collections.Generic.Dictionary%602> オブジェクトに格納されている時間と気温のデータを表示します。 書式指定文字列には3つの書式項目があることに注意してください。ただし、書式設定するオブジェクトは2つだけです。 これは、リスト内の最初のオブジェクト (日付と時刻の値) が2つの書式指定項目によって使用されるためです。最初の書式項目は時刻を表示し、2番目のオブジェクトは日付を表示します。  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 でも 1 でもありません。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="arg0" /> と <paramref name="arg1" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、2つの式を文字列形式に変換し、それらの表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 **tostring (IFormatProvider)** メソッドを呼び出すことによって各 <xref:System.Object> 引数を文字列形式に変換します。または、オブジェクトの対応する書式指定項目に**tostring (string, IFormatProvider) を呼び出すことによって書式文字列が含まれている場合は、を呼び出します。** メソッド。 これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 でも 1 でもありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。3 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、3つの式の値を文字列形式に変換し、それらの表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>例: 3 つの引数の書式設定  
 
 この例では、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> メソッドを使用して、2つの整数値を持つブール `And` 演算の結果を示す文字列を作成します。 書式指定文字列には6つの書式項目が含まれていますが、各項目は2つの異なる方法で書式設定されるため、メソッドのパラメーターリストには3つの項目しかありません。  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 より小さいか、または 2 より大きい値です。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。3 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式設定情報を指定します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、3つの式を文字列形式に変換し、それらの表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 **tostring (IFormatProvider)** メソッドを呼び出すことによって各 <xref:System.Object> 引数を文字列形式に変換します。または、オブジェクトの対応する書式指定項目に**tostring (string, IFormatProvider) を呼び出すことによって書式文字列が含まれている場合は、を呼び出します。** メソッド。 これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 より小さいか、または 2 より大きい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列に含まれる個々の文字を反復処理するオブジェクトを取得します。</summary>
        <returns>列挙子オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> <xref:System.String.GetEnumerator%2A> メソッドを呼び出して、文字列を列挙するために使用する <xref:System.CharEnumerator> オブジェクトを取得するのではなく、代わりに言語の反復構造を使用C#する必要C++があります (では、/clr では、Visual Basic)。 [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#、for [each](/cpp/dotnet/for-each-in) C++ [、および Visual Basic](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) )。
  
 このメソッドを使用すると、文字列内の個々の文字を反復処理できます。 たとえば、Visual Basic の `For Each` ステートメントとC#`foreach`ステートメントは、このメソッドを呼び出して、この文字列インスタンス内の文字への読み取り専用アクセスを提供できる<xref:System.CharEnumerator>オブジェクトを返します。  
  
   
  
## Examples  
 次の例では、複数の文字列の文字を反復処理し、個々の文字についての情報を表示します。 この例では、<xref:System.String.GetEnumerator%2A> メソッドの呼び出しではなく、言語イテレーション構成を使用しています。  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.GetHashCode%2A> の動作は、実装によって異なります。これは、共通言語ランタイムのあるバージョンから別のバージョンに変更される可能性があります。 これが発生する原因として、<xref:System.String.GetHashCode%2A>のパフォーマンスが向上することが考えられます。  
  
> [!IMPORTANT]
>  2つの文字列オブジェクトが等しい場合、<xref:System.String.GetHashCode%2A> メソッドは同一の値を返します。 ただし、一意の文字列値ごとに一意のハッシュコード値はありません。 異なる文字列は、同じハッシュコードを返すことができます。  
>   
>  ハッシュコード自体は、安定しているとは限りません。 同じ文字列のハッシュコードは、.net の実装間、.net の複数のバージョン間、.net の1つのバージョンの .net プラットフォーム (32 ビットや64ビットなど) で異なる場合があります。 場合によっては、アプリケーションドメインによって異なる場合もあります。 これは、同じプログラムの2回目の実行で異なるハッシュコードが返される可能性があることを意味します。  
>   
>  このため、ハッシュコードは、作成されたアプリケーションドメインの外部では使用できません。また、コレクションのキーフィールドとして使用することは避け、永続化しないでください。  
>   
>  最後に、暗号ハッシュ関数によって返される値の代わりに、暗号強度の高いハッシュが必要な場合は、ハッシュコードを使用しないでください。 暗号化ハッシュの場合は、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> または <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> クラスから派生したクラスを使用します。  
>   
>  ハッシュコードの詳細については、「<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>」を参照してください。  
  
 デスクトップアプリでは、 [\<UseRandomizedStringHashAlgorithm > 要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)を使用して、アプリケーションドメインごとに一意のハッシュコードを生成できます。 これにより、競合の数を減らし、ハッシュテーブルを使用する挿入と参照の全体的なパフォーマンスを向上させることができます。 次の例は、 [\<UseRandomizedStringHashAlgorithm > 要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)の使用方法を示しています。 このクラスは、"This is a string" という値を持つプライベート文字列定数 `s`を含む `DisplayString` クラスを定義します。 また、メソッドを実行しているアプリケーション ドメインの名前と共に文字列値とハッシュ コードを表示する `ShowStringHashCode` メソッドも含まれています。
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 構成ファイルを指定せずにこの例を実行すると、次のような出力が表示されます。 文字列のハッシュ コードが 2 つアプリケーション ドメインで同じであることに注意してください。  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 ただし、例のディレクトリに次の構成ファイルを追加して例を実行すると、同じ文字列のハッシュ コードがアプリケーション ドメインによって異なります。  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 構成ファイルが存在する場合、次の出力が表示されます。  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  ハッシュ コードは、ハッシュ テーブルからキーを持つオブジェクトを効率的に挿入および取得するために使用されます。 ただし、ハッシュ コードは、文字列を一意に識別しません。 同一の文字列は同じハッシュコードを持ちますが、共通言語ランタイムは同じハッシュコードを異なる文字列に割り当てることもできます。 さらに、ハッシュコードは、.NETのバージョン、単一バージョンでプラットフォームとアプリケーション ドメインを変更できます。 このため、ハッシュコードの値をシリアル化したり永続化したり、ハッシュテーブルまたはディクショナリのキーとして使用したりしないでください。  
  
 ハッシュコードと `GetHashCode` メソッドの使用方法の詳細については、「<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例は、さまざまな入力文字列を使用して <xref:System.String.GetHashCode%2A> メソッドを示しています。  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><see cref="M:System.String.GetHashCode" /> によって返される値は、プラットフォームに依存します。 これは、.NET Framework の32ビットバージョンと64ビットバージョンで異なります。 また、.NET Framework と .NET Core のバージョンによって異なる場合もあります。</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; 要素</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">読み取り専用の文字スパン。</param>
        <summary>指定された読み取り専用文字スパンのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された規則を使用して、この文字列のハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">読み取り専用の文字スパン。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された規則を使用して、指定された読み取り専用の文字スパンのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インデックス 0 にある文字列の要素への参照を返します。</summary>
        <returns>インデックス 0 にある文字列の要素への参照を表す文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`GetPinnableReference` メソッドは、メモリ内の <xref:System.String> をピン留めするために使用できる文字を返します。 これは、fixed ステートメント内での <xref:System.String> の使用をサポートするために必要です。

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">文字列が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.String" /> クラスには <see cref="T:System.TypeCode" /> を返します。</summary>
        <returns>列挙型定数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、<xref:System.String> 型の <xref:System.TypeCode> 列挙定数を表示します。  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最初に出現する指定 Unicode 文字または文字列の 0 から始まるインデックスをレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例は、<xref:System.String.IndexOf%2A> メソッドを使用して文字の <xref:System.String> を検索する方法を示しています。  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。 検索は、このインスタンスの最初の文字位置から開始し、最後の文字位置まで続行されます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 `value` が1つ以上の無視できる文字で構成されている場合、<xref:System.String.IndexOf%28System.String%29> メソッドは常に 0 (ゼロ) を返して、現在のインスタンスの先頭で一致が見つかったことを示します。 次の例では、<xref:System.String.IndexOf%28System.String%29> メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00AD)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、ソフトハイフンが無視できない文字であるため、結果は `value`にソフトハイフンが含まれていなかった場合と同じになります。 ソフトハイフンのみを検索する場合、メソッドは、文字列の先頭に一致するものが見つかったことを示す 0 (ゼロ) を返します。  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 次の例では、"animal" の "n" を検索します。 文字列インデックスは1ではなく0から始まるので、<xref:System.String.IndexOf%28System.String%29> メソッドは、"n" が1の位置にあることを示します。  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 次の例では、<xref:System.String.IndexOf%2A> メソッドを使用して、文に含まれる動物名の開始位置を決定します。 次に、この位置を使用して、動物を記述する形容詞を文に挿入します。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して、文字列インスタンス内の部分文字列の最初のインデックスを検索するには、`comparisonType` パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> 値を指定して <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> メソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは0から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 `startIndex` が文字列インスタンスの長さと等しい場合、メソッドは-1 を返します。  
  
 検索範囲は、`startIndex` から文字列の末尾までとなります。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 <xref:System.String.IndexOf%2A>メソッドの例を次に示します。  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 (ゼロ) 未満か、または文字列の長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">検索対象の文字。</param>
        <param name="comparisonType">検索の規則を指定する列挙値。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 指定した文字に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

インデックス番号は0から始まります。  
  
`comparisonType` パラメーターは、`value` 引数の検索で現在のカルチャまたはインバリアントカルチャを使用するか、大文字と小文字を区別するか、または大文字と小文字を区別するかを指定する、<xref:System.StringComparison> 列挙体メンバーです。または、単語または序数の比較規則を使用します。
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは0から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 `startIndex` が文字列インスタンスの長さと等しい場合、メソッドは-1 を返します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。 検索は、このインスタンスの `startIndex` 文字位置から開始し、最後の文字位置まで続行されます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 `value` が1つ以上の無視できる文字で構成されている場合、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> メソッドは常に `startIndex`を返します。これは、検索を開始する文字の位置です。 次の例では、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> メソッドを使用して、ソフトハイフン (U + 00AD) の後に2つの文字列の "m" が続く位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、ソフトハイフンが無視できない文字であるため、メソッドは文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 次の例では、対象の文字列内で指定された文字列のすべての出現箇所を検索します。  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して特定の文字位置より後に出現する部分文字列の最初のインデックスを検索するには、その `comparisonType` パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> 値を指定して、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> メソッドのオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターのインデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 `comparisonType` パラメーターは、大文字と小文字を区別するか、大文字と小文字を区別しない検索を使用し、word または序数の比較規則を使用して、現在のカルチャまたはインバリアントカルチャを使用して `value` パラメーターを検索するように指定します。  
  
   
  
## Examples  
 次の例は、<xref:System.StringComparison> 列挙体の異なる値を使用して、別の文字列内で最初に出現する文字列を検索する、<xref:System.String.IndexOf%2A> メソッドの3つのオーバーロードを示しています。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 <paramref name="value" /> が1つ以上の無視できる文字で構成されている場合、<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> メソッドは常に 0 (ゼロ) を返して、現在のインスタンスの先頭で一致が見つかったことを示します。  
  
次の例では、<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00AD)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合は、ソフトハイフンが無視できる文字であるため、カルチャに依存した検索では、検索文字列にソフトハイフンが含まれていない場合に返されるのと同じ値が返されます。 ただし、序数検索では、1つの文字列でソフトハイフンが正常に検出され、2番目の文字列に存在しないことが報告されます。  
  
[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定文字がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索は `startIndex` から開始され、 + `count`-1 `startIndex`続行されます。 `startIndex` + `count` の文字が検索に含まれていません。  
  
 インデックスの番号付けは 0 (ゼロ) から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 <xref:System.String.IndexOf%2A>メソッドの例を次に示します。  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは 0 (ゼロ) から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。 検索は `startIndex` から開始され、 + `count`-1 `startIndex`続行されます。 `startIndex` + `count` の文字が検索に含まれていません。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 `value` が1つ以上の無視できる文字で構成されている場合、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> メソッドは常に `startIndex`を返します。これは、検索を開始する文字の位置です。 次の例では、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> メソッドを使用して、2つの文字列の3番目から6番目までの文字位置から、ソフトハイフン (U + 00AD) の後に "m" を続けた位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、どちらの場合も、ソフトハイフンが無視できない文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内に出現する文字列 "he" のインデックスを検索します。 検索反復処理のたびに、検索する文字数を再計算する必要があることに注意してください。  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用してこの操作を実行するには、`comparisonType` パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> 値を指定して <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列内での検索の開始位置、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは0から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 `startIndex` が文字列インスタンスの長さと等しい場合、メソッドは-1 を返します。  
  
 `comparisonType` パラメーターは、大文字と小文字を区別するか、大文字と小文字を区別しない検索を使用し、word または序数の比較規則を使用して、現在のカルチャまたはインバリアントカルチャを使用して `value` パラメーターを検索するように指定します。  
  
   
  
## Examples  
 次の例は、<xref:System.StringComparison> 列挙体の異なる値を使用して、別の文字列内で最初に出現する文字列を検索する、<xref:System.String.IndexOf%2A> メソッドの3つのオーバーロードを示しています。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 <paramref name="value" /> が1つ以上の無視できる文字で構成されている場合、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> メソッドは常に <paramref name="startIndex" />を返します。これは、検索を開始する文字の位置です。  
  
次の例では、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> メソッドを使用して、ソフトハイフン (U + 00AD) の後に2つの文字列の3番目の文字位置から始まる "m" を検索します。 文字列の1つだけが、必須の部分文字列を含んでいます。この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、どちらの場合も、ソフトハイフンが無視できない文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列での検索開始位置、現在の文字列で検索する文字の数、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは 0 (ゼロ) から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 検索は `startIndex` から開始され、 + `count`-1 `startIndex`続行されます。 `startIndex` + `count` の文字が検索に含まれていません。  
  
 `comparisonType` パラメーターは、大文字と小文字を区別するか、大文字と小文字を区別しない検索を使用し、word または序数の比較規則を使用して、現在のカルチャまたはインバリアントカルチャを使用して `value` パラメーターを検索するように指定します。  
  
   
  
## Examples  
 次の例は、<xref:System.StringComparison> 列挙体の異なる値を使用して、別の文字列内で最初に出現する文字列を検索する、<xref:System.String.IndexOf%2A> メソッドの3つのオーバーロードを示しています。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> はこのインスタンスの長さを超えています。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 <paramref name="value" /> が1つ以上の無視できる文字で構成されている場合、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドは常に <paramref name="startIndex" />を返します。これは、検索を開始する文字の位置です。  
  
次の例では、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドを使用して、2つの文字列の3番目から6番目までの文字位置から、ソフトハイフン (U + 00AD) の後に "m" を続けた位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、どちらの場合も、ソフトハイフンが無視できない文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 ただし、序数による比較を実行する場合は、最初の文字列でのみ部分文字列が検索されます。 ソフトハイフンの後に "m" が続く最初の文字列の場合、メソッドはソフトハイフンのインデックスを返すのではなく、カルチャに依存した比較を実行するときに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置のインデックスをレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 `anyOf` の検索では大文字と小文字が区別されます。 `anyOf` が空の配列の場合、メソッドは文字列の先頭 (インデックス 0) で一致を検索します。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、文字列内の最初の母音を検索します。  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 `startIndex` パラメーターは、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
 検索範囲は、`startIndex` から文字列の末尾までとなります。  
  
 `anyOf` の検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内の文字列 "is" 内の任意の文字が出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索は `startIndex` から開始され、 + `count`-1 `startIndex`続行されます。 `startIndex` + `count` の文字が検索に含まれていません。  
  
 インデックス番号は0から始まります。 `startIndex` パラメーターは、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
 `anyOf` の検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内で文字列 "aid" の任意の文字が出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="count" /> + <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">挿入の 0 から始まるインデックス位置。</param>
        <param name="value">挿入する文字列。</param>
        <summary>このインスタンス内の指定したインデックス位置に指定した文字列を挿入する場合の、新しい文字列を返します。</summary>
        <returns>このインスタンスと等価で、<paramref name="value" /> の位置に <paramref name="startIndex" /> が挿入された新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `startIndex` がこのインスタンスの長さと等しい場合、`value` がこのインスタンスの末尾に追加されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスに `value` が挿入される新しい文字列を返します。  
  
 たとえば、`"abc".Insert(2, "XYZ")` の戻り値は "abXYZc" です。  
  
   
  
## Examples  
 次の例では、文字列の4番目の文字位置 (インデックス3の文字) に空白文字を挿入します。  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 次のコンソールアプリケーションは、2つの動物を説明するために1つ以上の形容詞を入力するようユーザーに求めます。 次に、<xref:System.String.Insert%2A> メソッドを呼び出して、ユーザーが入力したテキストを文字列に挿入します。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が負の数値か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> へのシステム参照を取得します。</summary>
        <returns><paramref name="str" /> がインターン プールに存在する場合は、それに対するシステム参照。それ以外の場合は、値が <paramref name="str" /> の文字列への新しい参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムは、インターンプールと呼ばれるテーブルを保持することによって文字列ストレージを節約します。このテーブルには、プログラムで宣言またはプログラムによって作成された一意のリテラル文字列への単一の参照が含まれています。 その結果、特定の値を持つリテラル文字列のインスタンスは、システム内に1回だけ存在します。  
  
 たとえば、同じリテラル文字列を複数の変数に割り当てた場合、ランタイムは、インターンプールからリテラル文字列への同じ参照を取得し、各変数に代入します。  
  
 <xref:System.String.Intern%2A> メソッドは、インターンプールを使用して、`str`の値と等しい文字列を検索します。 このような文字列が存在する場合は、インターンプール内のその参照が返されます。 文字列が存在しない場合は、`str` への参照がインターンプールに追加されると、その参照が返されます。  
  
 次の例では、値が "MyTest" の文字列 s1 は、プログラム内のリテラルであるため、既にインターンされています。 <xref:System.Text.StringBuilder?displayProperty=nameWithType> クラスは、s1 と同じ値を持つ新しい文字列オブジェクトを生成します。 その文字列への参照が s2 に割り当てられます。 <xref:System.String.Intern%2A> メソッドは、s2 と同じ値を持つ文字列を検索します。 このような文字列が存在するので、このメソッドは s1 に割り当てられているのと同じ参照を返します。 その後、その参照が s3 に割り当てられます。 参照 s1 と s2 は異なるオブジェクトを参照しているため、等しくないと比較します。参照 s1 と s3 は同じ文字列を参照しているため、等しいと比較されます。  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 このメソッドと <xref:System.String.IsInterned%2A> メソッドを比較します。  
  
## <a name="version-considerations"></a>バージョンに関する考慮事項  
 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]では、<xref:System.String.Intern%2A> メソッドは、インターンが空の文字列であることに関して、.NET Framework 1.0 および1.1 での動作に戻ります。 次の例では、変数 `str1` に <xref:System.String.Empty?displayProperty=nameWithtype>への参照が割り当てられています。変数 `str2` には、<xref:System.String.Intern%2A> オブジェクトを変換した後に <xref:System.Text.StringBuilder> メソッドを呼び出して返される <xref:System.String.Empty?displayProperty=nameWithtype> への参照が割り当てられています。文字列。<xref:System.String.Empty?displayProperty=nameWithtype> 次に、`str1` と `str2` に含まれる参照が等しいかどうかを比較します。  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]、[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]、および [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]では、`str1` と `str2` が等しいことを示します。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] と [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]では、`str1` と `str2` が等しくありません。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 アプリケーションによって割り当てられるメモリの総量を減らす場合は、インターン文字列に2つの望ましくない副作用があることに注意してください。 まず、インターンが <xref:System.String> オブジェクトに割り当てられたメモリは、共通言語ランタイム (CLR) が終了するまで解放されない可能性があります。 その理由は、アプリケーションまたはアプリケーションドメインが終了した後も、インターン化された <xref:System.String> オブジェクトへの CLR の参照が保持される可能性があるためです。 次に、文字列をインターンさせるには、最初に文字列を作成する必要があります。 メモリが最終的にガベージコレクトされる場合でも、<xref:System.String> オブジェクトによって使用されるメモリを割り当てる必要があります。  
  
 .NET Framework バージョン2.0 では、<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> 列挙メンバーが導入されています。 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> メンバーは、アセンブリをリテラル文字列インターンを必要としないものとしてマークします。 <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> 属性を使用して、アセンブリに <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> を適用できます。 また、 [ngen.exe (ネイティブイメージジェネレーター)](~/docs/framework/tools/ngen-exe-native-image-generator.md)を使用して、実行時より前にアセンブリをコンパイルする場合、文字列はモジュール間でインターンプールされません。  
  
   
  
## Examples  
 次の例では、値が等しい3つの文字列を使用して、新しく作成された文字列とインターンされた文字列が等しいかどうかを判断します。  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> への参照を取得します。</summary>
        <returns><paramref name="str" /> が共通言語ランタイムのインターン プール内にある場合は、それへの参照。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムは、インターンプールと呼ばれるテーブルを自動的に保持します。このテーブルには、プログラムで宣言された一意のリテラル文字列定数の1つのインスタンスと、を呼び出してプログラムで追加した <xref:System.String> の一意のインスタンスが含まれます。<xref:System.String.Intern%2A> メソッド。  
  
 インターンプールは、文字列ストレージを節約します。 リテラル文字列定数を複数の変数に割り当てた場合、同じ値を持つ <xref:System.String> の複数のインスタンスを参照するのではなく、各変数がインターンプールで同じ定数を参照するように設定されます。  
  
 このメソッドは、インターンプール内の `str` を検索します。 `str` が既にインターンされている場合は、そのインスタンスへの参照が返されます。それ以外の場合は `null` が返されます。  
  
 このメソッドと <xref:System.String.Intern%2A> メソッドを比較します。  
  
 このメソッドは、ブール値を返しません。 特定の文字列がインターンされているかどうかを示すブール値が必要なためにメソッドを呼び出す場合は、次のようなコードを使用できます。  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  .NET Framework バージョン2.0 以降では、 [ngen.exe (ネイティブイメージジェネレーター)](~/docs/framework/tools/ngen-exe-native-image-generator.md)を使用してローカルコンピューターのネイティブイメージキャッシュにアセンブリをインストールするときに、インターンプールの使用を無効にすることができます。 詳細については、「<xref:System.String.Intern%2A> プロパティ」の「解説」の「パフォーマンスに関する考慮事項」を参照してください。  
  
   
  
## Examples  
 次の例は、リテラル文字列がコンパイラによって自動的にインターンされることを示しています。  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列が、特定の Unicode 正規形であるかどうかを示します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列が、Unicode 正規形 C であるかどうかを示します。</summary>
        <returns>この文字列が正規形 C である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 現在、.NET では、C、D、KC、および KD の正規化形式がサポートされています。  
  
 サポートされている Unicode 正規化形式の詳細については、「<xref:System.Text.NormalizationForm?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列がさまざまな正規化形式に正常に正規化されたかどうかを判断します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> メソッドは、文字列内の最初の非正規化文字が検出された直後に <see langword="false" /> を返します。 したがって、文字列に正規化されていない文字が含まれ、その後に無効な Unicode 文字が続く場合は、<see cref="Overload:System.String.Normalize" /> メソッドによって <see cref="T:System.ArgumentException" /> がスローされますが、<see cref="Overload:System.String.IsNormalized" /> は <see langword="false" />を返します。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列が、指定された Unicode 正規形であるかどうかを示します。</summary>
        <returns>この文字列が <see langword="true" /> パラメーターに指定された正規形である場合は <paramref name="normalizationForm" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 現在、.NET では、C、D、KC、および KD の正規化形式がサポートされています。  
  
 サポートされている Unicode 正規化形式の詳細については、「<xref:System.Text.NormalizationForm?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例は、<xref:System.String.IsNormalized%2A> メソッドと <xref:System.String.Normalize%2A> メソッドを示しています。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> メソッドは、文字列内の最初の非正規化文字が検出された直後に <see langword="false" /> を返します。 したがって、文字列に正規化されていない文字が含まれ、その後に無効な Unicode 文字が続く場合は、<see cref="Overload:System.String.Normalize" /> メソッドによって <see cref="T:System.ArgumentException" /> がスローされますが、<see cref="Overload:System.String.IsNormalized" /> は <see langword="false" />を返します。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または空の文字列 ("") であるかどうかを示します。</summary>
        <returns><paramref name="value" /> パラメーターが <see langword="null" /> または空の文字列 ("") の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> は、<xref:System.String> が `null` か、その値が <xref:System.String.Empty?displayProperty=nameWithType>かどうかを同時にテストできる便利なメソッドです。 これは、次のコードと同じです。  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 <xref:System.String.IsNullOrWhiteSpace%2A> メソッドを使用して、文字列が `null`か、その値が <xref:System.String.Empty?displayProperty=nameWithType>か、または空白文字だけで構成されているかをテストできます。  
  
## <a name="what-is-a-null-string"></a>Null 文字列とは何ですか。

値 ( C++および Visual Basic) が割り当てられていない場合、または明示的に`null`の値が割り当てられている場合は、文字列が `null` されます。 次の例に示すように、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能は null 文字列を適切に処理できますが、メンバーが <xref:System.NullReferenceException>をスローする場合は、を呼び出すようにします。  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>空の文字列とは何ですか。  

空の文字列 ("") または <xref:System.String.Empty?displayProperty=nameWithType>が明示的に割り当てられている場合、文字列は空になります。 空の文字列の <xref:System.String.Length%2A> は0です。  次の例では、空の文字列を作成し、その値とその長さを表示します。  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 次の例では、3つの文字列を調べて、各文字列に値があるか、空の文字列であるか、または `null`かどうかを判断します。  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または空であるか、空白文字だけで構成されているかどうかを示します。</summary>
        <returns><see langword="true" /> パラメーターが <paramref name="value" /> または <see langword="null" /> であるか、<see cref="F:System.String.Empty" /> が空白文字だけで構成されている場合は <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> は、優れたパフォーマンスを提供する点を除いて、次のコードのような便利な方法です。  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 空白文字は、Unicode 規格で定義されています。 <xref:System.String.IsNullOrWhiteSpace%2A> メソッドは、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに空白文字として渡されるときに `true` の値を返す任意の文字を解釈します。  
  
   
  
## Examples  
 次の例では、文字列配列を作成し、配列の各要素を <xref:System.String.IsNullOrWhiteSpace%2A> メソッドに渡します。  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列の要素またはコレクションのメンバーを連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="values">文字列表現が連結されるオブジェクトの配列。</param>
        <summary>各メンバー間に指定した区切り記号を使用して、オブジェクトの配列の文字列表現を連結します。</summary>
        <returns><paramref name="separator" /> 文字で区切られた、<paramref name="values" /> の要素で構成される文字列。

- または -

<paramref name="values" /> に要素がない、または <paramref name="values" /> のすべての要素が <see langword="null" /> の場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="value">連結する文字列の配列。</param>
        <summary>各メンバー間に指定した区切り記号を使用して、文字列の配列を連結します。</summary>
        <returns><paramref name="separator" /> 文字で区切られた、<paramref name="value" /> の要素で構成される文字列。

- または -

<paramref name="value" /> に要素がない、または <paramref name="value" /> のすべての要素が <see langword="null" /> の場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。<paramref name="separator" /> が返される文字列に含まれるのは、<paramref name="values" /> が 2 つ以上の要素を含む場合に限られます。</param>
        <param name="values">連結する文字列を格納しているコレクション。</param>
        <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。

- または -

<paramref name="values" /> に要素がない、または <paramref name="values" /> のすべての要素が <see langword="null" /> の場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `separator` が `null`場合は、代わりに空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) が使用されます。 `values` のいずれかのメンバーが `null`場合は、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> は、最初に要素を文字列配列に変換しなくても、`IEnumerable(Of String)` コレクション内の各要素を連結できる便利なメソッドです。 これは、統合言語クエリ (LINQ) クエリ式で特に便利です。 次の例では、アルファベットの大文字または小文字を含む `List(Of String)` オブジェクトを、特定の文字以上の文字 (例では "M") を選択するラムダ式に渡します。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> メソッドによって返された `IEnumerable(Of String)` コレクションを <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> メソッドに渡して、結果を1つの文字列として表示します。  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 <xref:System.String>型の <xref:System.Collections.Generic.List%601> オブジェクトに結果を代入し、その後 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> メソッドに渡します。  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="values" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="values">連結する要素を格納している配列。</param>
        <summary>オブジェクト配列の要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="values" /> の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `separator` が `null` 場合、または最初の要素以外の `values` のいずれかの要素が `null`の場合は、代わりに空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) が使用されます。 `values` の最初の要素が `null`場合は、「呼び出し元のメモ」セクションを参照してください。  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> は、要素を文字列に明示的に変換せずに、オブジェクト配列の各要素を連結できる便利なメソッドです。 配列内の各オブジェクトの文字列形式は、そのオブジェクトの `ToString` メソッドを呼び出すことによって派生されます。  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 結果を整数の配列に代入し、次に <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> メソッドに渡します。  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
        <block subset="none" type="usage"><para><paramref name="values" /> の最初の要素が <see langword="null" />場合、<see cref="M:System.String.Join(System.String,System.Object[])" /> メソッドは <paramref name="values" /> 内の要素を連結するのではなく、<see cref="F:System.String.Empty" />を返します。 この問題の回避策は多数あります。 最も簡単な方法は、次の例に示すように、配列の最初の要素に <see cref="F:System.String.Empty" /> の値を割り当てることです。  
  
[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String()) As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <summary>文字列配列のすべての要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="value" /> 内の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="value" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、`separator` が "," で、`value` の要素が "apple"、"オレンジ"、"grape"、および "pear" の場合、`Join(separator, value)` は "apple, オレンジ, grape, pear" を返します。  
  
 `separator` が `null`場合は、代わりに空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) が使用されます。 `value` 内のいずれかの要素が `null`場合は、空の文字列が代わりに使用されます。  
  
   
  
## Examples  
 <xref:System.String.Join%2A>メソッドの例を次に示します。  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">各メンバー間に指定した区切り記号を使用して、文字列の配列を連結します。指定したインデックス位置にある要素から開始し、指定した数の要素を含めます。</param>
        <param name="value">連結する文字列の配列。</param>
        <param name="startIndex">連結する <paramref name="value" /> の最初の項目。</param>
        <param name="count"><paramref name="startIndex" /> の位置にある要素で始まる、連結する <paramref name="value" /> からの要素の数。</param>
        <summary>各メンバー間に指定した区切り記号を使用して、文字列の配列を連結します。<paramref name="startIndex" /> の位置に配置された <paramref name="value" /> 内の要素から開始し、<paramref name="count" /> 要素までを連結します。</summary>
        <returns><paramref name="separator" /> 文字で区切られた、<paramref name="value" /> の要素で構成される文字列。

- または -

<paramref name="count" /> が 0 である場合、<paramref name="value" /> に要素がない場合、または <paramref name="value" /> のすべての要素が <see langword="null" /> または <see cref="F:System.String.Empty" /> である場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="count" /> が負の値です。

- または -

<paramref name="startIndex" /> が <paramref name="value" />  - <paramref name="count" /> の長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <param name="startIndex">使用する <paramref name="value" /> の最初の要素。</param>
        <param name="count">使用する <paramref name="value" /> の要素の数。</param>
        <summary>文字列配列の指定した要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="value" /> 内の文字列からなる、<paramref name="separator" /> 文字列で区切られた文字列。  
  
- または - 
 <see cref="F:System.String.Empty" /> が 0 である場合、または <paramref name="count" /> に要素がない場合、または <paramref name="value" /> と <paramref name="separator" /> のすべての要素が <paramref name="value" /> である場合、<see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、`separator` が "," で、`value` の要素が "apple"、"オレンジ"、"grape"、および "pear" の場合、`Join(separator, value, 1, 2)` は "オレンジ, grape" を返します。  
  
 `separator` が `null`場合は、代わりに空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) が使用されます。 `value` 内のいずれかの要素が `null`場合は、空の文字列が代わりに使用されます。  
  
   
  
## Examples  
 次の例では、果物という名前の配列の2つの要素を連結しています。  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。

- または -

<paramref name="startIndex" /> と <paramref name="count" /> を加算すると、 <paramref name="value" />にある要素の数を超えます。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> のメンバーの型。</typeparam>
        <param name="separator">区切り記号として使用する文字。 <paramref name="values" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="values">連結するオブジェクトを格納しているコレクション。</param>
        <summary>コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="separator" /> 文字で区切られた <paramref name="values" /> のメンバーで構成される文字列。 <paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> のメンバーの型。</typeparam>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="values" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="values">連結するオブジェクトを格納しているコレクション。</param>
        <summary>コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `separator` が `null`場合は、代わりに空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) が使用されます。 `values` のいずれかのメンバーが `null`場合は、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> は、<xref:System.Collections.Generic.IEnumerable%601> コレクションの各メンバーを文字列に変換せずに連結できる便利なメソッドです。 <xref:System.Collections.Generic.IEnumerable%601> コレクション内の各オブジェクトの文字列形式は、そのオブジェクトの `ToString` メソッドを呼び出すことによって取得されます。  
  
 このメソッドは、統合言語クエリ (LINQ) クエリ式で特に便利です。 たとえば、次のコードでは、動物の名前とそれが属する順序を含む非常に単純な `Animal` クラスを定義しています。 次に、多数の `Animal` オブジェクトを含む <xref:System.Collections.Generic.List%601> オブジェクトを定義します。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 拡張メソッドは、`Order` プロパティが "げっ歯類" と等しい `Animal` オブジェクトを抽出するために呼び出されます。 結果は <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドに渡されます。  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 結果を integer 型の <xref:System.Collections.Generic.List%601> オブジェクトに代入し、次に <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドに渡します。  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">結果として生成される文字列の長さが、許容される最大長 (<see cref="F:System.Int32.MaxValue" />) をオーバーフローしています。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字または文字列の 0 から始まるインデックス位置をレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、`value` が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、<xref:System.String.LastIndexOf%28System.Char%29> メソッドを使用して文字列内の最後のディレクトリ区切り文字を検索し、文字列のファイル名を抽出する `ExtractFilename` メソッドを定義しています。 ファイルが存在する場合、メソッドはパスを指定せずにファイル名を返します。  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 検索は、このインスタンスの最後の文字位置から開始し、`value` が見つかるか、または最初の文字位置が確認されるまで、先頭に向かって逆方向に進みます。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 `value` が1つ以上の無視できる文字で構成されている場合、<xref:System.String.LastIndexOf%28System.String%29> メソッドは常に、現在のインスタンスの最後のインデックス位置を表す <xref:System.String.Length%2A?displayProperty=nameWithType>-1 を返します。 次の例では、<xref:System.String.LastIndexOf%28System.String%29> メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00AD)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、ソフトハイフンが無視できない文字であるため、結果は `value`にソフトハイフンが含まれていなかった場合と同じになります。 ソフトハイフンのみを検索する場合、メソッドは6と5を返します。 これらの値は、2つの文字列の最後の文字のインデックスに対応します。  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 次の例では、タグが文字列の先頭と末尾にある場合に、HTML タグの開始と終了を文字列から削除します。 文字列が右角かっこの文字 (">") で終わる場合、この例では、<xref:System.String.LastIndexOf%2A> メソッドを使用して終了タグの先頭を検索します。  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して、文字列インスタンス内の部分文字列の最後のインデックスを検索するには、<paramref name="comparisonType" /> パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> 値を指定して <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> メソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字がインデックス0になり、最後の文字が <xref:System.String.Length%2A>-1 になります。このメソッドは、このインスタンスの `startIndex` 文字位置から検索を開始し、`value` が見つかるか、または最初の文字位置が検査されるまで、現在のインスタンスの先頭に向かって後方に移動します。 たとえば、`startIndex` が-1 <xref:System.String.Length%2A> の場合、メソッドは文字列の最後の文字から先頭までのすべての文字を検索します。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、文字列の末尾から文字列の先頭まで、文字列内のすべての文字が出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 検索は、このインスタンスの `startIndex` 文字位置から開始し、`value` が見つかるか最初の文字位置が検査されるまで、先頭に向かって後方に移動します。 たとえば、`startIndex` が-1 <xref:System.String.Length%2A> の場合、メソッドは文字列の最後の文字から先頭までのすべての文字を検索します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 `value` が1つ以上の無視できる文字で構成されている場合、<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> メソッドは常に `startIndex`を返します。これは、検索を開始する文字の位置です。 次の例では、<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> メソッドを使用して、ソフトハイフン (U + 00AD) を含む部分文字列を検索し、最後の "m" を文字列の前または末尾に含めます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行される場合は、検索文字列のソフトハイフンが無視されるので、メソッドを呼び出して、ソフトハイフンで構成される部分文字列を検索し、"m" は文字列内の "m" の位置を返します。では、これを呼び出して、ソフトハイフンで構成される部分文字列を検索し、"n" は "n" の位置を返します。 検索文字列にソフトハイフンのみが含まれている場合、メソッドは、`startIndex`の値を表す "m" のインデックスを返します。  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 次の例では、ターゲット文字列内のすべての文字列のインデックスを検索し、ターゲット文字列の末尾からターゲット文字列の先頭に向かっています。  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が -1 未満であるか、または 0 を超えています。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して特定の文字位置の前にある部分文字列のインデックスを検索するには、その <paramref name="comparisonType" /> パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> の値を指定して、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> メソッドのオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 `comparisonType` パラメーターは、大文字と小文字を区別するか、大文字と小文字を区別しない検索を使用し、word または序数の比較規則を使用して、現在のカルチャまたはインバリアントカルチャを使用して `value` パラメーターを検索するように指定します。  
  
 検索は、このインスタンスの最後の文字位置から開始し、`value` が見つかるか、または最初の文字位置が確認されるまで、先頭に向かって逆方向に進みます。  
  
   
  
## Examples  
 次の例は、<xref:System.StringComparison> 列挙体の異なる値を使用して、別の文字列内で最後に出現する文字列を検索する、<xref:System.String.LastIndexOf%2A> メソッドの3つのオーバーロードを示しています。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="options" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 <paramref name="value" /> が1つ以上の無視できる文字で構成されている場合、<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> メソッドは常に、現在のインスタンスの最後のインデックス位置を表す <see cref="P:System.String.Length" />-1 を返します。  
  
次の例では、<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00AD)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合は、ソフトハイフンが無視できる文字であるため、カルチャに依存した検索では、検索文字列にソフトハイフンが含まれていない場合に返されるのと同じ値が返されます。 ただし、序数検索では、1つの文字列でソフトハイフンが正常に検出され、2番目の文字列に存在しないことが報告されます。  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>このインスタンス内の部分文字列で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 このメソッドは、`startIndex` 文字位置から検索を開始し、`value` が見つかったか `count` 文字位置が検査されるまで、このインスタンスの先頭に向かって逆方向に進みます。 たとえば、`startIndex` が-1 <xref:System.String.Length%2A> の場合、メソッドは文字列の最後の文字から後方 `count` 文字を検索します。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、部分文字列の末尾から部分文字列の先頭までの、部分文字列に出現するすべての文字のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 検索は、このインスタンスの `startIndex` 文字位置から開始し、`value` が見つかるか、または `count` 文字位置が確認されるまで、先頭に向かって逆方向に進みます。 たとえば、`startIndex` が-1 <xref:System.String.Length%2A> の場合、メソッドは文字列の最後の文字から後方 `count` 文字を検索します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 `value` が1つ以上の無視できる文字で構成されている場合、<xref:System.String.LastIndexOf%2A> メソッドは常に `startIndex`を返します。これは、検索を開始する文字の位置です。 次の例では、2つの文字列の最後の "m" の前にある2つの文字で、ソフトハイフン (U + 00AD) の位置を検索するために、<xref:System.String.LastIndexOf%2A> メソッドを使用しています。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、どちらの場合も、ソフトハイフンが無視できない文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 次の例では、部分文字列の末尾から部分文字列の先頭までの文字列の、部分文字列のすべての出現箇所のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 した値がこのインスタンス内にはない位置を指定しています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が -1 より小さいか 0 より大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用してこの操作を実行するには、<paramref name="comparisonType" /> パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> 値を指定して <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 検索は `startIndex` 文字位置から開始され、`value` が見つかるか、または最初の文字位置が検査されるまで、後方に進みます。 たとえば、`startIndex` が-1 <xref:System.String.Length%2A> の場合、メソッドは文字列の最後の文字から先頭までのすべての文字を検索します。  
  
 `comparisonType` パラメーターは、大文字と小文字を区別するか、大文字と小文字を区別しない検索を使用し、word または序数の比較規則を使用して、現在のカルチャまたはインバリアントカルチャを使用して `value` パラメーターを検索するように指定します。  
  
   
  
## Examples  
 次の例は、<xref:System.StringComparison> 列挙体の異なる値を使用して、別の文字列内で最後に出現する文字列を検索する、<xref:System.String.LastIndexOf%2A> メソッドの3つのオーバーロードを示しています。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が -1 未満であるか、または 0 を超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 <paramref name="value" /> が1つ以上の無視できる文字で構成されている場合、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> メソッドは常に <paramref name="startIndex" />を返します。これは、検索を開始する文字の位置です。  
  
次の例では、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> メソッドを使用して、2つの文字列の最後の "m" から始まる "m" の後に、ソフトハイフン (U + 00AD) の位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、どちらの場合も、ソフトハイフンが無視できない文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は <xref:System.String.Length%2A>-1 になります。  
  
 検索は `startIndex` 文字位置から開始され、`value` が見つかるか、または `count` 文字位置が調べられるまで、後方に進みます。 たとえば、`startIndex` が-1 <xref:System.String.Length%2A> の場合、メソッドは文字列の最後の文字から後方 `count` 文字を検索します。  
  
 `comparisonType` パラメーターは、大文字と小文字を区別するか、大文字と小文字を区別しない検索を使用し、word または序数の比較規則を使用して、現在のカルチャまたはインバリアントカルチャを使用して `value` パラメーターを検索するように指定します。  
  
   
  
## Examples  
 次の例は、<xref:System.StringComparison> 列挙体の異なる値を使用して、別の文字列内で最後に出現する文字列を検索する、<xref:System.String.LastIndexOf%2A> メソッドの3つのオーバーロードを示しています。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> + 1 - <paramref name="count" /> した値がこのインスタンス内にはない位置を指定しています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が -1 より小さいか 0 より大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 <paramref name="value" /> が1つ以上の無視できる文字で構成されている場合、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドは常に <paramref name="startIndex" />を返します。これは、検索を開始する文字の位置です。  
  
次の例では、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> メソッドを使用して、2つの文字列の最後の "m" の前にある最初の文字位置を除いて、ソフトハイフン (U + 00AD) の位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 以降で実行されている場合、どちらの場合も、ソフトハイフンが無視できない文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 ただし、序数による比較を実行する場合は、最初の文字列でのみ部分文字列が検索されます。 ソフトハイフンの後に "m" が続く最初の文字列の場合、メソッドはソフトハイフンのインデックスを返すのではなく、カルチャに依存した比較を実行するときに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、`anyOf` 内の文字が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列内の文字列 "is" 内の任意の文字が最後に出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、このインスタンスの `startIndex` 文字位置から検索を開始し、`anyOf` 内の文字が見つかるか、最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、文字列 "is" 内の任意の文字が、別の文字列の部分文字列内で最後に出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンス内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、このインスタンスの `startIndex` 文字位置から検索を開始し、`anyOf` 内の文字が見つかるか `count` 文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> メソッドを使用します。このメソッドでは、合字 "Æ" (U + 00C6) など、構成されていない文字を表す Unicode スカラー値が、正しい文字のコンポーネントの出現箇所と等価であると見なされる場合があります。カルチャに応じた "AE" (U + 0041 という, U + 0045) などのシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内の文字列 "aid" 内の任意の文字が最後に出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の文字数を取得します。</summary>
        <value>現在の文字列の文字数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A> プロパティは、Unicode 文字の数ではなく、このインスタンス内の <xref:System.Char> オブジェクトの数を返します。 これは、Unicode 文字が複数の <xref:System.Char>によって表される可能性があるためです。 各 <xref:System.Char>ではなく各 Unicode 文字を操作するには、<xref:System.Globalization.StringInfo?displayProperty=nameWithType> クラスを使用します。  
  
 C やC++などの一部の言語では、null 文字は文字列の末尾を示します。 .NET では、null 文字を文字列に埋め込むことができます。 文字列に1つ以上の null 文字が含まれている場合は、文字列全体の長さに含まれます。 たとえば、次の文字列では、部分文字列 "abc" と "def" が null 文字で区切られています。 <xref:System.String.Length%2A> プロパティは7を返します。これは、6つの英字と null 文字が含まれていることを示します。  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 <xref:System.String.Length%2A>プロパティの例を次に示します。  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ表現が特定の Unicode 正規形である新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が Unicode 正規形 C である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が正規形 C である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 たとえば、次のコードポイントは、"ắ" という文字を表すことができます。  
  
-   U+1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 .NET では、Unicode 規格で定義されている4つの正規化形式 (C、D、KC、および KD) がサポートされています。 2つの文字列が同じ正規化形式で表される場合は、序数に基づく比較を使用して比較できます。  
  
 2つの文字列を正規化して比較するには、次の手順を実行します。  
  
1.  ファイルやユーザー入力デバイスなどの入力ソースと比較する文字列を取得します。  
  
2.  <xref:System.String.Normalize> メソッドを呼び出して、文字列を正規形 C に正規化します。  
  
3.  2つの文字列を比較するには、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> メソッドなどの序数の文字列比較をサポートするメソッドを呼び出し、<xref:System.StringComparison> 引数として <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> または <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> の値を指定します。 正規化された文字列の配列を並べ替えるには、<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> または <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> の `comparer` 値を <xref:System.Array.Sort%2A?displayProperty=nameWithType>の適切なオーバーロードに渡します。  
  
4.  前の手順で示された順序に基づいて、並べ替えられた出力内の文字列を生成します。  
  
 サポートされている Unicode 正規化形式の詳細については、「<xref:System.Text.NormalizationForm?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列を4つの正規化された各形式に正規化し、文字列が指定した正規化形式に正規化されたことを確認した後、正規化された文字列内のコードポイントを一覧表示します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> メソッドは、文字列内の最初の非正規化文字が検出された直後に <see langword="false" /> を返します。 したがって、文字列に正規化されていない文字が含まれ、その後に無効な Unicode 文字が続く場合は、<see cref="Overload:System.String.Normalize" /> メソッドによって <see cref="T:System.ArgumentException" /> がスローされますが、<see cref="Overload:System.String.IsNormalized" /> は <see langword="false" />を返します。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、指定された Unicode 正規形である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、<paramref name="normalizationForm" /> パラメーターで指定された正規形である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 .NET では、Unicode 規格で定義されている4つの正規化形式 (C、D、KC、および KD) がサポートされています。 2つの文字列が同じ正規化形式で表される場合は、序数に基づく比較を使用して比較できます。  
  
 2つの文字列を正規化して比較するには、次の手順を実行します。  
  
1.  ファイルやユーザー入力デバイスなどの入力ソースと比較する文字列を取得します。  
  
2.  文字列を指定した正規化形式に正規化するには、<xref:System.String.Normalize%28System.Text.NormalizationForm%29> メソッドを呼び出します。  
  
3.  2つの文字列を比較するには、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> メソッドなどの序数の文字列比較をサポートするメソッドを呼び出し、<xref:System.StringComparison> 引数として <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> または <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> の値を指定します。 正規化された文字列の配列を並べ替えるには、<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> または <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> の `comparer` 値を <xref:System.Array.Sort%2A?displayProperty=nameWithType>の適切なオーバーロードに渡します。  
  
4.  前の手順で示された順序に基づいて、並べ替えられた出力内の文字列を生成します。  
  
 サポートされている Unicode 正規化形式の詳細については、「<xref:System.Text.NormalizationForm?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列を4つの正規化された各形式に正規化し、文字列が指定した正規化形式に正規化されたことを確認した後、正規化された文字列内のコードポイントを一覧表示します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> メソッドは、文字列内の最初の非正規化文字が検出された直後に <see langword="false" /> を返します。 したがって、文字列に正規化されていない文字が含まれ、その後に無効な Unicode 文字が続く場合は、<see cref="Overload:System.String.IsNormalized" /> が <see langword="false" />を返す場合でも、<see cref="Overload:System.String.Normalize" /> メソッドで <see cref="T:System.ArgumentException" /> がスローされる可能性があります。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が同一かどうかを判断します。</summary>
        <returns><paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A> メソッドは、<xref:System.String> クラスの等値演算子の演算を定義します。 ここでは、例のセクションに示されているようなコードを有効にします。 さらに、演算子は静的な <xref:System.String.Equals%28System.String%2CSystem.String%29> メソッドを呼び出します。このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。  
  
> [!NOTE]
>  Visual Basic コンパイラは、<xref:System.String.op_Equality%2A> メソッドの呼び出しとして等値演算子を解決しません。 代わりに、等値演算子は、<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> メソッドの呼び出しをラップします。  
  
   
  
## Examples  
 等値演算子の例を次に示します。  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">暗黙的に変換する文字列。</param>
        <summary>指定された文字列から文字の読み取り専用スパンへの暗黙的な変換を定義します。</summary>
        <returns>文字列を表す文字の新しい読み取り専用スパン。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が異なるかどうかを判断します。</summary>
        <returns><see langword="true" /> の値が <paramref name="a" /> の値と異なる場合は <paramref name="b" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A> メソッドは、<xref:System.String> クラスの非等値演算子の演算を定義します。   これにより、「例」のセクションに示されているようなコードが有効になります。  
  
 <xref:System.String.op_Inequality%2A> 演算子は、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行する静的な <xref:System.String.Equals%28System.String%2CSystem.String%29> メソッドを呼び出します。  
  
> [!NOTE]
>  Visual Basic コンパイラは、<xref:System.String.op_Inequality%2A> メソッドの呼び出しとして非等値演算子を解決しません。 代わりに、非等値演算子は <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> メソッドの呼び出しをラップします。  
  
   
  
## Examples  
 次の例は、非等値演算子を示しています。  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の先頭に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで左側に空白を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空間は、16進数の0x0020 として定義されています。  
  
 <xref:System.String.PadLeft%28System.Int32%29> メソッドは、返された文字列の先頭に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の右側の部分が埋め込まれます。  
  
> [!NOTE]
>  <xref:System.String.PadLeft%2A> メソッドで現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、先頭に空白が埋め込まれている新しい文字列を返します。これにより、合計の長さが文字 `totalWidth` になります。  
  
   
  
## Examples  
 <xref:System.String.PadLeft%2A>メソッドの例を次に示します。  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで左側に指定された Unicode 文字を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> メソッドは、返された文字列の先頭に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の右側の部分が埋め込まれます。  
  
> [!NOTE]
>  <xref:System.String.PadLeft%2A> メソッドで現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、先頭 `paddingChar` 文字が埋め込まれた新しい文字列を返して、合計長が `totalWidth` 文字になるようにします。  
  
   
  
## Examples  
 <xref:System.String.PadLeft%2A>メソッドの例を次に示します。  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の末尾に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで右側に空白を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空間は、16進数の0x0020 として定義されています。  
  
 <xref:System.String.PadRight%28System.Int32%29> メソッドは、返された文字列の末尾に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の左側に埋め込まれます。  
  
> [!NOTE]
>  <xref:System.String.PadRight%2A> メソッドで現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、末尾に空白が埋め込まれている新しい文字列を返します。これにより、合計の長さが文字 `totalWidth` になります。  
  
   
  
## Examples  
 <xref:System.String.PadRight%2A>メソッドの例を次に示します。  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで右側に指定された Unicode 文字を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> メソッドは、返された文字列の末尾に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の左側に埋め込まれます。  
  
> [!NOTE]
>  <xref:System.String.PadRight%2A> メソッドで現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、末尾 `paddingChar` 文字が埋め込まれた新しい文字列を返して、合計長が `totalWidth` 文字になるようにします。  
  
   
  
## Examples  
 <xref:System.String.PadRight%2A>メソッドの例を次に示します。  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列から指定された文字数を削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <summary>現在のインスタンスの指定した位置から指定した最後の位置までの全文字が削除された新しい文字列を返します。</summary>
        <returns>この文字列から対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]では、文字列は0から始まります。 `startIndex` パラメーターの値は、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、元の文字列の末尾に `startIndex` 位置からのすべての文字が削除された新しい文字列を返します。  
  
   
  
## Examples  
 <xref:System.String.Remove%2A>メソッドの例を次に示します。 最後から2番目のケースでは、指定したインデックスから文字列の末尾までのすべてのテキストが削除されます。 最後の例では、指定されたインデックスを開始位置として3文字を削除します。  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> が、この文字列内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <param name="count">削除する文字数。</param>
        <summary>現在のインスタンス内の指定した位置から指定した文字数が削除された新しい文字列を返します。</summary>
        <returns>このインスタンスから対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]では、文字列は0から始まります。 `startIndex` パラメーターの値は、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、`count` パラメーターによって指定された文字数が削除された新しい文字列を返します。 文字は `startIndex`によって指定された位置で削除されます。  
  
   
  
## Examples  
 次の例は、完全な名前からミドルネームを削除する方法を示しています。  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="count" /> のいずれかが 0 より小さい値です。  
  
- または - 
 <paramref name="startIndex" /> に <paramref name="count" /> を加えたものが、このインスタンスの外部の位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列に出現する指定した Unicode 文字または <see cref="T:System.String" /> をすべて、別の指定した Unicode 文字または <see cref="T:System.String" /> に置換した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する Unicode 文字。</param>
        <param name="newChar">出現するすべての <paramref name="oldChar" /> を置換する Unicode 文字。</param>
        <summary>このインスタンスに出現する指定された Unicode 文字をすべて、別の指定された Unicode 文字に置換した新しい文字列を返します。</summary>
        <returns><paramref name="oldChar" /> のすべてのインスタンスが <paramref name="newChar" /> で置き換えられることを除いて、このインスタンスと等価な文字列。 <paramref name="oldChar" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) 検索を実行して `oldChar`を検索します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、`oldChar` のすべての出現箇所が `newChar`に置き換えられた新しい文字列を返します。  
  
 このメソッドは変更された文字列を返すため、<xref:System.String.Replace%2A> メソッドの連続した呼び出しを連結して、元の文字列に対して複数の置換を実行できます。 メソッドの呼び出しは左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 次の例では、コンマ区切り値リストを作成します。そのためには、一連の数値の間の空白をコンマで区切って指定します。  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換される文字列。</param>
        <param name="newValue">出現するすべての <paramref name="oldValue" /> を置換する文字列。</param>
        <summary>現在のインスタンスに出現する指定した文字列をすべて、別に指定した文字列に置換した新しい文字列を返します。</summary>
        <returns><paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> で置き換えられることを除いて、現在の文字列と等価な文字列。 <paramref name="oldValue" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `newValue` が `null`場合、すべての `oldValue` が削除されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、`oldValue` のすべての出現箇所が `newValue`に置き換えられた新しい文字列を返します。  
  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) 検索を実行して `oldValue`を検索します。  
  
 このメソッドは変更された文字列を返すため、<xref:System.String.Replace%2A> メソッドの連続した呼び出しを連結して、元の文字列に対して複数の置換を実行できます。 メソッドの呼び出しは左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 次の例は、<xref:System.String.Replace%2A> メソッドを使用してスペルミスを修正する方法を示しています。  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> が空の文字列 ("") です。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換される文字列。</param>
        <param name="newValue">出現するすべての <paramref name="oldValue" /> を置換する文字列。</param>
        <param name="comparisonType">このインスタンス内で <paramref name="oldValue" /> を検索する方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較型を使用して、現在のインスタンスに出現する指定した文字列をすべて、別に指定した文字列に置換した新しい文字列を返します。</summary>
        <returns><paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> で置き換えられることを除いて、現在の文字列と等価な文字列。 <paramref name="oldValue" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
`newValue` が `null`場合、すべての `oldValue` が削除されます。

> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、`oldValue` のすべての出現箇所が `newValue`に置き換えられた新しい文字列を返します。

このメソッドは、`comparisonType`で説明されているカルチャおよび大文字と小文字の区別を使用して `oldValue` 検索を実行します。

このメソッドは変更された文字列を返すため、<xref:System.String.Replace%2A> メソッドの連続した呼び出しを連結して、元の文字列に対して複数の置換を実行できます。 メソッドの呼び出しは左から右に実行されます。 具体的な例を次に示します。

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> が空の文字列 ("") です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換される文字列。</param>
        <param name="newValue">出現するすべての <paramref name="oldValue" /> を置換する文字列。</param>
        <param name="ignoreCase">比較するときに大文字と小文字の指定を無視するには <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
        <param name="culture">比較するときに使用するカルチャ。</param>
        <summary>指定されたカルチャおよび大文字と小文字の区別を使用して、現在のインスタンスに出現する指定した文字列をすべて、別に指定した文字列に置換した新しい文字列を返します。</summary>
        <returns><paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> で置き換えられることを除いて、現在の文字列と等価な文字列。 <paramref name="oldValue" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
`newValue` が `null`場合、すべての `oldValue` が削除されます。

> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、`oldValue` のすべての出現箇所が `newValue`に置き換えられた新しい文字列を返します。

このメソッドは、指定された `culture` と `ignoreCase` 大文字小文字の区別を使用して `oldValue` 検索を実行します。

このメソッドは変更された文字列を返すため、<xref:System.String.Replace%2A> メソッドの連続した呼び出しを連結して、元の文字列に対して複数の置換を実行できます。 メソッドの呼び出しは左から右に実行されます。 具体的な例を次に示します。

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> が空の文字列 ("") です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内の、指定された文字列または Unicode 文字の配列の要素で区切られた部分文字列を格納する文字列配列を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> は、区切られた文字列を部分文字列に分割するために使用します。 文字配列を使用して、0個、1個、または複数の区切り文字 (<xref:System.String.Split%28System.Char%5B%5D%29> メソッド) を指定できます。または、文字配列を使用して、0個、1個、または複数の区切り文字列を指定できます。 <xref:System.String.Split%2A> メソッドのオーバーロードを使用すると、メソッドによって返される部分文字列の数 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> メソッド) を制限し、返された部分文字列に空の文字列が含まれるかどうかを判断できます (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> および <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> メソッド、またはその両方を行うことができます (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>メソッドと <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> メソッド)。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>文字列分割の代替手段

 <xref:System.String.Split%2A> メソッドは、区切られた文字列を部分文字列に分割するのに必ずしも最適な方法ではありません。 区切られた文字列の一部の部分文字列を抽出したくない場合、または区切り文字のセットではなくパターンに基づいて文字列を解析する場合は、次の代替手段を検討してください。  
  
### <a name="regular-expressions"></a>正規表現  
 文字列が固定パターンに準拠している場合は、正規表現を使用してその要素を抽出して処理できます。 たとえば、文字列の形式が "*数値**オペランド**数値*" の場合、[正規表現](~/docs/standard/base-types/regular-expressions.md)を使用して文字列の要素を抽出し、処理することができます。 次に例を示します。  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 正規表現パターン `(\d+)\s+([-+*/])\s+(\d+)` は次のように定義されています。  
  
|パターン|説明|  
|-------------|-----------------|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが最初のキャプチャ グループです。|  
|`\s+`|1個以上の空白文字と一致します。|  
|`([-+*/])`|算術演算子の符号 (+、-、*、/) と一致します。 これが 2 番目のキャプチャ グループです。|  
|`\s+`|1個以上の空白文字と一致します。|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが 3 番目のキャプチャ グループです。|  
  
 また、正規表現を使用して、固定された文字のセットではなく、パターンに基づいて文字列から部分文字列を抽出することもできます。 これは、次のいずれかの条件が発生した場合の一般的なシナリオです。  
  
-   1つ以上の区切り文字が <xref:System.String> インスタンスの区切り記号として機能しません。  
  
-   区切り文字のシーケンスと数は、変数または unknown です。  
  
 たとえば、<xref:System.String.Split%2A> メソッドを使用して、次の文字列を分割することはできません。 `\n` C#(in) または `vbCrLf` (Visual Basic) の文字数は変数であり、常に区切り記号として機能しないためです。  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 次の例に示すように、正規表現では、この文字列を簡単に分割できます。  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 正規表現パターン `\[([^\[\]]+)\]` は次のように定義されています。  
  
|パターン|説明|  
|-------------|-----------------|  
|`\[`|左角かっこと一致します。|  
|`([^\[\]]+)`|左または右の角かっこではない任意の文字と1回以上一致します。 これが最初のキャプチャ グループです。|  
|`\]`|右角かっこと一致します。|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> メソッドは <xref:System.String.Split%2A?displayProperty=nameWithType>とほぼ同じですが、固定文字セットではなく正規表現パターンに基づいて文字列を分割する点が異なります。 たとえば、次の例では、<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> メソッドを使用して、ハイフンとその他の文字のさまざまな組み合わせで区切られた部分文字列を含む文字列を分割します。  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 正規表現パターン `\s-\s?[+*]?\s?-\s` は次のように定義されています。  
  
|パターン|説明|  
|-------------|-----------------|  
|`\s-`|空白文字の後にハイフンが続くパターンに一致します。|  
|`\s?`|0 個または 1 個の空白文字と一致します。|  
|`[+*]?`|+ または * のいずれかの文字の0回または1回の繰り返しに一致します。|  
|`\s?`|0 個または 1 個の空白文字と一致します。|  
|`-\s`|ハイフンの後に空白文字が続くパターンに一致します。|  
  
### <a name="search-methods-and-the-substring-method"></a>検索メソッドと Substring メソッド  
 文字列内のすべての部分文字列に関心がない場合は、一致を開始する位置のインデックスを返す文字列比較メソッドのいずれかを使用することをお勧めします。 その後、<xref:System.String.Substring%2A> メソッドを呼び出して、必要な部分文字列を抽出できます。 文字列比較のメソッドは次のとおりです。  
  
-   <xref:System.String.IndexOf%2A>。文字列インスタンス内で文字または文字列が最初に出現する位置の0から始まるインデックスを返します。  
  
-   <xref:System.String.IndexOfAny%2A>。これは、文字配列内の任意の文字が最初に出現する位置の、現在の文字列インスタンス内の0から始まるインデックスを返します。  
  
-   <xref:System.String.LastIndexOf%2A>。文字列インスタンス内で文字または文字列が最後に出現する位置の0から始まるインデックスを返します。  
  
-   <xref:System.String.LastIndexOfAny%2A>。これは、文字配列内で最後に出現する文字の現在の文字列インスタンス内にある、0から始まるインデックスを返します。  
  
 次の例では、<xref:System.String.IndexOf%2A> メソッドを使用して、文字列内の期間を検索します。 次に、<xref:System.String.Substring%2A> メソッドを使用して完全な文を返します。  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <summary>区切り記号の配列内の文字に基づいて文字列を部分文字列に分割します。</summary>
        <returns>このインスタンスを <paramref name="separator" /> の 1 つ以上の文字で区切った部分文字列を要素に格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列が既知の文字のセットで区切られている場合は、<xref:System.String.Split%28System.Char%5B%5D%29> メソッドを使用して、文字列を部分文字列に区切ることができます。   
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り文字は、返される配列の要素には含まれません。 たとえば、区切り記号配列に文字 "-" が含まれていて、現在の文字列インスタンスの値が "aa-bb-cc" の場合、メソッドは、"aa"、"bb"、および "cc" の3つの要素を含む配列を返します。  
  
 このインスタンスに `separator`内の文字が含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。  
  
 `separator` の各要素は、個別の区切り文字を定義します。 2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号がある場合、返された配列内の対応する要素には <xref:System.String.Empty?displayProperty=nameWithtype>が含まれます。 次にいくつかの例を示します。  
  
|文字列値|区切り記号|返された配列|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|新しい Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c, "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|バナナ|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|{"バナナ"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|新しい Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>区切り記号配列  
 Separator の各要素は、1つの文字で構成される個別の区切り記号を定義します。 `separator` 引数が `null` か、文字が含まれていない場合、メソッドは空白文字を区切り記号として扱います。 空白文字は Unicode 規格で定義されています。これらのメソッドは、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡されると `true` を返します。  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>String. Split (Char []) とコンパイラのオーバーロードの解決  
 <xref:System.String.Split%2A?displayProperty=nameWithType> のこのオーバーロードの1つのパラメーターは文字配列ですが、次の例に示すように、1つの文字で呼び出すことができます。  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 `separator` パラメーターは <xref:System.ParamArrayAttribute> 属性で修飾されているため、コンパイラは1つの文字を単一要素の文字配列として解釈します。 これは、`separator` パラメーターを含むその他の <xref:System.String.Split%2A?displayProperty=nameWithType> のオーバーロードには当てはまりません。これらのオーバーロードは、`separator` 引数として文字配列に明示的に渡す必要があります。  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%28System.Char%5B%5D%29> メソッドは、`separator` 配列内の1つ以上の文字で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 <xref:System.String.Split%28System.Char%5B%5D%29> メソッドは、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 列挙型」を参照してください。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A> メソッドは、返された配列オブジェクトにメモリを割り当て、各配列要素の <xref:System.String> オブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、またはアプリケーションでメモリ割り当てを管理することが重要な場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> 方法の使用を検討してください。 また、<xref:System.String.Compare%2A> メソッドを使用して、文字列内の部分文字列を検索することもできます。  
  
 文字列を区切り文字で分割するには、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、文字列内の区切り文字を検索します。 区切り文字列で文字列を分割するには、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、区切り記号文字列の最初の文字を検索します。 次に、<xref:System.String.Compare%2A> メソッドを使用して、その最初の文字の後の文字が区切り記号の文字列の残りの文字と等しいかどうかを確認します。  
  
 また、同じ文字セットを使用して複数の <xref:System.String.Split%2A> メソッドの呼び出しで文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しで参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
## Examples  
 次の例では、空白と句読点を区切り記号として扱うことによって、テキストのブロックから個々の単語を抽出する方法を示します。 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> メソッドの `separator` パラメーターに渡される文字配列は、スペース文字とタブ文字で構成され、いくつかの一般的な区切り記号と共に使用されます。  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 以前のバージョンでは、<see cref="M:System.String.Split(System.Char[])" /> メソッドに <see langword="null" /> または文字が含まれていない <paramref name="separator" /> が渡された場合、メソッドは文字列を分割するために少し異なる文字のセットを使用します。これは、<see cref="M:System.String.Trim(System.Char[])" /> メソッドが文字列をトリミングする場合とは異なります。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列内の部分文字列を区切る文字。</param>
        <param name="options">分割操作で、戻り値から空の部分文字列を省略する必要があるかどうかを決定する列挙値の 1 つ。</param>
        <summary>指定された文字区切り記号に基づいて文字列を部分文字列に分割します。</summary>
        <returns><paramref name="separator" /> によって区切られた、このインスタンスの部分文字列を要素に格納する配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。 返される部分文字列の最大数を指定します。</summary>
        <returns>このインスタンスを、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 区切り文字は、返される配列の要素には含まれません。  
  
 このインスタンスに `separator`内の文字が含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。 `count` が0の場合は、空の配列が返されます。  
  
 `separator` パラメーターが `null` の場合、または文字が含まれていない場合は、空白文字が区切り記号と見なされます。 空白文字は Unicode 標準によって定義され、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡される場合は `true` を返します。  
  
 `separator` の各要素は、個別の区切り文字を定義します。 2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号がある場合、対応する配列要素には <xref:System.String.Empty?displayProperty=nameWithtype>が含まれます。  
  
 このインスタンスに `count` 複数の部分文字列が含まれている場合は、最初の `count`-1 の部分文字列が戻り値の1番目の `count`-1 要素から返され、このインスタンス内の残りの文字が戻り値の最後の要素に返されます。数値.  
  
 `count` が部分文字列の数より大きい場合は、使用可能な部分文字列が返され、例外はスローされません。  
  
 次の表に例を示します。  
  
|文字列値|区切り記号|カウント|返された配列|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|新しい Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c "," c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|バナナ|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|2|{"バナナ"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|新しい Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"}(C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char [] null (C#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char [] null (C#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A> メソッドは、返された配列オブジェクトにメモリを割り当て、各配列要素の <xref:System.String> オブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、またはアプリケーションでメモリ割り当てを管理することが重要な場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッド、および必要に応じて <xref:System.String.Compare%2A> メソッドを使用して、文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、文字列内の区切り文字を検索します。 区切り文字列で文字列を分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、区切り記号の文字列の最初の文字を検索します。 次に、<xref:System.String.Compare%2A> メソッドを使用して、その最初の文字の後の文字が区切り記号の文字列の残りの文字と等しいかどうかを確認します。  
  
 また、同じ文字セットを使用して複数の <xref:System.String.Split%2A> メソッドの呼び出しで文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しで参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例は、`count` が <xref:System.String.Split%2A>によって返される文字列の数にどのように影響するかを示しています。  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 以前のバージョンでは、<see cref="M:System.String.Split(System.Char[])" /> メソッドに <see langword="null" /> または文字が含まれていない <paramref name="separator" /> が渡された場合、メソッドは文字列を分割するために少し異なる文字のセットを使用します。これは、<see cref="M:System.String.Trim(System.Char[])" /> メソッドが文字列をトリミングする場合とは異なります。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り文字 (`separator` 配列内の文字) は、返される配列の要素には含まれません。 たとえば、`separator` 配列に文字 "-" が含まれていて、現在の文字列インスタンスの値が "aa-bb-cc" である場合、メソッドは、"aa"、"bb"、および "cc" の3つの要素を含む配列を返します。  
  
 このインスタンスに `separator`内の文字が含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。  
  
 `options` パラメーターが <xref:System.StringSplitOptions.RemoveEmptyEntries> で、このインスタンスの長さが0の場合、メソッドは空の配列を返します。  
  
 `separator` の各要素は、1つの文字で構成される個別の区切り記号を定義します。 `options` 引数が <xref:System.StringSplitOptions.None>で、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号がある場合は、対応する配列要素に <xref:System.String.Empty?displayProperty=nameWithType>が含まれます。 たとえば、`separator` に "-" と "\_" の2つの要素が含まれている場合、文字列インスタンスの値は "-\_aa-\_" で、`options` 引数の値が <xref:System.StringSplitOptions.None>の場合、メソッドは次の5つの要素を含む文字列配列を返します。:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 文字の前にある空の文字列を表します。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 文字とインデックス1の "_" 文字の間の空の文字列を表します。  
  
3.  "aa"、  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス4の "_" 文字の後に続く空の文字列を表します。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス5の "-" 文字の後に続く空の文字列を表します。  
  
### <a name="the-separator-array"></a>区切り記号配列  
 `separator` パラメーターが `null` の場合、または文字が含まれていない場合は、空白文字が区切り記号と見なされます。 空白文字は Unicode 標準によって定義され、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡される場合は `true` を返します。  
  
 このメソッドオーバーロードの呼び出しの `separator` パラメーターが `null`場合、コンパイラのオーバーロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには、コードで `null`の型を指定する必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%2A> メソッドは、`separator` パラメーターの1つ以上の文字で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 <xref:System.String.Split%2A> メソッドは、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 列挙型」を参照してください。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A> メソッドは、返された配列オブジェクトにメモリを割り当て、各配列要素の <xref:System.String> オブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、またはアプリケーションでメモリ割り当てを管理することが重要な場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッド、および必要に応じて <xref:System.String.Compare%2A> メソッドを使用して、文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、文字列内の区切り文字を検索します。 区切り文字列で文字列を分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、区切り記号の文字列の最初の文字を検索します。 次に、<xref:System.String.Compare%2A> メソッドを使用して、その最初の文字の後の文字が区切り記号の文字列の残りの文字と等しいかどうかを確認します。  
  
 また、同じ文字セットを使用して複数の <xref:System.String.Split%2A> メソッドの呼び出しで文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しで参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では、<xref:System.StringSplitOptions> 列挙体を使用して、<xref:System.String.Split%2A> メソッドによって生成される部分文字列を含めたり除外したりします。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 以前のバージョンでは、<see cref="M:System.String.Split(System.Char[])" /> メソッドに <see langword="null" /> または文字が含まれていない <paramref name="separator" /> が渡された場合、メソッドは文字列を分割するために少し異なる文字のセットを使用します。これは、<see cref="M:System.String.Trim(System.Char[])" /> メソッドが文字列をトリミングする場合とは異なります。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列内の部分文字列を区切る文字列。</param>
        <param name="options">分割操作で、戻り値から空の部分文字列を省略する必要があるかどうかを決定する列挙値の 1 つ。</param>
        <summary>指定された文字列の区切り記号に基づいて文字列を部分文字列に分割します。</summary>
        <returns><paramref name="separator" /> によって区切られた、このインスタンスの部分文字列を要素に格納する配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字列) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列が既知の文字列セットで区切られている場合は、<xref:System.String.Split%2A> メソッドを使用して、文字列を部分文字列に区切ることができます。  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り記号文字列は、返される配列の要素には含まれません。 たとえば、`separator` 配列に文字列 "--" が含まれていて、現在の文字列インスタンスの値が "aa--bb-cc" である場合、メソッドは、"aa"、"bb"、および "cc" という3つの要素を含む配列を返します。  
  
 このインスタンスに `separator`内のいずれの文字列も含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。  
  
 `options` パラメーターが <xref:System.StringSplitOptions.RemoveEmptyEntries> で、このインスタンスの長さが0の場合、メソッドは空の配列を返します。  
  
 `separator` の各要素は、1つ以上の文字で構成される個別の区切り記号を定義します。 `options` 引数が <xref:System.StringSplitOptions.None>で、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号がある場合は、対応する配列要素に <xref:System.String.Empty?displayProperty=nameWithType>が含まれます。 たとえば、`separator` に "-" と "\_" の2つの要素が含まれている場合、文字列インスタンスの値は "-\_aa-\_" で、`options` 引数の値が <xref:System.StringSplitOptions.None>の場合、メソッドは次の5つの要素を含む配列を返します。:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 部分文字列の前にある空の文字列を表します。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 部分文字列とインデックス1の "_" 部分文字列の間の空の文字列を表します。  
  
3.  "aa"、  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス4の "_" 部分文字列の後にある空の文字列を表します。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス5の "-" 部分文字列の後に続く空の文字列を表します。  
  
### <a name="the-separator-array"></a>区切り記号配列  
 `separator` 内のいずれかの要素が複数の文字で構成されている場合、部分文字列全体が区切り記号と見なされます。 たとえば、`separator` 内のいずれかの要素が "10" の場合、文字列 "This10is10a10string" を分割しようとしています。 は、次の4つの要素から成る配列を返します: {"This"、"is"、"a"、"string" }.  
  
 `separator` パラメーターが `null` の場合、または文字が含まれていない場合は、空白文字が区切り記号と見なされます。 空白文字は Unicode 標準によって定義され、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡される場合は `true` を返します。  
  
 このメソッドオーバーロードの呼び出しの `separator` パラメーターが `null`場合、コンパイラのオーバーロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには、コードで `null`の型を指定する必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%2A> メソッドは、`separator` パラメーターの1つ以上の文字列で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 <xref:System.String.Split%2A> メソッドは、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 列挙型」を参照してください。  
  
 <xref:System.String.Split%2A> メソッドは、値が `null` または空の文字列 ("") である `separator` のすべての要素を無視します。  
  
 `separator` の文字列に共通の文字が含まれている場合に、あいまいな結果が得られないようにするには、<xref:System.String.Split%2A> 操作をインスタンスの最初から最後まで続行し、インスタンス内の区切り記号と等しい `separator` の最初の要素と一致します。 インスタンスで部分文字列が検出される順序は、`separator`内の要素の順序よりも優先されます。  
  
 たとえば、値が "abcdef" であるインスタンスについて考えてみます。 `separator` の最初の要素が "ef" で、2番目の要素が "bcde" の場合、split 操作の結果は、"a" と "f" の2つの要素を含む文字列配列になります。 これは、"bcde" というインスタンス内の部分文字列が検出され、部分文字列 "f" が検出される前に `separator` 内の要素と一致するためです。  
  
 ただし、`separator` の最初の要素が "bcd" で、2番目の要素が "bc" の場合、split 操作の結果は、"a" と "ef" の2つの要素を含む文字列配列になります。 これは、"bcd" が、インスタンス内の区切り記号に一致する `separator` の最初の区切り記号であるためです。 最初の要素が "bc" で、2番目の要素が "bcd" であるために、区切り記号の順序が逆になった場合、結果は、"a" と "def" の2つの要素を含む文字列配列になります。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A> メソッドは、返された配列オブジェクトにメモリを割り当て、各配列要素の <xref:System.String> オブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、またはアプリケーションでメモリ割り当てを管理することが重要な場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッド、および必要に応じて <xref:System.String.Compare%2A> メソッドを使用して、文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、文字列内の区切り文字を検索します。 区切り文字列で文字列を分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、区切り記号の文字列の最初の文字を検索します。 次に、<xref:System.String.Compare%2A> メソッドを使用して、その最初の文字の後の文字が区切り記号の文字列の残りの文字と等しいかどうかを確認します。  
  
 また、同じ文字セットを使用して複数の <xref:System.String.Split%2A> メソッドの呼び出しで文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しで参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例は、文字列の <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> メソッドを呼び出すことによって返される配列の違いを示しています。これは、`options` パラメーターを <xref:System.StringSplitOptions.None?displayProperty=nameWithType> および <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>と同じにしたものです。  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 次の例では、句読点と空白文字を含む区切り記号の配列を定義しています。 この配列を <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> の値と共に <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> メソッドに渡すと、文字列の個々の単語で構成される配列が返されます。  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 `options` 引数を <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>に設定してメソッドが呼び出されることに注意してください。 これにより、返される配列に、区切り記号と空白文字の間の空の部分文字列の一致を表す <xref:System.String.Empty?displayProperty=nameWithType> 値が含まれないようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 以前のバージョンでは、<see cref="M:System.String.Split(System.Char[])" /> メソッドに <see langword="null" /> または文字が含まれていない <paramref name="separator" /> が渡された場合、メソッドは文字列を分割するために少し異なる文字のセットを使用します。これは、<see cref="M:System.String.Trim(System.Char[])" /> メソッドが文字列をトリミングする場合とは異なります。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">このインスタンス内の部分文字列を区切る文字。</param>
        <param name="count">配列に必要な要素の最大数。</param>
        <param name="options">分割操作で、戻り値から空の部分文字列を省略する必要があるかどうかを決定する列挙値の 1 つ。</param>
        <summary>指定された文字区切り記号に基づいて文字列を最大数の部分文字列に分割します。</summary>
        <returns><paramref name="separator" /> で区切られた、このインスタンスの最大 <paramref name="count" /> の部分文字列を要素に格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

文字列が既に1回 `count` 分割されていても、文字列の末尾に達していない場合、返された配列の最後の文字列には、このインスタンスの末尾の部分文字列が含まれます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 区切り文字は、返される配列の要素には含まれません。  
  
 このインスタンスに `separator`内の文字が含まれていない場合、または `count` パラメーターが1の場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。 `separator` パラメーターが `null` の場合、または文字が含まれていない場合は、空白文字が区切り記号と見なされます。 空白文字は Unicode 標準によって定義され、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡される場合は `true` を返します。 ただし、このメソッドオーバーロードの呼び出しの `separator` パラメーターが `null`場合、コンパイラのオーバーロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには、コードが null の型を示す必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 `count` パラメーターがゼロの場合、または `options` パラメーターが <xref:System.StringSplitOptions.RemoveEmptyEntries> で、このインスタンスの長さがゼロの場合は、空の配列が返されます。  
  
 `separator` の各要素は、個別の区切り文字を定義します。 `options` パラメーターが <xref:System.StringSplitOptions.None>で、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号がある場合は、対応する配列要素に <xref:System.String.Empty?displayProperty=nameWithtype>が含まれます。  
  
 このインスタンスに `count` 複数の部分文字列が含まれている場合は、最初の `count`-1 の部分文字列が戻り値の1番目の `count`-1 要素から返され、このインスタンス内の残りの文字が戻り値の最後の要素に返されます。数値.  
  
 `count` が部分文字列の数より大きい場合は、使用可能な部分文字列が返され、例外はスローされません。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A> メソッドは、返された配列オブジェクトにメモリを割り当て、各配列要素の <xref:System.String> オブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、またはアプリケーションでメモリ割り当てを管理することが重要な場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッド、および必要に応じて <xref:System.String.Compare%2A> メソッドを使用して、文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、文字列内の区切り文字を検索します。 区切り文字列で文字列を分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、区切り記号の文字列の最初の文字を検索します。 次に、<xref:System.String.Compare%2A> メソッドを使用して、その最初の文字の後の文字が区切り記号の文字列の残りの文字と等しいかどうかを確認します。  
  
 また、同じ文字セットを使用して複数の <xref:System.String.Split%2A> メソッドの呼び出しで文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しで参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では、<xref:System.StringSplitOptions> 列挙体を使用して、<xref:System.String.Split%2A> メソッドによって生成される部分文字列を含めたり除外したりします。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 以前のバージョンでは、<see cref="M:System.String.Split(System.Char[])" /> メソッドに <see langword="null" /> または文字が含まれていない <paramref name="separator" /> が渡された場合、メソッドは文字列を分割するために少し異なる文字のセットを使用します。これは、<see cref="M:System.String.Trim(System.Char[])" /> メソッドが文字列をトリミングする場合とは異なります。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">このインスタンス内の部分文字列を区切る文字列。</param>
        <param name="count">配列に必要な要素の最大数。</param>
        <param name="options">分割操作で、戻り値から空の部分文字列を省略する必要があるかどうかを決定する列挙値の 1 つ。</param>
        <summary>指定された文字列区切り記号に基づいて文字列を最大数の部分文字列に分割します。</summary>
        <returns><paramref name="separator" /> で区切られた、このインスタンスの最大 <paramref name="count" /> の部分文字列を要素に格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

文字列が既に1回 `count` 分割されていても、文字列の末尾に達していない場合、返された配列の最後の文字列には、このインスタンスの末尾の部分文字列が含まれます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を最大数の部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字列) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り記号文字列は、返される配列の要素には含まれません。  
  
 このインスタンスに `separator`内のいずれかの文字列が含まれていない場合、または `count` パラメーターが1の場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。 `separator` パラメーターが `null` の場合、または文字が含まれていない場合は、空白文字が区切り記号と見なされます。 空白文字は Unicode 標準によって定義され、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡される場合は `true` を返します。 ただし、このメソッドオーバーロードの呼び出しの `separator` パラメーターが `null`場合、コンパイラのオーバーロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには、コードで `null`の型を指定する必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 `count` パラメーターがゼロの場合、または `options` パラメーターが <xref:System.StringSplitOptions.RemoveEmptyEntries> で、このインスタンスの長さがゼロの場合は、空の配列が返されます。  
  
 `separator` の各要素は、1つ以上の文字で構成される個別の区切り記号を定義します。 `options` パラメーターが <xref:System.StringSplitOptions.None>で、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号がある場合は、対応する配列要素に <xref:System.String.Empty?displayProperty=nameWithtype>が含まれます。  
  
 このインスタンスに `count` 複数の部分文字列が含まれている場合は、最初の `count`-1 の部分文字列が戻り値の1番目の `count`-1 要素から返され、このインスタンス内の残りの文字が戻り値の最後の要素に返されます。数値.  
  
 `count` が部分文字列の数より大きい場合は、使用可能な部分文字列が返され、例外はスローされません。  
  
### <a name="the-separator-array"></a>区切り記号配列  
 `separator` 内のいずれかの要素が複数の文字で構成されている場合、部分文字列全体が区切り記号と見なされます。 たとえば、`separator` 内のいずれかの要素が "10" の場合、文字列 "This10is10a10string" を分割しようとしています。 この4つの要素を持つ配列 {"This"、"is"、"a"、"string" を返します。 }.  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%2A> メソッドは、`separator` パラメーターの1つ以上の文字列で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 <xref:System.String.Split%2A> メソッドは、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 列挙型」を参照してください。  
  
 <xref:System.String.Split%2A> メソッドは、値が `null` または空の文字列 ("") である `separator` のすべての要素を無視します。  
  
 `separator` 内の文字列に共通の文字が含まれている場合に、あいまいな結果を避けるために、<xref:System.String.Split%2A> メソッドは、インスタンスの値の先頭から末尾まで処理を進め、インスタンス内の区切り記号と等しい `separator` 内の最初の要素と一致します。 インスタンスで部分文字列が検出される順序は、`separator`内の要素の順序よりも優先されます。  
  
 たとえば、値が "abcdef" であるインスタンスについて考えてみます。 `separator` の最初の要素が "ef" で、2番目の要素が "bcde" の場合、分割操作の結果は "a" と "f" になります。 これは、"bcde" というインスタンス内の部分文字列が検出され、部分文字列 "f" が検出される前に `separator` 内の要素と一致するためです。  
  
 ただし、`separator` の最初の要素が "bcd" で、2番目の要素が "bc" の場合、分割操作の結果は "a" と "ef" になります。 これは、"bcd" が、インスタンス内の区切り記号に一致する `separator` の最初の区切り記号であるためです。 最初の要素が "bc" で、2番目の要素が "bcd" であるために、区切り記号の順序が逆になった場合、結果は "a" と "def" になります。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A> メソッドは、返された配列オブジェクトにメモリを割り当て、各配列要素の <xref:System.String> オブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、またはアプリケーションでメモリ割り当てを管理することが重要な場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッド、および必要に応じて <xref:System.String.Compare%2A> メソッドを使用して、文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、文字列内の区切り文字を検索します。 区切り文字列で文字列を分割する場合は、<xref:System.String.IndexOf%2A> または <xref:System.String.IndexOfAny%2A> メソッドを使用して、区切り記号の文字列の最初の文字を検索します。 次に、<xref:System.String.Compare%2A> メソッドを使用して、その最初の文字の後の文字が区切り記号の文字列の残りの文字と等しいかどうかを確認します。  
  
 また、同じ文字セットを使用して複数の <xref:System.String.Split%2A> メソッドの呼び出しで文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しで参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では、<xref:System.StringSplitOptions> 列挙体を使用して、<xref:System.String.Split%2A> メソッドによって生成される部分文字列を含めたり除外したりします。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 以前のバージョンでは、<see cref="M:System.String.Split(System.Char[])" /> メソッドに <see langword="null" /> または文字が含まれていない <paramref name="separator" /> が渡された場合、メソッドは文字列を分割するために少し異なる文字のセットを使用します。これは、<see cref="M:System.String.Trim(System.Char[])" /> メソッドが文字列をトリミングする場合とは異なります。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字。</param>
        <summary>この文字列インスタンスが指定した文字で始まっているかどうかを判断します。</summary>
        <returns>この文字列の先頭が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>この文字列の先頭が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、`value` を、このインスタンスの先頭にある、`value`と同じ長さの部分文字列と比較し、等しいかどうかを示す値を返します。 同じにするには、`value` が空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) であるか、この同じインスタンスへの参照であるか、またはこのインスタンスの先頭と一致する必要があります。

このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。

## Examples

次の例では、<xref:System.String.StartsWith%28System.String%29> メソッドを使用して、文字列の先頭から HTML 開始タグを削除する `StripStartTags` メソッドを定義します。 `StripStartTags` メソッドは、行の先頭にある複数の HTML 開始タグが削除されるように、再帰的に呼び出されることに注意してください。 この例では、文字列に埋め込まれている HTML タグは削除されません。

[!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
[!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
[!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの文字列比較規則を使用して文字列が特定の部分文字列で始まるかどうかを判断するには、その <paramref name="comparisonType" /> パラメーターに <see cref="F:System.StringComparison.CurrentCulture" /> の値を指定して、<see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> メソッドのオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="comparisonType">この文字列と <paramref name="value" /> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>インスタンスが <see langword="true" /> で開始する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A> メソッドは、`value` パラメーターをこの文字列の先頭の部分文字列と比較し、等しいかどうかを示す値を返します。 同じにするには、`value` がこの同じ文字列への参照であるか、空の文字列 ("") であるか、またはこの文字列の先頭と一致している必要があります。 <xref:System.String.StartsWith%2A> メソッドによって実行される比較の種類は、`comparisonType` パラメーターの値によって異なります。 この比較では、現在のカルチャの規則 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> と <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) またはインバリアントカルチャ (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> および <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) を使用するか、コードポイント (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> または <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>) の文字単位の比較で構成することができます。 比較では、大文字と小文字を区別することもできます (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>、<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>、または <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>)。または、大文字小文字を無視することもできます (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>、<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>、<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>)。  
  
   
  
## Examples  
 次の例では、"the" という語で始まる長い文字列の先頭にある文字列 "the" を検索します。 この例の出力に示すように、カルチャを認識しないが大文字と小文字を区別する比較を実行する <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> メソッドへの呼び出しは、文字列に一致しません。一方、カルチャおよび大文字と小文字を区別しない比較を実行する呼び出しは文字列に一致します。  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 次の例では、文字列が特定の部分文字列で始まるかどうかを判断します。 2次元の文字列配列を初期化します。 2番目の次元の最初の要素には文字列が含まれ、2番目の要素には、最初の文字列の先頭で検索する文字列が含まれます。 結果は、カルチャの選択、case が無視されるかどうか、および序数に基づく比較が実行されるかどうかによって影響を受けます。 文字列インスタンスに合字が含まれている場合、その連続する文字とのカルチャに依存した比較が正常に行われることに注意してください。  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">この文字列と <paramref name="value" /> との比較方法を決定するカルチャ情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns><see langword="true" /> パラメーターがこの文字列の先頭と一致する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`value` パラメーターを、この文字列の先頭にある、`value`と同じ長さの部分文字列と比較し、等しいかどうかを示す値を返します。 同じにするには、`value` が空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) であるか、この同じインスタンスへの参照であるか、またはこのインスタンスの先頭と一致する必要があります。  
  
 このメソッドは、指定された大文字と小文字の区別とカルチャを使用して比較を実行します。  
  
   
  
## Examples  
 次の例では、文字列が別の文字列の先頭にあるかどうかを判断します。 <xref:System.String.StartsWith%2A> メソッドは、大文字と小文字の区別、大文字と小文字の区別、および検索結果に影響を与えるさまざまなカルチャを使用して、複数回呼び出されます。  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>インスタンスから部分文字列を取得します。  
  
 このメンバーはオーバーロードされます。 構文、使用方法、例など、このメンバーの詳細については、オーバーロード リストで名前をクリックしてください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <summary>インスタンスから部分文字列を取得します。 部分文字列は、文字列中の指定した文字の位置で開始し、文字列の末尾まで続きます。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> で始まる部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しい場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Substring%28System.Int32%29> メソッドを呼び出して、指定した文字位置から開始し、文字列の末尾で終わる文字列から部分文字列を抽出します。 開始文字の位置は0から始まります。つまり、文字列の最初の文字は、インデックス1ではなくインデックス0になります。 指定した文字位置から開始し、文字列の末尾の前にある部分文字列を抽出するには、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> メソッドを呼び出します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在の文字列の `startIndex` 位置から始まる新しい文字列を返します。  
  
 特定の文字または文字シーケンスで始まる部分文字列を抽出するには、<xref:System.String.IndexOf%2A> や <xref:System.String.IndexOf%2A> などのメソッドを呼び出して、`startIndex`の値を取得します。 2番目の例では、これを示します。"=" 文字の後に1文字位置を開始するキー値を抽出します。  
  
 `startIndex` が0に等しい場合、メソッドは元の文字列を変更せずに返します。  
   
  
## Examples  
 文字列から部分文字列を取得する例を次に示します。  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 次の例では、<xref:System.String.Substring%2A> メソッドを使用して、等号 ("=") 文字で区切られたキーと値のペアを区切ります。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 文字列内の equals 文字の位置を取得するには、<xref:System.String.IndexOf%2A> メソッドを使用します。 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すと、キー名が抽出されます。キー名は、文字列の最初の文字から始まり、<xref:System.String.IndexOf%2A> メソッドへの呼び出しによって返される文字数に対してが拡張されます。 <xref:System.String.Substring%28System.Int32%29> メソッドを呼び出すと、キーに割り当てられた値が抽出されます。 これは、等号文字を超えて1文字位置から開始し、文字列の末尾まで拡張します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <param name="length">部分文字列の文字数。</param>
        <summary>インスタンスから部分文字列を取得します。 この部分文字列は、指定した文字位置から開始し、指定した文字数の文字列です。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> から始まる長さ <paramref name="length" /> の部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しく、<paramref name="length" /> がゼロの場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> メソッドを呼び出して、指定した文字位置から開始し、文字列の末尾の前にある文字列から部分文字列を抽出します。 開始文字の位置は0から始まります。つまり、文字列の最初の文字は、インデックス1ではなくインデックス0になります。 指定した文字位置から開始し、文字列の末尾まで続く部分文字列を抽出するには、<xref:System.String.Substring%28System.Int32%29> メソッドを呼び出します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在の文字列の `startIndex` 位置から始まる `length` 文字を含む新しい文字列を返します。  
  
 `length` パラメーターは、現在の文字列インスタンスから抽出する文字の合計数を表します。 これには、インデックス `startIndex`で見つかった開始文字も含まれます。  言い換えると、<xref:System.String.Substring%2A> メソッドは、インデックス `startIndex` からインデックス `startIndex` + `length`-1 に文字を抽出しようとします。  
  
 特定の文字または文字シーケンスで始まる部分文字列を抽出するには、<xref:System.String.IndexOf%2A> や <xref:System.String.LastIndexOf%2A> などのメソッドを呼び出して、`startIndex`の値を取得します。  
  
 部分文字列が `startIndex` から指定した文字シーケンスに拡張される場合、<xref:System.String.IndexOf%2A> や <xref:System.String.LastIndexOf%2A> などのメソッドを呼び出して、終了文字または文字シーケンスのインデックスを取得できます。  その後、次のように、その値を文字列内のインデックス位置に変換できます。  
  
-   部分文字列の末尾を示す1文字を検索した場合、`length` パラメーターは `endIndex` - `startIndex` + 1 と等しくなります。ここで、`endIndex` は <xref:System.String.IndexOf%2A> メソッドまたは <xref:System.String.IndexOf%2A> メソッドの戻り値です。 次の例では、文字列から "b" 文字の連続ブロックを抽出します。  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   部分文字列の末尾を示す複数の文字を検索した場合、`length` パラメーターは `endIndex` + `endMatchLength` - `startIndex`と等しくなります。ここで `endIndex` は <xref:System.String.IndexOf%2A> メソッドまたは <xref:System.String.IndexOf%2A> メソッドの戻り値です。と `endMatchLength` は、部分文字列の末尾を示す文字シーケンスの長さです。 次の例では、XML `<definition>` 要素を含むテキストのブロックを抽出します。  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   文字または文字のシーケンスが部分文字列の末尾に含まれていない場合、`length` パラメーターは `endIndex` - `startIndex`と等しくなります。ここで、`endIndex` は <xref:System.String.IndexOf%2A> メソッドまたは <xref:System.String.IndexOf%2A> メソッドの戻り値です。  
  
 `startIndex` が0で、現在の文字列の長さと等しい場合、メソッドは元の文字列を変更せずに返します。  
  
   
  
## Examples  
 次の例は、6番目の文字位置 (つまり、インデックス 5) から始まる文字列から2つの文字を抽出する <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> メソッドの単純な呼び出しを示しています。  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 次の例では、文字列内で部分文字列を分離するために、次の3つのケースで <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> メソッドを使用しています。 2つのケースでは、部分文字列が比較に使用されます。3番目のケースでは、無効なパラメーターが指定されているため、例外がスローされます。  
  
-   このメソッドは、文字列内の1文字と3番目の位置 (インデックス 2) を抽出し、それを "c" と比較します。 この比較は `true`を返します。  
  
-   文字列の4番目の位置 (インデックス 3) から開始してゼロ文字を抽出し、それを <xref:System.String.IsNullOrEmpty%2A> メソッドに渡します。 これは、<xref:System.String.Substring%2A> メソッドの呼び出しが <xref:System.String.Empty?displayProperty=nameWithType>を返すため、true を返します。  
  
-   文字列の4番目の位置から1文字を抽出しようとします。 その位置に文字がないため、メソッドの呼び出しは <xref:System.ArgumentOutOfRangeException> 例外をスローします。  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 次の例では、<xref:System.String.Substring%2A> メソッドを使用して、等号 ("=") 文字で区切られたキーと値のペアを区切ります。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 文字列内の equals 文字の位置を取得するには、<xref:System.String.IndexOf%2A> メソッドを使用します。 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> メソッドを呼び出すと、キー名が抽出されます。キー名は、文字列の最初の文字から始まり、<xref:System.String.IndexOf%2A> メソッドへの呼び出しによって返される文字数に対してが拡張されます。 <xref:System.String.Substring%28System.Int32%29> メソッドを呼び出すと、キーに割り当てられた値が抽出されます。 これは、等号文字を超えて1文字位置から開始し、文字列の末尾まで拡張します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> に<paramref name="length" /> を加算した値はこのインスタンスの範囲外である位置を示します。  
  
- または - 
 <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトを反復処理するために使用できる、厳密に型指定された列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 <xref:System.String> インスタンスが <xref:System.Collections.Generic.IEnumerable%601> インターフェイスオブジェクトにキャストされている場合にのみ使用できます。 詳細については、<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の文字列を反復処理するために使用できる列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.Collections.IEnumerable> インターフェイスにキャストされる場合のみ、使用できます。 詳細については、<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.String" /> に評価されるオブジェクト。</param>
        <summary>このインスタンスと指定した <see cref="T:System.Object" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定した <see cref="T:System.Object" /> の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="value" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。

          <list type="table">
            <listheader>
              <term>[値]</term>
              <description>条件</description>
            </listheader>
            <item>
              <term>0 より小さい値</term>
              <description>このインスタンスの位置が <paramref name="value" /> よりも前です。</description>
            </item>
            <item>
              <term>0</term>
              <description>このインスタンスの位置が、並べ替え順序において <paramref name="value" /> と同じです。</description>
            </item>
            <item>
              <term>0 より大きい値</term>
              <description>このインスタンスの位置が <paramref name="value" /> よりも後ろです。

- または -

                <paramref name="value" /> が <see langword="null" /> です。</description>
            </item>
          </list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`value` は <xref:System.String> オブジェクトである必要があります。

> [!CAUTION]
>  <xref:System.String.CompareTo%2A> メソッドは、主に並べ替え操作または alphabetizing 操作で使用するように設計されています。 2つの文字列が等価かどうかを判断するために、メソッド呼び出しの主な目的がである場合は、使用しないでください。 2つの文字列が等価かどうかを判断するには、<xref:System.String.Equals%2A> メソッドを呼び出します。

このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、「<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>」を参照してください。

このメソッドの動作の詳細については、<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> メソッドの「解説」を参照してください。

## Examples

次の例では、<xref:System.Object>と共に <xref:System.String.CompareTo%2A> メソッドを使用します。 <xref:System.String> インスタンスを `TestClass` オブジェクトと比較しようとするため、メソッドは <xref:System.ArgumentException>をスローします。

[!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
[!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
[!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が <see cref="T:System.String" /> ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.String" /> クラスには <see cref="T:System.TypeCode" /> を返します。</summary>
        <returns>列挙型定数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples

次の例では、<xref:System.String> 型の <xref:System.TypeCode> 列挙定数を表示します。

[!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
[!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
[!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の文字列の値が <see langword="true" /> の場合は <see cref="F:System.Boolean.TrueString" />。現在の文字列の値が <see langword="false" /> の場合は <see cref="F:System.Boolean.FalseString" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の文字列の値が <see cref="F:System.Boolean.TrueString" /> または <see cref="F:System.Boolean.FalseString" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Byte.MaxValue" /> より大きい数か、<see cref="F:System.Byte.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトのインデックス 0 位置にある文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Decimal.MinValue" /> 未満か、<see cref="F:System.Decimal.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Double.MinValue" /> 未満か、<see cref="F:System.Double.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Int16.MaxValue" /> より大きい数か、<see cref="F:System.Int16.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.SByte.MaxValue" /> より大きい数か、<see cref="F:System.SByte.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。

- または -

現在のカルチャの書式指定規則を使用する場合は <see langword="null" />。</param>
        <summary>このメンバーの詳細については、「<see cref="T:System.IConvertible.ToString(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>対象のインスタンスの値と等価な <see cref="T:System.String" /> インスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<see cref="T:System.String" /> のインスタンスが <see cref="T:System.IConvertible" /> インターフェイスにキャストされる場合のみ、使用できます。

          ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">取得するオブジェクトの型。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ChangeType%2A> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">現在の <see cref="T:System.String" /> オブジェクトの値を、<paramref name="type" /> パラメーターで指定された型に変換できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt16.MaxValue" /> より大きい数か、<see cref="F:System.UInt16.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt32.MaxValue" /> より大きい数か、<see cref="F:System.UInt32.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の方法として、<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
        <returns>このインスタンスの各文字を要素とする Unicode 文字配列。 このインスタンスが空の文字列である場合、返される配列は空で、長さは 0 になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、文字列内の各文字 (つまり <xref:System.Char> オブジェクト) を文字配列にコピーします。 コピーされた最初の文字は、返された文字配列のインデックス0になります。コピーされた最後の文字は、インデックス <xref:System.Array.Length%2A?displayProperty=nameWithType>-1 になります。  
  
 文字配列内の文字から文字列を作成するには、<xref:System.String.%23ctor%28System.Char%5B%5D%29> コンストラクターを呼び出します。  
  
 文字列内のエンコードされた文字を含むバイト配列を作成するには、適切な <xref:System.Text.Encoding> オブジェクトをインスタンス化し、その <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> メソッドを呼び出します。 .NET で使用できる標準エンコーディングには、次のようなものがあります。  
  
|エンコード|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.String.ToCharArray%2A> メソッドを呼び出して、文字列内の文字を文字配列に抽出します。 次に、元の文字列と配列内の要素が表示されます。  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 次の例では、区切り記号で区切られた文字列で区切り文字として機能する文字を含む文字列を定義します。 次に、<xref:System.String.ToCharArray%2A> メソッドを呼び出して、区切られた文字列を個々の部分文字列に区切るために <xref:System.String.Split%28System.Char%5B%5D%29> メソッドに渡すことができる文字配列を作成します。  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の開始位置。</param>
        <param name="length">このインスタンス内の部分文字列の長さ。</param>
        <summary>このインスタンスの指定した部分文字列の文字を Unicode 文字配列へコピーします。</summary>
        <returns>文字位置 <paramref name="startIndex" /> から始まる、このインスタンス内の文字の <paramref name="length" /> 数を要素とする Unicode 文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、文字列の一部の文字を文字配列にコピーします。 文字配列内の文字範囲から文字列を作成するには、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> コンストラクターを呼び出します。  
  
 `startIndex` パラメーターは0から始まります。 つまり、文字列インスタンス内の最初の文字のインデックスは0です。  
  
 `length` が0の場合、返される配列は空で、長さは0になります。 このインスタンスが `null` または空の文字列 ("") の場合、返される配列は空で、長さは0になります。  
  
 文字列の一部にエンコードされた文字を含むバイト配列を作成するには、適切な <xref:System.Text.Encoding> オブジェクトをインスタンス化し、その <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> メソッドを呼び出します。 .NET で使用できる標準エンコーディングには、次のようなものがあります。  
  
|エンコード|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列内の部分文字列を文字の配列に変換してから、配列の要素を列挙して表示します。  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> に <paramref name="length" /> を加算した値がこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
        <returns>小文字の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のカルチャの大文字と小文字の規則を考慮します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 <xref:System.String.ToLower> メソッドを呼び出すことによって生成される大文字と小文字の演算では、現在のカルチャの大文字と小文字の表記規則が考慮されます。 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、<xref:System.String.ToLowerInvariant%2A> または <xref:System.String.ToUpperInvariant%2A> メソッドを使用します。 これにより、(<xref:System.String.ToLower> メソッドとは異なり) すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では、複数の大文字と小文字が混在する文字列を小文字に変換します。  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明されているように、既定値を置き換える文字列の大文字と小文字の使い分けメソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことをお勧めします。 現在のカルチャの大文字と小文字の表記規則を使用して文字を小文字に変換するには、その <paramref name="culture" /> パラメーターに <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 値を指定して、<see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> メソッドのオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `culture` パラメーターによって指定されたカルチャの大文字と小文字の規則によって、文字列の大文字と小文字の変更方法が決まります。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> メソッドに <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>以外の <xref:System.Globalization.CultureInfo> オブジェクトを渡すと、大文字と小文字の操作によってカルチャ固有の規則が考慮されます。 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、<xref:System.String.ToLowerInvariant%2A> または <xref:System.String.ToUpperInvariant%2A> 方法を使用します。 これにより、すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では、大文字の2つの文字列を、英語 (米国) とトルコ語 (トルコ) のカルチャを使用して小文字に変換し、その後、小文字の文字列を比較します。 大文字の文字列は同じですが、1つの文字列に Unicode ラテン大文字 I が出現するたびに、もう一方の文字列には上記のドット付きのラテン大文字 I が含まれている点が異なります。  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インバリアントカルチャは、カルチャを認識しないカルチャを表します。 英語と関連付けられていますが、特定の国または地域には関連付けられていません。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティを参照してください。  
  
 現在のカルチャの影響を受けない予測可能な方法で文字列が変更された場合にアプリケーションが依存している場合は、<xref:System.String.ToLowerInvariant%2A> メソッドを使用します。 <xref:System.String.ToLowerInvariant%2A> メソッドは `ToLower(CultureInfo.InvariantCulture)`と同じです。 文字列のコレクションをユーザーインターフェイスコントロールで予測可能な順序で表示する必要がある場合は、メソッドをお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、<xref:System.String.ToLowerInvariant%2A> または <xref:System.String.ToUpperInvariant%2A> メソッドを使用します。  
  
   
  
## Examples  
 次の例では、複数の言語に含まれる1つの単語を含む文字列配列を定義します。 <xref:System.String.ToLowerInvariant%2A> メソッドは、各単語の大文字と小文字を区別しないバージョンで並列配列の要素を設定するために使用されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> メソッドを使用して、小文字配列内の要素の順序に基づいて大文字と小文字を区別する配列を並べ替え、要素が言語に関係なく同じ順序で表示されるようにします。  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの値を <see cref="T:System.String" /> に変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の文字列をそのまま返すだけなので、直接呼び出す必要はありません。 この例に示すように、通常、複合書式指定操作で暗黙的に呼び出されます。  
  
   
  
## Examples  
 <xref:System.String.ToString%2A> メソッドの例を次に示します。この例では、<xref:System.String.ToString%2A> メソッドが明示的に呼び出されないことに注意してください。 代わりに、メソッドは[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能によって暗黙的に呼び出されます。  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">(予約済み) カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary><see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` は予約されており、現在この操作に参加していません。  
  
 このメソッドは、現在の文字列をそのまま返すだけなので、直接呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のカルチャの大文字と小文字の規則を使用して、現在のインスタンスの各文字を、それと等価な大文字に変換します。 文字に大文字と小文字が含まれていない場合は、返された文字列にそのまま含まれます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換される新しい文字列が返されます。  
  
 <xref:System.String.ToUpper%2A> メソッドは、大文字と小文字を区別しない比較で使用できるように、文字列を大文字に変換するためによく使用されます。 大文字と小文字を区別しない比較を実行するには、カルチャに依存し、大文字と小文字を区別しない比較のために <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> に設定した値を持つ <xref:System.StringComparison> パラメーターを持つ文字列比較メソッドを呼び出すことをお勧めします。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 <xref:System.String.ToUpper> メソッドを呼び出すことによって生成される大文字と小文字の演算では、現在のカルチャの大文字と小文字の表記規則が考慮されます。 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、<xref:System.String.ToLowerInvariant%2A> または <xref:System.String.ToUpperInvariant%2A> 方法を使用します。 これにより、(<xref:System.String.ToUpper> メソッドとは異なり) すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では、<xref:System.String.ToUpper%2A> メソッドを呼び出して、基本的なラテン、ラテン1の追加、およびラテン拡張文字セットの各文字を含む一連の1文字の文字列を変換します。 次に、大文字が小文字と異なる文字列をそれぞれ表示します。  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明されているように、既定値を置き換える文字列の大文字と小文字の使い分けメソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことをお勧めします。 現在のカルチャの大文字と小文字の表記規則を使用して文字列を大文字に変換するには、その <paramref name="culture" /> パラメーターに <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> の値を指定して、<see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> メソッドのオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `culture` パラメーターによって指定されたカルチャの大文字と小文字の規則によって、文字列の大文字と小文字の変更方法が決まります。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> メソッドに <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>以外の <xref:System.Globalization.CultureInfo> オブジェクトを渡すと、大文字と小文字の操作によってカルチャ固有の規則が考慮されます。 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、<xref:System.String.ToLowerInvariant%2A> または <xref:System.String.ToUpperInvariant%2A> 方法を使用します。 これにより、すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では、米国英語とトルコ語のカルチャを使用して小文字の文字列を大文字の2つの文字列に変換し、その後、大文字の文字列を比較します。 大文字の文字列は同じですが、1つの文字列に Unicode ラテン大文字 I が出現するたびに、もう一方の文字列には上記のドット付きのラテン大文字 I が含まれている点が異なります。  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インバリアントカルチャは、カルチャを認識しないカルチャを表します。 英語と関連付けられていますが、特定の国または地域には関連付けられていません。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティを参照してください。  
  
 現在のカルチャの影響を受けない予測可能な方法で文字列が変更された場合にアプリケーションが依存している場合は、<xref:System.String.ToUpperInvariant%2A> メソッドを使用します。 <xref:System.String.ToUpperInvariant%2A> メソッドは `ToUpper(CultureInfo.InvariantCulture)`と同じです。 文字列のコレクションをユーザーインターフェイスコントロールで予測可能な順序で表示する必要がある場合は、メソッドをお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、<xref:System.String.ToLowerInvariant%2A> または <xref:System.String.ToUpperInvariant%2A> メソッドを使用します。  
  
   
  
## Examples  
 次の例では、複数の言語に含まれる1つの単語を含む文字列配列を定義します。 <xref:System.String.ToUpperInvariant%2A> メソッドは、各単語の大文字と小文字を区別しないバージョンで並列配列の要素を設定するために使用されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> メソッドは、大文字の配列の要素の順序に基づいて大文字と小文字を区別する配列を並べ替えるために使用されます。これにより、要素は言語に関係なく同じ順序で表示されます。  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列から、指定した文字セットを先頭および末尾の出現箇所からすべて削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の文字列から、先頭および末尾にある空白文字をすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から空白文字をすべて削除した後に残った文字列。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Trim` メソッドは、現在の文字列からすべての先頭および末尾の空白文字を削除します。 それぞれの先頭および末尾のトリム操作は、空白以外の文字が検出されると停止します。 たとえば、現在の文字列が "abc xyz" の場合、`Trim` メソッドは "abc xyz" を返します。 文字列内の単語間の空白文字を削除するには、 [.net の正規表現](~/docs/standard/base-types/regular-expressions.md)を使用します。

> [!NOTE]
>  `Trim` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかった先頭および末尾の空白文字がすべて削除された新しい文字列を返します。

現在の文字列が <xref:System.String.Empty?displayProperty=nameWithtype> に等しい場合、または現在のインスタンス内のすべての文字が空白文字で構成されている場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithtype>を返します。

空白文字は、Unicode 規格で定義されています。 `Trim` メソッドは、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡されるときに `true` の戻り値を生成する先頭と末尾の文字を削除します。

## Examples

次の例では、<xref:System.String.Trim?displayProperty=nameWithType> メソッドを使用して、ユーザーが入力した文字列から余分な空白をすべて削除してから、それらを連結します。

[!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
[!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
[!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンでは、このメソッドがトリムする空白文字の内部リストが保持されています。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、メソッドはすべての Unicode 空白文字 (つまり、<see cref="M:System.Char.IsWhiteSpace(System.Char)" /> メソッドに渡されるときに <see langword="true" /> 戻り値を生成する文字) をトリムします。 この変更のため、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、2つの文字、0の幅のスペース (U + 200B) とゼロ幅の改行なしスペース (U + FEFF) が削除されます。これは、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降のバージョンの <see cref="M:System.String.Trim" /> メソッドでは削除されません。 さらに、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、3つの Unicode の空白文字 (モンゴル語の母音の区切り記号 (U + 180 e)、ナローの区切りスペース (U + 202F)、中かっこ (U + 205F)) は削除されません。</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">削除する Unicode 文字。</param>
        <summary>現在の文字列から、文字の先頭および末尾のインスタンスをすべて削除します。</summary>
        <returns>現在の文字列の先頭と末尾から <paramref name="trimChar" /> 文字のすべてのインスタンスが削除された後に残った文字列。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Trim(System.Char)` メソッドは、`trimChar` 文字の先頭および末尾のすべてのインスタンスを現在の文字列から削除します。 `trimChar` とは異なる文字が検出されると、それぞれの先頭および末尾のトリム操作が停止します。 たとえば、`trimChar` が `-`、現在の文字列が "---abc---xyz----" の場合、`Trim(System.Char)` メソッドは "abc---xyz" を返します。 文字列内の単語間の文字を削除するには、 [.net の正規表現](~/docs/standard/base-types/regular-expressions.md)を使用します。

> [!NOTE]
>  `Trim(System.Char)` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかったすべての先頭および末尾の `trimChar` 文字が削除された新しい文字列を返します。

現在の文字列が <xref:System.String.Empty?displayProperty=nameWithtype> に等しい場合、または現在のインスタンス内のすべての文字が `trimChar` 文字で構成されている場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithtype>を返します。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の文字列から、配列で指定された一連の文字が先頭および末尾に現れる箇所をすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Trim(System.Char[])` メソッドは、`trimChars` パラメーターに含まれる先頭と末尾のすべての文字を現在の文字列から削除します。 `trimChars` に含まれていない文字が検出されると、それぞれの先頭および末尾のトリム操作が停止します。 たとえば、現在の文字列が "123abc456xyz789" で、`trimChars` に "1" ~ "9" の数字が含まれている場合、`Trim(System.Char[])` メソッドは "abc456xyz" を返します。

> [!NOTE]
>  `Trim(System.Char[])` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかったすべての先頭および末尾の `trimChars` 文字が削除された新しい文字列を返します。

現在の文字列が <xref:System.String.Empty?displayProperty=nameWithtype> に等しい場合、または現在のインスタンス内のすべての文字が `trimChars` 配列内の文字で構成されている場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithtype>を返します。

`trimChars` が `null` または空の配列の場合、このメソッドは、メソッドが <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> メソッドに渡されたときに `true` を返す、先頭または末尾の文字を削除します。

## Examples

次の例では、`Trim(System.Char[])` メソッドを使用して、文字列からスペース、アスタリスク (*)、およびアポストロフィ (') 文字を削除します。

[!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
[!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
[!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンは、<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合に、このメソッドがトリムする空白文字の内部リストを保持します。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合、メソッドはすべての Unicode 空白文字 (つまり、<see cref="M:System.Char.IsWhiteSpace(System.Char)" /> メソッドに渡されるときに <see langword="true" /> 戻り値を生成する文字) をトリムします。 この変更のため、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、2つの文字、0の幅のスペース (U + 200B) とゼロ幅の改行なしスペース (U + FEFF) が削除されます。これは、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降のバージョンの <see cref="M:System.String.Trim" /> メソッドでは削除されません。 さらに、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、3つの Unicode の空白文字 (モンゴル語の母音の区切り記号 (U + 180 e)、ナローの区切りスペース (U + 202F)、中かっこ (U + 205F)) は削除されません。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の文字列から末尾の空白文字をすべて削除します。</summary>
        <returns>現在の文字列の末尾から空白文字をすべて削除した後に残った文字列。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimEnd` メソッドは、現在の文字列からすべての末尾の空白文字を削除します。 トリム操作は、文字列の末尾に空白以外の文字が最初に出現したときに停止します。 たとえば、現在の文字列が "abc xyz" の場合、`TrimEnd` メソッドは "abc xyz" を返します。

> [!NOTE]
>  `TrimEnd` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、すべての末尾の空白文字が現在の文字列から削除される新しい文字列を返します。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">削除する Unicode 文字。</param>
        <summary>現在の文字列から、末尾に出現する文字をすべて削除します。</summary>
        <returns>現在の文字列の末尾から、<paramref name="trimChar" /> 文字の出現箇所がすべて削除された後に残った文字列。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimEnd(System.Char)` メソッドは、現在の文字列からすべての末尾の文字 `trimChar` を削除します。 トリム操作は、文字列の末尾で `trimChar` されていない最初の文字が見つかったときに停止します。 たとえば、`trimChar` が `-`、現在の文字列が "---abc---xyz----" の場合、`TrimEnd(System.Char)` メソッドは "---abc---xyz" を返します。

> [!NOTE]
>  `TrimEnd(System.Char)` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在の文字列からすべての末尾の `trimChar` 文字が削除される新しい文字列が返されます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の文字列から、配列で指定された一連の文字が末尾に現れる箇所をすべて削除します。</summary>
        <returns>現在の文字列の末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに Unicode の空白文字が削除されます。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimEnd(System.Char[])` メソッドは、`trimChars` パラメーターに含まれるすべての末尾の文字を現在の文字列から削除します。 `trimChars` に含まれていない最初の文字が文字列の末尾で見つかった場合、トリム操作は停止します。 たとえば、現在の文字列が "123abc456xyz789" で、`trimChars` に "1" ~ "9" の数字が含まれている場合、`TrimEnd(System.Char[])` メソッドは "123abc456xyz" を返します。

> [!NOTE]
>  `TrimEnd(System.Char[])` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、`trimChars` で見つかったすべての末尾の文字が現在の文字列から削除された新しい文字列を返します。

## Examples

次の例は、`TrimEnd(System.Char[])` メソッドを使用して、文字列の末尾から空白や句読点を除去する方法を示しています。

[!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
[!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンは、<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合に、このメソッドがトリムする空白文字の内部リストを保持します。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合、メソッドはすべての Unicode 空白文字 (つまり、<see cref="M:System.Char.IsWhiteSpace(System.Char)" /> メソッドに渡されるときに <see langword="true" /> 戻り値を生成する文字) をトリムします。 この変更のため、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、2つの文字、0の幅のスペース (U + 200B) とゼロ幅の改行なしスペース (U + FEFF) が削除されます。これは、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以降のバージョンの <see cref="M:System.String.Trim" /> メソッドでは削除されません。 さらに、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、3つの Unicode の空白文字 (モンゴル語の母音の区切り記号 (U + 180 e)、ナローの区切りスペース (U + 202F)、中かっこ (U + 205F)) は削除されません。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の文字列から先頭の空白文字をすべて削除します。</summary>
        <returns>現在の文字列の先頭からすべての空白文字が削除された後に残った文字列。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimStart` メソッドは、現在の文字列からすべての先頭の空白文字を削除します。 空白以外の文字が検出されると、トリム操作は停止します。 たとえば、現在の文字列が "abc xyz" の場合、`TrimStart` メソッドは "abc xyz" を返します。

> [!NOTE]
>  `TrimStart` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかったすべての先頭の空白文字が削除される新しい文字列を返します。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">削除する Unicode 文字。</param>
        <summary>現在の文字列から、指定した文字が先頭に現れる箇所をすべて削除します。</summary>
        <returns>現在の文字列の先頭から、<paramref name="trimChar" /> 文字の出現箇所がすべて削除された後に残った文字列。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimStart(System.Char)` メソッドは、現在の文字列からすべての先頭 `trimChar` 文字を削除します。 `trimChar` ない文字が検出されると、トリム操作は停止します。 たとえば、`trimChar` が `-`、現在の文字列が "---abc---xyz----" の場合、`TrimStart(System.Char)` メソッドは "abc---xyz----" を返します。

> [!NOTE]
>  `TrimStart(System.Char)` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかったすべての先頭 `trimChar` 文字が削除された新しい文字列を返します。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の文字列から、配列で指定された一連の文字が先頭に現れる箇所をすべて削除します。</summary>
        <returns>現在の文字列の先頭から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimStart(System.Char[])` メソッドは、`trimChars` パラメーターに含まれるすべての先頭文字を現在の文字列から削除します。 `trimChars` に含まれていない文字が検出されると、トリム操作は停止します。 たとえば、現在の文字列が "123abc456xyz789" で、`trimChars` に "1" ~ "9" の数字が含まれている場合、`TrimStart(System.Char[])` メソッドは "abc456xyz789" を返します。

> [!NOTE]
>  `TrimStart(System.Char[])` メソッドが現在のインスタンスから文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかった `trimChars` パラメーターに含まれるすべての先頭文字が削除された新しい文字列を返します。

## Examples

次の例は、<xref:System.String.TrimStart%2A> メソッドの基本的な機能を示しています。

[!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
[!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

次の例では、<xref:System.String.TrimStart%2A> メソッドを使用して、ソースコードの行から空白とコメント文字を削除します。 `StripComments` メソッドは、<xref:System.String.TrimStart%2A> への呼び出しをラップし、空白とコメント文字を含む文字配列を渡します。これは、Visual Basic のアポストロフィ (') と、のC#スラッシュ (/) です。 <xref:System.String.TrimStart%2A> メソッドは、文字列がコメントであるかどうかを評価するときに先頭の空白を削除するためにも呼び出されます。

[!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
[!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]

`StripComments` メソッドを呼び出す例を次に示します。

[!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
[!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンは、<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合に、このメソッドがトリムする空白文字の内部リストを保持します。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合、メソッドはすべての Unicode 空白文字 (つまり、<see cref="M:System.Char.IsWhiteSpace(System.Char)" /> メソッドに渡されるときに <see langword="true" /> 戻り値を生成する文字) をトリムします。 この変更のため、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、2つの文字、0の幅のスペース (U + 200B) とゼロ幅の改行なしスペース (U + FEFF) が削除されます。これは、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以降のバージョンの <see cref="M:System.String.Trim" /> メソッドでは削除されません。 さらに、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 以前のバージョンの <see cref="M:System.String.Trim" /> メソッドでは、3つの Unicode の空白文字 (モンゴル語の母音の区切り記号 (U + 180 e)、ナローの区切りスペース (U + 202F)、中かっこ (U + 205F)) は削除されません。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
