<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="23b498111dcd32e8fd288d4acceb83bbdbc3d32d" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82293248" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="990e5-101">.NET クラス階層のすべてのクラスをサポートし、派生クラスに下位レベルのサービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-101">Supports all classes in the .NET class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="990e5-102">これは、全 .NET クラスの基本クラスであり、型階層のルートです。</span><span class="sxs-lookup"><span data-stu-id="990e5-102">This is the ultimate base class of all .NET classes; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-103">継承は暗黙的に行われるため、通常、言語は <xref:System.Object> から継承を宣言するためにクラスを必要としません。</span><span class="sxs-lookup"><span data-stu-id="990e5-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="990e5-104">.NET のすべてのクラスは <xref:System.Object>から派生するため、<xref:System.Object> クラスで定義されているすべてのメソッドは、システム内のすべてのオブジェクトで使用できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-104">Because all classes in .NET are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="990e5-105">派生クラスは、次のようなメソッドの一部をオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="990e5-106"><xref:System.Object.Equals%2A>-オブジェクト間の比較をサポートします。</span><span class="sxs-lookup"><span data-stu-id="990e5-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="990e5-107"><xref:System.Object.Finalize%2A>-オブジェクトが自動的に再利用される前にクリーンアップ操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="990e5-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="990e5-108"><xref:System.Object.GetHashCode%2A>-ハッシュテーブルの使用をサポートするために、オブジェクトの値に対応する番号を生成します。</span><span class="sxs-lookup"><span data-stu-id="990e5-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="990e5-109"><xref:System.Object.ToString%2A>-クラスのインスタンスを記述する、人間が判読できるテキスト文字列を製造します。</span><span class="sxs-lookup"><span data-stu-id="990e5-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="990e5-110">パフォーマンスに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="990e5-110">Performance Considerations</span></span>  
 <span data-ttu-id="990e5-111">コレクションなど、任意の型のオブジェクトを処理する必要があるクラスをデザインする場合は、<xref:System.Object> クラスのインスタンスを受け入れるクラスメンバーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="990e5-112">ただし、型のボックス化とボックス化解除のプロセスでは、パフォーマンスコストがかかります。</span><span class="sxs-lookup"><span data-stu-id="990e5-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="990e5-113">新しいクラスで特定の値型を頻繁に処理することがわかっている場合は、2つの戦術のいずれかを使用して、ボックス化のコストを最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="990e5-114"><xref:System.Object> 型を受け取る一般的なメソッドと、クラスで頻繁に処理する必要のある各値型を受け入れる型固有のメソッドオーバーロードのセットを作成します。</span><span class="sxs-lookup"><span data-stu-id="990e5-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="990e5-115">呼び出し元のパラメーターの型を受け入れる型固有のメソッドが存在する場合は、ボックス化が行われず、型固有のメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="990e5-116">呼び出し元のパラメーターの型と一致するメソッド引数がない場合、パラメーターはボックス化され、一般メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="990e5-117">ジェネリックを使用するように型とそのメンバーを設計します。</span><span class="sxs-lookup"><span data-stu-id="990e5-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="990e5-118">共通言語ランタイムは、クラスのインスタンスを作成し、ジェネリック型引数を指定するときに、クローズジェネリック型を作成します。</span><span class="sxs-lookup"><span data-stu-id="990e5-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="990e5-119">ジェネリックメソッドは型固有であり、呼び出し元のパラメーターをボックス化せずに呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="990e5-120"><xref:System.Object> 型を受け入れて返す汎用クラスを開発することが必要になる場合もありますが、頻繁に使用される型を処理する型固有のクラスも用意することで、パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="990e5-121">たとえば、ブール値の設定と取得に固有のクラスを指定すると、ブール値のボックス化とボックス化解除のコストが削減されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="990e5-122">次の例では、<xref:System.Object> クラスから派生した Point 型を定義し、<xref:System.Object> クラスの多くの仮想メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="990e5-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="990e5-123">また、この例は、<xref:System.Object> クラスの静的メソッドとインスタンスメソッドの多くを呼び出す方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs" interactive="try-dotnet" id="snippet1":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp" id="snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb" id="snippet1":::
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="990e5-124">パブリック静的 (Visual Basic では<see langword="Shared" />) なこの型のメンバーはスレッド セーフです</span><span class="sxs-lookup"><span data-stu-id="990e5-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="990e5-125">インスタンスメンバーは、スレッドセーフであるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="990e5-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="990e5-126"><see cref="T:System.Object" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="990e5-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-127">このコンストラクターは、派生クラスのコンストラクターによって呼び出されますが、<xref:System.Object> クラスのインスタンスを直接作成するために使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="990e5-128">2 つのオブジェクト インスタンスが等しいかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="990e5-128">Determines whether two object instances are equal.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="990e5-129">現在のオブジェクトと比較するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="990e5-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="990e5-130">指定されたオブジェクトが現在のオブジェクトと等しいかどうかを判定します。</span><span class="sxs-lookup"><span data-stu-id="990e5-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="990e5-131">指定したオブジェクトが現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="990e5-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-132">現在のインスタンスと `obj` パラメーターの比較の種類は、現在のインスタンスが参照型であるか値型であるかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="990e5-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  

-   <span data-ttu-id="990e5-133">現在のインスタンスが参照型の場合、<xref:System.Object.Equals%28System.Object%29> メソッドは参照の等価性をテストし、<xref:System.Object.Equals%28System.Object%29> メソッドの呼び出しは <xref:System.Object.ReferenceEquals%2A> メソッドの呼び出しと同じです。</span><span class="sxs-lookup"><span data-stu-id="990e5-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="990e5-134">参照の等価性とは、比較されるオブジェクト変数が同じオブジェクトを参照することを意味します。</span><span class="sxs-lookup"><span data-stu-id="990e5-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="990e5-135">次の例は、このような比較の結果を示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="990e5-136">これは参照型である `Person` クラスを定義し、`Person` クラスコンストラクターを呼び出して、同じ値を持つ2つの新しい `Person` オブジェクト `person1a` と `person2`をインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="990e5-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="990e5-137">また、別のオブジェクト変数 `person1b`にも `person1a` が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="990e5-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="990e5-138">例の出力が示すように、`person1a` と `person1b` は同じオブジェクトを参照しているため、同じです。</span><span class="sxs-lookup"><span data-stu-id="990e5-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="990e5-139">ただし、`person1a` と `person2` は同じ値を持っていますが、同じではありません。</span><span class="sxs-lookup"><span data-stu-id="990e5-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="990e5-140">現在のインスタンスが値型の場合、<xref:System.Object.Equals%28System.Object%29> メソッドは値が等しいかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="990e5-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="990e5-141">値の等価性は、次のことを意味します。</span><span class="sxs-lookup"><span data-stu-id="990e5-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="990e5-142">2つのオブジェクトの型は同じです。</span><span class="sxs-lookup"><span data-stu-id="990e5-142">The two objects are of the same type.</span></span> <span data-ttu-id="990e5-143">次の例に示すように、値が12の <xref:System.Byte> オブジェクトは、値が12の <xref:System.Int32> オブジェクトとは異なります。これは、2つのオブジェクトの実行時の型が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="990e5-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp-interactive[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="990e5-144">2つのオブジェクトのパブリックフィールドとプライベートフィールドの値が等しい。</span><span class="sxs-lookup"><span data-stu-id="990e5-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="990e5-145">次の例では、値が等しいかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="990e5-145">The following example tests for value equality.</span></span> <span data-ttu-id="990e5-146">これは、値型の `Person` 構造体を定義し、`Person` クラスコンストラクターを呼び出して、同じ値を持つ2つの新しい `Person` オブジェクト `person1` と `person2`をインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="990e5-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="990e5-147">この例の出力に示されているように、2つのオブジェクト変数は異なるオブジェクトを参照しますが、`person1` と `person2` は、private `personName` フィールドの値が同じであるため、等しいと見なされます。</span><span class="sxs-lookup"><span data-stu-id="990e5-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="990e5-148"><xref:System.Object> クラスは .NET Framework 内のすべての型の基底クラスであるため、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドは、他のすべての型に対して既定の等値比較を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="990e5-149">ただし、型は、多くの場合、<xref:System.Object.Equals%2A> メソッドをオーバーライドして値の等価性を実装します。</span><span class="sxs-lookup"><span data-stu-id="990e5-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="990e5-150">詳細については、以下を参照してください。の呼び出し元とメモ継承先のセクションです。</span><span class="sxs-lookup"><span data-stu-id="990e5-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-wrt"></a><span data-ttu-id="990e5-151">[!INCLUDE[wrt](~/includes/wrt-md.md)] のメモ</span><span class="sxs-lookup"><span data-stu-id="990e5-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="990e5-152">[!INCLUDE[wrt](~/includes/wrt-md.md)]内のクラスで <xref:System.Object.Equals%28System.Object%29> メソッドオーバーロードを呼び出すと、<xref:System.Object.Equals%28System.Object%29>をオーバーライドしないクラスの既定の動作が提供されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="990e5-153">これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)] に提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="990e5-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="990e5-154">[!INCLUDE[wrt](~/includes/wrt-md.md)] のクラスは <xref:System.Object>を継承せず、現在は <xref:System.Object.Equals%28System.Object%29> メソッドを実装していません。</span><span class="sxs-lookup"><span data-stu-id="990e5-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="990e5-155">ただし、 C#または Visual Basic コードで使用する場合、<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>、および <xref:System.Object.GetHashCode%2A> メソッドがあるように見えます。 .NET Framework は、これらのメソッドの既定の動作を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="990e5-156">または Visual Basic でC#記述された [!INCLUDE[wrt](~/includes/wrt-md.md)] クラスは、<xref:System.Object.Equals%28System.Object%29> メソッドのオーバーロードをオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-156">[!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="990e5-157">呼び出し元に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="990e5-157">Notes for Callers</span></span>  
 <span data-ttu-id="990e5-158">派生クラスは、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドして値の等価性を実装することがよくあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="990e5-159">また、型は、通常、<xref:System.IEquatable%601> インターフェイスを実装することによって、`Equals` メソッドに厳密に型指定された追加のオーバーロードを提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="990e5-160">`Equals` メソッドを呼び出して等しいかどうかをテストする場合は、現在のインスタンスが <xref:System.Object.Equals%2A?displayProperty=nameWithType> をオーバーライドし、`Equals` メソッドへの特定の呼び出しがどのように解決されるかを理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="990e5-161">それ以外の場合は、意図したものとは異なる等しいかどうかのテストを実行し、メソッドが予期しない値を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="990e5-162">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-162">The following example provides an illustration.</span></span> <span data-ttu-id="990e5-163">同じ文字列を持つ3つの <xref:System.Text.StringBuilder> オブジェクトをインスタンス化し、`Equals` メソッドに対して4つの呼び出しを行います。</span><span class="sxs-lookup"><span data-stu-id="990e5-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="990e5-164">最初のメソッド呼び出しで `true`が返され、残りの3つの `false`が返されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="990e5-165">最初のケースでは、厳密に型指定された <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> メソッドオーバーロード (値が等しいかどうかをテストする) が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="990e5-166">2つの <xref:System.Text.StringBuilder> オブジェクトに割り当てられた文字列は等しいため、メソッドは `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="990e5-167">ただし、<xref:System.Text.StringBuilder> では <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>はオーバーライドされません。</span><span class="sxs-lookup"><span data-stu-id="990e5-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="990e5-168">このため、<xref:System.Text.StringBuilder> オブジェクトが <xref:System.Object>にキャストされると、<xref:System.Text.StringBuilder> インスタンスが <xref:System.Object>型の変数に割り当てられ、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> メソッドに2つの <xref:System.Text.StringBuilder> オブジェクトが渡されたときに、既定の <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="990e5-169"><xref:System.Text.StringBuilder> は参照型であるため、この方法は、2つの <xref:System.Text.StringBuilder> オブジェクトを <xref:System.Object.ReferenceEquals%2A> メソッドに渡すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="990e5-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="990e5-170">3つの <xref:System.Text.StringBuilder> オブジェクトにはすべて同一の文字列が含まれますが、3つの異なるオブジェクトを参照します。</span><span class="sxs-lookup"><span data-stu-id="990e5-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="990e5-171">このため、この3つのメソッド呼び出しは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="990e5-172"><xref:System.Object.ReferenceEquals%2A> メソッドを呼び出すことにより、現在のオブジェクトを別のオブジェクトと比較して、参照の等価性を確認できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="990e5-173">Visual Basic では、`is` キーワード (`If Me Is otherObject Then ...`など) を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="990e5-174">継承に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="990e5-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="990e5-175">独自の型を定義する場合、その型は、その基本型の `Equals` メソッドによって定義された機能を継承します。</span><span class="sxs-lookup"><span data-stu-id="990e5-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="990e5-176">次の表は、.NET Framework の型の主なカテゴリに対する `Equals` メソッドの既定の実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="990e5-177">型のカテゴリ</span><span class="sxs-lookup"><span data-stu-id="990e5-177">Type category</span></span>|<span data-ttu-id="990e5-178">等しいかどうかの定義</span><span class="sxs-lookup"><span data-stu-id="990e5-178">Equality defined by</span></span>|<span data-ttu-id="990e5-179">コメント</span><span class="sxs-lookup"><span data-stu-id="990e5-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="990e5-180"><xref:System.Object> から直接派生したクラス</span><span class="sxs-lookup"><span data-stu-id="990e5-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="990e5-181">参照の等価性。<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>の呼び出しと同じです。</span><span class="sxs-lookup"><span data-stu-id="990e5-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="990e5-182">構造体</span><span class="sxs-lookup"><span data-stu-id="990e5-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="990e5-183">値の等価性。リフレクションを使用して、バイト単位の比較またはフィールドごとの比較を直接行います。</span><span class="sxs-lookup"><span data-stu-id="990e5-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="990e5-184">列挙型</span><span class="sxs-lookup"><span data-stu-id="990e5-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="990e5-185">値の列挙型と基になる値が同じである必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="990e5-186">デリゲート</span><span class="sxs-lookup"><span data-stu-id="990e5-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="990e5-187">デリゲートは、同じ型の呼び出しリストを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="990e5-188">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="990e5-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="990e5-189">参照の等価性。</span><span class="sxs-lookup"><span data-stu-id="990e5-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="990e5-190">値型の場合は、常に <xref:System.Object.Equals%2A>をオーバーライドする必要があります。これは、リフレクションに依存する等しいかどうかのテストによってパフォーマンスが低下するためです。</span><span class="sxs-lookup"><span data-stu-id="990e5-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="990e5-191">参照型の <xref:System.Object.Equals%2A> の既定の実装をオーバーライドして、参照の等価性ではなく値の等価性をテストし、値の等価性の正確な意味を定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="990e5-192">このような <xref:System.Object.Equals%2A> の実装では、2つのオブジェクトが同じインスタンスでない場合でも、同じ値を持つ場合は `true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="990e5-193">型の実装者は、オブジェクトの値を構成する対象を決定しますが、通常は、オブジェクトのインスタンス変数に格納されているデータの一部またはすべてを指定します。</span><span class="sxs-lookup"><span data-stu-id="990e5-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="990e5-194">たとえば、<xref:System.String> オブジェクトの値は、文字列の文字に基づいています。<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> メソッドは、同じ順序で同じ文字を含む2つの文字列インスタンスの `true` を返すように、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="990e5-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="990e5-195">次の例は、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドして値の等価性をテストする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="990e5-196">`Person` クラスの <xref:System.Object.Equals%2A> メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="990e5-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="990e5-197">`Person` その基底クラスの等価性の実装を受け入れた場合、2つの `Person` オブジェクトは、1つのオブジェクトを参照した場合にのみ等しくなります。</span><span class="sxs-lookup"><span data-stu-id="990e5-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="990e5-198">ただし、この場合、`Person.Id` プロパティの値が同じである場合、2つの `Person` オブジェクトは等しいことになります。</span><span class="sxs-lookup"><span data-stu-id="990e5-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="990e5-199"><xref:System.Object.Equals%2A>をオーバーライドするだけでなく、厳密に型指定されたテストを等価に提供するために、<xref:System.IEquatable%601> インターフェイスを実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="990e5-200">次のステートメントは、<xref:System.Object.Equals%28System.Object%29> メソッドのすべての実装に対して true である必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="990e5-201">一覧では、`x`、`y`、および `z` は**null**ではないオブジェクト参照を表します。</span><span class="sxs-lookup"><span data-stu-id="990e5-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="990e5-202">浮動小数点型が含まれている場合を除き、`x.Equals(x)` は `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="990e5-203">「 [ISO/IEC/IEEE 60559:2011」、「情報技術-マイクロプロセッサシステム--浮動小数点演算」を](https://www.iso.org/standard/57469.html)参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="990e5-204">`x.Equals(y)` からは `y.Equals(x)` と同じ値が返されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="990e5-205">`x` と `y` の両方が `NaN`ている場合、`x.Equals(y)` は `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="990e5-206">`(x.Equals(y) && y.Equals(z))` が `true`を返す場合、`x.Equals(z)` は `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="990e5-207">`x.Equals(y)` を連続して呼び出すと、`x` と `y` で参照されているオブジェクトが変更されない限り、同じ値が返されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="990e5-208">`x.Equals(null)` は、`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="990e5-209"><xref:System.Object.Equals%2A> の実装では、例外をスローすることはできません。常に値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="990e5-210">たとえば、`obj` が `null`場合、<xref:System.Object.Equals%2A> メソッドは <xref:System.ArgumentNullException>をスローするのではなく、`false` を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="990e5-211"><xref:System.Object.Equals%28System.Object%29>をオーバーライドするときは、次のガイドラインに従ってください。</span><span class="sxs-lookup"><span data-stu-id="990e5-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="990e5-212"><xref:System.IComparable> を実装する型は <xref:System.Object.Equals%28System.Object%29>をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="990e5-213"><xref:System.Object.Equals%28System.Object%29> をオーバーライドする型は、<xref:System.Object.GetHashCode%2A>もオーバーライドする必要があります。それ以外の場合、ハッシュテーブルが正しく機能しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="990e5-214">厳密に型指定されたテストが等しいかどうかをサポートするには、<xref:System.IEquatable%601> インターフェイスを実装することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="990e5-215"><xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> の実装は、<xref:System.Object.Equals%2A>と一貫性のある結果を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="990e5-216">プログラミング言語で演算子のオーバーロードがサポートされていて、特定の型に対して等値演算子をオーバーロードする場合は、<xref:System.Object.Equals%28System.Object%29> メソッドもオーバーライドして、等値演算子と同じ結果を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="990e5-217">これにより、<xref:System.Object.Equals%2A> を使用するクラスライブラリコード (<xref:System.Collections.ArrayList> や <xref:System.Collections.Hashtable>など) が、アプリケーションコードで等値演算子が使用される方法と一貫性のある方法で動作するようになります。</span><span class="sxs-lookup"><span data-stu-id="990e5-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="990e5-218">参照型のガイドライン</span><span class="sxs-lookup"><span data-stu-id="990e5-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="990e5-219">参照型の <xref:System.Object.Equals%28System.Object%29> をオーバーライドするには、次のガイドラインが適用されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="990e5-220">型のセマンティクスがなんらかの値を表すという事実に基づいている場合は、<xref:System.Object.Equals%2A> をオーバーライドすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="990e5-221"><xref:System.Object.Equals%2A>をオーバーライドする場合でも、ほとんどの参照型で等値演算子をオーバーロードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="990e5-222">ただし、複素数型などの値のセマンティクスを持つ参照型を実装する場合は、等値演算子をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="990e5-223">変更可能な参照型で <xref:System.Object.Equals%2A> をオーバーライドしないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="990e5-224">これは、前のセクションで説明したように、<xref:System.Object.Equals%2A> をオーバーライドするには、<xref:System.Object.GetHashCode%2A> メソッドもオーバーライドする必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="990e5-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="990e5-225">これは、変更可能な参照型のインスタンスのハッシュコードがその有効期間中に変更される可能性があることを意味します。そのため、ハッシュテーブル内のオブジェクトが失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="990e5-226">値型のガイドライン</span><span class="sxs-lookup"><span data-stu-id="990e5-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="990e5-227">次のガイドラインは、値型の <xref:System.Object.Equals%28System.Object%29> をオーバーライドする場合に適用されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="990e5-228">値が参照型である1つ以上のフィールドを含む値型を定義する場合は、<xref:System.Object.Equals%28System.Object%29>をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="990e5-229"><xref:System.ValueType> によって提供される <xref:System.Object.Equals%28System.Object%29> の実装では、フィールドがすべて値型である値型のバイト単位の比較が実行されますが、リフレクションを使用して、フィールドに参照型が含まれる値型のフィールドごとの比較が実行されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="990e5-230"><xref:System.Object.Equals%2A> をオーバーライドし、開発言語で演算子のオーバーロードがサポートされている場合は、等値演算子をオーバーロードする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="990e5-231"><xref:System.IEquatable%601> インターフェイスを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="990e5-232">厳密に型指定された <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> メソッドを呼び出すと、`obj` 引数のボックス化が回避されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="990e5-233">次の例は、<xref:System.Object.Equals%2A> メソッドをオーバーライドして値の等価性を提供する `Point` クラスと、`Point`から派生した `Point3D` クラスを示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="990e5-234">値が等しいかどうかをテストするために <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> `Point` オーバーライドされるため、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="990e5-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="990e5-235">ただし、`Point3D.Equals` は `Point.Equals` を呼び出します。 `Point` は、値の等価性を提供する方法で <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> を実装するためです。</span><span class="sxs-lookup"><span data-stu-id="990e5-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="990e5-236">`Point.Equals` メソッドは、`obj` 引数が**null**でないこと、およびこのオブジェクトと同じ型のインスタンスを参照していることを確認します。</span><span class="sxs-lookup"><span data-stu-id="990e5-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="990e5-237">いずれかのチェックが失敗した場合、メソッドは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="990e5-238">`Point.Equals` メソッドは、<xref:System.Object.GetType%2A> メソッドを呼び出して、2つのオブジェクトの実行時の型が同一かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="990e5-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="990e5-239">メソッドが、Visual Basic 内のフォーム `obj is Point` C#または `TryCast(obj, Point)` のチェックを使用した場合、`obj` と現在のインスタンスが同じ実行時の型ではない場合でも、`Point`が `obj` の派生クラスのインスタンスである場合に、このチェックによって `true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="990e5-240">両方のオブジェクトが同じ型であることを検証した後、メソッドは、`obj` を `Point` 型にキャストし、2つのオブジェクトのインスタンスフィールドを比較した結果を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="990e5-241">`Point3D.Equals`では、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>をオーバーライドする継承された `Point.Equals` メソッドが、他の処理が行われる前に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="990e5-242">`Point3D` はシールクラス (Visual Basic では`NotInheritable`) であるため、`TryCast(obj, Point)` の `obj is Point` の形式C#でのチェックインは、Visual Basic が `obj` オブジェクトであることを保証するのに適しています。`Point3D`</span><span class="sxs-lookup"><span data-stu-id="990e5-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="990e5-243">`Point3D` オブジェクトの場合、`Point` オブジェクトにキャストされ、<xref:System.Object.Equals%2A>の基本クラスの実装に渡されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="990e5-244">継承された `Point.Equals` メソッドがを返す場合にのみ、メソッドは、派生クラスで導入された `z` インスタンスフィールドを比較 `true` ます。</span><span class="sxs-lookup"><span data-stu-id="990e5-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="990e5-245">次の例では、内部的に四角形を2つの `Point` オブジェクトとして実装する `Rectangle` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="990e5-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="990e5-246">`Rectangle` クラスも <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> をオーバーライドして、値の等価性を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="990e5-247">や Visual Basic などのC#一部の言語では、演算子のオーバーロードがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="990e5-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="990e5-248">型が等値演算子をオーバーロードする場合は、同じ機能を提供するために <xref:System.Object.Equals%28System.Object%29> メソッドもオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="990e5-249">通常、これを行うには、次の例のように、オーバーロードされた等値演算子の観点から <xref:System.Object.Equals%28System.Object%29> メソッドを記述します。</span><span class="sxs-lookup"><span data-stu-id="990e5-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="990e5-250">`Complex` は値型であるため、から派生することはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="990e5-251">したがって、<xref:System.Object.Equals%28System.Object%29> メソッドに対するオーバーライドでは、各オブジェクトの正確な実行時の型を決定するために <xref:System.Object.GetType%2A> を呼び出す必要はC#ありませんが、または Visual Basic の `TypeOf` 演算子を `is` 使用して `obj` パラメーターの型を確認することができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="990e5-252">比較する最初のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="990e5-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="990e5-253">比較する 2 番目のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="990e5-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="990e5-254">指定されたインスタンスが等しいかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="990e5-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="990e5-255">オブジェクトが等しいと見なされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="990e5-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="990e5-256"><paramref name="objA" /> と <paramref name="objB" /> の両方が **null** の場合、このメソッドは <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-257">静的 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> メソッドは、`objA` と `objB`の2つのオブジェクトが等しいかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="990e5-258">また、値が等しい場合に**null**を持つオブジェクトをテストすることもできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="990e5-259">次のように、`objA` と `objB` が等しいかどうかを比較します。</span><span class="sxs-lookup"><span data-stu-id="990e5-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="990e5-260">2つのオブジェクトが同じオブジェクト参照を表しているかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="990e5-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="990e5-261">その場合、メソッドは `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="990e5-262">このテストは、<xref:System.Object.ReferenceEquals%2A> メソッドを呼び出すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="990e5-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="990e5-263">さらに、`objA` と `objB` の両方が**null**の場合、メソッドは `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="990e5-264">`objA` または `objB` のいずれかが**null**かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="990e5-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="990e5-265">その場合は `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="990e5-266">2つのオブジェクトが同じオブジェクト参照を表しておらず、どちらも**null**でない場合は、`objA`を呼び出します。`Equals`(`objB`) し、結果を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="990e5-267">これは、`objA` が <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドする場合に、このオーバーライドが呼び出されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="990e5-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="990e5-268">次の例は、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29> メソッドを示し、<xref:System.Object.ReferenceEquals%2A> メソッドと比較します。</span><span class="sxs-lookup"><span data-stu-id="990e5-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="990e5-269">オブジェクトが、ガベージ コレクションによって収集される前に、リソースの解放とその他のクリーンアップ操作の実行を試みることができるようにします。</span><span class="sxs-lookup"><span data-stu-id="990e5-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-270"><xref:System.Object.Finalize%2A> メソッドは、オブジェクトが破棄される前に、現在のオブジェクトによって保持されているアンマネージリソースに対してクリーンアップ操作を実行するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="990e5-271">メソッドは保護されているため、このクラスまたは派生クラスを介してのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="990e5-272">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="990e5-272">In this section:</span></span>  
  
-   [<span data-ttu-id="990e5-273">終了処理のしくみ</span><span class="sxs-lookup"><span data-stu-id="990e5-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="990e5-274">実装に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="990e5-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="990e5-275">SafeHandle 代替</span><span class="sxs-lookup"><span data-stu-id="990e5-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="990e5-276">終了処理のしくみ</span><span class="sxs-lookup"><span data-stu-id="990e5-276">How finalization works</span></span>  
 <span data-ttu-id="990e5-277"><xref:System.Object> クラスは、<xref:System.Object.Finalize%2A> メソッドの実装を提供しません。また、ガベージコレクターは、<xref:System.Object.Finalize%2A> メソッドをオーバーライドしない限り、<xref:System.Object> から派生した型に終了をマークしません。</span><span class="sxs-lookup"><span data-stu-id="990e5-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="990e5-278">型が <xref:System.Object.Finalize%2A> メソッドをオーバーライドする場合、ガベージコレクターは、その型の各インスタンスのエントリを、終了キューと呼ばれる内部構造に追加します。</span><span class="sxs-lookup"><span data-stu-id="990e5-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="990e5-279">終了キューには、ガベージコレクターがメモリを再利用できるようにするために、終了コードを実行する必要があるマネージヒープ内のすべてのオブジェクトのエントリが含まれています。</span><span class="sxs-lookup"><span data-stu-id="990e5-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="990e5-280">次に、ガベージコレクターは、次の条件下で <xref:System.Object.Finalize%2A> メソッドを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="990e5-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="990e5-281">オブジェクトが <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッドの呼び出しによって終了から除外されている場合を除き、オブジェクトにアクセスできないことをガベージコレクターが検出した後。</span><span class="sxs-lookup"><span data-stu-id="990e5-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="990e5-282">オブジェクトが終了処理から除外されている場合を除き、アプリケーションドメインのシャットダウン時に**のみ .NET Framework**。</span><span class="sxs-lookup"><span data-stu-id="990e5-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="990e5-283">シャットダウン中に、まだアクセス可能なオブジェクトであっても、終了します。</span><span class="sxs-lookup"><span data-stu-id="990e5-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="990e5-284"><xref:System.Object.Finalize%2A> は、特定のインスタンスで1回だけ自動的に呼び出されます。ただし、<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> などの機構を使用してオブジェクトを再登録しても、その後、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッドが呼び出されていない場合は除きます。</span><span class="sxs-lookup"><span data-stu-id="990e5-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="990e5-285"><xref:System.Object.Finalize%2A> の操作には、次の制限があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="990e5-286">ファイナライザーが実行される正確な時間は未定義です。</span><span class="sxs-lookup"><span data-stu-id="990e5-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="990e5-287">クラスのインスタンスのリソースを確実に解放するには、`Close` メソッドを実装するか、<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> の実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="990e5-288">2つのオブジェクトのファイナライザーは、一方のオブジェクトが他方を参照している場合でも、特定の順序で実行されることは保証されません。</span><span class="sxs-lookup"><span data-stu-id="990e5-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="990e5-289">つまり、オブジェクト A がオブジェクト B への参照を持ち、両方にファイナライザーがある場合、オブジェクト B は、オブジェクト A のファイナライザーが開始されたときに既に完了している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="990e5-290">ファイナライザーを実行するスレッドが指定されていません。</span><span class="sxs-lookup"><span data-stu-id="990e5-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="990e5-291"><xref:System.Object.Finalize%2A> メソッドが完了まで実行されないか、次の例外的な状況下ではまったく実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="990e5-292">別のファイナライザーが無期限にブロックした場合 (無限ループに入る場合、は取得できないロックを取得しようとします)。</span><span class="sxs-lookup"><span data-stu-id="990e5-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="990e5-293">ランタイムはファイナライザーの実行を完了しようとするため、ファイナライザーが無期限にブロックした場合、他のファイナライザーが呼び出されないことがあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="990e5-294">ランタイムをクリーンアップする機会を与えずにプロセスを終了する場合は。</span><span class="sxs-lookup"><span data-stu-id="990e5-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="990e5-295">この場合、ランタイムのプロセス終了通知は、DLL_PROCESS_DETACH 通知です。</span><span class="sxs-lookup"><span data-stu-id="990e5-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="990e5-296">実行可能オブジェクトの数が減少し続けている間、シャットダウン中にも、ランタイムはオブジェクトの最終処理を継続します。</span><span class="sxs-lookup"><span data-stu-id="990e5-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="990e5-297"><xref:System.Object.Finalize%2A> または <xref:System.Object.Finalize%2A> のオーバーライドによって例外がスローされ、ランタイムが既定のポリシーをオーバーライドするアプリケーションによってホストされていない場合、ランタイムはプロセスを終了し、アクティブな `try`/`finally` ブロックまたはファイナライザーが実行されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="990e5-298">この動作により、ファイナライザーがリソースを解放または破棄できない場合に、プロセスの整合性が確保されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="990e5-299">Finalize メソッドのオーバーライド</span><span class="sxs-lookup"><span data-stu-id="990e5-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="990e5-300">ファイルハンドルやデータベース接続など、アンマネージリソースを使用するクラスの <xref:System.Object.Finalize%2A> をオーバーライドする必要があります。このクラスを使用するマネージオブジェクトは、ガベージコレクション中に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="990e5-301">マネージリソースは、ガベージコレクターによって自動的に解放されるので、マネージオブジェクトの <xref:System.Object.Finalize%2A> メソッドを実装しないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="990e5-302">アンマネージリソースをラップする <xref:System.Runtime.InteropServices.SafeHandle> オブジェクトが使用可能な場合は、セーフハンドルで dispose パターンを実装し、<xref:System.Object.Finalize%2A>をオーバーライドしないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="990e5-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="990e5-303">詳細については、「 [SafeHandle の代替](#SafeHandle)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="990e5-304"><xref:System.Object.Finalize%2A?displayProperty=nameWithType> メソッドでは、既定では何も実行されませんが、必要な場合にのみ <xref:System.Object.Finalize%2A> をオーバーライドし、アンマネージリソースだけを解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="990e5-305">メモリの再利用は、終了操作を実行すると、少なくとも2つのガベージコレクションが必要になるため、かなり長くかかる傾向があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="990e5-306">さらに、参照型に対してのみ <xref:System.Object.Finalize%2A> メソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="990e5-307">共通言語ランタイムは、参照型のみを終了します。</span><span class="sxs-lookup"><span data-stu-id="990e5-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="990e5-308">値型のファイナライザーは無視されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="990e5-309"><xref:System.Object.Finalize%2A?displayProperty=nameWithType> メソッドのスコープは `protected`です。</span><span class="sxs-lookup"><span data-stu-id="990e5-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="990e5-310">クラス内でこのメソッドをオーバーライドする場合は、このスコープの範囲を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="990e5-311"><xref:System.Object.Finalize%2A> メソッドを保護したままにすると、アプリケーションのユーザーがオブジェクトの <xref:System.Object.Finalize%2A> メソッドを直接呼び出すことを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="990e5-312">派生型の <xref:System.Object.Finalize%2A> のすべての実装は、その基本型の <xref:System.Object.Finalize%2A>の実装を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="990e5-313">これは、アプリケーションコードが <xref:System.Object.Finalize%2A>を呼び出すことができる唯一のケースです。</span><span class="sxs-lookup"><span data-stu-id="990e5-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="990e5-314">オブジェクトの <xref:System.Object.Finalize%2A> メソッドは、基底クラスのオブジェクト以外のオブジェクトに対してメソッドを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="990e5-315">これは、共通言語ランタイムがシャットダウンされる場合など、呼び出し元のオブジェクトと呼び出された別のオブジェクトが同時にガベージ コレクションされることがあるからです。</span><span class="sxs-lookup"><span data-stu-id="990e5-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="990e5-316">C#コンパイラでは、<xref:System.Object.Finalize%2A> メソッドをオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="990e5-317">代わりに、クラスの[デストラクター](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)を実装することによってファイナライザーを提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="990e5-318">デストラクター C#は、基底クラスのデストラクターを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="990e5-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="990e5-319">ビジュアルC++には、<xref:System.Object.Finalize%2A> メソッドを実装するための独自の構文も用意されています。</span><span class="sxs-lookup"><span data-stu-id="990e5-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="990e5-320">詳細については、「[方法: クラスと構造体を定義および使用する (C++/cli)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)」の「デストラクターとファイナライザー」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="990e5-321">ガベージコレクションは非決定的であるため、ガベージコレクターが終了処理を実行するタイミングを正確に把握することはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="990e5-322">リソースをすぐに解放するには、 [dispose パターン](~/docs/standard/garbage-collection/implementing-dispose.md)と <xref:System.IDisposable> インターフェイスを実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="990e5-323"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 実装は、アンマネージリソースを解放するためにクラスのコンシューマーによって呼び出すことができます。また、<xref:System.IDisposable.Dispose%2A> メソッドが呼び出されていない場合は、<xref:System.Object.Finalize%2A> メソッドを使用してアンマネージリソースを解放できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="990e5-324"><xref:System.Object.Finalize%2A> は、ガベージコレクション中にクリーンアップされた後、オブジェクトの resurrecting (つまり、オブジェクトに再度アクセスできるようにする) など、ほぼすべてのアクションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="990e5-325">ただし、オブジェクトを再生することはできません。<xref:System.Object.Finalize%2A> は、ガベージコレクション中に再生オブジェクトで呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span>
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="990e5-326">代替手段としての SafeHandle</span><span class="sxs-lookup"><span data-stu-id="990e5-326">The SafeHandle alternative</span></span>  
 <span data-ttu-id="990e5-327">アプリケーションの状態を想定することはできず、<xref:System.OutOfMemoryException> や <xref:System.StackOverflowException> などの未処理のシステム例外によってファイナライザーが終了するため、信頼性の高いファイナライザーを作成することは、多くの場合、困難です。</span><span class="sxs-lookup"><span data-stu-id="990e5-327">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="990e5-328">アンマネージリソースを解放するためにクラスのファイナライザーを実装する代わりに、<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> クラスから派生したオブジェクトを使用してアンマネージリソースをラップし、ファイナライザーを使用せずに dispose パターンを実装することができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-328">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="990e5-329">.NET Framework には、<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>から派生した <xref:Microsoft.Win32?displayProperty=nameWithType> 名前空間の次のクラスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="990e5-329">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="990e5-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> は、ファイルハンドルのラッパークラスです。</span><span class="sxs-lookup"><span data-stu-id="990e5-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="990e5-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> は、メモリマップトファイルハンドルのラッパークラスです。</span><span class="sxs-lookup"><span data-stu-id="990e5-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="990e5-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> は、アンマネージメモリブロックへのポインターのラッパークラスです。</span><span class="sxs-lookup"><span data-stu-id="990e5-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="990e5-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>、および <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> は、暗号化ハンドルのラッパークラスです。</span><span class="sxs-lookup"><span data-stu-id="990e5-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="990e5-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> は、パイプハンドルのラッパークラスです。</span><span class="sxs-lookup"><span data-stu-id="990e5-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="990e5-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> は、レジストリキーへのハンドルのラッパークラスです。</span><span class="sxs-lookup"><span data-stu-id="990e5-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="990e5-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> は、待機ハンドルのラッパークラスです。</span><span class="sxs-lookup"><span data-stu-id="990e5-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="990e5-337">次の例では、<xref:System.Object.Finalize%2A> メソッドをオーバーライドする代わりに、セーフハンドルで[dispose パターン](~/docs/standard/garbage-collection/implementing-dispose.md)を使用します。</span><span class="sxs-lookup"><span data-stu-id="990e5-337">The following example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="990e5-338">これは、特定のファイル拡張子を持つファイルを処理するアプリケーションに関するレジストリ情報をラップする `FileAssociation` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="990e5-338">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="990e5-339">Windows [regopenkeyex が](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)関数の呼び出しによって `out` パラメーターとして返される2つのレジストリハンドルは、<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> コンストラクターに渡されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-339">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="990e5-340">次に、型の protected `Dispose` メソッドは、`SafeRegistryHandle.Dispose` メソッドを呼び出して、これらの2つのハンドルを解放します。</span><span class="sxs-lookup"><span data-stu-id="990e5-340">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="990e5-341">次の例では、<xref:System.Object.Finalize%2A> をオーバーライドするオブジェクトが破棄されたときに、<xref:System.Object.Finalize%2A> メソッドが呼び出されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="990e5-341">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="990e5-342">実稼働アプリケーションでは、オブジェクトに保持されているアンマネージリソースを解放するために <xref:System.Object.Finalize%2A> メソッドがオーバーライドされることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-342">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="990e5-343">また、このC#例では、<xref:System.Object.Finalize%2A> メソッドをオーバーライドするのではなく、デストラクターが使用されていることにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-343">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="990e5-344"><xref:System.Object.Finalize%2A> メソッドをオーバーライドするその他の例については、「<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッド」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-344">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="990e5-345">既定のハッシュ関数として機能します。</span><span class="sxs-lookup"><span data-stu-id="990e5-345">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="990e5-346">現在のオブジェクトのハッシュ コード。</span><span class="sxs-lookup"><span data-stu-id="990e5-346">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-347">ハッシュコードは、<xref:System.Collections.Generic.Dictionary%602> クラス、<xref:System.Collections.Hashtable> クラス、<xref:System.Collections.DictionaryBase> クラスから派生した型など、ハッシュベースのコレクションにオブジェクトを挿入および識別するために使用される数値です。</span><span class="sxs-lookup"><span data-stu-id="990e5-347">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="990e5-348"><xref:System.Object.GetHashCode%2A> メソッドは、オブジェクトの等価性を簡単にチェックする必要があるアルゴリズムに対して、このハッシュコードを提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-348">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="990e5-349">ハッシュコードをハッシュテーブルで使用する方法と、追加のハッシュコードアルゴリズムの詳細については、Wikipedia の[Hash 関数](https://en.wikipedia.org/wiki/Hash_function)のエントリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-349">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="990e5-350">等しい2つのオブジェクトが等しい場合は、そのハッシュコードが等しいことを示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-350">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="990e5-351">ただし、逆は true ではありません。等値のハッシュコードでは、オブジェクトの等価性を意味しません。これは、異なる (等しくない) オブジェクトが同じハッシュコードを持つことができるためです。</span><span class="sxs-lookup"><span data-stu-id="990e5-351">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="990e5-352">さらに、.NET は <xref:System.Object.GetHashCode%2A> メソッドの既定の実装を保証しません。また、このメソッドが返す値は、異なるバージョンの .NET Framework や .NET Core などの .NET 実装と、32ビットおよび64ビットプラットフォームなどのプラットフォームで異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-352">Furthermore, .NET does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET implementations, such as different versions of .NET Framework and .NET Core, and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="990e5-353">このような理由から、このメソッドの既定の実装をハッシュ用の一意のオブジェクト識別子として使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-353">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="990e5-354">これには、次の2つの影響があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-354">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="990e5-355">等しいハッシュコードでは、オブジェクトの等価性を意味することを想定しないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-355">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="990e5-356">同じオブジェクトがアプリケーションドメイン、プロセス、およびプラットフォーム間でハッシュされる可能性があるため、作成元のアプリケーションドメインの外部でハッシュコードを永続化したり、使用したりしないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-356">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="990e5-357">ハッシュコードは、ハッシュテーブルに基づくコレクション内での効率的な挿入と検索を目的としています。</span><span class="sxs-lookup"><span data-stu-id="990e5-357">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="990e5-358">ハッシュコードが永続的な値ではありません。</span><span class="sxs-lookup"><span data-stu-id="990e5-358">A hash code is not a permanent value.</span></span> <span data-ttu-id="990e5-359">理由:</span><span class="sxs-lookup"><span data-stu-id="990e5-359">For this reason:</span></span>  
>   
> -   <span data-ttu-id="990e5-360">ハッシュコード値をシリアル化したり、データベースに格納したりしないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-360">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="990e5-361">キーとしてハッシュコードを使用して、キー付きコレクションからオブジェクトを取得することは避けてください。</span><span class="sxs-lookup"><span data-stu-id="990e5-361">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="990e5-362">アプリケーションドメインまたはプロセス間でハッシュコードを送信しないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-362">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="990e5-363">場合によっては、プロセスごとまたはアプリケーションごとのドメインごとにハッシュコードを計算することがあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-363">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="990e5-364">暗号ハッシュ関数によって返される値の代わりにハッシュコードを使用しないでください。暗号化に強力なハッシュが必要な場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="990e5-364">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="990e5-365">暗号化ハッシュの場合は、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> または <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> クラスから派生したクラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="990e5-365">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="990e5-366">2つのオブジェクトが等しいかどうかを判断するために、ハッシュコードが等しいかどうかをテストしないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-366">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="990e5-367">(等しくないオブジェクトは、同一のハッシュコードを持つことができます)。等しいかどうかをテストするには、<xref:System.Object.ReferenceEquals%2A> または <xref:System.Object.Equals%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="990e5-367">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="990e5-368"><xref:System.Object.GetHashCode%2A> メソッドは、派生型でオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-368">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="990e5-369"><xref:System.Object.GetHashCode%2A> がオーバーライドされていない場合、参照型のハッシュコードは、オブジェクトの参照に基づいてハッシュコードを計算する基底クラスの <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> メソッドを呼び出すことによって計算されます。詳細については、「<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-369">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="990e5-370">言い換えると、<xref:System.Object.ReferenceEquals%2A> メソッドが返す2つのオブジェクト `true` 同じハッシュコードを持つことになります。</span><span class="sxs-lookup"><span data-stu-id="990e5-370">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="990e5-371">値型が <xref:System.Object.GetHashCode%2A>をオーバーライドしない場合、基本クラスの <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> メソッドは、リフレクションを使用して、型のフィールドの値に基づいてハッシュコードを計算します。</span><span class="sxs-lookup"><span data-stu-id="990e5-371">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="990e5-372">言い換えると、同じ値を持つフィールドを持つ値型には、同じハッシュコードが含まれます。</span><span class="sxs-lookup"><span data-stu-id="990e5-372">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="990e5-373"><xref:System.Object.GetHashCode%2A>のオーバーライドの詳細については、「継承に関する注意事項」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-373">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="990e5-374"><xref:System.Object.GetHashCode%2A> メソッドをオーバーライドする場合は、<xref:System.Object.Equals%2A>もオーバーライドする必要があります (その逆も同様)。</span><span class="sxs-lookup"><span data-stu-id="990e5-374">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="990e5-375">2つのオブジェクトが等しいかどうかをテストするときに、オーバーライドされた <xref:System.Object.Equals%2A> メソッドが `true` を返す場合、オーバーライドされた <xref:System.Object.GetHashCode%2A> メソッドは、2つのオブジェクトに対して同じ値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-375">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="990e5-376">ハッシュテーブルのキーとして使用されているオブジェクトが <xref:System.Object.GetHashCode%2A>の便利な実装を提供していない場合は、<xref:System.Collections.Hashtable> クラスコンストラクターのいずれかのオーバーロードに <xref:System.Collections.IEqualityComparer> の実装を指定することで、ハッシュコードプロバイダーを指定できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-376">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-wrt"></a><span data-ttu-id="990e5-377">[!INCLUDE[wrt](~/includes/wrt-md.md)] のメモ</span><span class="sxs-lookup"><span data-stu-id="990e5-377">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="990e5-378">[!INCLUDE[wrt](~/includes/wrt-md.md)]のクラスで <xref:System.Object.GetHashCode%2A> メソッドを呼び出すと、<xref:System.Object.GetHashCode%2A>をオーバーライドしないクラスの既定の動作が提供されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-378">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="990e5-379">これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)] に提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="990e5-379">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="990e5-380">[!INCLUDE[wrt](~/includes/wrt-md.md)] のクラスは <xref:System.Object>を継承せず、現在は <xref:System.Object.GetHashCode%2A>を実装していません。</span><span class="sxs-lookup"><span data-stu-id="990e5-380">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="990e5-381">ただし、 C#または Visual Basic コードで使用する場合、<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>、および <xref:System.Object.GetHashCode%2A> メソッドがあるように見えます。 .NET Framework は、これらのメソッドの既定の動作を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-381">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="990e5-382">または Visual Basic でC#記述された [!INCLUDE[wrt](~/includes/wrt-md.md)] クラスは、<xref:System.Object.GetHashCode%2A> メソッドをオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-382">[!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="990e5-383"><xref:System.Int32> 型と同じまたは小さい範囲の数値のハッシュコードを計算する最も簡単な方法の1つは、単にその値を返すことです。</span><span class="sxs-lookup"><span data-stu-id="990e5-383">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="990e5-384">次の例は、`Number` 構造体のこのような実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-384">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="990e5-385">多くの場合、型にはハッシュコードの生成に参加できる複数のデータフィールドがあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-385">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="990e5-386">ハッシュコードを生成する方法の1つは、次の例に示すように、`XOR (eXclusive OR)` 操作を使用してこれらのフィールドを結合することです。</span><span class="sxs-lookup"><span data-stu-id="990e5-386">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="990e5-387">前の例では、(n1, n2) と (n2, n1) に対して同じハッシュコードが返されるため、望ましいよりも多くの衝突が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-387">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="990e5-388">これらのケースのハッシュコードが同一でないように、いくつかのソリューションを利用できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-388">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="990e5-389">1つは、各フィールドの順序を反映する `Tuple` オブジェクトのハッシュコードを返すことです。</span><span class="sxs-lookup"><span data-stu-id="990e5-389">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="990e5-390"><xref:System.Tuple%602> クラスを使用する実装の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-390">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="990e5-391">ただし、`Tuple` オブジェクトをインスタンス化することによるパフォーマンスのオーバーヘッドによって、ハッシュテーブルに多数のオブジェクトが格納されるアプリケーションの全体的なパフォーマンスに大きな影響を与える可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-391">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="990e5-392">2つ目の代替ソリューションでは、連続するフィールドのハッシュコードを2つ以上のビットで左にシフトすることで、個々のハッシュコードを重み付けします。</span><span class="sxs-lookup"><span data-stu-id="990e5-392">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="990e5-393">理想的には、ビット31を超えてシフトされたビットは、破棄されるのではなく、ラップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-393">Optimally, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="990e5-394">ビットは Visual Basic との両方C#の左シフト演算子によって破棄されるため、次のような左シフトアンドラップメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-394">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="990e5-395">次の例では、この shift キーと wrap メソッドを使用して、前の例で使用した `Point` 構造のハッシュコードを計算します。</span><span class="sxs-lookup"><span data-stu-id="990e5-395">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="990e5-396">ハッシュ関数は、オブジェクトの値に対応する数値 (ハッシュコード) をすばやく生成するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-396">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="990e5-397">通常、ハッシュ関数はそれぞれの型に固有であり、一意性を確保するには、少なくとも1つのインスタンスフィールドを入力として使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-397">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="990e5-398">ハッシュコードは、静的フィールドの値を使用して計算することはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-398">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="990e5-399"><see cref="T:System.Object" />から派生したクラスの場合、<see langword="GetHashCode" /> メソッドは、派生クラスが参照の等価性を定義する場合にのみ、基本クラス <see cref="M:System.Object.GetHashCode" /> の実装にデリゲートできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-399">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="990e5-400">参照型の <see cref="M:System.Object.GetHashCode" /> の既定の実装では、<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> メソッドによって返されるハッシュコードが返されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-400">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="990e5-401">変更できない参照型については、<see cref="M:System.Object.GetHashCode" /> をオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-401">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="990e5-402">一般に、変更可能な参照型の場合は、次の場合にのみ <see cref="M:System.Object.GetHashCode" /> をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-402">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="990e5-403">-変更できないフィールドからハッシュコードを計算できます。もしくは</span><span class="sxs-lookup"><span data-stu-id="990e5-403">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="990e5-404">-ハッシュコードに依存するコレクションにオブジェクトが含まれている間は、変更可能なオブジェクトのハッシュコードが変更されないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-404">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="990e5-405">それ以外の場合は、変更可能なオブジェクトがハッシュテーブルで失われると考えられます。</span><span class="sxs-lookup"><span data-stu-id="990e5-405">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="990e5-406">変更可能な参照型に対して <see cref="M:System.Object.GetHashCode" /> をオーバーライドする場合、ドキュメントでは、オブジェクトがハッシュテーブルに格納されている間、型のユーザーがオブジェクトの値を変更しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-406">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="990e5-407">値型の場合、<see cref="M:System.ValueType.GetHashCode" /> には、リフレクションを使用する既定のハッシュコード実装が用意されています。</span><span class="sxs-lookup"><span data-stu-id="990e5-407">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="990e5-408">パフォーマンスを向上させるためにオーバーライドすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-408">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="990e5-409">さまざまな方法でハッシュコードを計算する詳細と例については、「例」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-409">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="990e5-410">ハッシュ関数には、次のプロパティが必要です。</span><span class="sxs-lookup"><span data-stu-id="990e5-410">A hash function must have the following properties:</span></span> 
<span data-ttu-id="990e5-411">-2 つのオブジェクトが等しいと比較される場合、各オブジェクトの <see cref="M:System.Object.GetHashCode" /> メソッドは同じ値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-411">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="990e5-412">ただし、2つのオブジェクトが等しいかどうかを比較しない場合、2つのオブジェクトの <see cref="M:System.Object.GetHashCode" /> メソッドは、異なる値を返す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="990e5-412">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="990e5-413">-オブジェクトの <see cref="M:System.Object.GetHashCode" /> メソッドは、オブジェクトの system.object メソッドの戻り値を決定する[オブジェクトの状態](xref:System.Object.Equals*)が変更されていない限り、常に同じハッシュコードを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-413">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="990e5-414">これはアプリケーションの現在の実行に対してのみ true であり、アプリケーションが再実行されると別のハッシュコードが返される可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-414">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="990e5-415">-最適なパフォーマンスを得るために、ハッシュ関数では、大量の入力 (大量のクラスター化された入力を含む) に対して均等な分布を生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-415">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="990e5-416">暗黙的には、オブジェクトの状態を変更すると、ハッシュテーブルのパフォーマンスが最適になるように、結果のハッシュコードが大幅に変更されることになります。</span><span class="sxs-lookup"><span data-stu-id="990e5-416">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="990e5-417">-ハッシュ関数は、コンピューティングのコストを安くする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-417">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="990e5-418">-<see cref="M:System.Object.GetHashCode" /> メソッドは例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="990e5-418">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="990e5-419">たとえば、<see cref="T:System.String" /> クラスによって提供される <see cref="M:System.String.GetHashCode" /> メソッドの実装は、同一の文字列値に対して同一のハッシュコードを返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-419">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="990e5-420">したがって、2つの <see cref="T:System.String" /> オブジェクトが同じ文字列値を表す場合は、同じハッシュコードを返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-420">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="990e5-421">また、このメソッドは、入力が特定の範囲でクラスター化されている場合でも、文字列内のすべての文字を使用して、適度にランダムに分散された出力を生成します (たとえば、文字列に 65535 Unicode 文字を含めることはできますが、多くのユーザーには、128の ASCII 文字のみを含む文字列がある可能性が</span><span class="sxs-lookup"><span data-stu-id="990e5-421">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="990e5-422">クラスに適切なハッシュ関数を指定すると、それらのオブジェクトをハッシュテーブルに追加するときのパフォーマンスに大きく影響することがあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-422">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="990e5-423">ハッシュ関数の適切な実装を提供するキーを持つハッシュテーブルでは、要素の検索には一定の時間がかかります (O (1) 操作など)。</span><span class="sxs-lookup"><span data-stu-id="990e5-423">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="990e5-424">ハッシュ関数が不適切に実装されているハッシュテーブルでは、検索のパフォーマンスはハッシュテーブル内の項目の数 (たとえば、O (`n`) 操作など) によって異なります (`n` はハッシュテーブル内の項目の数です)。</span><span class="sxs-lookup"><span data-stu-id="990e5-424">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="990e5-425">悪意のあるユーザーがデータを入力すると、衝突の数が増えるため、次のような状況下で、ハッシュテーブルに依存するアプリケーションのパフォーマンスが大幅に低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-425">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="990e5-426">-ハッシュ関数が頻繁に衝突を生成する場合。</span><span class="sxs-lookup"><span data-stu-id="990e5-426">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="990e5-427">-ハッシュテーブル内のオブジェクトの大部分が、互いに等しいまたはほぼ等しいハッシュコードを生成する場合。</span><span class="sxs-lookup"><span data-stu-id="990e5-427">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="990e5-428">-ハッシュコードの計算元のデータをユーザーが入力した場合。</span><span class="sxs-lookup"><span data-stu-id="990e5-428">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="990e5-429"><see cref="M:System.Object.GetHashCode" /> をオーバーライドする派生クラスも <see cref="M:System.Object.Equals(System.Object)" /> をオーバーライドして、等しいと見なされる2つのオブジェクトが同じハッシュコードを持つことを保証する必要があります。それ以外の場合、<see cref="T:System.Collections.Hashtable" /> の種類が正しく機能しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-429">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="990e5-430">現在のインスタンスの <see cref="T:System.Type" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="990e5-430">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="990e5-431">現在のインスタンスの正確なランタイム型。</span><span class="sxs-lookup"><span data-stu-id="990e5-431">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-432"><xref:System.Object?displayProperty=nameWithType> は .NET 型システムのすべての型の基本クラスであるため、<xref:System.Object.GetType%2A> メソッドを使用して、すべての .NET 型を表す <xref:System.Type> オブジェクトを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-432">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET types.</span></span> <span data-ttu-id="990e5-433">.NET では、次の5種類のカテゴリが認識されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-433">.NET recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="990e5-434"><xref:System.Object?displayProperty=nameWithType>から派生したクラス</span><span class="sxs-lookup"><span data-stu-id="990e5-434">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="990e5-435">値型。 <xref:System.ValueType?displayProperty=nameWithType>から派生します。</span><span class="sxs-lookup"><span data-stu-id="990e5-435">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="990e5-436">.NET Framework 2.0 から始まる <xref:System.Object?displayProperty=nameWithType> から派生したインターフェイス。</span><span class="sxs-lookup"><span data-stu-id="990e5-436">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="990e5-437"><xref:System.Enum?displayProperty=nameWithType>から派生した列挙型。</span><span class="sxs-lookup"><span data-stu-id="990e5-437">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="990e5-438">デリゲート。 <xref:System.MulticastDelegate?displayProperty=nameWithType>から派生します。</span><span class="sxs-lookup"><span data-stu-id="990e5-438">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="990e5-439">2つのオブジェクト `x` と `y` のランタイム型が同一である場合、`Object.ReferenceEquals(x.GetType(),y.GetType())` は `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-439">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="990e5-440">次の例では、<xref:System.Object.GetType%2A> メソッドを <xref:System.Object.ReferenceEquals%2A> メソッドと共に使用して、1つの数値が他の2つの数値と同じ型であるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="990e5-440">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb" id="Snippet1"::: 

> [!NOTE]
>  <span data-ttu-id="990e5-441">オブジェクトが特定の型であるかどうかを判断するには、言語の型比較キーワードまたはコンストラクトを使用できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-441">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="990e5-442">たとえば、Visual Basic の `TypeOf…Is` コンストラクト、またはのC#`is` キーワードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-442">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="990e5-443"><xref:System.Object.GetType%2A> メソッドは、<xref:System.Object>から派生したすべての型によって継承されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-443">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="990e5-444">つまり、次の例に示すように、独自の言語の比較キーワードを使用するだけでなく、<xref:System.Object.GetType%2A> メソッドを使用して特定のオブジェクトの型を特定することもできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-444">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb" id="Snippet2":::
  
 <span data-ttu-id="990e5-445"><xref:System.Type> オブジェクトは、現在の <xref:System.Object>のクラスに関連付けられているメタデータを公開します。</span><span class="sxs-lookup"><span data-stu-id="990e5-445">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  

 <span data-ttu-id="990e5-446">次のコード例は、<xref:System.Object.GetType%2A> が現在のインスタンスのランタイム型を返すことを示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-446">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp" id="Snippet1"::: 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="990e5-447">現在の <see cref="T:System.Object" /> の簡易コピーを作成します。</span><span class="sxs-lookup"><span data-stu-id="990e5-447">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="990e5-448">現在の <see cref="T:System.Object" /> の簡易コピー。</span><span class="sxs-lookup"><span data-stu-id="990e5-448">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-449"><xref:System.Object.MemberwiseClone%2A> メソッドは、新しいオブジェクトを作成し、現在のオブジェクトの非静的フィールドを新しいオブジェクトにコピーすることによって、簡易コピーを作成します。</span><span class="sxs-lookup"><span data-stu-id="990e5-449">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="990e5-450">フィールドが値型の場合は、フィールドのビットごとのコピーが実行されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-450">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="990e5-451">フィールドが参照型の場合、参照はコピーされますが、参照先のオブジェクトはコピーされません。したがって、元のオブジェクトとその複製は、同じオブジェクトを参照します。</span><span class="sxs-lookup"><span data-stu-id="990e5-451">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="990e5-452">たとえば、オブジェクト A と B を参照する X と呼ばれるオブジェクトについて考えてみます。オブジェクト B がオブジェクト C を参照しているとします。X の簡易コピーでは、オブジェクト A と B も参照する新しいオブジェクト X2 が作成されます。これに対し、X の詳細コピーでは新しいオブジェクト X2 が作成されます。これは、A と B のコピーである A2 と B2 の新しいオブジェクトを参照します。 B2 は、C のコピーである新しいオブジェクト C2 を参照します。この例では、簡易コピー操作と詳細コピー操作の違いについて説明します。</span><span class="sxs-lookup"><span data-stu-id="990e5-452">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="990e5-453"><xref:System.Object.MemberwiseClone%2A> メソッドによって実行される簡易コピー操作がニーズを満たさない場合は、ディープコピー操作を実装する方法が多数あります。</span><span class="sxs-lookup"><span data-stu-id="990e5-453">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="990e5-454">コーディネートは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="990e5-454">These include the following:</span></span>  
  
-   <span data-ttu-id="990e5-455">コピーするオブジェクトのクラスコンストラクターを呼び出して、最初のオブジェクトから取得したプロパティ値を持つ2番目のオブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="990e5-455">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="990e5-456">これは、オブジェクトの値がクラスコンストラクターによって完全に定義されていることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="990e5-456">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="990e5-457"><xref:System.Object.MemberwiseClone%2A> メソッドを呼び出してオブジェクトの簡易コピーを作成し、元のオブジェクトと同じ値を持つ新しいオブジェクトを、値が参照型であるプロパティまたはフィールドに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="990e5-457">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="990e5-458">この例の `DeepCopy` メソッドは、この方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-458">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="990e5-459">詳細にコピーされるようにオブジェクトをシリアル化し、シリアル化されたデータを別のオブジェクト変数に復元します。</span><span class="sxs-lookup"><span data-stu-id="990e5-459">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="990e5-460">詳細コピー操作を実行するには、再帰と共にリフレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="990e5-460">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="990e5-461">次の例は、<xref:System.Object.MemberwiseClone%2A> メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="990e5-461">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="990e5-462"><xref:System.Object.MemberwiseClone%2A> メソッドを呼び出して `Person` オブジェクトに対して簡易コピー操作を実行する `ShallowCopy` メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="990e5-462">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="990e5-463">また、`Person` オブジェクトに対して詳細コピー操作を実行する `DeepCopy` メソッドも定義します。</span><span class="sxs-lookup"><span data-stu-id="990e5-463">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="990e5-464">この例では、`Person.IdInfo` プロパティは `IdInfo` オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-464">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="990e5-465">この例の出力に示すように、<xref:System.Object.MemberwiseClone%2A> メソッドを呼び出すことによって `Person` オブジェクトを複製すると、複製された `Person` オブジェクトは元のオブジェクトの独立したコピーになります。ただし、同じ `Person.IdInfo` オブジェクト参照を共有する点が異なります。</span><span class="sxs-lookup"><span data-stu-id="990e5-465">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="990e5-466">その結果、複製の `Person.IdInfo` プロパティを変更すると、元のオブジェクトの `Person.IdInfo` プロパティが変更されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-466">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="990e5-467">一方、詳細コピー操作を実行するときに、複製された `Person` オブジェクト (`Person.IdInfo` プロパティを含む) は、元のオブジェクトに影響を与えることなく変更できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-467">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="990e5-468">比較する最初のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="990e5-468">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="990e5-469">比較する 2 番目のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="990e5-469">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="990e5-470">指定した複数の <see cref="T:System.Object" /> インスタンスが同一インスタンスかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="990e5-470">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="990e5-471"><see langword="true" /> が <paramref name="objA" /> と同一のインスタンスである場合、または両方のインスタンスが <paramref name="objB" />null**参照の場合は**。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="990e5-471"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-472"><xref:System.Object.Equals%2A> メソッドと等値演算子とは異なり、<xref:System.Object.ReferenceEquals%2A> メソッドをオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-472">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="990e5-473">このため、2つのオブジェクト参照が等しいかどうかをテストし、`Equals` メソッドの実装がわからない場合は、<xref:System.Object.ReferenceEquals%2A> メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-473">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="990e5-474">ただし、次の2つのシナリオでは、<xref:System.Object.ReferenceEquals%2A> メソッドの戻り値が異常であるように見えることがあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-474">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="990e5-475">値型を比較する場合。</span><span class="sxs-lookup"><span data-stu-id="990e5-475">When comparing value types.</span></span> <span data-ttu-id="990e5-476">`objA` と `objB` が値型の場合、<xref:System.Object.ReferenceEquals%2A> メソッドに渡される前にボックス化されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-476">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="990e5-477">これは、`objA` と `objB` の両方が値型の同じインスタンスを表している場合、次の例に示すように、<xref:System.Object.ReferenceEquals%2A> メソッドが `false`を返すことを意味します。</span><span class="sxs-lookup"><span data-stu-id="990e5-477">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="990e5-478">値型のボックス化の詳細については、「[ボックス化とボックス化解除](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-478">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="990e5-479">文字列を比較する場合。</span><span class="sxs-lookup"><span data-stu-id="990e5-479">When comparing strings.</span></span> <span data-ttu-id="990e5-480">`objA` と `objB` が文字列の場合、<xref:System.Object.ReferenceEquals%2A> メソッドは、文字列がインターンプールされている場合は `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-480">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="990e5-481">値が等しいかどうかのテストは実行されません。</span><span class="sxs-lookup"><span data-stu-id="990e5-481">It does not perform a test for value equality.</span></span>  <span data-ttu-id="990e5-482">次の例では、1つのインターン文字列の2つのインスタンスであるため、`s1` と `s2` は等しくなります。</span><span class="sxs-lookup"><span data-stu-id="990e5-482">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="990e5-483">ただし、`s3` と `s4` は同じではありませんが、文字列値が同一であっても、その文字列はインターンプールされていません。</span><span class="sxs-lookup"><span data-stu-id="990e5-483">However, `s3` and `s4` are not equal, because although they have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="990e5-484">文字列インターンの詳細については、「<xref:System.String.IsInterned%2A?displayProperty=nameWithType>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-484">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  

 <span data-ttu-id="990e5-485">次の例では、<xref:System.Object.ReferenceEquals%2A> を使用して、2つのオブジェクトが同じインスタンスであるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="990e5-485">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp-interactive[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="990e5-486">現在のオブジェクトを表す string を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-486">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="990e5-487">現在のオブジェクトを表す文字列。</span><span class="sxs-lookup"><span data-stu-id="990e5-487">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="990e5-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> は、.NET Framework の主要な書式設定メソッドです。</span><span class="sxs-lookup"><span data-stu-id="990e5-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="990e5-489">オブジェクトを文字列形式に変換して、表示に適した状態にします。</span><span class="sxs-lookup"><span data-stu-id="990e5-489">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="990e5-490">(.NET Framework での書式設定のサポートについては、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください)。<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドの既定の実装では、オブジェクトの型の完全修飾名が返されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-490">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="990e5-491">別の種類のメンバーリストからのリンクに従って、このページに到達した可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-491">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="990e5-492">これは、その型が <xref:System.Object.ToString%2A?displayProperty=nameWithType>をオーバーライドしないためです。</span><span class="sxs-lookup"><span data-stu-id="990e5-492">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="990e5-493">代わりに、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドの機能を継承します。</span><span class="sxs-lookup"><span data-stu-id="990e5-493">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="990e5-494">型は、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドを頻繁にオーバーライドして、特定の型のより適切な文字列表現を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-494">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="990e5-495">また、型は、書式指定文字列またはカルチャに依存した書式設定をサポートするために、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーロードすることもよくあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-495">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  

 <span data-ttu-id="990e5-496">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="990e5-496">In this section:</span></span>  
  
 <span data-ttu-id="990e5-497">[既定のオブジェクトの ToString () メソッド](#Default) </span><span class="sxs-lookup"><span data-stu-id="990e5-497">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="990e5-498">[オブジェクトの ToString () メソッドのオーバーライド](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="990e5-498">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="990e5-499">[ToString メソッドのオーバーロード](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="990e5-499">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="990e5-500">[オブジェクトの拡張メソッド](#Extending) </span><span class="sxs-lookup"><span data-stu-id="990e5-500">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="990e5-501">Windows ランタイムのメモ</span><span class="sxs-lookup"><span data-stu-id="990e5-501">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="990e5-502">既定のオブジェクトの ToString () メソッド</span><span class="sxs-lookup"><span data-stu-id="990e5-502">The default Object.ToString() method</span></span>  
 <span data-ttu-id="990e5-503">次の例に示すように、<xref:System.Object.ToString%2A> メソッドの既定の実装は、<xref:System.Object>の型の完全修飾名を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-503">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp-interactive[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="990e5-504"><xref:System.Object> は .NET Framework 内のすべての参照型の基本クラスであるため、この動作は <xref:System.Object.ToString%2A> メソッドをオーバーライドしない参照型によって継承されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-504">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="990e5-505">これを次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-505">The following example illustrates this.</span></span> <span data-ttu-id="990e5-506">これは、すべての <xref:System.Object> メンバーの既定の実装を受け入れる `Object1` という名前のクラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="990e5-506">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="990e5-507"><xref:System.Object.ToString%2A> メソッドは、オブジェクトの完全修飾型名を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-507">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="990e5-508">オブジェクトのオーバーライド () メソッド</span><span class="sxs-lookup"><span data-stu-id="990e5-508">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="990e5-509">型は、通常、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドして、オブジェクトインスタンスを表す文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-509">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="990e5-510">たとえば、<xref:System.Char>、<xref:System.Int32>、<xref:System.String> などの基本型は、オブジェクトが表す値の文字列形式を返す <xref:System.Object.ToString%2A> の実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-510">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="990e5-511">次の例では、`Object2`クラスを定義しています。このクラスは、<xref:System.Object.ToString%2A> メソッドをオーバーライドして、型名とその値を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-511">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="990e5-512">次の表に、.NET の型カテゴリの一覧を示し、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドするかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-512">The following table lists the type categories in .NET and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="990e5-513">型のカテゴリ</span><span class="sxs-lookup"><span data-stu-id="990e5-513">Type category</span></span>|<span data-ttu-id="990e5-514">Object. ToString () をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="990e5-514">Overrides Object.ToString()</span></span>|<span data-ttu-id="990e5-515">動作</span><span class="sxs-lookup"><span data-stu-id="990e5-515">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="990e5-516">クラス</span><span class="sxs-lookup"><span data-stu-id="990e5-516">Class</span></span>|<span data-ttu-id="990e5-517">該当なし</span><span class="sxs-lookup"><span data-stu-id="990e5-517">n/a</span></span>|<span data-ttu-id="990e5-518">該当なし</span><span class="sxs-lookup"><span data-stu-id="990e5-518">n/a</span></span>|  
|<span data-ttu-id="990e5-519">構造体</span><span class="sxs-lookup"><span data-stu-id="990e5-519">Structure</span></span>|<span data-ttu-id="990e5-520">はい (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="990e5-520">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="990e5-521">`Object.ToString()` と同じ</span><span class="sxs-lookup"><span data-stu-id="990e5-521">Same as `Object.ToString()`</span></span>|  
|<span data-ttu-id="990e5-522">列挙型</span><span class="sxs-lookup"><span data-stu-id="990e5-522">Enumeration</span></span>|<span data-ttu-id="990e5-523">はい (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="990e5-523">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="990e5-524">メンバー名</span><span class="sxs-lookup"><span data-stu-id="990e5-524">The member name</span></span>|  
|<span data-ttu-id="990e5-525">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="990e5-525">Interface</span></span>|<span data-ttu-id="990e5-526">いいえ</span><span class="sxs-lookup"><span data-stu-id="990e5-526">No</span></span>|<span data-ttu-id="990e5-527">該当なし</span><span class="sxs-lookup"><span data-stu-id="990e5-527">n/a</span></span>|  
|<span data-ttu-id="990e5-528">デリゲート</span><span class="sxs-lookup"><span data-stu-id="990e5-528">Delegate</span></span>|<span data-ttu-id="990e5-529">いいえ</span><span class="sxs-lookup"><span data-stu-id="990e5-529">No</span></span>|<span data-ttu-id="990e5-530">該当なし</span><span class="sxs-lookup"><span data-stu-id="990e5-530">n/a</span></span>|  
  
 <span data-ttu-id="990e5-531"><xref:System.Object.ToString%2A>のオーバーライドの詳細については、「継承に関する注意事項」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-531">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="990e5-532">ToString メソッドのオーバーロード</span><span class="sxs-lookup"><span data-stu-id="990e5-532">Overloading the ToString method</span></span>  
 <span data-ttu-id="990e5-533">パラメーターのない <xref:System.Object.ToString?displayProperty=nameWithType> メソッドをオーバーライドするだけでなく、多くの型では、パラメーターを受け取るメソッドのバージョンを提供するために、`ToString` メソッドがオーバーロードされます。</span><span class="sxs-lookup"><span data-stu-id="990e5-533">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="990e5-534">ほとんどの場合、これは変数の書式設定とカルチャに依存した書式設定のサポートを提供するために行われます。</span><span class="sxs-lookup"><span data-stu-id="990e5-534">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="990e5-535">次の例では、`ToString` メソッドをオーバーロードして、`Automobile` クラスのさまざまなフィールドの値を含む結果の文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-535">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="990e5-536">4つの書式指定文字列を定義します。 G は、モデル名と年を返します。D: モデル名、年、およびドアの数を返します。C: モデル名、年、およびシリンダーの数を返します。とは、4つのフィールド値すべてを含む文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-536">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="990e5-537">次の例では、オーバーロードされた <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、通貨値のカルチャに依存した書式設定を表示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-537">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="990e5-538">書式指定文字列とカルチャに依存した書式設定の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-538">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="990e5-539">数値でサポートされる書式指定文字列については、「[標準の数値書式指定](~/docs/standard/base-types/standard-numeric-format-strings.md)文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-539">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="990e5-540">日付と時刻の値でサポートされる書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-540">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="990e5-541">オブジェクトの ToString メソッドの拡張</span><span class="sxs-lookup"><span data-stu-id="990e5-541">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="990e5-542">型は既定の <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドを継承するため、その動作が望ましくなく、変更が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-542">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="990e5-543">これは、配列とコレクションクラスに特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="990e5-543">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="990e5-544">配列またはコレクションクラスの `ToString` メソッドでメンバーの値を表示することが予想される場合がありますが、次の例に示すように、型の完全修飾型名が表示されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-544">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="990e5-545">結果の文字列を生成するには、いくつかのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="990e5-545">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="990e5-546">型が配列、コレクションオブジェクト、または <xref:System.Collections.IEnumerable> インターフェイスまたは <xref:System.Collections.Generic.IEnumerable%601> インターフェイスを実装するオブジェクトである場合は、のC# `foreach` ステートメントまたは Visual Basic の `For Each...Next` コンストラクトを使用して、その要素を列挙できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-546">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="990e5-547">クラスが `sealed` ( C#) または `NotInheritable` (Visual Basic) でない場合は、カスタマイズする <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドを持つ基本クラスから継承するラッパークラスを開発できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-547">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="990e5-548">少なくとも、次の操作を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-548">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="990e5-549">必要なコンストラクターを実装します。</span><span class="sxs-lookup"><span data-stu-id="990e5-549">Implement any necessary constructors.</span></span> <span data-ttu-id="990e5-550">派生クラスは、基底クラスのコンストラクターを継承しません。</span><span class="sxs-lookup"><span data-stu-id="990e5-550">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="990e5-551"><xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドして、必要な結果文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="990e5-551">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="990e5-552">次の例では、<xref:System.Collections.Generic.List%601> クラスのラッパークラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="990e5-552">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="990e5-553"><xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドして、完全修飾型名ではなく、コレクションの各メソッドの値を表示します。</span><span class="sxs-lookup"><span data-stu-id="990e5-553">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="990e5-554">必要な結果文字列を返す[拡張メソッド](~/docs/standard/design-guidelines/extension-methods.md)を開発します。</span><span class="sxs-lookup"><span data-stu-id="990e5-554">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="990e5-555">この方法では既定の <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドできないことに注意してください (つまり、 C#拡張クラス (内) またはモジュール (Visual Basic) は、元の型の `ToString` メソッドの代わりに呼び出される `ToString` という名前のパラメーターなしのメソッドを持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-555">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="990e5-556">パラメーターなしの `ToString` 置換には、他の名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-556">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="990e5-557">次の例では、<xref:System.Collections.Generic.List%601> クラスを拡張する2つのメソッドを定義しています。パラメーターなしの `ToString2` メソッドと、書式指定文字列を表す <xref:System.String> パラメーターを持つ `ToString` メソッドです。</span><span class="sxs-lookup"><span data-stu-id="990e5-557">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-wrt"></a><span data-ttu-id="990e5-558">[!INCLUDE[wrt](~/includes/wrt-md.md)] のメモ</span><span class="sxs-lookup"><span data-stu-id="990e5-558">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="990e5-559">[!INCLUDE[wrt](~/includes/wrt-md.md)]のクラスで <xref:System.Object.ToString%2A> メソッドを呼び出すと、<xref:System.Object.ToString%2A>をオーバーライドしないクラスの既定の動作が提供されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-559">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="990e5-560">これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)] に提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="990e5-560">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="990e5-561">[!INCLUDE[wrt](~/includes/wrt-md.md)] のクラスは <xref:System.Object>を継承せず、常に <xref:System.Object.ToString%2A>を実装することはありません。</span><span class="sxs-lookup"><span data-stu-id="990e5-561">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="990e5-562">ただし、これらのメソッドをC#または Visual Basic コードで使用すると、これらのメソッドは常に <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>、および <xref:System.Object.GetHashCode%2A> に表示されます。また、.NET Framework は、これらのメソッドの既定の動作を提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-562">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="990e5-563">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]以降では、共通言語ランタイムは、<xref:System.Object.ToString%2A?displayProperty=nameWithType>の既定の実装に戻る前に、[!INCLUDE[wrt](~/includes/wrt-md.md)] オブジェクトに対して[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)を使用します。</span><span class="sxs-lookup"><span data-stu-id="990e5-563">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="990e5-564">または Visual Basic でC#記述された [!INCLUDE[wrt](~/includes/wrt-md.md)] クラスは、<xref:System.Object.ToString%2A> メソッドをオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="990e5-564">[!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-wrt-and-the-istringable-interface"></a><span data-ttu-id="990e5-565">[!INCLUDE[wrt](~/includes/wrt-md.md)] と IStringable インターフェイス</span><span class="sxs-lookup"><span data-stu-id="990e5-565">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="990e5-566">[!INCLUDE[win81](~/includes/win81-md.md)]以降では、[!INCLUDE[wrt](~/includes/wrt-md.md)] に[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイスが含まれています。このインターフェイスは、単一のメソッドである[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)を使用して、<xref:System.Object.ToString%2A?displayProperty=nameWithType>によって提供される基本的な書式設定のサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="990e5-566">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="990e5-567">あいまいさを防ぐには、マネージ型に[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装しないでください。</span><span class="sxs-lookup"><span data-stu-id="990e5-567">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="990e5-568">マネージオブジェクトがネイティブコードまたは JavaScript やC++/cx などの言語で記述されたコードによって呼び出されると、 [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装するように見えます。</span><span class="sxs-lookup"><span data-stu-id="990e5-568">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="990e5-569">共通言語ランタイムは、 [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)からの呼び出しを、マネージオブジェクトに実装されてい[ないイベントの](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)<xref:System.Object.ToString%2A?displayProperty=nameWithType> に自動的にルーティングします。</span><span class="sxs-lookup"><span data-stu-id="990e5-569">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="990e5-570">共通言語ランタイムは、[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] アプリのすべてのマネージ型に対して[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を自動的に実装するため、独自の[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)の実装を提供しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="990e5-570">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="990e5-571">[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装すると、[!INCLUDE[wrt](~/includes/wrt-md.md)]、 C++/Cx、または JavaScript から `ToString` を呼び出すときに意図しない動作が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-571">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="990e5-572">[!INCLUDE[wrt](~/includes/wrt-md.md)] コンポーネントにエクスポートされるパブリックマネージ型に[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装する場合は、次の制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="990e5-572">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="990e5-573">[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイスは、"クラスが実装する" 関係でのみ定義できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-573">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="990e5-574">C# では、上記のようになります。</span><span class="sxs-lookup"><span data-stu-id="990e5-574">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="990e5-575">Visual Basic では、上記のようになります。</span><span class="sxs-lookup"><span data-stu-id="990e5-575">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="990e5-576">インターフェイスに[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装することはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-576">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="990e5-577">パラメーターの型を[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)として宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-577">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="990e5-578">[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)は、メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="990e5-579">次のようなメソッド定義を使用して、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)の実装を基底クラスから隠すことはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-579">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="990e5-580">代わりに、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)の実装では、常に基底クラスの実装をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-580">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="990e5-581">`ToString` の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。</span><span class="sxs-lookup"><span data-stu-id="990e5-581">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="990e5-582">さまざまな条件下では、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装するマネージ型、または[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)実装を隠すマネージ型にネイティブコードから呼び出すと、予期しない動作が発生する可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="990e5-582">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="990e5-583">独自の型を実装する場合は、<see cref="M:System.Object.ToString" /> メソッドをオーバーライドして、これらの型にとって意味のある値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-583">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="990e5-584"><see cref="M:System.Object.ToString" /> よりも書式設定をより詳細に制御する必要がある派生クラスは、<see cref="T:System.IFormattable" /> インターフェイスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="990e5-584">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="990e5-585"><see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> メソッドを使用すると、書式設定を制御する書式指定文字列を定義したり、カルチャ固有の書式設定用に提供される <see cref="T:System.IFormatProvider" /> オブジェクトを使用したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="990e5-585">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="990e5-586"><see cref="M:System.Object.ToString" /> メソッドのオーバーライドは、次のガイドラインに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-586">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="990e5-587">-返される文字列は、わかりやすく、人間が判読できるものにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-587">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="990e5-588">-返される文字列は、オブジェクトインスタンスの値を一意に識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-588">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="990e5-589">-返される文字列は、デバッガーによる表示に適しているように、可能な限り短くする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-589">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="990e5-590">-<see cref="M:System.Object.ToString" /> のオーバーライドは、<see cref="F:System.String.Empty" /> または null 文字列を返さないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-590">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="990e5-591">-<see cref="M:System.Object.ToString" /> のオーバーライドでは、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="990e5-591">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="990e5-592">-インスタンスの文字列表現がカルチャに依存しているか、複数の方法で書式設定できる場合は、<see cref="T:System.IFormattable" /> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="990e5-592">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="990e5-593">-返された文字列に機密情報が含まれている場合は、まず適切なアクセス許可を要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-593">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="990e5-594">要求が成功した場合は、機密情報を返すことができます。それ以外の場合は、機密情報を除外する文字列を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-594">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="990e5-595">-<see cref="M:System.Object.ToString" /> のオーバーライドには、デバッグの複雑さを避けるために、監視可能な副作用はありません。</span><span class="sxs-lookup"><span data-stu-id="990e5-595">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="990e5-596">たとえば、<see cref="M:System.Object.ToString" /> メソッドを呼び出す場合、インスタンスフィールドの値を変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="990e5-596">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="990e5-597">-型が解析メソッド (または <see langword="Parse" /> または <see langword="TryParse" /> メソッド、コンストラクター、または文字列から型のインスタンスをインスタンス化するその他の静的メソッド) を実装している場合は、<see cref="M:System.Object.ToString" /> メソッドによって返された文字列をオブジェクトインスタンスに変換できることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="990e5-597">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="990e5-598">.NET での型の書式設定</span><span class="sxs-lookup"><span data-stu-id="990e5-598">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
