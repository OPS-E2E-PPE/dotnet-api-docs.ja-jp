<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e6a978c9ab41e0a864fa39bc466a70175c79ff6f" /><Meta Name="ms.sourcegitcommit" Value="2b0967e04b047f6709322418d97215dfcef6a938" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="11/20/2019" /><Meta Name="ms.locfileid" Value="74237962" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>.NET クラス階層のすべてのクラスをサポートし、派生クラスに下位レベルのサービスを提供します。 これは、全 .NET クラスの基本クラスであり、型階層のルートです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承は暗黙的に行われるため、通常、言語は <xref:System.Object> から継承を宣言するためにクラスを必要としません。  
  
 .NET のすべてのクラスは <xref:System.Object>から派生するため、<xref:System.Object> クラスで定義されているすべてのメソッドは、システム内のすべてのオブジェクトで使用できます。 派生クラスは、次のようなメソッドの一部をオーバーライドできます。  
  
-   <xref:System.Object.Equals%2A>-オブジェクト間の比較をサポートします。  
  
-   <xref:System.Object.Finalize%2A>-オブジェクトが自動的に再利用される前にクリーンアップ操作を実行します。  
  
-   <xref:System.Object.GetHashCode%2A>-ハッシュテーブルの使用をサポートするために、オブジェクトの値に対応する番号を生成します。  
  
-   <xref:System.Object.ToString%2A>-クラスのインスタンスを記述する、人間が判読できるテキスト文字列を製造します。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 コレクションなど、任意の型のオブジェクトを処理する必要があるクラスをデザインする場合は、<xref:System.Object> クラスのインスタンスを受け入れるクラスメンバーを作成できます。 ただし、型のボックス化とボックス化解除のプロセスでは、パフォーマンスコストがかかります。 新しいクラスで特定の値型を頻繁に処理することがわかっている場合は、2つの戦術のいずれかを使用して、ボックス化のコストを最小限に抑えることができます。  
  
-   <xref:System.Object> 型を受け取る一般的なメソッドと、クラスで頻繁に処理する必要のある各値型を受け入れる型固有のメソッドオーバーロードのセットを作成します。 呼び出し元のパラメーターの型を受け入れる型固有のメソッドが存在する場合は、ボックス化が行われず、型固有のメソッドが呼び出されます。 呼び出し元のパラメーターの型と一致するメソッド引数がない場合、パラメーターはボックス化され、一般メソッドが呼び出されます。  
  
-   ジェネリックを使用するように型とそのメンバーを設計します。 共通言語ランタイムは、クラスのインスタンスを作成し、ジェネリック型引数を指定するときに、クローズジェネリック型を作成します。 ジェネリックメソッドは型固有であり、呼び出し元のパラメーターをボックス化せずに呼び出すことができます。  
  
 <xref:System.Object> 型を受け入れて返す汎用クラスを開発することが必要になる場合もありますが、頻繁に使用される型を処理する型固有のクラスも用意することで、パフォーマンスを向上させることができます。 たとえば、ブール値の設定と取得に固有のクラスを指定すると、ブール値のボックス化とボックス化解除のコストが削減されます。  
  
   
  
## Examples  
 次の例では、<xref:System.Object> クラスから派生した Point 型を定義し、<xref:System.Object> クラスの多くの仮想メソッドをオーバーライドします。 また、この例は、<xref:System.Object> クラスの静的メソッドとインスタンスメソッドの多くを呼び出す方法を示しています。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (Visual Basic では<see langword="Shared" />) なこの型のメンバーはスレッド セーフです インスタンスメンバーは、スレッドセーフであるとは限りません。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Object" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、派生クラスのコンストラクターによって呼び出されますが、<xref:System.Object> クラスのインスタンスを直接作成するために使用することもできます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つのオブジェクト インスタンスが等しいかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在のオブジェクトと比較するオブジェクト。</param>
        <summary>指定されたオブジェクトが現在のオブジェクトと等しいかどうかを判定します。</summary>
        <returns>指定したオブジェクトが現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のインスタンスと `obj` パラメーターの比較の種類は、現在のインスタンスが参照型であるか値型であるかによって異なります。  
  
-   現在のインスタンスが参照型の場合、<xref:System.Object.Equals%28System.Object%29> メソッドは参照の等価性をテストし、<xref:System.Object.Equals%28System.Object%29> メソッドの呼び出しは <xref:System.Object.ReferenceEquals%2A> メソッドの呼び出しと同じです。 参照の等価性とは、比較されるオブジェクト変数が同じオブジェクトを参照することを意味します。 次の例は、このような比較の結果を示しています。 これは参照型である `Person` クラスを定義し、`Person` クラスコンストラクターを呼び出して、同じ値を持つ2つの新しい `Person` オブジェクト `person1a` と `person2`をインスタンス化します。 また、別のオブジェクト変数 `person1b`にも `person1a` が割り当てられます。 例の出力が示すように、`person1a` と `person1b` は同じオブジェクトを参照しているため、同じです。 ただし、`person1a` と `person2` は同じ値を持っていますが、同じではありません。  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   現在のインスタンスが値型の場合、<xref:System.Object.Equals%28System.Object%29> メソッドは値が等しいかどうかをテストします。 値の等価性は、次のことを意味します。  
  
    -   2つのオブジェクトの型は同じです。 次の例に示すように、値が12の <xref:System.Byte> オブジェクトは、値が12の <xref:System.Int32> オブジェクトとは異なります。これは、2つのオブジェクトの実行時の型が異なるためです。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   2つのオブジェクトのパブリックフィールドとプライベートフィールドの値が等しい。 次の例では、値が等しいかどうかをテストします。 これは、値型の `Person` 構造体を定義し、`Person` クラスコンストラクターを呼び出して、同じ値を持つ2つの新しい `Person` オブジェクト `person1` と `person2`をインスタンス化します。 この例の出力に示されているように、2つのオブジェクト変数は異なるオブジェクトを参照しますが、`person1` と `person2` は、private `personName` フィールドの値が同じであるため、等しいと見なされます。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <xref:System.Object> クラスは .NET Framework 内のすべての型の基底クラスであるため、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドは、他のすべての型に対して既定の等値比較を提供します。 ただし、型は、多くの場合、<xref:System.Object.Equals%2A> メソッドをオーバーライドして値の等価性を実装します。 詳細については、以下を参照してください。の呼び出し元とメモ継承先のセクションです。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] のメモ  
 [!INCLUDE[wrt](~/includes/wrt-md.md)]内のクラスで <xref:System.Object.Equals%28System.Object%29> メソッドオーバーロードを呼び出すと、<xref:System.Object.Equals%28System.Object%29>をオーバーライドしないクラスの既定の動作が提供されます。 これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)] に提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。 [!INCLUDE[wrt](~/includes/wrt-md.md)] のクラスは <xref:System.Object>を継承せず、現在は <xref:System.Object.Equals%28System.Object%29> メソッドを実装していません。 ただし、 C#または Visual Basic コードで使用する場合、<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>、および <xref:System.Object.GetHashCode%2A> メソッドがあるように見えます。 .NET Framework は、これらのメソッドの既定の動作を提供します。  
  
> [!NOTE]
>  または Visual Basic でC#記述された [!INCLUDE[wrt](~/includes/wrt-md.md)] クラスは、<xref:System.Object.Equals%28System.Object%29> メソッドのオーバーロードをオーバーライドできます。  
  
## <a name="notes-for-callers"></a>呼び出し元に関する注意事項  
 派生クラスは、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドして値の等価性を実装することがよくあります。 また、型は、通常、<xref:System.IEquatable%601> インターフェイスを実装することによって、`Equals` メソッドに厳密に型指定された追加のオーバーロードを提供します。 `Equals` メソッドを呼び出して等しいかどうかをテストする場合は、現在のインスタンスが <xref:System.Object.Equals%2A?displayProperty=nameWithType> をオーバーライドし、`Equals` メソッドへの特定の呼び出しがどのように解決されるかを理解しておく必要があります。 それ以外の場合は、意図したものとは異なる等しいかどうかのテストを実行し、メソッドが予期しない値を返す可能性があります。  
  
 具体的な例を次に示します。 同じ文字列を持つ3つの <xref:System.Text.StringBuilder> オブジェクトをインスタンス化し、`Equals` メソッドに対して4つの呼び出しを行います。 最初のメソッド呼び出しで `true`が返され、残りの3つの `false`が返されます。  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 最初のケースでは、厳密に型指定された <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> メソッドオーバーロード (値が等しいかどうかをテストする) が呼び出されます。 2つの <xref:System.Text.StringBuilder> オブジェクトに割り当てられた文字列は等しいため、メソッドは `true`を返します。 ただし、<xref:System.Text.StringBuilder> では <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>はオーバーライドされません。 このため、<xref:System.Text.StringBuilder> オブジェクトが <xref:System.Object>にキャストされた場合、<xref:System.Text.StringBuilder> インスタンスが <xref:System.Object>型の変数に割り当てられている場合、および <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> メソッドに2つの <xref:System.Text.StringBuilder> オブジェクトが渡された場合に発生します。では、既定の <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドが呼び出されます。 <xref:System.Text.StringBuilder> は参照型であるため、この方法は、2つの <xref:System.Text.StringBuilder> オブジェクトを <xref:System.Object.ReferenceEquals%2A> メソッドに渡すことと同じです。 3つの <xref:System.Text.StringBuilder> オブジェクトにはすべて同一の文字列が含まれますが、3つの異なるオブジェクトを参照します。 このため、この3つのメソッド呼び出しは `false`を返します。  
  
 <xref:System.Object.ReferenceEquals%2A> メソッドを呼び出すことにより、現在のオブジェクトを別のオブジェクトと比較して、参照の等価性を確認できます。 Visual Basic では、`is` キーワード (`If Me Is otherObject Then ...`など) を使用することもできます。  
  
## <a name="notes-for-inheritors"></a>継承に関する注意事項  
 独自の型を定義する場合、その型は、その基本型の `Equals` メソッドによって定義された機能を継承します。 次の表は、.NET Framework の型の主なカテゴリに対する `Equals` メソッドの既定の実装を示しています。  
  
|型のカテゴリ|等しいかどうかの定義|コメント|  
|-------------------|-------------------------|--------------|  
|<xref:System.Object> から直接派生したクラス|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|参照の等価性。<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>の呼び出しと同じです。|  
|構造体|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|値の等価性。リフレクションを使用して、バイト単位の比較またはフィールドごとの比較を直接行います。|  
|列挙型|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|値の列挙型と基になる値が同じである必要があります。|  
|デリゲート|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|デリゲートは、同じ型の呼び出しリストを持つ必要があります。|  
|インターフェイス|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|参照の等価性。|  
  
 値型の場合は、常に <xref:System.Object.Equals%2A>をオーバーライドする必要があります。これは、リフレクションに依存する等しいかどうかのテストによってパフォーマンスが低下するためです。 参照型の <xref:System.Object.Equals%2A> の既定の実装をオーバーライドして、参照の等価性ではなく値の等価性をテストし、値の等価性の正確な意味を定義することもできます。 このような <xref:System.Object.Equals%2A> の実装では、2つのオブジェクトが同じインスタンスでない場合でも、同じ値を持つ場合は `true` が返されます。 型の実装者は、オブジェクトの値を構成する対象を決定しますが、通常は、オブジェクトのインスタンス変数に格納されているデータの一部またはすべてを指定します。 たとえば、<xref:System.String> オブジェクトの値は、文字列の文字に基づいています。<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> メソッドは、同じ順序で同じ文字を含む2つの文字列インスタンスの `true` を返すように、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドします。  
  
 次の例は、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドして値の等価性をテストする方法を示しています。 `Person` クラスの <xref:System.Object.Equals%2A> メソッドをオーバーライドします。 `Person` その基底クラスの等価性の実装を受け入れた場合、2つの `Person` オブジェクトは、1つのオブジェクトを参照した場合にのみ等しくなります。 ただし、この場合、`Person.Id` プロパティの値が同じである場合、2つの `Person` オブジェクトは等しいことになります。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <xref:System.Object.Equals%2A>をオーバーライドするだけでなく、厳密に型指定されたテストを等価に提供するために、<xref:System.IEquatable%601> インターフェイスを実装することもできます。  
  
 次のステートメントは、<xref:System.Object.Equals%28System.Object%29> メソッドのすべての実装に対して true である必要があります。 一覧では、`x`、`y`、および `z` は**null**ではないオブジェクト参照を表します。  
  
-   浮動小数点型が含まれている場合を除き、`x.Equals(x)` は `true`を返します。 「 [ISO/IEC/IEEE 60559:2011」、「情報技術-マイクロプロセッサシステム--浮動小数点演算」を](https://www.iso.org/standard/57469.html)参照してください。  
  
-   `x.Equals(y)` からは `y.Equals(x)` と同じ値が返されます。  
  
-   `x` と `y` の両方が `NaN`ている場合、`x.Equals(y)` は `true` を返します。  
  
-   `(x.Equals(y) && y.Equals(z))` が `true`を返す場合、`x.Equals(z)` は `true`を返します。  
  
-   `x.Equals(y)` を連続して呼び出すと、`x` と `y` で参照されているオブジェクトが変更されない限り、同じ値が返されます。  
  
-   `x.Equals(null)` は、`false` を返します。  
  
 <xref:System.Object.Equals%2A> の実装では、例外をスローすることはできません。常に値を返す必要があります。 たとえば、`obj` が `null`場合、<xref:System.Object.Equals%2A> メソッドは <xref:System.ArgumentNullException>をスローするのではなく、`false` を返す必要があります。  
  
 <xref:System.Object.Equals%28System.Object%29>をオーバーライドするときは、次のガイドラインに従ってください。  
  
-   <xref:System.IComparable> を実装する型は <xref:System.Object.Equals%28System.Object%29>をオーバーライドする必要があります。  
  
-   <xref:System.Object.Equals%28System.Object%29> をオーバーライドする型は、<xref:System.Object.GetHashCode%2A>もオーバーライドする必要があります。それ以外の場合、ハッシュテーブルが正しく機能しない可能性があります。  
  
-   厳密に型指定されたテストが等しいかどうかをサポートするには、<xref:System.IEquatable%601> インターフェイスを実装することを検討してください。 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> の実装は、<xref:System.Object.Equals%2A>と一貫性のある結果を返す必要があります。  
  
-   プログラミング言語で演算子のオーバーロードがサポートされていて、特定の型に対して等値演算子をオーバーロードする場合は、<xref:System.Object.Equals%28System.Object%29> メソッドもオーバーライドして、等値演算子と同じ結果を返す必要があります。 これにより、<xref:System.Object.Equals%2A> を使用するクラスライブラリコード (<xref:System.Collections.ArrayList> や <xref:System.Collections.Hashtable>など) が、アプリケーションコードで等値演算子が使用される方法と一貫性のある方法で動作するようになります。  
  
### <a name="guidelines-for-reference-types"></a>参照型のガイドライン  
 参照型の <xref:System.Object.Equals%28System.Object%29> をオーバーライドするには、次のガイドラインが適用されます。  
  
-   型のセマンティクスがなんらかの値を表すという事実に基づいている場合は、<xref:System.Object.Equals%2A> をオーバーライドすることを検討してください。  
  
-   <xref:System.Object.Equals%2A>をオーバーライドする場合でも、ほとんどの参照型で等値演算子をオーバーロードすることはできません。 ただし、複素数型などの値のセマンティクスを持つ参照型を実装する場合は、等値演算子をオーバーライドする必要があります。  
  
-   変更可能な参照型で <xref:System.Object.Equals%2A> をオーバーライドしないでください。 これは、前のセクションで説明したように、<xref:System.Object.Equals%2A> をオーバーライドするには、<xref:System.Object.GetHashCode%2A> メソッドもオーバーライドする必要があるためです。 これは、変更可能な参照型のインスタンスのハッシュコードがその有効期間中に変更される可能性があることを意味します。そのため、ハッシュテーブル内のオブジェクトが失われる可能性があります。  
  
### <a name="guidelines-for-value-types"></a>値型のガイドライン  
 次のガイドラインは、値型の <xref:System.Object.Equals%28System.Object%29> をオーバーライドする場合に適用されます。  
  
-   値が参照型である1つ以上のフィールドを含む値型を定義する場合は、<xref:System.Object.Equals%28System.Object%29>をオーバーライドする必要があります。 <xref:System.ValueType> によって提供される <xref:System.Object.Equals%28System.Object%29> の実装では、フィールドがすべて値型である値型のバイト単位の比較が実行されますが、リフレクションを使用して、フィールドに参照型が含まれる値型のフィールドごとの比較が実行されます。  
  
-   <xref:System.Object.Equals%2A> をオーバーライドし、開発言語で演算子のオーバーロードがサポートされている場合は、等値演算子をオーバーロードする必要があります。  
  
-   <xref:System.IEquatable%601> インターフェイスを実装する必要があります。 厳密に型指定された <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> メソッドを呼び出すと、`obj` 引数のボックス化が回避されます。  
  
   
  
## Examples  
 次の例は、<xref:System.Object.Equals%2A> メソッドをオーバーライドして値の等価性を提供する `Point` クラスと、`Point`から派生した `Point3D` クラスを示しています。 値が等しいかどうかをテストするために <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> `Point` オーバーライドされるため、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドは呼び出されません。 ただし、`Point3D.Equals` は `Point.Equals` を呼び出します。 `Point` は、値の等価性を提供する方法で <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> を実装するためです。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals` メソッドは、`obj` 引数が**null**でないこと、およびこのオブジェクトと同じ型のインスタンスを参照していることを確認します。 いずれかのチェックが失敗した場合、メソッドは `false`を返します。  
  
 `Point.Equals` メソッドは、<xref:System.Object.GetType%2A> メソッドを呼び出して、2つのオブジェクトの実行時の型が同一かどうかを判断します。 メソッドが、Visual Basic 内のフォーム `obj is Point` C#または `TryCast(obj, Point)` のチェックを使用した場合、`obj` と現在のインスタンスがない場合でも、`Point`が `obj` の派生クラスのインスタンスである場合、このチェックによって `true` が返されます。同じランタイム型の。 両方のオブジェクトが同じ型であることを検証した後、メソッドは、`obj` を `Point` 型にキャストし、2つのオブジェクトのインスタンスフィールドを比較した結果を返します。  
  
 `Point3D.Equals`では、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>をオーバーライドする継承された `Point.Equals` メソッドが、他の処理が行われる前に呼び出されます。 `Point3D` はシールクラス (Visual Basic では`NotInheritable`) であるため、`TryCast(obj, Point)` の `obj is Point` の形式C#でのチェックインは、Visual Basic が `obj` オブジェクトであることを保証するのに適しています。`Point3D` `Point3D` オブジェクトの場合、`Point` オブジェクトにキャストされ、<xref:System.Object.Equals%2A>の基本クラスの実装に渡されます。 継承された `Point.Equals` メソッドがを返す場合にのみ、メソッドは、派生クラスで導入された `z` インスタンスフィールドを比較 `true` ます。  
  
 次の例では、内部的に四角形を2つの `Point` オブジェクトとして実装する `Rectangle` クラスを定義します。 `Rectangle` クラスも <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> をオーバーライドして、値の等価性を提供します。  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 や Visual Basic などのC#一部の言語では、演算子のオーバーロードがサポートされています。 型が等値演算子をオーバーロードする場合は、同じ機能を提供するために <xref:System.Object.Equals%28System.Object%29> メソッドもオーバーライドする必要があります。 通常、これを行うには、次の例のように、オーバーロードされた等値演算子の観点から <xref:System.Object.Equals%28System.Object%29> メソッドを記述します。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 `Complex` は値型であるため、から派生することはできません。  したがって、<xref:System.Object.Equals%28System.Object%29> メソッドに対するオーバーライドでは、各オブジェクトの正確な実行時の型を決定するために <xref:System.Object.GetType%2A> を呼び出す必要はC#ありませんが、または Visual Basic の `TypeOf` 演算子を `is` 使用して `obj` パラメーターの型を確認することができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較する最初のオブジェクト。</param>
        <param name="objB">比較する 2 番目のオブジェクト。</param>
        <summary>指定されたインスタンスが等しいかどうかを判断します。</summary>
        <returns>オブジェクトが等しいと見なされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <paramref name="objA" /> と <paramref name="objB" /> の両方が **null** の場合、このメソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静的 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> メソッドは、`objA` と `objB`の2つのオブジェクトが等しいかどうかを示します。 また、値が等しい場合に**null**を持つオブジェクトをテストすることもできます。 次のように、`objA` と `objB` が等しいかどうかを比較します。  
  
-   2つのオブジェクトが同じオブジェクト参照を表しているかどうかを判断します。 その場合、メソッドは `true`を返します。 このテストは、<xref:System.Object.ReferenceEquals%2A> メソッドを呼び出すことと同じです。 さらに、`objA` と `objB` の両方が**null**の場合、メソッドは `true`を返します。  
  
-   `objA` または `objB` のいずれかが**null**かどうかを判断します。 その場合は `false`を返します。  
  
-   2つのオブジェクトが同じオブジェクト参照を表しておらず、どちらも**null**でない場合は、`objA`を呼び出します。`Equals`(`objB`) し、結果を返します。 これは、`objA` が <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドする場合に、このオーバーライドが呼び出されることを意味します。  
  
   
  
## Examples  
 次の例は、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29> メソッドを示し、<xref:System.Object.ReferenceEquals%2A> メソッドと比較します。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトが、ガベージ コレクションによって収集される前に、リソースの解放とその他のクリーンアップ操作の実行を試みることができるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A> メソッドは、オブジェクトが破棄される前に、現在のオブジェクトによって保持されているアンマネージリソースに対してクリーンアップ操作を実行するために使用されます。 メソッドは保護されているため、このクラスまたは派生クラスを介してのみアクセスできます。  
  
 このセクションの内容:  
  
-   [終了処理のしくみ](#How)  
  
-   [実装に関する注意事項](#Notes)  
  
-   [SafeHandle 代替](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>終了処理のしくみ  
 <xref:System.Object> クラスは、<xref:System.Object.Finalize%2A> メソッドの実装を提供しません。また、ガベージコレクターは、<xref:System.Object.Finalize%2A> メソッドをオーバーライドしない限り、<xref:System.Object> から派生した型に終了をマークしません。  
  
 型が <xref:System.Object.Finalize%2A> メソッドをオーバーライドする場合、ガベージコレクターは、その型の各インスタンスのエントリを、終了キューと呼ばれる内部構造に追加します。 終了キューには、ガベージコレクターがメモリを再利用できるようにするために、終了コードを実行する必要があるマネージヒープ内のすべてのオブジェクトのエントリが含まれています。 次に、ガベージコレクターは、次の条件下で <xref:System.Object.Finalize%2A> メソッドを自動的に呼び出します。  
  
-   オブジェクトが <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッドの呼び出しによって終了から除外されている場合を除き、オブジェクトにアクセスできないことをガベージコレクターが検出した後。  
  
-   オブジェクトが終了処理から除外されている場合を除き、アプリケーションドメインのシャットダウン時に**のみ .NET Framework**。 シャットダウン中に、まだアクセス可能なオブジェクトであっても、終了します。  
  
 <xref:System.Object.Finalize%2A> は、特定のインスタンスで1回だけ自動的に呼び出されます。ただし、<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> などの機構を使用してオブジェクトを再登録しても、その後、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッドが呼び出されていない場合は除きます。  
  
 <xref:System.Object.Finalize%2A> の操作には、次の制限があります。  
  
-   ファイナライザーが実行される正確な時間は未定義です。 クラスのインスタンスのリソースを確実に解放するには、`Close` メソッドを実装するか、<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> の実装を提供します。  
  
-   2つのオブジェクトのファイナライザーは、一方のオブジェクトが他方を参照している場合でも、特定の順序で実行されることは保証されません。 つまり、オブジェクト A がオブジェクト B への参照を持ち、両方にファイナライザーがある場合、オブジェクト B は、オブジェクト A のファイナライザーが開始されたときに既に完了している可能性があります。  
  
-   ファイナライザーを実行するスレッドが指定されていません。  
  
 <xref:System.Object.Finalize%2A> メソッドが完了まで実行されないか、次の例外的な状況下ではまったく実行されない可能性があります。  
  
-   別のファイナライザーが無期限にブロックした場合 (無限ループに入る場合、は取得できないロックを取得しようとします)。 ランタイムはファイナライザーの実行を完了しようとするため、ファイナライザーが無期限にブロックした場合、他のファイナライザーが呼び出されないことがあります。  
  
-   ランタイムをクリーンアップする機会を与えずにプロセスを終了する場合は。 この場合、ランタイムのプロセス終了通知は、DLL_PROCESS_DETACH 通知です。  
  
 実行可能オブジェクトの数が減少し続けている間、シャットダウン中にも、ランタイムはオブジェクトの最終処理を継続します。  
  
 <xref:System.Object.Finalize%2A> または <xref:System.Object.Finalize%2A> のオーバーライドによって例外がスローされ、ランタイムが既定のポリシーをオーバーライドするアプリケーションによってホストされていない場合、ランタイムはプロセスを終了し、アクティブな `try`/`finally` ブロックまたはファイナライザーが実行されます。 この動作により、ファイナライザーがリソースを解放または破棄できない場合に、プロセスの整合性が確保されます。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Finalize メソッドのオーバーライド 
 ファイルハンドルやデータベース接続など、アンマネージリソースを使用するクラスの <xref:System.Object.Finalize%2A> をオーバーライドする必要があります。このクラスを使用するマネージオブジェクトは、ガベージコレクション中に破棄されます。 マネージリソースは、ガベージコレクターによって自動的に解放されるので、マネージオブジェクトの <xref:System.Object.Finalize%2A> メソッドを実装しないでください。  
  
> [!IMPORTANT]
>  アンマネージリソースをラップする <xref:System.Runtime.InteropServices.SafeHandle> オブジェクトが使用可能な場合は、セーフハンドルで dispose パターンを実装し、<xref:System.Object.Finalize%2A>をオーバーライドしないことをお勧めします。 詳細については、「 [SafeHandle の代替](#SafeHandle)」セクションを参照してください。  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> メソッドでは、既定では何も実行されませんが、必要な場合にのみ <xref:System.Object.Finalize%2A> をオーバーライドし、アンマネージリソースだけを解放する必要があります。 メモリの再利用は、終了操作を実行すると、少なくとも2つのガベージコレクションが必要になるため、かなり長くかかる傾向があります。 さらに、参照型に対してのみ <xref:System.Object.Finalize%2A> メソッドをオーバーライドする必要があります。 共通言語ランタイムは、参照型のみを終了します。 値型のファイナライザーは無視されます。  

<xref:System.Object.Finalize%2A?displayProperty=nameWithType> メソッドのスコープは `protected`です。 クラス内でこのメソッドをオーバーライドする場合は、このスコープの範囲を維持する必要があります。 <xref:System.Object.Finalize%2A> メソッドを保護したままにすると、アプリケーションのユーザーがオブジェクトの <xref:System.Object.Finalize%2A> メソッドを直接呼び出すことを防ぐことができます。
  
 派生型の <xref:System.Object.Finalize%2A> のすべての実装は、その基本型の <xref:System.Object.Finalize%2A>の実装を呼び出す必要があります。 これは、アプリケーションコードが <xref:System.Object.Finalize%2A>を呼び出すことができる唯一のケースです。 オブジェクトの <xref:System.Object.Finalize%2A> メソッドは、基底クラスのオブジェクト以外のオブジェクトに対してメソッドを呼び出すことはできません。 これは、共通言語ランタイムがシャットダウンされる場合など、呼び出し元のオブジェクトと呼び出された別のオブジェクトが同時にガベージ コレクションされることがあるからです。 
  
> [!NOTE]
>  C#コンパイラでは、<xref:System.Object.Finalize%2A> メソッドをオーバーライドすることはできません。 代わりに、クラスの[デストラクター](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)を実装することによってファイナライザーを提供します。 デストラクター C#は、基底クラスのデストラクターを自動的に呼び出します。  
>   
>  ビジュアルC++には、<xref:System.Object.Finalize%2A> メソッドを実装するための独自の構文も用意されています。 詳細については、「[方法: クラスと構造体を定義および使用する (C++/cli)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)」の「デストラクターとファイナライザー」を参照してください。  
  
 ガベージコレクションは非決定的であるため、ガベージコレクターが終了処理を実行するタイミングを正確に把握することはできません。 リソースをすぐに解放するには、 [dispose パターン](~/docs/standard/garbage-collection/implementing-dispose.md)と <xref:System.IDisposable> インターフェイスを実装することもできます。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 実装は、アンマネージリソースを解放するためにクラスのコンシューマーによって呼び出すことができます。また、<xref:System.IDisposable.Dispose%2A> メソッドが呼び出されていない場合は、<xref:System.Object.Finalize%2A> メソッドを使用してアンマネージリソースを解放できます。  
  
 <xref:System.Object.Finalize%2A> は、ガベージコレクション中にクリーンアップされた後、オブジェクトの resurrecting (つまり、オブジェクトに再度アクセスできるようにする) など、ほぼすべてのアクションを実行できます。 ただし、オブジェクトを再生することはできません。<xref:System.Object.Finalize%2A> は、ガベージコレクション中に再生オブジェクトで呼び出すことはできません。
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>代替手段としての SafeHandle  
 アプリケーションの状態を想定することはできず、<xref:System.OutOfMemoryException> や <xref:System.StackOverflowException> などの未処理のシステム例外によってファイナライザーが終了するため、信頼性の高いファイナライザーを作成することは、多くの場合、困難です。 アンマネージリソースを解放するためにクラスのファイナライザーを実装する代わりに、<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> クラスから派生したオブジェクトを使用してアンマネージリソースをラップし、ファイナライザーを使用せずに dispose パターンを実装することができます。 .NET Framework には、<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>から派生した <xref:Microsoft.Win32?displayProperty=nameWithType> 名前空間の次のクラスが用意されています。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> は、ファイルハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> は、メモリマップトファイルハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> は、アンマネージメモリブロックへのポインターのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>、および <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> は、暗号化ハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> は、パイプハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> は、レジストリキーへのハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> は、待機ハンドルのラッパークラスです。  
  
 次の例では、<xref:System.Object.Finalize%2A> メソッドをオーバーライドする代わりに、セーフハンドルで[dispose パターン](~/docs/standard/garbage-collection/implementing-dispose.md)を使用します。 これは、特定のファイル拡張子を持つファイルを処理するアプリケーションに関するレジストリ情報をラップする `FileAssociation` クラスを定義します。 Windows [regopenkeyex が](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)関数の呼び出しによって `out` パラメーターとして返される2つのレジストリハンドルは、<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> コンストラクターに渡されます。 次に、型の protected `Dispose` メソッドは、`SafeRegistryHandle.Dispose` メソッドを呼び出して、これらの2つのハンドルを解放します。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 次の例では、<xref:System.Object.Finalize%2A> をオーバーライドするオブジェクトが破棄されたときに、<xref:System.Object.Finalize%2A> メソッドが呼び出されることを確認します。 実稼働アプリケーションでは、オブジェクトに保持されているアンマネージリソースを解放するために <xref:System.Object.Finalize%2A> メソッドがオーバーライドされることに注意してください。 また、このC#例では、<xref:System.Object.Finalize%2A> メソッドをオーバーライドするのではなく、デストラクターが使用されていることにも注意してください。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <xref:System.Object.Finalize%2A> メソッドをオーバーライドするその他の例については、「<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッド」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のハッシュ関数として機能します。</summary>
        <returns>現在のオブジェクトのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハッシュコードは、<xref:System.Collections.Generic.Dictionary%602> クラス、<xref:System.Collections.Hashtable> クラス、<xref:System.Collections.DictionaryBase> クラスから派生した型など、ハッシュベースのコレクションにオブジェクトを挿入および識別するために使用される数値です。 <xref:System.Object.GetHashCode%2A> メソッドは、オブジェクトの等価性を簡単にチェックする必要があるアルゴリズムに対して、このハッシュコードを提供します。  
  
> [!NOTE]
>  ハッシュコードをハッシュテーブルで使用する方法と、追加のハッシュコードアルゴリズムの詳細については、Wikipedia の[Hash 関数](https://en.wikipedia.org/wiki/Hash_function)のエントリを参照してください。  
  
 等しい2つのオブジェクトが等しい場合は、そのハッシュコードが等しいことを示します。 ただし、逆は true ではありません。等値のハッシュコードでは、オブジェクトの等価性を意味しません。これは、異なる (等しくない) オブジェクトが同じハッシュコードを持つことができるためです。 さらに、.NET では <xref:System.Object.GetHashCode%2A> メソッドの既定の実装は保証されません。また、このメソッドが返す値は、異なるバージョンの .NET Framework や .NET Core などの .NET 実装と、32ビットや64ビットなどのプラットフォームで異なる場合があります。・. このような理由から、このメソッドの既定の実装をハッシュ用の一意のオブジェクト識別子として使用しないでください。 これには、次の2つの影響があります。  
  
-   等しいハッシュコードでは、オブジェクトの等価性を意味することを想定しないでください。  
  
-   同じオブジェクトがアプリケーションドメイン、プロセス、およびプラットフォーム間でハッシュされる可能性があるため、作成元のアプリケーションドメインの外部でハッシュコードを永続化したり、使用したりしないでください。  
  
> [!WARNING]
>  ハッシュコードは、ハッシュテーブルに基づくコレクション内での効率的な挿入と検索を目的としています。 ハッシュコードが永続的な値ではありません。 理由:  
>   
> -   ハッシュコード値をシリアル化したり、データベースに格納したりしないでください。  
> -   キーとしてハッシュコードを使用して、キー付きコレクションからオブジェクトを取得することは避けてください。  
> -   アプリケーションドメインまたはプロセス間でハッシュコードを送信しないでください。 場合によっては、プロセスごとまたはアプリケーションごとのドメインごとにハッシュコードを計算することがあります。  
> -   暗号ハッシュ関数によって返される値の代わりにハッシュコードを使用しないでください。暗号化に強力なハッシュが必要な場合に使用します。 暗号化ハッシュの場合は、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> または <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> クラスから派生したクラスを使用します。  
> -   2つのオブジェクトが等しいかどうかを判断するために、ハッシュコードが等しいかどうかをテストしないでください。 (等しくないオブジェクトは、同一のハッシュコードを持つことができます)。等しいかどうかをテストするには、<xref:System.Object.ReferenceEquals%2A> または <xref:System.Object.Equals%2A> メソッドを呼び出します。  
  
 <xref:System.Object.GetHashCode%2A> メソッドは、派生型でオーバーライドできます。 <xref:System.Object.GetHashCode%2A> がオーバーライドされていない場合、参照型のハッシュコードは、オブジェクトの参照に基づいてハッシュコードを計算する基底クラスの <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> メソッドを呼び出すことによって計算されます。詳細については、「<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>」を参照してください。 言い換えると、<xref:System.Object.ReferenceEquals%2A> メソッドが返す2つのオブジェクト `true` 同じハッシュコードを持つことになります。 値型が <xref:System.Object.GetHashCode%2A>をオーバーライドしない場合、基本クラスの <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> メソッドは、リフレクションを使用して、型のフィールドの値に基づいてハッシュコードを計算します。 言い換えると、同じ値を持つフィールドを持つ値型には、同じハッシュコードが含まれます。 <xref:System.Object.GetHashCode%2A>のオーバーライドの詳細については、「継承に関する注意事項」を参照してください。  
  
> [!WARNING]
>  <xref:System.Object.GetHashCode%2A> メソッドをオーバーライドする場合は、<xref:System.Object.Equals%2A>もオーバーライドする必要があります (その逆も同様)。 2つのオブジェクトが等しいかどうかをテストするときに、オーバーライドされた <xref:System.Object.Equals%2A> メソッドが `true` を返す場合、オーバーライドされた <xref:System.Object.GetHashCode%2A> メソッドは、2つのオブジェクトに対して同じ値を返す必要があります。  
  
 ハッシュテーブルのキーとして使用されているオブジェクトが <xref:System.Object.GetHashCode%2A>の便利な実装を提供していない場合は、<xref:System.Collections.Hashtable> クラスコンストラクターのいずれかのオーバーロードに <xref:System.Collections.IEqualityComparer> の実装を指定することで、ハッシュコードプロバイダーを指定できます。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] のメモ  
 [!INCLUDE[wrt](~/includes/wrt-md.md)]のクラスで <xref:System.Object.GetHashCode%2A> メソッドを呼び出すと、<xref:System.Object.GetHashCode%2A>をオーバーライドしないクラスの既定の動作が提供されます。 これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)] に提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。 [!INCLUDE[wrt](~/includes/wrt-md.md)] のクラスは <xref:System.Object>を継承せず、現在は <xref:System.Object.GetHashCode%2A>を実装していません。 ただし、 C#または Visual Basic コードで使用する場合、<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>、および <xref:System.Object.GetHashCode%2A> メソッドがあるように見えます。 .NET Framework は、これらのメソッドの既定の動作を提供します。  
  
> [!NOTE]
>  または Visual Basic でC#記述された [!INCLUDE[wrt](~/includes/wrt-md.md)] クラスは、<xref:System.Object.GetHashCode%2A> メソッドをオーバーライドできます。  
  
   
  
## Examples  
 <xref:System.Int32> 型と同じまたは小さい範囲の数値のハッシュコードを計算する最も簡単な方法の1つは、単にその値を返すことです。 次の例は、`Number` 構造体のこのような実装を示しています。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 多くの場合、型にはハッシュコードの生成に参加できる複数のデータフィールドがあります。 ハッシュコードを生成する方法の1つは、次の例に示すように、`XOR (eXclusive OR)` 操作を使用してこれらのフィールドを結合することです。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前の例では、(n1, n2) と (n2, n1) に対して同じハッシュコードが返されるため、望ましいよりも多くの衝突が発生する可能性があります。 これらのケースのハッシュコードが同一でないように、いくつかのソリューションを利用できます。 1つは、各フィールドの順序を反映する `Tuple` オブジェクトのハッシュコードを返すことです。 <xref:System.Tuple%602> クラスを使用する実装の例を次に示します。 ただし、`Tuple` オブジェクトをインスタンス化することによるパフォーマンスのオーバーヘッドによって、ハッシュテーブルに多数のオブジェクトが格納されるアプリケーションの全体的なパフォーマンスに大きな影響を与える可能性があることに注意してください。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 2つ目の代替ソリューションでは、連続するフィールドのハッシュコードを2つ以上のビットで左にシフトすることで、個々のハッシュコードを重み付けします。 最適です。破棄するのではなく、ビット31を超えてシフトされたビットは、破棄されるのではなく、ラップする必要があります。 ビットは Visual Basic との両方C#の左シフト演算子によって破棄されるため、次のような左シフトアンドラップメソッドを作成する必要があります。  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 次の例では、この shift キーと wrap メソッドを使用して、前の例で使用した `Point` 構造のハッシュコードを計算します。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>ハッシュ関数は、オブジェクトの値に対応する数値 (ハッシュコード) をすばやく生成するために使用されます。 通常、ハッシュ関数はそれぞれの型に固有であり、一意性を確保するには、少なくとも1つのインスタンスフィールドを入力として使用する必要があります。 ハッシュコードは、静的フィールドの値を使用して計算することはできません。  
  
<see cref="T:System.Object" />から派生したクラスの場合、<see langword="GetHashCode" /> メソッドは、派生クラスが参照の等価性を定義する場合にのみ、基本クラス <see cref="M:System.Object.GetHashCode" /> の実装にデリゲートできます。 参照型の <see cref="M:System.Object.GetHashCode" /> の既定の実装では、<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> メソッドによって返されるハッシュコードが返されます。 変更できない参照型については、<see cref="M:System.Object.GetHashCode" /> をオーバーライドできます。 一般に、変更可能な参照型の場合は、次の場合にのみ <see cref="M:System.Object.GetHashCode" /> をオーバーライドする必要があります。 
-変更できないフィールドからハッシュコードを計算できます。もしくは 
-ハッシュコードに依存するコレクションにオブジェクトが含まれている間は、変更可能なオブジェクトのハッシュコードが変更されないようにすることができます。  
  
それ以外の場合は、変更可能なオブジェクトがハッシュテーブルで失われると考えられます。 変更可能な参照型に対して <see cref="M:System.Object.GetHashCode" /> をオーバーライドする場合、ドキュメントでは、オブジェクトがハッシュテーブルに格納されている間、型のユーザーがオブジェクトの値を変更しないようにする必要があります。  
  
値型の場合、<see cref="M:System.ValueType.GetHashCode" /> には、リフレクションを使用する既定のハッシュコード実装が用意されています。 パフォーマンスを向上させるためにオーバーライドすることを検討してください。  
  
 <block subset="none" type="note"><para>  
 さまざまな方法でハッシュコードを計算する詳細と例については、「例」を参照してください。  
  
</para></block>  
  
 ハッシュ関数には、次のプロパティが必要です。 
-2 つのオブジェクトが等しいと比較される場合、各オブジェクトの <see cref="M:System.Object.GetHashCode" /> メソッドは同じ値を返す必要があります。 ただし、2つのオブジェクトが等しいかどうかを比較しない場合、2つのオブジェクトの <see cref="M:System.Object.GetHashCode" /> メソッドは、異なる値を返す必要はありません。  
  
-オブジェクトの <see cref="M:System.Object.GetHashCode" /> メソッドは、オブジェクトの system.object メソッドの戻り値を決定する[オブジェクトの状態](xref:System.Object.Equals*)が変更されていない限り、常に同じハッシュコードを返す必要があります。 これはアプリケーションの現在の実行に対してのみ true であり、アプリケーションが再実行されると別のハッシュコードが返される可能性があることに注意してください。  
  
-最適なパフォーマンスを得るために、ハッシュ関数では、大量の入力 (大量のクラスター化された入力を含む) に対して均等な分布を生成する必要があります。 暗黙的には、オブジェクトの状態を変更すると、ハッシュテーブルのパフォーマンスが最適になるように、結果のハッシュコードが大幅に変更されることになります。  
  
-ハッシュ関数は、コンピューティングのコストを安くする必要があります。  
  
-<see cref="M:System.Object.GetHashCode" /> メソッドは例外をスローしません。  
  
たとえば、<see cref="T:System.String" /> クラスによって提供される <see cref="M:System.String.GetHashCode" /> メソッドの実装は、同一の文字列値に対して同一のハッシュコードを返します。 したがって、2つの <see cref="T:System.String" /> オブジェクトが同じ文字列値を表す場合は、同じハッシュコードを返します。 また、入力が特定の範囲内でクラスター化されている場合でも、メソッドは文字列内のすべての文字を使用して、適度にランダムに分散された出力を生成します。たとえば、多くのユーザーは、128の ASCII 文字のみを含む文字列を持つこともできます。文字列には、65535の Unicode 文字を含めることができます。  
  
クラスに適切なハッシュ関数を指定すると、それらのオブジェクトをハッシュテーブルに追加するときのパフォーマンスに大きく影響することがあります。 ハッシュ関数の適切な実装を提供するキーを持つハッシュテーブルでは、要素の検索には一定の時間がかかります (O (1) 操作など)。 ハッシュ関数が不適切に実装されているハッシュテーブルでは、検索のパフォーマンスはハッシュテーブル内の項目の数 (たとえば、O (`n`) 操作など) によって異なります (`n` はハッシュテーブル内の項目の数です)。 悪意のあるユーザーがデータを入力すると、衝突の数が増えるため、次のような状況下で、ハッシュテーブルに依存するアプリケーションのパフォーマンスが大幅に低下する可能性があります。 
-ハッシュ関数が頻繁に衝突を生成する場合。  
  
-ハッシュテーブル内のオブジェクトの大部分が、互いに等しいまたはほぼ等しいハッシュコードを生成する場合。  
  
-ハッシュコードの計算元のデータをユーザーが入力した場合。  
  
<see cref="M:System.Object.GetHashCode" /> をオーバーライドする派生クラスも <see cref="M:System.Object.Equals(System.Object)" /> をオーバーライドして、等しいと見なされる2つのオブジェクトが同じハッシュコードを持つことを保証する必要があります。それ以外の場合、<see cref="T:System.Collections.Hashtable" /> の種類が正しく機能しない可能性があります。</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在のインスタンスの正確なランタイム型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object?displayProperty=nameWithType> は .NET 型システムのすべての型の基本クラスであるため、<xref:System.Object.GetType%2A> メソッドを使用して、すべての .NET 型を表す <xref:System.Type> オブジェクトを返すことができます。 .NET では、次の5種類のカテゴリが認識されます。  
  
-   <xref:System.Object?displayProperty=nameWithType>から派生したクラス  
  
-   値型。 <xref:System.ValueType?displayProperty=nameWithType>から派生します。  
  
-   .NET Framework 2.0 から始まる <xref:System.Object?displayProperty=nameWithType> から派生したインターフェイス。  
  
-   <xref:System.Enum?displayProperty=nameWithType>から派生した列挙型。  
  
-   デリゲート。 <xref:System.MulticastDelegate?displayProperty=nameWithType>から派生します。  
  
 2つのオブジェクト `x` と `y` のランタイム型が同一である場合、`Object.ReferenceEquals(x.GetType(),y.GetType())` は `true`を返します。 次の例では、<xref:System.Object.GetType%2A> メソッドを <xref:System.Object.ReferenceEquals%2A> メソッドと共に使用して、1つの数値が他の2つの数値と同じ型であるかどうかを判断します。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  オブジェクトが特定の型であるかどうかを判断するには、言語の型比較キーワードまたはコンストラクトを使用できます。 たとえば、Visual Basic の `TypeOf…Is` コンストラクト、またはのC#`is` キーワードを使用できます。  
  
 <xref:System.Object.GetType%2A> メソッドは、<xref:System.Object>から派生したすべての型によって継承されます。 つまり、次の例に示すように、独自の言語の比較キーワードを使用するだけでなく、<xref:System.Object.GetType%2A> メソッドを使用して特定のオブジェクトの型を特定することもできます。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type> オブジェクトは、現在の <xref:System.Object>のクラスに関連付けられているメタデータを公開します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Object.GetType%2A> が現在のインスタンスのランタイム型を返すことを示しています。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Object" /> の簡易コピーを作成します。</summary>
        <returns>現在の <see cref="T:System.Object" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A> メソッドは、新しいオブジェクトを作成し、現在のオブジェクトの非静的フィールドを新しいオブジェクトにコピーすることによって、簡易コピーを作成します。 フィールドが値型の場合は、フィールドのビットごとのコピーが実行されます。 フィールドが参照型の場合、参照はコピーされますが、参照先のオブジェクトはコピーされません。したがって、元のオブジェクトとその複製は、同じオブジェクトを参照します。  
  
 たとえば、オブジェクト A と B を参照する X と呼ばれるオブジェクトについて考えてみます。オブジェクト B がオブジェクト C を参照しているとします。X の簡易コピーでは、オブジェクト A と B も参照する新しいオブジェクト X2 が作成されます。これに対し、X の詳細コピーでは新しいオブジェクト X2 が作成されます。これは、A と B のコピーである A2 と B2 の新しいオブジェクトを参照します。 B2 は、C のコピーである新しいオブジェクト C2 を参照します。この例では、簡易コピー操作と詳細コピー操作の違いについて説明します。  
  
 <xref:System.Object.MemberwiseClone%2A> メソッドによって実行される簡易コピー操作がニーズを満たさない場合は、ディープコピー操作を実装する方法が多数あります。 リポジトリには、次のものが含まれます。  
  
-   コピーするオブジェクトのクラスコンストラクターを呼び出して、最初のオブジェクトから取得したプロパティ値を持つ2番目のオブジェクトを作成します。 これは、オブジェクトの値がクラスコンストラクターによって完全に定義されていることを前提としています。  
  
-   <xref:System.Object.MemberwiseClone%2A> メソッドを呼び出してオブジェクトの簡易コピーを作成し、元のオブジェクトと同じ値を持つ新しいオブジェクトを、値が参照型であるプロパティまたはフィールドに割り当てます。 この例の `DeepCopy` メソッドは、この方法を示しています。  
  
-   詳細にコピーされるようにオブジェクトをシリアル化し、シリアル化されたデータを別のオブジェクト変数に復元します。  
  
-   詳細コピー操作を実行するには、再帰と共にリフレクションを使用します。  
  
   
  
## Examples  
 次の例は、<xref:System.Object.MemberwiseClone%2A> メソッドを示しています。 <xref:System.Object.MemberwiseClone%2A> メソッドを呼び出して `Person` オブジェクトに対して簡易コピー操作を実行する `ShallowCopy` メソッドを定義します。 また、`Person` オブジェクトに対して詳細コピー操作を実行する `DeepCopy` メソッドも定義します。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 この例では、`Person.IdInfo` プロパティは `IdInfo` オブジェクトを返します。 この例の出力に示すように、<xref:System.Object.MemberwiseClone%2A> メソッドを呼び出すことによって `Person` オブジェクトを複製すると、複製された `Person` オブジェクトは元のオブジェクトの独立したコピーになります。ただし、同じ `Person.IdInfo` オブジェクト参照を共有する点が異なります。 その結果、複製の `Person.IdInfo` プロパティを変更すると、元のオブジェクトの `Person.IdInfo` プロパティが変更されます。 一方、詳細コピー操作を実行するときに、複製された `Person` オブジェクト (`Person.IdInfo` プロパティを含む) は、元のオブジェクトに影響を与えることなく変更できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較する最初のオブジェクト。</param>
        <param name="objB">比較する 2 番目のオブジェクト。</param>
        <summary>指定した複数の <see cref="T:System.Object" /> インスタンスが同一インスタンスかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="objA" /> と同一のインスタンスである場合、または両方のインスタンスが <paramref name="objB" />null**の場合は**。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Equals%2A> メソッドと等値演算子とは異なり、<xref:System.Object.ReferenceEquals%2A> メソッドをオーバーライドすることはできません。 このため、2つのオブジェクト参照が等しいかどうかをテストし、`Equals` メソッドの実装がわからない場合は、<xref:System.Object.ReferenceEquals%2A> メソッドを呼び出すことができます。  
  
 ただし、次の2つのシナリオでは、<xref:System.Object.ReferenceEquals%2A> メソッドの戻り値が異常であるように見えることがあります。  
  
-   値型を比較する場合。 `objA` と `objB` が値型の場合、<xref:System.Object.ReferenceEquals%2A> メソッドに渡される前にボックス化されます。 これは、`objA` と `objB` の両方が値型の同じインスタンスを表している場合、次の例に示すように、<xref:System.Object.ReferenceEquals%2A> メソッドが `false`を返すことを意味します。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     値型のボックス化の詳細については、「[ボックス化とボックス化解除](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)」を参照してください。  
  
-   文字列を比較する場合。 `objA` と `objB` が文字列の場合、<xref:System.Object.ReferenceEquals%2A> メソッドは、文字列がインターンプールされている場合は `true` を返します。 値が等しいかどうかのテストは実行されません。  次の例では、1つのインターン文字列の2つのインスタンスであるため、`s1` と `s2` は等しくなります。 ただし、`s3` と `s4` は等しくありません。これは、文字列値が同一であっても、その文字列がインターンインターンに含まれていないためです。  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     文字列インターンの詳細については、「<xref:System.String.IsInterned%2A?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Object.ReferenceEquals%2A> を使用して、2つのオブジェクトが同じインスタンスであるかどうかを確認します。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のオブジェクトを表す string を返します。</summary>
        <returns>現在のオブジェクトを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> は、.NET Framework の主要な書式設定メソッドです。 オブジェクトを文字列形式に変換して、表示に適した状態にします。 (.NET Framework での書式設定のサポートについては、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください)。<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドの既定の実装では、オブジェクトの型の完全修飾名が返されます。  
  
> [!IMPORTANT]
>  別の種類のメンバーリストからのリンクに従って、このページに到達した可能性があります。 これは、その型が <xref:System.Object.ToString%2A?displayProperty=nameWithType>をオーバーライドしないためです。 代わりに、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドの機能を継承します。  
  
 型は、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドを頻繁にオーバーライドして、特定の型のより適切な文字列表現を提供します。 また、型は、書式指定文字列またはカルチャに依存した書式設定をサポートするために、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーロードすることもよくあります。  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 このセクションの内容:  
  
 [既定のオブジェクトの ToString () メソッド](#Default)   
 [オブジェクトの ToString () メソッドのオーバーライド](#Overriding)   
 [ToString メソッドのオーバーロード](#Overloading)   
 [オブジェクトの拡張メソッド](#Extending)   
 [Windows ランタイムのメモ](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>既定のオブジェクトの ToString () メソッド  
 次の例に示すように、<xref:System.Object.ToString%2A> メソッドの既定の実装は、<xref:System.Object>の型の完全修飾名を返します。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp-interactive[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <xref:System.Object> は .NET Framework 内のすべての参照型の基本クラスであるため、この動作は <xref:System.Object.ToString%2A> メソッドをオーバーライドしない参照型によって継承されます。 これを次の例に示します。 これは、すべての <xref:System.Object> メンバーの既定の実装を受け入れる `Object1` という名前のクラスを定義します。 <xref:System.Object.ToString%2A> メソッドは、オブジェクトの完全修飾型名を返します。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>オブジェクトのオーバーライド () メソッド  
 型は、通常、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドして、オブジェクトインスタンスを表す文字列を返します。 たとえば、<xref:System.Char>、<xref:System.Int32>、<xref:System.String> などの基本型は、オブジェクトが表す値の文字列形式を返す <xref:System.Object.ToString%2A> の実装を提供します。 次の例では、`Object2`クラスを定義しています。このクラスは、<xref:System.Object.ToString%2A> メソッドをオーバーライドして、型名とその値を返します。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 次の表に、.NET の型カテゴリの一覧を示し、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドするかどうかを示します。  
  
|型のカテゴリ|Object. ToString () をオーバーライドします。|動作|  
|-------------------|-----------------------------------|--------------|  
|インスタンス|該当なし|該当なし|  
|構造体|はい (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|`Object.ToString()` と同じ|  
|列挙型|はい (<xref:System.Enum.ToString?displayProperty=nameWithType>)|メンバー名|  
|インターフェイス|いいえ|該当なし|  
|デリゲート|いいえ|該当なし|  
  
 <xref:System.Object.ToString%2A>のオーバーライドの詳細については、「継承に関する注意事項」を参照してください。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>ToString メソッドのオーバーロード  
 パラメーターのない <xref:System.Object.ToString?displayProperty=nameWithType> メソッドをオーバーライドするだけでなく、多くの型では、パラメーターを受け取るメソッドのバージョンを提供するために、`ToString` メソッドがオーバーロードされます。 ほとんどの場合、これは変数の書式設定とカルチャに依存した書式設定のサポートを提供するために行われます。  
  
 次の例では、`ToString` メソッドをオーバーロードして、`Automobile` クラスのさまざまなフィールドの値を含む結果の文字列を返します。 4つの書式指定文字列を定義します。 G は、モデル名と年を返します。D: モデル名、年、およびドアの数を返します。C: モデル名、年、およびシリンダーの数を返します。とは、4つのフィールド値すべてを含む文字列を返します。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 次の例では、オーバーロードされた <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、通貨値のカルチャに依存した書式設定を表示します。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 書式指定文字列とカルチャに依存した書式設定の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。 数値でサポートされる書式指定文字列については、「[標準の数値書式指定](~/docs/standard/base-types/standard-numeric-format-strings.md)文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 日付と時刻の値でサポートされる書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>オブジェクトの ToString メソッドの拡張  
 型は既定の <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドを継承するため、その動作が望ましくなく、変更が必要になる場合があります。 これは、配列とコレクションクラスに特に当てはまります。 配列またはコレクションクラスの `ToString` メソッドでメンバーの値を表示することが予想される場合がありますが、次の例に示すように、型の完全修飾型名が表示されます。  
  
 [!code-csharp-interactive[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 結果の文字列を生成するには、いくつかのオプションがあります。  
  
-   型が配列、コレクションオブジェクト、または <xref:System.Collections.IEnumerable> インターフェイスまたは <xref:System.Collections.Generic.IEnumerable%601> インターフェイスを実装するオブジェクトである場合は、のC# `foreach` ステートメントまたは Visual Basic の `For Each...Next` コンストラクトを使用して、その要素を列挙できます。  
  
-   クラスが `sealed` ( C#) または `NotInheritable` (Visual Basic) でない場合は、カスタマイズする <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドを持つ基本クラスから継承するラッパークラスを開発できます。 少なくとも、次の操作を行う必要があります。  
  
    1.  必要なコンストラクターを実装します。 派生クラスは、基底クラスのコンストラクターを継承しません。  
  
    2.  <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドして、必要な結果文字列を返します。  
  
     次の例では、<xref:System.Collections.Generic.List%601> クラスのラッパークラスを定義します。 <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドして、完全修飾型名ではなく、コレクションの各メソッドの値を表示します。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   必要な結果文字列を返す[拡張メソッド](~/docs/standard/design-guidelines/extension-methods.md)を開発します。 この方法では既定の <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドできないことに注意してください (つまり、 C#拡張クラス (内) またはモジュール (Visual Basic) は、元の型の `ToString` メソッドの代わりに呼び出される `ToString` という名前のパラメーターなしのメソッドを持つことはできません。 パラメーターなしの `ToString` 置換には、他の名前を指定する必要があります。  
  
     次の例では、<xref:System.Collections.Generic.List%601> クラスを拡張する2つのメソッドを定義しています。パラメーターなしの `ToString2` メソッドと、書式指定文字列を表す <xref:System.String> パラメーターを持つ `ToString` メソッドです。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] のメモ  
 [!INCLUDE[wrt](~/includes/wrt-md.md)]のクラスで <xref:System.Object.ToString%2A> メソッドを呼び出すと、<xref:System.Object.ToString%2A>をオーバーライドしないクラスの既定の動作が提供されます。 これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)] に提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。 [!INCLUDE[wrt](~/includes/wrt-md.md)] のクラスは <xref:System.Object>を継承せず、常に <xref:System.Object.ToString%2A>を実装することはありません。 ただし、これらのメソッドをC#または Visual Basic コードで使用すると、これらのメソッドは常に <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>、および <xref:System.Object.GetHashCode%2A> に表示されます。また、.NET Framework は、これらのメソッドの既定の動作を提供します。  
  
 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]以降では、共通言語ランタイムは、<xref:System.Object.ToString%2A?displayProperty=nameWithType>の既定の実装に戻る前に、[!INCLUDE[wrt](~/includes/wrt-md.md)] オブジェクトに対して[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)を使用します。  
  
> [!NOTE]
>  または Visual Basic でC#記述された [!INCLUDE[wrt](~/includes/wrt-md.md)] クラスは、<xref:System.Object.ToString%2A> メソッドをオーバーライドできます。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] と IStringable インターフェイス  
 [!INCLUDE[win81](~/includes/win81-md.md)]以降では、[!INCLUDE[wrt](~/includes/wrt-md.md)] に[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイスが含まれています。このインターフェイスは、単一のメソッドである[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)を使用して、<xref:System.Object.ToString%2A?displayProperty=nameWithType>によって提供される基本的な書式設定のサポートを提供します。 あいまいさを防ぐには、マネージ型に[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装しないでください。  
  
 マネージオブジェクトがネイティブコードまたは JavaScript やC++/cx などの言語で記述されたコードによって呼び出されると、 [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装するように見えます。 共通言語ランタイムは、 [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)からの呼び出しを、マネージオブジェクトに実装されてい[ないイベントの](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)<xref:System.Object.ToString%2A?displayProperty=nameWithType> に自動的にルーティングします。  
  
> [!WARNING]
>  共通言語ランタイムは、[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] アプリのすべてのマネージ型に対して[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を自動的に実装するため、独自の[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)の実装を提供しないことをお勧めします。 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装すると、[!INCLUDE[wrt](~/includes/wrt-md.md)]、 C++/Cx、または JavaScript から `ToString` を呼び出すときに意図しない動作が発生する可能性があります。  
  
 [!INCLUDE[wrt](~/includes/wrt-md.md)] コンポーネントにエクスポートされるパブリックマネージ型に[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装する場合は、次の制限が適用されます。  
  
-   [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイスは、"クラスが実装する" 関係でのみ定義できます。  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     C# では、上記のようになります。  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     Visual Basic では、上記のようになります。  
  
-   インターフェイスに[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装することはできません。  
  
-   パラメーターの型を[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)として宣言することはできません。  
  
-   [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)は、メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。  
  
-   次のようなメソッド定義を使用して、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)の実装を基底クラスから隠すことはできません。  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     代わりに、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)の実装では、常に基底クラスの実装をオーバーライドする必要があります。 `ToString` の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。  
  
 さまざまな条件下では、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装するマネージ型、または[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)実装を隠すマネージ型にネイティブコードから呼び出すと、予期しない動作が発生する可能性があることに注意してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>独自の型を実装する場合は、<see cref="M:System.Object.ToString" /> メソッドをオーバーライドして、これらの型にとって意味のある値を返す必要があります。 <see cref="M:System.Object.ToString" /> よりも書式設定をより詳細に制御する必要がある派生クラスは、<see cref="T:System.IFormattable" /> インターフェイスを実装できます。 <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> メソッドを使用すると、書式設定を制御する書式指定文字列を定義したり、カルチャ固有の書式設定用に提供される <see cref="T:System.IFormatProvider" /> オブジェクトを使用したりすることができます。  
  
<see cref="M:System.Object.ToString" /> メソッドのオーバーライドは、次のガイドラインに従う必要があります。 
-返される文字列は、わかりやすく、人間が判読できるものにする必要があります。  
  
-返される文字列は、オブジェクトインスタンスの値を一意に識別する必要があります。  
  
-返される文字列は、デバッガーによる表示に適しているように、可能な限り短くする必要があります。  
  
-<see cref="M:System.Object.ToString" /> のオーバーライドは、<see cref="F:System.String.Empty" /> または null 文字列を返さないようにする必要があります。  
  
-<see cref="M:System.Object.ToString" /> のオーバーライドでは、例外をスローしません。  
  
-インスタンスの文字列表現がカルチャに依存しているか、複数の方法で書式設定できる場合は、<see cref="T:System.IFormattable" /> インターフェイスを実装します。  
  
-返された文字列に機密情報が含まれている場合は、まず適切なアクセス許可を要求する必要があります。 要求が成功した場合は、機密情報を返すことができます。それ以外の場合は、機密情報を除外する文字列を返す必要があります。  
  
-<see cref="M:System.Object.ToString" /> のオーバーライドには、デバッグの複雑さを避けるために、監視可能な副作用はありません。 たとえば、<see cref="M:System.Object.ToString" /> メソッドを呼び出す場合、インスタンスフィールドの値を変更することはできません。  
  
-型が解析メソッド (または <see langword="Parse" /> または <see langword="TryParse" /> メソッド、コンストラクター、または文字列から型のインスタンスをインスタンス化するその他の静的メソッド) を実装している場合は、<see cref="M:System.Object.ToString" /> メソッドによって返された文字列をに変換できることを確認する必要があります。オブジェクトインスタンス。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
      </Docs>
    </Member>
  </Members>
</Type>
