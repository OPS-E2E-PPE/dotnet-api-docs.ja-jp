<Type Name="Type" FullName="System.Type">
  <TypeSignature Language="C#" Value="public abstract class Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Type extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Type = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="20716-101">型宣言を表します。型には、クラス型、インターフェイス型、配列型、値型、列挙型、型パラメーター、ジェネリック型定義、およびオープン構築ジェネリック型またはクローズ構築ジェネリック型があります。</span><span class="sxs-lookup"><span data-stu-id="20716-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-102">`Type` は <xref:System.Reflection> 機能のルートであり、メタデータにアクセスする主な方法です。</span><span class="sxs-lookup"><span data-stu-id="20716-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="20716-103">型のメンバー (クラスのコンストラクター、メソッド、フィールド、プロパティ、イベントなど) と、そのクラスが配置されているモジュールとアセンブリについて、型宣言に関する情報を取得するには、<xref:System.Type> のメンバーを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="20716-104">アクセスレベルに関係なく、型とそのメンバーに関する情報を取得するためにリフレクションを使用するためのアクセス許可は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="20716-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="20716-105">リフレクションを使用してパブリックメンバーにアクセスするコード、またはアクセスレベルが通常のコンパイル中に表示される他のメンバーにアクセスするためのアクセス許可は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="20716-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="20716-106">ただし、プライベートメソッド、内部メソッド、またはクラスが継承しない型の保護されたフィールドなど、通常はアクセスできないメンバーにコードがリフレクションを使用してアクセスするためには、コードに <xref:System.Security.Permissions.ReflectionPermission>が必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="20716-107">「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="20716-108">`Type` は、複数の実装を許可する抽象基本クラスです。</span><span class="sxs-lookup"><span data-stu-id="20716-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="20716-109">システムは常に `RuntimeType`派生クラスを提供します。</span><span class="sxs-lookup"><span data-stu-id="20716-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="20716-110">リフレクションでは、word ランタイムで始まるすべてのクラスは、システム内のオブジェクトごとに1回だけ作成され、比較操作をサポートします。</span><span class="sxs-lookup"><span data-stu-id="20716-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-111">マルチスレッドのシナリオでは、`static` データへのアクセスを同期するために <xref:System.Type> オブジェクトをロックしないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="20716-112">コントロールがない他のコードも、クラス型をロックすることがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="20716-113">これにより、デッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-113">This might result in a deadlock.</span></span> <span data-ttu-id="20716-114">代わりに、プライベート `static` オブジェクトをロックすることによって、静的データへのアクセスを同期します。</span><span class="sxs-lookup"><span data-stu-id="20716-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-115">派生クラスは、呼び出し元のコードの基本クラスのプロテクトメンバーにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="20716-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="20716-116">また、呼び出し元のコードのアセンブリのメンバーにアクセスすることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="20716-117">規則として、事前バインディングされたコード内でアクセスが許可されている場合は、遅延バインディングされたコードでアクセスを許可することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-118">他のインターフェイスを拡張するインターフェイスは、拡張インターフェイスで定義されているメソッドを継承しません。</span><span class="sxs-lookup"><span data-stu-id="20716-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="20716-119">このセクションの内容は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="20716-119">In this section:</span></span>  
  
 <span data-ttu-id="20716-120">[Type オブジェクトはどのような型を表していますか。](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="20716-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="20716-121">[型オブジェクトの取得](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="20716-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="20716-122">型オブジェクトの等価性の比較</span><span class="sxs-lookup"><span data-stu-id="20716-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="20716-123">Type オブジェクトはどのような型を表していますか。</span><span class="sxs-lookup"><span data-stu-id="20716-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="20716-124">このクラスはスレッドセーフです。この型のインスタンスから複数のスレッドが同時に読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="20716-125"><xref:System.Type> クラスのインスタンスは、次のいずれかの型を表すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="20716-126">クラス</span><span class="sxs-lookup"><span data-stu-id="20716-126">Classes</span></span>  
  
-   <span data-ttu-id="20716-127">値型</span><span class="sxs-lookup"><span data-stu-id="20716-127">Value types</span></span>  
  
-   <span data-ttu-id="20716-128">配列</span><span class="sxs-lookup"><span data-stu-id="20716-128">Arrays</span></span>  
  
-   <span data-ttu-id="20716-129">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="20716-129">Interfaces</span></span>  
  
-   <span data-ttu-id="20716-130">列挙型</span><span class="sxs-lookup"><span data-stu-id="20716-130">Enumerations</span></span>  
  
-   <span data-ttu-id="20716-131">デリゲート</span><span class="sxs-lookup"><span data-stu-id="20716-131">Delegates</span></span>  
  
-   <span data-ttu-id="20716-132">構築されたジェネリック型とジェネリック型の定義</span><span class="sxs-lookup"><span data-stu-id="20716-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="20716-133">構築されたジェネリック型、ジェネリック型定義、ジェネリックメソッド定義の型引数と型パラメーター</span><span class="sxs-lookup"><span data-stu-id="20716-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="20716-134">型オブジェクトの取得</span><span class="sxs-lookup"><span data-stu-id="20716-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="20716-135">特定の型に関連付けられている <xref:System.Type> オブジェクトは、次の方法で取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="20716-136">インスタンス <xref:System.Object.GetType%2A?displayProperty=nameWithType> メソッドは、インスタンスの型を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="20716-137">すべてのマネージ型は <xref:System.Object>から派生するため、<xref:System.Object.GetType%2A> メソッドは任意の型のインスタンスで呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="20716-138">次の例では、<xref:System.Object.GetType%2A?displayProperty=nameWithType> メソッドを呼び出して、オブジェクト配列内の各オブジェクトのランタイム型を確認します。</span><span class="sxs-lookup"><span data-stu-id="20716-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp-interactive[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="20716-139">静的 <xref:System.Type.GetType%2A?displayProperty=nameWithType> メソッドは、完全修飾名で指定された型を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="20716-140"><xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>、<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>、および <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> の各メソッドは、モジュールで定義されている型を表す `Type` オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="20716-141">最初のメソッドを使用すると、モジュールで定義されているすべてのパブリック型とプライベート型の <xref:System.Type> オブジェクトの配列を取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="20716-142">(<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> メソッドを使用して、または <xref:System.Type.Module%2A?displayProperty=nameWithType> プロパティを使用して `Module` のインスタンスを取得できます)。</span><span class="sxs-lookup"><span data-stu-id="20716-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="20716-143"><xref:System.Reflection.Assembly?displayProperty=nameWithType> オブジェクトには、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>、<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>、<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>など、アセンブリで定義されているクラスを取得するためのメソッドが多数含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="20716-144"><xref:System.Type.FindInterfaces%2A> メソッドは、型によってサポートされる、フィルター処理されたインターフェイスの型のリストを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="20716-145"><xref:System.Type.GetElementType%2A> メソッドは、要素を表す `Type` オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="20716-146"><xref:System.Type.GetInterfaces%2A> メソッドと <xref:System.Type.GetInterface%2A> メソッドは、型でサポートされているインターフェイス型を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="20716-147"><xref:System.Type.GetTypeArray%2A> メソッドは、任意のオブジェクトセットによって指定された型を表す <xref:System.Type> オブジェクトの配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="20716-148">オブジェクトは <xref:System.Object>型の配列で指定されます。</span><span class="sxs-lookup"><span data-stu-id="20716-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="20716-149"><xref:System.Type.GetTypeFromProgID%2A> および <xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM 相互運用性のために用意されています。</span><span class="sxs-lookup"><span data-stu-id="20716-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="20716-150">これらは、`ProgID` または `CLSID`によって指定された型を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="20716-151"><xref:System.Type.GetTypeFromHandle%2A> メソッドは、相互運用性を確保するために用意されています。</span><span class="sxs-lookup"><span data-stu-id="20716-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="20716-152">クラスハンドルによって指定された型を表す `Type` オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="20716-153">C# `typeof` 演算子、 C++ `typeid` 演算子、および Visual Basic `GetType` 演算子は、型の `Type` オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="20716-154"><xref:System.Type.MakeGenericType%2A> メソッドは、構築されたジェネリック型を表す <xref:System.Type> オブジェクトを返します。これは、<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`を返した場合はオープン構築型、それ以外の場合は閉じた構築型です。</span><span class="sxs-lookup"><span data-stu-id="20716-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="20716-155">ジェネリック型は、閉じられている場合にのみインスタンス化できます。</span><span class="sxs-lookup"><span data-stu-id="20716-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="20716-156"><xref:System.Type.MakeArrayType%2A>、<xref:System.Type.MakePointerType%2A>、および <xref:System.Type.MakeByRefType%2A> メソッドは、指定された型の配列、指定された型へのポインター、および参照パラメーターの型 ( C#`ref` では `ByRef`) を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="20716-157">型オブジェクトの等価性の比較</span><span class="sxs-lookup"><span data-stu-id="20716-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="20716-158">型を表す <xref:System.Type> オブジェクトは一意です。つまり、2つの <xref:System.Type> オブジェクト参照は、同じ型を表している場合に限り、同じオブジェクトを参照します。</span><span class="sxs-lookup"><span data-stu-id="20716-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="20716-159">これにより、参照の等価性を使用して <xref:System.Type> オブジェクトを比較できます。</span><span class="sxs-lookup"><span data-stu-id="20716-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="20716-160">次の例では、整数値の数を表す <xref:System.Type> オブジェクトを比較して、それらが同じ型であるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp-interactive[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="20716-161">次の例は、<xref:System.Type>のいくつかの代表的な機能を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-161">The following example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="20716-162">`typeof` C#演算子 (Visual Basic の`GetType` 演算子) を使用して、<xref:System.String>を表す <xref:System.Type> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-162">The C# `typeof` operator (`GetType` operator in Visual Basic) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="20716-163">この <xref:System.Type> オブジェクトから、<xref:System.Type.GetMethod%2A> メソッドを使用して、開始位置と長さを受け取る <xref:System.String.Substring%2A?displayProperty=nameWithType> のオーバーロードを表す <xref:System.Reflection.MethodInfo> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A?displayProperty=nameWithType> overload that takes a starting location and a length.</span></span>
  
 <span data-ttu-id="20716-164">オーバーロードシグネチャを識別するために、コード例では、`int` (Visual Basic で`Integer`) を表す2つの <xref:System.Type> オブジェクトを含む一時配列を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-165">正確に言うと、配列には、現在のアプリケーションドメインの `int` を表す <xref:System.Type> のインスタンスへの2つの参照が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="20716-166">任意の型の場合、アプリケーションドメインごとに <xref:System.Type> のインスタンスが1つだけ存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  

 <span data-ttu-id="20716-167">このコード例では、<xref:System.Reflection.MethodInfo> を使用して、文字列 "Hello, World!" の <xref:System.String.Substring%2A> メソッドを呼び出し、結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="20716-168">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="20716-168">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="20716-169"><see langword="Type" />から継承する場合は、次のメンバーをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-169">When you inherit from <see langword="Type" />, you must override the following members:</span></span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md"><span data-ttu-id="20716-170">型情報の表示</span><span class="sxs-lookup"><span data-stu-id="20716-170">Viewing Type Information</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-171"><see cref="T:System.Type" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="20716-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-172">このコンストラクターは、型オブジェクトの構築中に、派生クラスによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-173">型が宣言される <see cref="T:System.Reflection.Assembly" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span></span> <span data-ttu-id="20716-174">ジェネリック型の場合は、ジェネリック型が定義される <see cref="T:System.Reflection.Assembly" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span></span></summary>
        <value><span data-ttu-id="20716-175">現在の型を含むアセンブリを説明する <see cref="T:System.Reflection.Assembly" /> インスタンス。</span><span class="sxs-lookup"><span data-stu-id="20716-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span></span> <span data-ttu-id="20716-176">ジェネリック型の場合、インスタンスは特定の構築型を作成および使用するアセンブリではなく、ジェネリック型定義を含むアセンブリを説明します。</span><span class="sxs-lookup"><span data-stu-id="20716-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-177">現在の <xref:System.Type> オブジェクトが構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義を含むアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="20716-178">たとえば、ジェネリック型定義 `MyGenericStack<T>` (`MyGenericStack(Of T)` Visual Basic では `generic<T> ref class MyGenericStack` C++) を含む mygenerics .dll という名前のアセンブリを作成したとします。</span><span class="sxs-lookup"><span data-stu-id="20716-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="20716-179">別のアセンブリに `MyGenericStack<int>` (Visual Basic で`MyGenericStack(Of Integer)`) のインスタンスを作成すると、構築された型の <xref:System.Type.Assembly%2A> プロパティによって、MyGenerics .dll を表す <xref:System.Reflection.Assembly> オブジェクトが返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="20716-180">同様に、現在の <xref:System.Type> オブジェクトが割り当てられていないジェネリックパラメーター `T`を表している場合、このプロパティは `T`を定義するジェネリック型を含むアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="20716-181">.NET Core やユニバーサル Windows プラットフォームなど、特定の .NET 実装で <xref:System.Type.Assembly%2A?displayProperty=nameWithType> プロパティを使用できない場合は、代わりに <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="20716-182">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-183">次の例では、クラスに関連付けられているアセンブリ名と、その型の完全修飾名を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-184"><see cref="T:System.Type" /> オブジェクトの読み込み元であるアセンブリの名前を含む型のアセンブリ修飾名を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span></span></summary>
        <value><span data-ttu-id="20716-185"><see cref="T:System.Type" /> の読み込み元であるアセンブリの名前を含む、<see cref="T:System.Type" /> のアセンブリ修飾名。現在のインスタンスがジェネリック型パラメーターを表す場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-186">型のアセンブリ修飾名は、名前空間を含む型名とその後に続くコンマ、およびアセンブリの表示名で構成されます。</span><span class="sxs-lookup"><span data-stu-id="20716-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="20716-187">アセンブリの表示名は、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> プロパティを使用して取得されます。</span><span class="sxs-lookup"><span data-stu-id="20716-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-188">.NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="20716-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="20716-189">たとえば、"ProcessorArchitecture = msil" のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="20716-190">ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="20716-191">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="20716-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="20716-192">共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。</span><span class="sxs-lookup"><span data-stu-id="20716-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="20716-193">区切り記号</span><span class="sxs-lookup"><span data-stu-id="20716-193">Delimiter</span></span>|<span data-ttu-id="20716-194">意味</span><span class="sxs-lookup"><span data-stu-id="20716-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="20716-195">円記号 (\\)</span><span class="sxs-lookup"><span data-stu-id="20716-195">Backslash (\\)</span></span>|<span data-ttu-id="20716-196">エスケープ文字。</span><span class="sxs-lookup"><span data-stu-id="20716-196">Escape character.</span></span>|  
|<span data-ttu-id="20716-197">コンマ (,)</span><span class="sxs-lookup"><span data-stu-id="20716-197">Comma (,)</span></span>|<span data-ttu-id="20716-198">アセンブリ名の前に指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="20716-199">プラス記号 (+)</span><span class="sxs-lookup"><span data-stu-id="20716-199">Plus sign (+)</span></span>|<span data-ttu-id="20716-200">入れ子になったクラスの前に置きます。</span><span class="sxs-lookup"><span data-stu-id="20716-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="20716-201">ピリオド (.)</span><span class="sxs-lookup"><span data-stu-id="20716-201">Period (.)</span></span>|<span data-ttu-id="20716-202">名前空間識別子を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="20716-203">角かっこ ([])</span><span class="sxs-lookup"><span data-stu-id="20716-203">Brackets ([])</span></span>|<span data-ttu-id="20716-204">型名の後には、その型の配列を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="20716-205">または</span><span class="sxs-lookup"><span data-stu-id="20716-205">-or-</span></span><br /><br /> <span data-ttu-id="20716-206">ジェネリック型の場合は、ジェネリック型引数リストを囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="20716-207">または</span><span class="sxs-lookup"><span data-stu-id="20716-207">-or-</span></span><br /><br /> <span data-ttu-id="20716-208">型引数リスト内で、アセンブリ修飾型を囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="20716-209">たとえば、クラスのアセンブリ修飾名は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="20716-210">名前空間にプラス記号 (TopNamespace. Sub + Namespace など) が含まれている場合、プラス記号 (+) の前にエスケープ文字 (\\) があるため、入れ子の区切り記号として解釈されません。</span><span class="sxs-lookup"><span data-stu-id="20716-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="20716-211">リフレクションは、この文字列を次のように出力します。</span><span class="sxs-lookup"><span data-stu-id="20716-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="20716-212">"+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。</span><span class="sxs-lookup"><span data-stu-id="20716-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="20716-213">この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="20716-214"><xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="20716-215">型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="20716-216">アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。</span><span class="sxs-lookup"><span data-stu-id="20716-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="20716-217">型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="20716-218">末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。</span><span class="sxs-lookup"><span data-stu-id="20716-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="20716-219">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</span><span class="sxs-lookup"><span data-stu-id="20716-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="20716-220">アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="20716-221">ジェネリック型のジェネリック引数自体は、アセンブリ名によって修飾されます。</span><span class="sxs-lookup"><span data-stu-id="20716-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="20716-222">たとえば、`MyGenericClass<int>` (Visual Basic の`MyGenericClass(Of Integer)`) のアセンブリ修飾型名では、`int` が <xref:System.Int32>のアセンブリ修飾型名に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="20716-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="20716-223">現在の <xref:System.Type> オブジェクトがジェネリックパラメーターを表している場合、このプロパティは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-224">次の例では、クラスに関連付けられているアセンブリ名と、その型の完全修飾名を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="20716-225">次の例では、<xref:System.Type.ToString%2A> メソッドによって返される文字列と、<xref:System.Type.Name%2A>、<xref:System.Type.FullName%2A>、および `AssemblyQualifiedName` プロパティを比較します。</span><span class="sxs-lookup"><span data-stu-id="20716-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the <xref:System.Type.Name%2A>, <xref:System.Type.FullName%2A>, and `AssemblyQualifiedName` properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-226">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-226">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-227"><see cref="T:System.Type" /> に関連付けられている属性を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-227">Gets the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="20716-228"><see cref="T:System.Reflection.TypeAttributes" /> の属性セットを表す <see cref="T:System.Type" /> オブジェクト。ただし、<see cref="T:System.Type" /> がジェネリック型パラメーターを表す場合、値は未指定。</span><span class="sxs-lookup"><span data-stu-id="20716-228">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-229"><xref:System.Reflection.TypeAttributes> 列挙体の一部のメンバーは、値のグループを表すマスクです。</span><span class="sxs-lookup"><span data-stu-id="20716-229">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="20716-230">各グループには、基になる値が0である1つのメンバーが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-230">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="20716-231">たとえば、<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> グループの <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> メンバーの基になる値は、<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> グループの <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> メンバーと同様に0になります。</span><span class="sxs-lookup"><span data-stu-id="20716-231">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="20716-232">このため、これらの値をテストする前にマスクを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-232">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="20716-233">具体的な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="20716-233">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="20716-234">ほとんどの場合、<xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>、<xref:System.Type.IsSpecialName%2A> などのプロパティは、型属性よりも簡単に使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-234">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="20716-235">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティはジェネリック型定義の属性を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-235">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="20716-236">たとえば、`MyGenericClass<int>` (Visual Basic の`MyGenericClass(Of Integer)`) に対して返される属性は `MyGenericClass<T>` (`MyGenericClass(Of T)` では Visual Basic) の属性です。</span><span class="sxs-lookup"><span data-stu-id="20716-236">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="20716-237">現在の <xref:System.Type> がジェネリック型パラメーターを表している場合 (つまり、<xref:System.Type.IsGenericParameter%2A> プロパティが `true` を返した場合、このプロパティによって返される <xref:System.Reflection.TypeAttributes> 値は指定されていません。</span><span class="sxs-lookup"><span data-stu-id="20716-237">If the current <xref:System.Type> represents a generic type parameter - that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` - the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-238">次の例では、<xref:System.Type.Attributes%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-238">The following example uses the <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-239">現在の <see cref="T:System.Type" /> の直接の継承元である型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-239">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span></span></summary>
        <value><span data-ttu-id="20716-240">現在の <see cref="T:System.Type" /> の直接の継承元の <see cref="T:System.Type" />。現在の <see langword="null" /> が <see langword="Type" /> クラスまたはインターフェイスを表す場合は <see cref="T:System.Object" />。</span><span class="sxs-lookup"><span data-stu-id="20716-240">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-241">基本型は、現在の型が直接継承する型です。</span><span class="sxs-lookup"><span data-stu-id="20716-241">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="20716-242"><xref:System.Object> が基本型を持たない唯一の型であるため、`null` は <xref:System.Object>の基本型として返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-242"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="20716-243">インターフェイスは、0個以上の基本インターフェイスから継承します。したがって、`Type` オブジェクトがインターフェイスを表す場合、このプロパティは `null` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-243">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="20716-244">基本インターフェイスは <xref:System.Type.GetInterfaces%2A> または <xref:System.Type.FindInterfaces%2A>で決定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-244">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="20716-245">現在の <xref:System.Type> が構築されたジェネリック型を表している場合、基本型はジェネリック引数を反映します。</span><span class="sxs-lookup"><span data-stu-id="20716-245">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="20716-246">たとえば、次のような宣言があるとします。</span><span class="sxs-lookup"><span data-stu-id="20716-246">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="20716-247">構築された型 `C<int>` (Visual Basic で`C(Of Integer)`) の場合、<xref:System.Type.BaseType%2A> プロパティは `B<int>`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-247">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="20716-248">現在の <xref:System.Type> がジェネリック型定義の型パラメーターを表している場合、<xref:System.Type.BaseType%2A> は、クラスの制約、つまり、型パラメーターが継承する必要があるクラスを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-248">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="20716-249">クラスの制約がない場合、<xref:System.Type.BaseType%2A> は <xref:System.Object?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-249">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="20716-250">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-250">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-251">次の例では、<xref:System.Type.BaseType%2A> プロパティの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-251">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="20716-252">次の例では、再帰を使用して、アセンブリ内で見つかった各クラスの完全な継承階層を一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-252">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="20716-253">この例では、`B`という名前のクラスから派生する `C` という名前のクラスを定義しています。これは、`A`という名前のクラスから派生します。</span><span class="sxs-lookup"><span data-stu-id="20716-253">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-254">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-254">Reflection and Generic Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-255">現在の <see cref="T:System.Type" /> オブジェクトが特定の型で置き換えられていない型パラメーターを持っているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-255">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span></span></summary>
        <value><span data-ttu-id="20716-256"><see langword="true" /> オブジェクト自体がジェネリック型パラメーターであるか、特定の型が指定されていない型パラメーターを持っている場合は <see cref="T:System.Type" />。そうでない場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-256"><see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-257">型のインスタンスを作成するには、型自体の型引数、外側のジェネリック型、または型の任意の要素で、ジェネリック型定義またはオープン構築型が存在しない必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-257">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="20716-258">これを示すもう1つの方法は、再帰的に検査するときに、型にジェネリック型パラメーターが含まれていなければならないということです。</span><span class="sxs-lookup"><span data-stu-id="20716-258">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="20716-259">型は任意に複雑になる可能性があるため、この決定を行うことは困難です。</span><span class="sxs-lookup"><span data-stu-id="20716-259">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="20716-260">利便性を高めると共に、エラーの可能性を減らすために、<xref:System.Type.ContainsGenericParameters%2A> プロパティは、インスタンス化できる閉じた構築型と、作成できないオープン構築型を区別するための標準的な方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="20716-260">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="20716-261"><xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`を返す場合、型をインスタンス化することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-261">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="20716-262"><xref:System.Type.ContainsGenericParameters%2A> プロパティは、型パラメーターを再帰的に検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-262">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="20716-263">たとえば、配列自体がジェネリックではない場合でも、要素が型 `A<T>` (Visual Basic では`A(Of T)`) である配列の `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-263">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="20716-264">これは、<xref:System.Type.IsGenericType%2A> プロパティの動作と比較して、配列の `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-264">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="20716-265">一連のクラスの例と、<xref:System.Type.ContainsGenericParameters%2A> プロパティの値を示す表については、「<xref:System.Type.IsGenericType%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-265">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-266">次の例では、2つの型パラメーターを持つジェネリッククラスを定義し、最初のクラスから派生する2番目のジェネリッククラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="20716-266">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="20716-267">派生クラスの基底クラスには、2つの型引数があります。1つ目は <xref:System.Int32>、2つ目は派生型の型パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="20716-267">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="20716-268">この例では、<xref:System.Type.GenericParameterPosition%2A> プロパティによって報告された位置を含む、これらのジェネリッククラスに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-268">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-269">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-269">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-270">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-270">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-271">現在の <see cref="T:System.Reflection.MethodBase" /> がジェネリック メソッドの型パラメーターを表している場合に、宣言するメソッドを表す <see cref="T:System.Type" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-271">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span></span></summary>
        <value><span data-ttu-id="20716-272">現在の <see cref="T:System.Type" /> がジェネリック メソッドの型パラメーターを表している場合は、宣言メソッドを表す <see cref="T:System.Reflection.MethodBase" />。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-272">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-273">宣言するメソッドは、ジェネリックメソッドの定義です。</span><span class="sxs-lookup"><span data-stu-id="20716-273">The declaring method is a generic method definition.</span></span> <span data-ttu-id="20716-274">つまり、<xref:System.Type.DeclaringMethod%2A> が `null`を返さない場合、`DeclaringMethod.IsGenericMethodDefinition` は `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-274">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="20716-275"><xref:System.Type.DeclaringType%2A> と <xref:System.Type.DeclaringMethod%2A> のプロパティは、ジェネリック型の定義またはジェネリック型パラメーターが最初に定義されたジェネリックメソッド定義を識別します。</span><span class="sxs-lookup"><span data-stu-id="20716-275">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="20716-276"><xref:System.Type.DeclaringMethod%2A> プロパティが <xref:System.Reflection.MethodInfo>を返した場合、その <xref:System.Reflection.MethodInfo> はジェネリックメソッド定義を表し、現在の <xref:System.Type> オブジェクトはそのジェネリックメソッド定義の型パラメーターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-276">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="20716-277"><xref:System.Type.DeclaringMethod%2A> プロパティが `null`を返す場合、<xref:System.Type.DeclaringType%2A> プロパティは常にジェネリック型定義を表す <xref:System.Type> オブジェクトを返し、現在の <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-277">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="20716-278"><xref:System.Type.IsGenericParameter%2A> プロパティが `false` 型の <xref:System.Type.DeclaringMethod%2A> プロパティを取得すると、<xref:System.InvalidOperationException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-278">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="20716-279"><xref:System.Type.DeclaringMethod%2A> プロパティによって返される <xref:System.Reflection.MethodBase> は、ジェネリックメソッドの場合は <xref:System.Reflection.MethodInfo>、ジェネリックコンストラクターの場合は <xref:System.Reflection.ConstructorInfo> になります。</span><span class="sxs-lookup"><span data-stu-id="20716-279">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-280">.NET Framework バージョン2.0 では、ジェネリックコンストラクターはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-280">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="20716-281">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-281">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-282">次のコード例では、ジェネリックメソッドを持つクラスを定義し、そのメソッドに型引数を割り当てて、構築されたジェネリックメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-282">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="20716-283">また、ジェネリックメソッドの定義と構築されたメソッドについての情報も表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-283">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="20716-284">ジェネリックメソッド定義の型パラメーターについての情報を表示するときに、`DisplayGenericMethodInfo` メソッドのコード例では、メソッドのジェネリック型パラメーターの <xref:System.Type.DeclaringMethod%2A> プロパティの値を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-284">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-285">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-285">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-286">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-286">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public abstract Type DeclaringType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DeclaringType As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-287">現在の入れ子にされた型またはジェネリック型パラメーターを宣言する型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-287">Gets the type that declares the current nested type or generic type parameter.</span></span></summary>
        <value><span data-ttu-id="20716-288">現在の型が入れ子にされた型である場合、包含する型を表す <see cref="T:System.Type" /> オブジェクト。現在の型がジェネリック型の型パラメーターである場合、ジェネリック型定義。現在の型がジェネリック メソッドの型パラメーターである場合、ジェネリック メソッドを宣言する型。それ以外の場合、<see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-288">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-289">現在の <xref:System.Type> オブジェクトがジェネリック型の型パラメーターを表している場合、このプロパティはジェネリック型定義を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-289">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="20716-290">現在の <xref:System.Type> オブジェクトがジェネリックメソッドの型パラメーターを表している場合、このプロパティは、ジェネリックメソッド定義を含む型を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-290">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="20716-291">型がジェネリックの場合は、ジェネリック型の定義が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-291">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="20716-292">つまり、次のコードは、<xref:System.Collections.Generic.List%601.ConvertAll%2A> ジェネリックメソッドを含む <xref:System.Collections.Generic.List%601> ジェネリッククラスのジェネリック型定義を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-292">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="20716-293">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、<xref:System.Type.DeclaringType%2A> プロパティと <xref:System.Type.DeclaringMethod%2A> プロパティは、ジェネリック型パラメーターが最初に定義されたジェネリック型定義またはジェネリックメソッド定義を識別します。</span><span class="sxs-lookup"><span data-stu-id="20716-293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="20716-294"><xref:System.Type.DeclaringMethod%2A> プロパティが <xref:System.Reflection.MethodInfo>を返した場合、その <xref:System.Reflection.MethodInfo> はジェネリックメソッド定義を表し、現在の <xref:System.Type> オブジェクトはそのジェネリックメソッド定義の型パラメーターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-294">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="20716-295"><xref:System.Type.DeclaringMethod%2A> プロパティが `null`を返す場合、<xref:System.Type.DeclaringType%2A> プロパティは常にジェネリック型定義を表す <xref:System.Type> オブジェクトを返し、現在の <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-295">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="20716-296"><xref:System.Type.IsGenericParameter%2A> プロパティが `false` 型の <xref:System.Type.DeclaringType%2A> プロパティを取得すると、<xref:System.InvalidOperationException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-296">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-297">この例では、派生クラスのメソッドの宣言型を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-297">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-298">既定のバインダーへの参照を取得します。このバインダーは、<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> によって呼び出される適切なメンバーを選択するための内部規則を実装します。</span><span class="sxs-lookup"><span data-stu-id="20716-298">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span></summary>
        <value><span data-ttu-id="20716-299">システムで使用される既定のバインダーへの参照。</span><span class="sxs-lookup"><span data-stu-id="20716-299">A reference to the default binder used by the system.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-300">共通言語ランタイムに用意されている既定のバインダーは、特に特殊化されたすべての状況で適用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-300">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="20716-301">指定された既定のバインダーとは異なる規則に従うバインダーが必要な場合は、<xref:System.Reflection.Binder> クラスから派生した型を定義し、<xref:System.Type.InvokeMember%2A> オーバーロードのいずれかの `binder` パラメーターを使用して、その型のインスタンスを渡します。</span><span class="sxs-lookup"><span data-stu-id="20716-301">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="20716-302">リフレクションは、共通型システムのアクセシビリティ規則をモデル化します。</span><span class="sxs-lookup"><span data-stu-id="20716-302">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="20716-303">たとえば、呼び出し元が同じアセンブリ内にある場合、呼び出し元は内部メンバーに対して特別なアクセス許可を必要としません。</span><span class="sxs-lookup"><span data-stu-id="20716-303">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="20716-304">それ以外の場合は、呼び出し元に <xref:System.Security.Permissions.ReflectionPermission>が必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-304">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="20716-305">これは、protected、private などのメンバーの参照と一致します。</span><span class="sxs-lookup"><span data-stu-id="20716-305">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="20716-306">一般的な原則として、<xref:System.Reflection.Binder.ChangeType%2A> は、データを失うことのない拡大変換のみを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-306">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="20716-307">拡大変換の例として、32ビット符号付き整数の値を64ビット符号付き整数値に変換する場合が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="20716-307">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="20716-308">これは縮小変換と区別されるため、データが失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-308">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="20716-309">縮小変換の例としては、64ビット符号付き整数を32ビット符号付き整数に変換することが挙げられます。</span><span class="sxs-lookup"><span data-stu-id="20716-309">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="20716-310">次の表に、既定のバインダーでサポートされている変換の一覧を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-310">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="20716-311">ソースの種類</span><span class="sxs-lookup"><span data-stu-id="20716-311">Source Type</span></span>|<span data-ttu-id="20716-312">ターゲットの種類</span><span class="sxs-lookup"><span data-stu-id="20716-312">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="20716-313">任意の型</span><span class="sxs-lookup"><span data-stu-id="20716-313">Any type</span></span>|<span data-ttu-id="20716-314">その基本型。</span><span class="sxs-lookup"><span data-stu-id="20716-314">Its base type.</span></span>|  
|<span data-ttu-id="20716-315">任意の型</span><span class="sxs-lookup"><span data-stu-id="20716-315">Any type</span></span>|<span data-ttu-id="20716-316">実装するインターフェイス。</span><span class="sxs-lookup"><span data-stu-id="20716-316">The interface it implements.</span></span>|  
|<span data-ttu-id="20716-317">Char</span><span class="sxs-lookup"><span data-stu-id="20716-317">Char</span></span>|<span data-ttu-id="20716-318">Unt16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="20716-319">Byte</span><span class="sxs-lookup"><span data-stu-id="20716-319">Byte</span></span>|<span data-ttu-id="20716-320">Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="20716-321">SByte</span><span class="sxs-lookup"><span data-stu-id="20716-321">SByte</span></span>|<span data-ttu-id="20716-322">Int16、Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-322">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="20716-323">UInt16</span><span class="sxs-lookup"><span data-stu-id="20716-323">UInt16</span></span>|<span data-ttu-id="20716-324">UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-324">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="20716-325">Int16</span><span class="sxs-lookup"><span data-stu-id="20716-325">Int16</span></span>|<span data-ttu-id="20716-326">Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-326">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="20716-327">UInt32</span><span class="sxs-lookup"><span data-stu-id="20716-327">UInt32</span></span>|<span data-ttu-id="20716-328">UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-328">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="20716-329">Int32</span><span class="sxs-lookup"><span data-stu-id="20716-329">Int32</span></span>|<span data-ttu-id="20716-330">Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-330">Int64, Single, Double</span></span>|  
|<span data-ttu-id="20716-331">UInt64</span><span class="sxs-lookup"><span data-stu-id="20716-331">UInt64</span></span>|<span data-ttu-id="20716-332">Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-332">Single, Double</span></span>|  
|<span data-ttu-id="20716-333">Int64</span><span class="sxs-lookup"><span data-stu-id="20716-333">Int64</span></span>|<span data-ttu-id="20716-334">Single、Double</span><span class="sxs-lookup"><span data-stu-id="20716-334">Single, Double</span></span>|  
|<span data-ttu-id="20716-335">Single</span><span class="sxs-lookup"><span data-stu-id="20716-335">Single</span></span>|<span data-ttu-id="20716-336">Double</span><span class="sxs-lookup"><span data-stu-id="20716-336">Double</span></span>|  
|<span data-ttu-id="20716-337">非参照</span><span class="sxs-lookup"><span data-stu-id="20716-337">Non-reference</span></span>|<span data-ttu-id="20716-338">参照渡し。</span><span class="sxs-lookup"><span data-stu-id="20716-338">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="20716-339">次の例では、`DefaultBinder` プロパティから既定のバインダーを取得し、`DefaultBinder` 値をパラメーターとして <xref:System.Type.InvokeMember%2A>に渡すことによって、MyClass のメンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-339">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-340"><see cref="T:System.Type" /> の名前空間で、複数の名前を区切ります。</span><span class="sxs-lookup"><span data-stu-id="20716-340">Separates names in the namespace of the <see cref="T:System.Type" />.</span></span> <span data-ttu-id="20716-341">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-341">This field is read-only.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-342"><see cref="T:System.Type" /> 型の空の配列を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-342">Represents an empty array of type <see cref="T:System.Type" />.</span></span> <span data-ttu-id="20716-343">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-343">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="20716-344">次のコード例は、パラメーターをとらないコンストラクターを取得するために、いずれかの `GetConstructor` メソッドで使用される `EmptyTypes` フィールドを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-344">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-345">現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Object" /> または <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-345">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="20716-346">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-346">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span> <span data-ttu-id="20716-347">比較を成功させるには、<paramref name="o" /> をキャストまたは型 <see cref="T:System.Type" /> のオブジェクトに変換できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-347">For the comparison to succeed, <paramref name="o" /> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="20716-348">現在の <see cref="T:System.Type" /> オブジェクトの基になるシステム型が、指定した <see cref="T:System.Object" /> の基になるシステム型と同じかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-348">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="20716-349"><paramref name="o" /> の基になるシステム型が現在の <see cref="T:System.Type" /> の基になるシステム型と同じである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-349"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="20716-350">次の場合にも、このメソッドは <see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-350">This method also returns <see langword="false" /> if:</span></span> <span data-ttu-id="20716-351">
-   <paramref name="o" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-351">
-   <paramref name="o" /> is <see langword="null" />.</span></span>  
  <span data-ttu-id="20716-352">
-   <paramref name="o" /> をキャストまたは <see cref="T:System.Type" /> オブジェクトに変換できない。</span><span class="sxs-lookup"><span data-stu-id="20716-352">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-353">このメソッドは、<xref:System.Object.Equals%2A?displayProperty=nameWithType> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="20716-353">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20716-354">`o` を <xref:System.Type> 型のオブジェクトにキャストし、<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-354">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-355">次の例では、<xref:System.Type.Equals%28System.Object%29> を使用して、さまざまな <xref:System.Type> オブジェクトインスタンスをさまざまな <xref:System.Object> インスタンスと比較します。</span><span class="sxs-lookup"><span data-stu-id="20716-355">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="20716-356">この例については、特に注意すべき点が2つあります。</span><span class="sxs-lookup"><span data-stu-id="20716-356">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="20716-357"><xref:System.Reflection.TypeInfo> が <xref:System.Type>から派生しているため `true` 整数を表す <xref:System.Reflection.TypeInfo> オブジェクトを持つ整数を表す <xref:System.Type> オブジェクトの比較。</span><span class="sxs-lookup"><span data-stu-id="20716-357">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="20716-358">`List(Of String)` オブジェクト (クローズジェネリック型) を使用して <xref:System.Collections.Generic.IList%601> オブジェクト (オープンジェネリック型) を表す <xref:System.Type> オブジェクトを比較すると、`false`が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-358">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Type o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (o As Type) As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(Type ^ o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="20716-359">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-359">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="20716-360">現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-360">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-361"><paramref name="o" /> の基になるシステム型が現在の <see cref="T:System.Type" /> の基になるシステム型と同じである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-361"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="20716-362">次の例では、`Equals` を使用して2つの型を比較します。</span><span class="sxs-lookup"><span data-stu-id="20716-362">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-363">属性に適用するメンバー フィルターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-363">Represents the member filter used on attributes.</span></span> <span data-ttu-id="20716-364">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-364">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-365">このフィールドは、<xref:System.Type.FindMembers%2A> メソッドによって使用されるデリゲートへの参照を保持します。</span><span class="sxs-lookup"><span data-stu-id="20716-365">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="20716-366">このデリゲートによってカプセル化されるメソッドは、2つのパラメーターを受け取ります。最初のパラメーターは <xref:System.Reflection.MemberInfo> オブジェクトで、2番目のパラメーターは `Object`です。</span><span class="sxs-lookup"><span data-stu-id="20716-366">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="20716-367">メソッドは、`MemberInfo` オブジェクトが `Object`によって指定された条件と一致するかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-367">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="20716-368">`Object` には、クラス <xref:System.Reflection.FieldAttributes>、<xref:System.Reflection.MethodAttributes>、または <xref:System.Reflection.MethodImplAttributes>のいずれかのフィールドの値が割り当てられる場合があります。</span><span class="sxs-lookup"><span data-stu-id="20716-368">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="20716-369">たとえば、`Object` には、`FieldAttributes` のフィールドの値 (Public など) を割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-369">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="20716-370">この場合、`FilterAttribute` デリゲートが呼び出されると、`MemberInfo` オブジェクトによって表されるメソッドがメタデータのパブリックフィールド属性で修飾されている場合にのみ、`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-370">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-371">次の例では、`FilterAttribute` デリゲートを取得し、それをパラメーターとして <xref:System.Type.FindMembers%2A> メソッドに渡して、指定されたメンバーとその属性を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-371">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-372">名前に適用され、大文字と小文字を区別するメンバー フィルターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-372">Represents the case-sensitive member filter used on names.</span></span> <span data-ttu-id="20716-373">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-373">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-374">このフィールドは、<xref:System.Type.FindMembers%2A> メソッドによって使用されるデリゲートへの参照を保持します。</span><span class="sxs-lookup"><span data-stu-id="20716-374">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="20716-375">このデリゲートによってカプセル化されるメソッドは、2つのパラメーターを受け取ります。最初のパラメーターは <xref:System.Reflection.MemberInfo> オブジェクトで、2番目のパラメーターは `Object`です。</span><span class="sxs-lookup"><span data-stu-id="20716-375">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="20716-376">メソッドは、`MemberInfo` オブジェクトが `Object`によって指定された条件と一致するかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-376">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="20716-377">`Object` には文字列値が割り当てられます。文字列値には、末尾に "\*" というワイルドカード文字を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-377">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="20716-378">ワイルドカードの終了文字列の照合のみがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="20716-378">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="20716-379">たとえば、`Object` に値 "Byte \*" が割り当てられている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-379">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="20716-380">この場合、`FilterName` デリゲートが呼び出されると、`MemberInfo` オブジェクトによって表されるメソッドの名前が "Byte" で始まる場合にのみ、`true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-380">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-381">次のコード例では、ユーザー定義 `Application` 型に関連付けられているメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-381">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-382">名前に適用され、大文字と小文字を区別しないメンバー フィルターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-382">Represents the case-insensitive member filter used on names.</span></span> <span data-ttu-id="20716-383">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-383">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-384">このフィールドは、<xref:System.Type.FindMembers%2A> メソッドによって使用されるデリゲートへの参照を保持します。</span><span class="sxs-lookup"><span data-stu-id="20716-384">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="20716-385">このデリゲートによってカプセル化されるメソッドは、2つのパラメーターを受け取ります。最初のパラメーターは <xref:System.Reflection.MemberInfo> オブジェクトで、2番目のパラメーターは `Object`です。</span><span class="sxs-lookup"><span data-stu-id="20716-385">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="20716-386">メソッドは、`MemberInfo` オブジェクトが `Object`によって指定された条件と一致するかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-386">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="20716-387">`Object` には文字列値が割り当てられます。文字列値には、末尾に "\*" というワイルドカード文字を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-387">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="20716-388">ワイルドカードの終了文字列の照合のみがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="20716-388">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="20716-389">たとえば、`Object` に値 "ByTe \*" が割り当てられている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-389">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="20716-390">この場合、`FilterName` デリゲートが呼び出されると、`MemberInfo` オブジェクトによって表されるメソッドの名前が "byte" で始まり、大文字小文字が無視される場合にのみ、true が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-390">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-391">次の例では、`MemberFilter` デリゲートを取得し、それをパラメーターとして <xref:System.Type.FindMembers%2A> メソッドに渡し、文字 "c" で始まる `String` クラスのメソッドとその属性を表示します。大文字と小文字は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-391">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="20716-392">インターフェイスを <paramref name="filterCriteria" /> と比較するデリゲート。</span><span class="sxs-lookup"><span data-stu-id="20716-392">The delegate that compares the interfaces against <paramref name="filterCriteria" />.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="20716-393">返される配列に、検出したインターフェイスを含めるかどうかを判断する検索条件。</span><span class="sxs-lookup"><span data-stu-id="20716-393">The search criteria that determines whether an interface should be included in the returned array.</span></span></param>
        <summary><span data-ttu-id="20716-394">現在の <see cref="T:System.Type" /> によって実装または継承されているインターフェイスのフィルター適用済みリストを表す、<see cref="T:System.Type" /> オブジェクトの配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-394">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-395">現在の <see cref="T:System.Type" /> によって実装または継承されたインターフェイスのフィルター処理されたリストを表している <see cref="T:System.Type" /> オブジェクトの配列。または、フィルターに一致するインターフェイスが現在の <see cref="T:System.Type" /> によって実装または継承されていない場合は、空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-395">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-396">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-396">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="20716-397"><xref:System.Reflection.Module?displayProperty=nameWithType> クラスによって提供される <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> および <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> デリゲートは、<xref:System.Reflection.TypeFilter?displayProperty=nameWithType> デリゲートの代わりに使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-397">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="20716-398">このクラスによって実装されるすべてのインターフェイスは、基本クラスまたはこのクラス自体によって宣言されているかどうかにかかわらず、検索時に考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-398">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="20716-399">このメソッドは、基底クラスの階層を検索し、各クラスが実装する各インターフェイスと、それらの各インターフェイスが実装するすべての一致するインターフェイスを返します (つまり、一致するインターフェイスの推移的なクロージャが返されます)。</span><span class="sxs-lookup"><span data-stu-id="20716-399">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="20716-400">重複するインターフェイスは返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-400">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="20716-401">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、<xref:System.Type.FindInterfaces%2A> は、型パラメーターの制約で宣言されているすべてのインターフェイスと、制約で宣言されたインターフェイスを介して継承されたすべてのインターフェイスを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-401">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="20716-402">現在の <xref:System.Type> がジェネリック型の型引数を表している場合、<xref:System.Type.FindInterfaces%2A> は、制約に一致するかどうかにかかわらず、型によって実装されているすべてのインターフェイスを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-402">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-403">ジェネリックではない型でも、<xref:System.Type.FindInterfaces%2A> はジェネリックインターフェイスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-403"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="20716-404">たとえば、非ジェネリック型は `IEnumerable<int>` (`IEnumerable(Of Integer)` Visual Basic) を実装する場合があります。</span><span class="sxs-lookup"><span data-stu-id="20716-404">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-405">次の例では、指定した型によって実装または継承された指定のインターフェイスを検索し、インターフェイス名を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-405">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-406"><paramref name="filter" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-406"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-407">静的初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-407">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="memberType"><span data-ttu-id="20716-408">検索するメンバー型を示す、列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-408">A bitwise combination of the enumeration values that indicates the type of member to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-409">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-409">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-410">または</span><span class="sxs-lookup"><span data-stu-id="20716-410">-or-</span></span> 
 <span data-ttu-id="20716-411"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-411"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="filter"><span data-ttu-id="20716-412">比較を実行して、現在調べているメンバーが <see langword="true" /> に一致する場合は <paramref name="filterCriteria" /> を返し、それ以外の場合は <see langword="false" /> を返すデリゲート。</span><span class="sxs-lookup"><span data-stu-id="20716-412">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <paramref name="filterCriteria" /> and <see langword="false" /> otherwise.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="20716-413"><see langword="MemberInfo" /> オブジェクトの配列でメンバーが返されたかどうかを判断する検索条件。</span><span class="sxs-lookup"><span data-stu-id="20716-413">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span></span>  
  
<span data-ttu-id="20716-414"><see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドは、このクラスで提供される <see langword="FilterAttribute" /> デリゲートと組み合わせて使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-414">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span></span></param>
        <summary><span data-ttu-id="20716-415">指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列にフィルターを適用して返します。</span><span class="sxs-lookup"><span data-stu-id="20716-415">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span></summary>
        <returns><span data-ttu-id="20716-416">指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトのフィルター適用済みの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-416">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span>  
  
<span data-ttu-id="20716-417">または</span><span class="sxs-lookup"><span data-stu-id="20716-417">-or-</span></span> 
<span data-ttu-id="20716-418">現在の <see cref="T:System.Type" /> に、フィルター条件に一致する <paramref name="memberType" /> 型のメンバーが存在しない場合は、空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-418">An empty array if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="20716-419">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-419">This method can be overridden by a derived class.</span></span>  
  
<span data-ttu-id="20716-420">メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-420">Members include properties, methods, fields, events, and so on.</span></span>  

<span data-ttu-id="20716-421">`FindMembers` メソッドでメンバー情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、および少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-421">For the `FindMembers` method to successfully retrieve member information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

 <span data-ttu-id="20716-422">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-422">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-423">インスタンスメンバーを検索に含めるには、`BindingFlags.Instance` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-423">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="20716-424">`BindingFlags.Static` を指定して、検索に静的メンバーを含めます。</span><span class="sxs-lookup"><span data-stu-id="20716-424">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="20716-425">パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-425">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="20716-426">検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-426">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="20716-427">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-427">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-428">単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-428">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-429">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="20716-430">このメソッドを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-430">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-431"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-431">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
<span data-ttu-id="20716-432">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの型パラメーターを表している場合、は、クラス制約および型パラメーターのインターフェイス制約によって宣言されたすべてのメンバーを処理 <xref:System.Type.FindMembers%2A> ます。</span><span class="sxs-lookup"><span data-stu-id="20716-432">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  

<span data-ttu-id="20716-433">`filter` 引数には、<xref:System.Reflection.MemberFilter>型のカスタムデリゲートを指定することも、次の定義済みデリゲートのいずれかを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-433">The `filter` argument can be a custom delegate of type <xref:System.Reflection.MemberFilter>, or it can be one of the following  predefined delegates:</span></span>

- <span data-ttu-id="20716-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>、<xref:System.Reflection.FieldAttributes>、<xref:System.Reflection.MethodAttributes>、または <xref:System.Reflection.MethodImplAttributes> ビットマスクを `filterCriteria` 値として使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>, which uses a<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes> bitmask as the `filterCriteria` value.</span></span>

- <span data-ttu-id="20716-435"><xref:System.Type.FilterName?displayProperty=nameWithType>、`filterCriteria`に渡された文字列を使用して、各メンバー名の大文字と小文字を区別した比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="20716-435"><xref:System.Type.FilterName?displayProperty=nameWithType>, which performs a case-sensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

- <span data-ttu-id="20716-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>、`filterCriteria`に渡された文字列を使用して、各メンバー名の大文字と小文字を区別しない比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="20716-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, which performs a case-insensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

## Examples  
 <span data-ttu-id="20716-437">次の例では、指定した検索条件に一致するクラスのすべてのメンバーを検索し、一致したメンバーを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-437">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-438"><paramref name="filter" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-438"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-439">型の完全修飾名を取得します。その名前空間を含みますが、アセンブリは含みません。</span><span class="sxs-lookup"><span data-stu-id="20716-439">Gets the fully qualified name of the type, including its namespace but not its assembly.</span></span></summary>
        <value><span data-ttu-id="20716-440">型の完全修飾名で、名前空間を含むが、アセンブリは含まないもの。現在のインスタンスが、ジェネリック型パラメーター、配列型、ポインター型、または型パラメーターに基づく<see langword="null" /> 型、またはジェネリック型定義ではないが未解決の型パラメーターを含むジェネリック型を表す場合は、<see langword="byref" />。</span><span class="sxs-lookup"><span data-stu-id="20716-440">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-441">たとえば、<xref:System.String> の種類の完全修飾名は `System.String`です。</span><span class="sxs-lookup"><span data-stu-id="20716-441">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="20716-442">これは、完全な名前と完全なアセンブリ名で構成される、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返されるアセンブリ修飾名と比較します。</span><span class="sxs-lookup"><span data-stu-id="20716-442">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="20716-443">現在の型がクローズジェネリック型を表している場合、ジェネリック型自体の文字列表現が完全なアセンブリ名で修飾されていなくても、<xref:System.Type.FullName%2A> プロパティによって返される文字列の型引数は完全なアセンブリ名で修飾されます。</span><span class="sxs-lookup"><span data-stu-id="20716-443">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="20716-444">次の例は、ジェネリック型定義を表す型の FullName プロパティと、クローズジェネリック型を表す型の違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-444">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="20716-445">このプロパティは、次の場合に `null` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-445">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="20716-446">現在の <xref:System.Type> オブジェクトは、ジェネリック型の型パラメーターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-446">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="20716-447">次の例では、<xref:System.Nullable%601> 型の型パラメーターを取得し、その <xref:System.Type.FullName%2A> プロパティを表示しようとしています。</span><span class="sxs-lookup"><span data-stu-id="20716-447">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="20716-448">現在の <xref:System.Type> オブジェクトは、ジェネリック型パラメーターに基づく配列型、ポインター型、または `byref` 型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-448">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="20716-449">次の例では、型 T の配列に渡される3つの `Display(T[])`メソッドを使用して、`Generictype1<T>`のジェネリック型を定義しています。`HandleT(T)`、 T オブジェクトが渡されます。および `ChangeValue(ref T)`。参照渡しで T オブジェクトを渡します。</span><span class="sxs-lookup"><span data-stu-id="20716-449">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="20716-450">とC# Visual Basic では、`HandleT` メソッドのポインターとして T を定義することはできないため、ジェネリック型へのポインターを作成するには、メソッドのパラメーター型を表す <xref:System.Type> オブジェクトで <xref:System.Type.MakePointerType%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-450">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="20716-451">この例の出力は、3つのすべてのケースで、<xref:System.Type.FullName%2A> プロパティが `null`であることを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-451">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="20716-452">現在の型には、特定の型で置き換えられていないジェネリック型パラメーターが含まれています (つまり、<xref:System.Type.ContainsGenericParameters%2A> プロパティは `true`を返します) が、型はジェネリック型定義ではありません (つまり、<xref:System.Type.IsGenericTypeDefinition%2A> プロパティはを返し `false`</span><span class="sxs-lookup"><span data-stu-id="20716-452">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="20716-453">次の例では、`Derived<T>` が `Base<T>`から継承されます。</span><span class="sxs-lookup"><span data-stu-id="20716-453">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="20716-454"><xref:System.Type.BaseType%2A> プロパティは `Derived<T>`の基本型を表す <xref:System.Type> オブジェクトを取得し、その <xref:System.Type.FullName%2A> プロパティは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-454">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="20716-455">`null`ない <xref:System.Type.FullName%2A> を取得するには、例に示すように、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドを使用してジェネリック型定義を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-455">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="20716-456">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-456">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-457">次の例では、指定された型の完全な名前を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-457">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="20716-458">次の例では、<xref:System.Type.ToString%2A> メソッドによって返される文字列と、<xref:System.Type.Name%2A>、`FullName`、および <xref:System.Type.AssemblyQualifiedName%2A> プロパティを比較します。</span><span class="sxs-lookup"><span data-stu-id="20716-458">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the <xref:System.Type.Name%2A>, `FullName`, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-459">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-459">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-460">現在のジェネリック型パラメーターの共変性および特殊な制約を説明する <see cref="T:System.Reflection.GenericParameterAttributes" /> フラグの組み合わせを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-460">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="20716-461">現在のジェネリック型パラメーターの共変性と特殊な制約を表す <see cref="T:System.Reflection.GenericParameterAttributes" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-461">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-462">このプロパティの値には、現在のジェネリック型パラメーターが共変であるかどうかを示すフラグと、特殊な制約を示すフラグが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-462">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="20716-463"><xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> 値を使用して共変性フラグを選択し、<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> 値を使用して制約フラグを選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-463">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="20716-464">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-464">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-465">次のコード例では、異なる制約を持つ2つの型パラメーターを持つジェネリック型 `Test` を定義しています。</span><span class="sxs-lookup"><span data-stu-id="20716-465">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="20716-466">プログラムの実行時には、<xref:System.Type.GenericParameterAttributes%2A> プロパティと <xref:System.Type.GetGenericParameterConstraints%2A> メソッドを使用して制約が検査されます。</span><span class="sxs-lookup"><span data-stu-id="20716-466">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-467">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-467">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="20716-468">つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-468">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-469">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-469">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-470">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-470">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-471">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-471">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public abstract int GenericParameterPosition { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int GenericParameterPosition { int get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-472"><see cref="T:System.Type" /> オブジェクトがジェネリック型またはジェネリック メソッドの型パラメーターを表す場合に、パラメーターを宣言したジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-472">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span></span></summary>
        <value><span data-ttu-id="20716-473">パラメーターを定義するジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置。</span><span class="sxs-lookup"><span data-stu-id="20716-473">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span></span> <span data-ttu-id="20716-474">位置の番号は 0 で始まります。</span><span class="sxs-lookup"><span data-stu-id="20716-474">Position numbers begin at 0.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-475"><xref:System.Type.GenericParameterPosition%2A> プロパティは、型パラメーターが最初に定義されたジェネリック型定義またはジェネリックメソッド定義のパラメーターリスト内の型パラメーターの位置を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-475">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="20716-476"><xref:System.Type.DeclaringType%2A> プロパティと <xref:System.Type.DeclaringMethod%2A> プロパティは、ジェネリック型またはメソッドの定義を識別します。</span><span class="sxs-lookup"><span data-stu-id="20716-476">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="20716-477"><xref:System.Type.DeclaringMethod%2A> プロパティが <xref:System.Reflection.MethodInfo>を返した場合、その <xref:System.Reflection.MethodInfo> はジェネリックメソッド定義を表し、現在の <xref:System.Type> オブジェクトはそのジェネリックメソッド定義の型パラメーターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-477">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="20716-478"><xref:System.Type.DeclaringMethod%2A> プロパティが `null`を返す場合、<xref:System.Type.DeclaringType%2A> プロパティは常にジェネリック型定義を表す <xref:System.Type> オブジェクトを返し、現在の <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。</span><span class="sxs-lookup"><span data-stu-id="20716-478">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="20716-479"><xref:System.Type.GenericParameterPosition%2A> プロパティの値に適切なコンテキストを提供するには、型パラメーターが属するジェネリック型またはメソッドを識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-479">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="20716-480">たとえば、次のコードでは、ジェネリックメソッド `GetSomething` の戻り値を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="20716-480">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="20716-481">`GetSomething` によって返される型は、クラス `A` に指定された型引数に依存し、それ自体を `GetSomething` します。</span><span class="sxs-lookup"><span data-stu-id="20716-481">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="20716-482">`GetSomething`の <xref:System.Reflection.MethodInfo> を取得できます。また、戻り値の型を取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-482">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="20716-483">戻り値の型の型パラメーターを確認すると、<xref:System.Type.GenericParameterPosition%2A> は両方に対して0を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-483">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="20716-484">`V` の位置は0です。これは `V` がクラス `A`の型パラメーターリストの最初の型パラメーターであるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-484">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="20716-485">`X` の位置は0です。これは、`X` が `GetSomething`の型パラメーターリストの最初の型パラメーターであるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-485">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-486">現在の <xref:System.Type> が型パラメーターを表していない場合、<xref:System.Type.GenericParameterPosition%2A> プロパティを呼び出すと例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="20716-486">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="20716-487">オープン構築型の型引数を調べる場合は、<xref:System.Type.IsGenericParameter%2A> プロパティを使用して、型パラメーターと型を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-487">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="20716-488"><xref:System.Type.IsGenericParameter%2A> プロパティは、型パラメーターの `true` を返します。その後、<xref:System.Type.GenericParameterPosition%2A> メソッドを使用してその位置を取得し、<xref:System.Type.DeclaringMethod%2A> プロパティと <xref:System.Type.DeclaringType%2A> プロパティを使用して、それを定義するジェネリックメソッドまたは型定義を確認できます。</span><span class="sxs-lookup"><span data-stu-id="20716-488">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-489">次の例では、2つの型パラメーターを持つジェネリッククラスを定義し、最初のクラスから派生する2番目のジェネリッククラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="20716-489">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="20716-490">派生クラスの基底クラスには、2つの型引数があります。1つ目は <xref:System.Int32>で、2つ目は派生型の型パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="20716-490">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="20716-491">この例では、<xref:System.Type.GenericParameterPosition%2A> プロパティによって報告された位置を含む、これらのジェネリッククラスに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-491">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-492">現在の型は型パラメーターを表していません。</span><span class="sxs-lookup"><span data-stu-id="20716-492">The current type does not represent a type parameter.</span></span> <span data-ttu-id="20716-493">つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-493">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-494">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-494">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-495">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-495">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public abstract Type[] GenericTypeArguments { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-496">この型のジェネリック型引数の配列を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-496">Gets an array of the generic type arguments for this type.</span></span></summary>
        <value><span data-ttu-id="20716-497">この型のジェネリック型引数の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-497">An array of the generic type arguments for this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-498">このプロパティは、ジェネリック型引数のみを取得します。これは、現在の型のジェネリック型パラメーターに対して指定された型です。</span><span class="sxs-lookup"><span data-stu-id="20716-498">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="20716-499">現在の型がジェネリック型定義の場合、このプロパティは空の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-499">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-500">ジェネリック型がジェネリックメソッドまたは別のジェネリック型で使用されている場合、そのジェネリック型引数の一部は、外側のメソッドまたは型のジェネリック型パラメーターである可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-500">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="20716-501">ジェネリック型の定義を表す型のジェネリック型パラメーターを取得するには、<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-501">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="20716-502">現在の <xref:System.Type> オブジェクトの <xref:System.Reflection.TypeInfo> オブジェクトを取得するには、<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> 拡張メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-502">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public abstract int GetArrayRank ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetArrayRank () As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetArrayRank();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-503">配列の次元数を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-503">Gets the number of dimensions in an array.</span></span></summary>
        <returns><span data-ttu-id="20716-504">現在の型の次元数である整数。</span><span class="sxs-lookup"><span data-stu-id="20716-504">An integer that contains the number of dimensions in the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="20716-505">次の例では、配列の次元数を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-505">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-506">このメソッドの機能は、基底クラスではサポートされていないため、代わりに派生クラスで実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-506">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-507">現在の型は配列ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-507">The current type is not an array.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-508">派生クラスでオーバーライドされた場合、<see cref="P:System.Type.Attributes" /> プロパティを実装し、<see cref="T:System.Type" /> に関連付けられている属性を示す列挙値のビットごとの組み合わせを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-508">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitwise combination of enumeration values that indicate the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-509"><see cref="T:System.Reflection.TypeAttributes" /> の属性のセットを表す <see cref="T:System.Type" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-509">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-510">現在の <see cref="T:System.Type" /> の特定のコンストラクターを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-510">Gets a specific constructor of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="types"><span data-ttu-id="20716-511">目的のコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span></span>  
  
<span data-ttu-id="20716-512">または</span><span class="sxs-lookup"><span data-stu-id="20716-512">-or-</span></span> 
<span data-ttu-id="20716-513">パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-513">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span></span> <span data-ttu-id="20716-514">このような空の配列は、<see langword="static" /> フィールド <see cref="F:System.Type.EmptyTypes" /> によって提供されます。</span><span class="sxs-lookup"><span data-stu-id="20716-514">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <summary><span data-ttu-id="20716-515">指定した配列の型に一致するパラメーターが設定されているパブリック インスタンス コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-515">Searches for a public instance constructor whose parameters match the types in the specified array.</span></span></summary>
        <returns><span data-ttu-id="20716-516">パラメーター型配列の型と一致するパラメーターが設定されているパブリック インスタンス コンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-516">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-517">このメソッドオーバーロードは、パブリックインスタンスコンストラクターを検索します。クラス初期化子 (静的コンストラクター) を取得するために使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-517">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (static constructor).</span></span> <span data-ttu-id="20716-518">クラス初期化子を取得するには、<xref:System.Reflection.BindingFlags>を受け取るオーバーロードを使用し&#124; 、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-518">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-519"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-519">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-520">要求されたコンストラクターがパブリックでない場合、このメソッドは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-520">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-521">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-521">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-522">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-522">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-523">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.ConstructorInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-523">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="20716-524">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは常に `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-524">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-525">次の例では、`MyClass`の型を取得し、<xref:System.Reflection.ConstructorInfo> オブジェクトを取得して、コンストラクターシグネチャを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-525">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-526"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-526"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-527">または</span><span class="sxs-lookup"><span data-stu-id="20716-527">-or-</span></span> 
<span data-ttu-id="20716-528"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-528">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-529"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-529"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (bindingAttr As BindingFlags, binder As Binder, types As Type(), modifiers As ParameterModifier()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-530">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-530">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-531">または</span><span class="sxs-lookup"><span data-stu-id="20716-531">-or-</span></span> 
 <span data-ttu-id="20716-532"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-532"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-533">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-534">または</span><span class="sxs-lookup"><span data-stu-id="20716-534">-or-</span></span> 
<span data-ttu-id="20716-535"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="20716-536">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-536">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="20716-537">または</span><span class="sxs-lookup"><span data-stu-id="20716-537">-or-</span></span> 
<span data-ttu-id="20716-538">パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-538">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span>  
  
<span data-ttu-id="20716-539">または</span><span class="sxs-lookup"><span data-stu-id="20716-539">-or-</span></span> 
 <span data-ttu-id="20716-540">[https://login.microsoftonline.com/consumers/](<see cref="F:System.Type.EmptyTypes" />)</span><span class="sxs-lookup"><span data-stu-id="20716-540"><see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-541">パラメーター型配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-541">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span></span> <span data-ttu-id="20716-542">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-542">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-543">指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-543">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-544">指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-544">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-545">完全に一致するものが存在しない場合、一致を選択するために、`binder` は `types` 配列に指定されているパラメーターの型を強制的に強制しようとします。</span><span class="sxs-lookup"><span data-stu-id="20716-545">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="20716-546">`binder` が一致を選択できない場合は、`null` が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-546">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="20716-547">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-547">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-548">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-548">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-549">検索にパブリックコンストラクターを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-549">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="20716-550">`BindingFlags.NonPublic` を指定して、検索で非パブリックコンストラクター (プライベート、内部、およびプロテクトコンストラクター) を含めるようにします。</span><span class="sxs-lookup"><span data-stu-id="20716-550">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="20716-551">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-551">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-552">このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-552">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-553"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-553">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-554">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-554">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-555">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-555">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-556">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.ConstructorInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-556">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="20716-557">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは常に `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-558">次のプログラムは `MyClass1` クラスの型を取得し、指定したバインディングフラグに一致する <xref:System.Reflection.ConstructorInfo> オブジェクトを取得し、コンストラクターのシグネチャを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-558">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-559"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-559"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-560">または</span><span class="sxs-lookup"><span data-stu-id="20716-560">-or-</span></span> 
<span data-ttu-id="20716-561"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-561">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-562"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-562"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-563">または</span><span class="sxs-lookup"><span data-stu-id="20716-563">-or-</span></span> 
 <span data-ttu-id="20716-564"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-564"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-565">または</span><span class="sxs-lookup"><span data-stu-id="20716-565">-or-</span></span> 
 <span data-ttu-id="20716-566"><paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-566"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-567">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-567">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-568">または</span><span class="sxs-lookup"><span data-stu-id="20716-568">-or-</span></span> 
 <span data-ttu-id="20716-569"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-569"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-570">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-570">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-571">または</span><span class="sxs-lookup"><span data-stu-id="20716-571">-or-</span></span> 
<span data-ttu-id="20716-572"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-572">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="20716-573">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-573">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="20716-574">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-574">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="20716-575">または</span><span class="sxs-lookup"><span data-stu-id="20716-575">-or-</span></span> 
<span data-ttu-id="20716-576">パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-576">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-577"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-577">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-578">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-578">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-579">指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-579">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="20716-580">指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-580">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-581">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-581">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-582">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-582">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-583">完全に一致するものが存在しない場合、一致を選択するために、`binder` は `types` 配列に指定されているパラメーターの型を強制的に強制しようとします。</span><span class="sxs-lookup"><span data-stu-id="20716-583">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="20716-584">`binder` が一致を選択できない場合は、`null` が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-584">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="20716-585">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-585">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-586">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-586">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-587">検索にパブリックコンストラクターを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-587">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="20716-588">`BindingFlags.NonPublic` を指定して、検索で非パブリックコンストラクター (プライベート、内部、およびプロテクトコンストラクター) を含めるようにします。</span><span class="sxs-lookup"><span data-stu-id="20716-588">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="20716-589">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-589">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-590">このメソッドを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-590">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-591"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-591">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-592">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-592">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-593">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-593">Member Type</span></span>|<span data-ttu-id="20716-594">静的</span><span class="sxs-lookup"><span data-stu-id="20716-594">Static</span></span>|<span data-ttu-id="20716-595">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-595">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-596">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-596">Constructor</span></span>|<span data-ttu-id="20716-597">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-597">No</span></span>|<span data-ttu-id="20716-598">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-598">No</span></span>|  
|<span data-ttu-id="20716-599">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-599">Field</span></span>|<span data-ttu-id="20716-600">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-600">No</span></span>|<span data-ttu-id="20716-601">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-601">Yes.</span></span> <span data-ttu-id="20716-602">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-602">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-603">Event</span><span class="sxs-lookup"><span data-stu-id="20716-603">Event</span></span>|<span data-ttu-id="20716-604">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-604">Not applicable</span></span>|<span data-ttu-id="20716-605">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-605">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-606">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-606">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-607">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-607">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-608">方法</span><span class="sxs-lookup"><span data-stu-id="20716-608">Method</span></span>|<span data-ttu-id="20716-609">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-609">No</span></span>|<span data-ttu-id="20716-610">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-610">Yes.</span></span> <span data-ttu-id="20716-611">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-611">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-612">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-612">Nested Type</span></span>|<span data-ttu-id="20716-613">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-613">No</span></span>|<span data-ttu-id="20716-614">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-614">No</span></span>|  
|<span data-ttu-id="20716-615">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-615">Property</span></span>|<span data-ttu-id="20716-616">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-616">Not applicable</span></span>|<span data-ttu-id="20716-617">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-617">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-618">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-618">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-619">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-619">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-620">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-620">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-621">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-621">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-622">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-622">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-623">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-623">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-624">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-624">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-625">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-625">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-626">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-626">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-627">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.ConstructorInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-627">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="20716-628">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは常に `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-628">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-629">次の例では、`MyClass1`の型を取得し、指定したバインディングフラグと一致する <xref:System.Reflection.ConstructorInfo> オブジェクトを取得し、コンストラクターシグネチャを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-629">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-630"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-630"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-631">または</span><span class="sxs-lookup"><span data-stu-id="20716-631">-or-</span></span> 
<span data-ttu-id="20716-632"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-632">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-633"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-633"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-634">または</span><span class="sxs-lookup"><span data-stu-id="20716-634">-or-</span></span> 
 <span data-ttu-id="20716-635"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-635"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-636">または</span><span class="sxs-lookup"><span data-stu-id="20716-636">-or-</span></span> 
 <span data-ttu-id="20716-637"><paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-637"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetConstructorImpl (bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-638">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-638">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-639">または</span><span class="sxs-lookup"><span data-stu-id="20716-639">-or-</span></span> 
<span data-ttu-id="20716-640"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-640"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-641">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-641">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-642">または</span><span class="sxs-lookup"><span data-stu-id="20716-642">-or-</span></span> 
<span data-ttu-id="20716-643"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-643">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="20716-644">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-644">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="20716-645">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-645">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="20716-646">または</span><span class="sxs-lookup"><span data-stu-id="20716-646">-or-</span></span> 
<span data-ttu-id="20716-647">パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-647">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-648"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-648">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-649">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-649">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-650">派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-650">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="20716-651">指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-651">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-652">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-652">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-653">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-653">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-654">完全に一致するものが存在しない場合、一致を選択するために、`binder` は `types` 配列に指定されているパラメーターの型を強制的に強制しようとします。</span><span class="sxs-lookup"><span data-stu-id="20716-654">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="20716-655">`binder` が一致を選択できない場合は、`null` が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-655">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="20716-656">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-656">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-657">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-657">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-658">検索にパブリックコンストラクターを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-658">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="20716-659">`BindingFlags.NonPublic` を指定して、検索で非パブリックコンストラクター (プライベート、内部、およびプロテクトコンストラクター) を含めるようにします。</span><span class="sxs-lookup"><span data-stu-id="20716-659">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="20716-660">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-660">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-661">このメソッドは、<xref:System.Type.GetConstructor%2A> を実装します。</span><span class="sxs-lookup"><span data-stu-id="20716-661">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-662"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-662"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-663">または</span><span class="sxs-lookup"><span data-stu-id="20716-663">-or-</span></span> 
<span data-ttu-id="20716-664"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-664">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-665"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-665"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-666">または</span><span class="sxs-lookup"><span data-stu-id="20716-666">-or-</span></span> 
 <span data-ttu-id="20716-667"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-667"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-668">または</span><span class="sxs-lookup"><span data-stu-id="20716-668">-or-</span></span> 
 <span data-ttu-id="20716-669"><paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-669"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-670">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-670">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-671">現在の <see cref="T:System.Type" /> のコンストラクターを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-671">Gets the constructors of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-672">現在の <see cref="T:System.Type" /> に対して定義されているパブリック コンストラクターをすべて返します。</span><span class="sxs-lookup"><span data-stu-id="20716-672">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-673">現在の <see cref="T:System.Reflection.ConstructorInfo" /> に対して定義されたすべてのパブリック インスタンス コンストラクター (ただし、型初期化子 (静的コンストラクター) を除く) を表している <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-673">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span></span> <span data-ttu-id="20716-674">パブリック インスタンス コンストラクターが現在の <see cref="T:System.Type" /> に対して定義されている場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-674">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-675"><xref:System.Type.GetConstructors%2A> メソッドは、宣言の順序など、特定の順序でコンストラクターを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-675">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="20716-676">コードは、コンストラクターが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-676">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-677">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-677">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-678">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-678">Member Type</span></span>|<span data-ttu-id="20716-679">静的</span><span class="sxs-lookup"><span data-stu-id="20716-679">Static</span></span>|<span data-ttu-id="20716-680">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-680">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-681">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-681">Constructor</span></span>|<span data-ttu-id="20716-682">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-682">No</span></span>|<span data-ttu-id="20716-683">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-683">No</span></span>|  
|<span data-ttu-id="20716-684">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-684">Field</span></span>|<span data-ttu-id="20716-685">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-685">No</span></span>|<span data-ttu-id="20716-686">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-686">Yes.</span></span> <span data-ttu-id="20716-687">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-687">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-688">Event</span><span class="sxs-lookup"><span data-stu-id="20716-688">Event</span></span>|<span data-ttu-id="20716-689">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-689">Not applicable</span></span>|<span data-ttu-id="20716-690">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-690">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-691">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-691">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-692">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-692">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-693">方法</span><span class="sxs-lookup"><span data-stu-id="20716-693">Method</span></span>|<span data-ttu-id="20716-694">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-694">No</span></span>|<span data-ttu-id="20716-695">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-695">Yes.</span></span> <span data-ttu-id="20716-696">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-696">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-697">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-697">Nested Type</span></span>|<span data-ttu-id="20716-698">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-698">No</span></span>|<span data-ttu-id="20716-699">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-699">No</span></span>|  
|<span data-ttu-id="20716-700">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-700">Property</span></span>|<span data-ttu-id="20716-701">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-701">Not applicable</span></span>|<span data-ttu-id="20716-702">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-702">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-703">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-703">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-704">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-704">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-705">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-705">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-706">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-706">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-707">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-707">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-708">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-708">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-709">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-709">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-710">このメソッドオーバーロードは、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual Basic) を使用して、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> メソッドのオーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-710">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-711">クラス初期化子 (静的コンストラクター) は見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-711">It will not find class initializers (static constructor).</span></span> <span data-ttu-id="20716-712">クラス初期化子を検索するには、<xref:System.Reflection.BindingFlags>を受け取るオーバーロードを使用&#124;し、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-712">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-713"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-713">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-714">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.ConstructorInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-714">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="20716-715">たとえば、クラス `C<T>` にコンストラクター `C(T t1)` (Visual Basic 内の`Sub New(ByVal t1 As T)`) がある場合、<xref:System.Type.GetConstructors%2A> で `C<int>` を呼び出すと、(<xref:System.Reflection.ConstructorInfo> C#の `C(int t1)`) の`Sub New(ByVal t1 As Integer)` を表す Visual Basic が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-715">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="20716-716">現在の <xref:System.Type> がジェネリック型パラメーターを表している場合、<xref:System.Type.GetConstructors%2A> メソッドは空の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-716">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-717">この例では、2つのインスタンスコンストラクターと1つの静的コンストラクターを持つクラスからの <xref:System.Type.GetConstructors%2A> オーバーロードの出力を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-717">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="20716-718">このコードの出力は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="20716-718">The output of this code is:</span></span>  
  
 <span data-ttu-id="20716-719">2</span><span class="sxs-lookup"><span data-stu-id="20716-719">2</span></span>  
  
 <span data-ttu-id="20716-720">False</span><span class="sxs-lookup"><span data-stu-id="20716-720">False</span></span>  
  
 <span data-ttu-id="20716-721">False</span><span class="sxs-lookup"><span data-stu-id="20716-721">False</span></span>  
  
 <span data-ttu-id="20716-722"><xref:System.Type.GetConstructors> のオーバーロードは <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>のみを使用するため、静的コンストラクターは `for` 式によってカウントされることも、`IsStatic`によって評価されることもありません。</span><span class="sxs-lookup"><span data-stu-id="20716-722">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="20716-723">静的コンストラクターを検索するには、次のコード例に示すように、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> のオーバーロードを使用し、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>の組み合わせ (論理 `OR`) を渡します。</span><span class="sxs-lookup"><span data-stu-id="20716-723">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="20716-724">出力は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-724">Now the output is:</span></span>  
  
 <span data-ttu-id="20716-725">3</span><span class="sxs-lookup"><span data-stu-id="20716-725">3</span></span>  
  
 <span data-ttu-id="20716-726">False</span><span class="sxs-lookup"><span data-stu-id="20716-726">False</span></span>  
  
 <span data-ttu-id="20716-727">True</span><span class="sxs-lookup"><span data-stu-id="20716-727">True</span></span>  
  
 <span data-ttu-id="20716-728">False</span><span class="sxs-lookup"><span data-stu-id="20716-728">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-729">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-729">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-730">または</span><span class="sxs-lookup"><span data-stu-id="20716-730">-or-</span></span> 
<span data-ttu-id="20716-731">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-731"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-732">派生クラス内でオーバーライドされた場合、指定した <see langword="BindingFlags" /> を使用して、現在の <see cref="T:System.Type" /> に対して定義されているコンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-732">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span></span></summary>
        <returns><span data-ttu-id="20716-733">現在の <see cref="T:System.Reflection.ConstructorInfo" /> にコンストラクターが定義されている場合は、型初期化子を含め、定義されているコンストラクターのうち指定したバインディング制約に一致するすべてのコンストラクターを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-733">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span></span> <span data-ttu-id="20716-734">現在の <see cref="T:System.Type" /> に対してコンストラクターが定義されていない場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-734">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="20716-735">`bindingAttr` を使用すると、パブリックコンストラクターだけを返すか、パブリックコンストラクターと非パブリックコンストラクターの両方を返すかを指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-735">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
<span data-ttu-id="20716-736">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-736">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
- <span data-ttu-id="20716-737">クラス初期化子 (静的コンストラクター) を取得するには、`BindingFlags.NonPublic` と共に `BindingFlags.Static` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-737">Specify `BindingFlags.Static` along with `BindingFlags.NonPublic` to retrieve the class initializer (static constructor).</span></span> <span data-ttu-id="20716-738"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-738">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>

- <span data-ttu-id="20716-739">インスタンスコンストラクターを取得するには、`BindingFlags.Public` と `BindingFlags.NonPublic` の一方または両方と共に `BindingFlags.Instance` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-739">Specify `BindingFlags.Instance` along with one or both of `BindingFlags.Public` and `BindingFlags.NonPublic` to retrieve instance constructors.</span></span>   
  
<span data-ttu-id="20716-740">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-740">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="20716-741"><xref:System.Type.GetConstructors%2A> メソッドは、宣言の順序など、特定の順序でコンストラクターを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-741">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="20716-742">コードは、コンストラクターが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-742">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  

<span data-ttu-id="20716-743">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.ConstructorInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-743">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="20716-744">たとえば、クラス `C<T>` にコンストラクター `C(T t1)` (Visual Basic 内の`Sub New(ByVal t1 As T)`) がある場合、<xref:System.Type.GetConstructors%2A> で `C<int>` を呼び出すと、(<xref:System.Reflection.ConstructorInfo> C#の `C(int t1)`) の`Sub New(ByVal t1 As Integer)` を表す Visual Basic が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-744">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
<span data-ttu-id="20716-745">現在の <xref:System.Type> がジェネリック型パラメーターを表している場合、<xref:System.Type.GetConstructors%2A> メソッドは空の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-745">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
## Examples  

<span data-ttu-id="20716-746">この例では、2つのインスタンスコンストラクターと1つの静的コンストラクターを持つクラスからの <xref:System.Type.GetConstructors> オーバーロードの出力を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-746">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="20716-747">このコードの出力は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="20716-747">The output of this code is:</span></span>  
  
 <span data-ttu-id="20716-748">2</span><span class="sxs-lookup"><span data-stu-id="20716-748">2</span></span>  
  
 <span data-ttu-id="20716-749">False</span><span class="sxs-lookup"><span data-stu-id="20716-749">False</span></span>  
  
 <span data-ttu-id="20716-750">False</span><span class="sxs-lookup"><span data-stu-id="20716-750">False</span></span>  
  
 <span data-ttu-id="20716-751"><xref:System.Type.GetConstructors%2A> のオーバーロードは <xref:System.Reflection.BindingFlags.Public> と <xref:System.Reflection.BindingFlags.Instance>のみを使用するため、静的コンストラクターは `for` 式によってカウントされることも、`IsStatic`によって評価されることもありません。</span><span class="sxs-lookup"><span data-stu-id="20716-751">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="20716-752">静的コンストラクターを検索するには、次のコード例に示すように、<xref:System.Type.GetConstructors%2A> のオーバーロードを使用し、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>の組み合わせ (論理 OR) を渡します。</span><span class="sxs-lookup"><span data-stu-id="20716-752">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="20716-753">出力は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-753">Now the output is:</span></span>  
  
 <span data-ttu-id="20716-754">3</span><span class="sxs-lookup"><span data-stu-id="20716-754">3</span></span>  
  
 <span data-ttu-id="20716-755">False</span><span class="sxs-lookup"><span data-stu-id="20716-755">False</span></span>  
  
 <span data-ttu-id="20716-756">True</span><span class="sxs-lookup"><span data-stu-id="20716-756">True</span></span>  
  
 <span data-ttu-id="20716-757">False</span><span class="sxs-lookup"><span data-stu-id="20716-757">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-758"><see cref="T:System.Type" /> が設定されている現在の <see cref="T:System.Reflection.DefaultMemberAttribute" /> に定義されているメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-758">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span></span></summary>
        <returns><span data-ttu-id="20716-759">現在の <see cref="T:System.Reflection.MemberInfo" /> のすべての既定メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-759">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="20716-760">または</span><span class="sxs-lookup"><span data-stu-id="20716-760">-or-</span></span> 
<span data-ttu-id="20716-761">現在の <see cref="T:System.Reflection.MemberInfo" /> に既定のメンバーがない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-761">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-762"><xref:System.Type.GetDefaultMembers%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-762">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-763">コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-763">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-764">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-764">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="20716-765">メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-765">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="20716-766">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-766">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-767">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-767">Member Type</span></span>|<span data-ttu-id="20716-768">静的</span><span class="sxs-lookup"><span data-stu-id="20716-768">Static</span></span>|<span data-ttu-id="20716-769">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-769">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-770">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-770">Constructor</span></span>|<span data-ttu-id="20716-771">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-771">No</span></span>|<span data-ttu-id="20716-772">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-772">No</span></span>|  
|<span data-ttu-id="20716-773">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-773">Field</span></span>|<span data-ttu-id="20716-774">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-774">No</span></span>|<span data-ttu-id="20716-775">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-775">Yes.</span></span> <span data-ttu-id="20716-776">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-776">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-777">Event</span><span class="sxs-lookup"><span data-stu-id="20716-777">Event</span></span>|<span data-ttu-id="20716-778">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-778">Not applicable</span></span>|<span data-ttu-id="20716-779">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-779">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-780">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-780">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-781">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-781">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-782">方法</span><span class="sxs-lookup"><span data-stu-id="20716-782">Method</span></span>|<span data-ttu-id="20716-783">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-783">No</span></span>|<span data-ttu-id="20716-784">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-784">Yes.</span></span> <span data-ttu-id="20716-785">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-785">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-786">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-786">Nested Type</span></span>|<span data-ttu-id="20716-787">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-787">No</span></span>|<span data-ttu-id="20716-788">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-788">No</span></span>|  
|<span data-ttu-id="20716-789">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-789">Property</span></span>|<span data-ttu-id="20716-790">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-790">Not applicable</span></span>|<span data-ttu-id="20716-791">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-791">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-792">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-792">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-793">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-793">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-794">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-794">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-795">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-795">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-796">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-796">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-797">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-797">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-798">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-798">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-799">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MemberInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-799">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="20716-800">たとえば、クラス `C<T>` に `T`を返すプロパティ `P` がある場合、`C<int>` で <xref:System.Type.GetDefaultMembers%2A> を呼び出すとC# 、(`int P` の`Property P As Integer`) の Visual Basic が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-800">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="20716-801">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-801">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-802">次の例では、`MyClass` の既定のメンバー情報を取得し、既定のメンバーを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-802">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-803">派生クラスによってオーバーライドされた場合、現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-803">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span></span></summary>
        <returns><span data-ttu-id="20716-804">現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" />。現在の <see langword="null" /> が配列またはポインターではない場合、参照によって渡されない場合、ジェネリック型やジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、<see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="20716-804">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-805">このメソッドは、<xref:System.Array> クラスの `null` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-805">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-806">`GetElementType` メソッドの使用例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="20716-806">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="20716-807">名前を取得する対象の値。</span><span class="sxs-lookup"><span data-stu-id="20716-807">The value whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="20716-808">現在の列挙型の指定された値を持つ定数の名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-808">Returns the name of the constant that has the specified value, for the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="20716-809">指定された値を持つ現在の列挙型のメンバーの名前。そのような定数が見つからない場合は、<see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-809">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-810">現在の型は列挙型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-810">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="20716-811">または</span><span class="sxs-lookup"><span data-stu-id="20716-811">-or-</span></span> 
 <span data-ttu-id="20716-812"><paramref name="value" /> は、現在の型ではなく、基になる型が現在の型と同じでもありません。</span><span class="sxs-lookup"><span data-stu-id="20716-812"><paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-813"><paramref name="value" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-813"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-814">現在の列挙型のメンバーの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-814">Returns the names of the members of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="20716-815">列挙型のメンバーの名前が含まれている配列。</span><span class="sxs-lookup"><span data-stu-id="20716-815">An array that contains the names of the members of the enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-816">戻り値の配列の要素は、列挙定数のバイナリ値 (符号なしの値) によって並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="20716-816">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="20716-817">配列に同じ値を持つ列挙定数が含まれている場合は、対応する名前の順序が指定されていません。</span><span class="sxs-lookup"><span data-stu-id="20716-817">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-818">現在の型は列挙型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-818">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-819">現在の列挙型の基になる型を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-819">Returns the underlying type of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="20716-820">現在の列挙型の基になる型。</span><span class="sxs-lookup"><span data-stu-id="20716-820">The underlying type of the current enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-821">既定では、 C#および Visual Basic の列挙型の基になる型は <xref:System.Int32>です。</span><span class="sxs-lookup"><span data-stu-id="20716-821">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="20716-822">その他の整数型を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-822">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-823">現在の型は列挙型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-823">The current type is not an enumeration.</span></span>  
  
 <span data-ttu-id="20716-824">または</span><span class="sxs-lookup"><span data-stu-id="20716-824">-or-</span></span>  
  
 <span data-ttu-id="20716-825">列挙型に複数のインスタンス フィールドが含まれているため、無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-825">The enumeration type is not valid, because it contains more than one instance field.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-826">現在の列挙型の定数の値の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-826">Returns an array of the values of the constants in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="20716-827">値を格納する配列。</span><span class="sxs-lookup"><span data-stu-id="20716-827">An array that contains the values.</span></span> <span data-ttu-id="20716-828">配列の要素は列挙定数のバイナリ値 (符号なしの値) に基づいて並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="20716-828">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-829">現在の型は列挙型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-829">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-830">現在の <see cref="T:System.Type" /> で宣言または継承されている特定のイベントを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-830">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-831">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-831">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="20716-832">指定したパブリック イベントを表す <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-832">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span></span></summary>
        <returns><span data-ttu-id="20716-833">現在の <see cref="T:System.Type" /> で宣言または継承されている指定パブリック イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-833">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-834">パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-834">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="20716-835">それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-835">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-836">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-836">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-837">検索には、パブリックの静的インスタンスイベントとパブリックインスタンスイベントが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-837">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="20716-838">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-838">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-839">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-839">Member Type</span></span>|<span data-ttu-id="20716-840">静的</span><span class="sxs-lookup"><span data-stu-id="20716-840">Static</span></span>|<span data-ttu-id="20716-841">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-841">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-842">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-842">Constructor</span></span>|<span data-ttu-id="20716-843">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-843">No</span></span>|<span data-ttu-id="20716-844">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-844">No</span></span>|  
|<span data-ttu-id="20716-845">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-845">Field</span></span>|<span data-ttu-id="20716-846">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-846">No</span></span>|<span data-ttu-id="20716-847">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-847">Yes.</span></span> <span data-ttu-id="20716-848">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-848">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-849">Event</span><span class="sxs-lookup"><span data-stu-id="20716-849">Event</span></span>|<span data-ttu-id="20716-850">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-850">Not applicable</span></span>|<span data-ttu-id="20716-851">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-851">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-852">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-852">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-853">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-853">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-854">方法</span><span class="sxs-lookup"><span data-stu-id="20716-854">Method</span></span>|<span data-ttu-id="20716-855">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-855">No</span></span>|<span data-ttu-id="20716-856">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-856">Yes.</span></span> <span data-ttu-id="20716-857">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-857">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-858">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-858">Nested Type</span></span>|<span data-ttu-id="20716-859">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-859">No</span></span>|<span data-ttu-id="20716-860">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-860">No</span></span>|  
|<span data-ttu-id="20716-861">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-861">Property</span></span>|<span data-ttu-id="20716-862">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-862">Not applicable</span></span>|<span data-ttu-id="20716-863">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-863">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-864">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-864">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-865">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-865">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-866">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-866">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-867">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-867">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-868">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-868">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-869">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-869">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-870">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-870">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-871">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.EventInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-871">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-872">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-872">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-873">次の例では、<xref:System.Reflection.EventInfo> オブジェクトを作成し、指定したイベントのボタンクラスのイベントを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-873">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-874"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-874"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-875">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-875">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-876">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-876">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-877">または</span><span class="sxs-lookup"><span data-stu-id="20716-877">-or-</span></span> 
 <span data-ttu-id="20716-878"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-878"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="20716-879">派生クラス内でオーバーライドされた場合、指定されたバイディング制約を使用して、指定されたイベントを表わす <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-879">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-880">現在の <see cref="T:System.Type" /> で宣言または継承されている指定イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-880">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-881">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるイベントを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-881">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-882">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-882">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-883">検索にパブリックイベントを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-883">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="20716-884">検索に非パブリックイベント (プライベート、内部、および保護されたイベント) を含めるには、`BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-884">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="20716-885">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-885">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-886">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-886">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-887">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-887">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-888">単純に継承されたイベントではなく、<xref:System.Type>で宣言されたイベントのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-888">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-889">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-889">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-890">パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-890">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="20716-891">それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-891">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-892">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.EventInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-892">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-893">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-893">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-894">次のコード例では、<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> メソッドを使用して、`static` (Visual Basic で`Shared`) ではない、"Click" という名前のパブリックまたは非パブリックイベントの型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-894">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-895"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-895"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-896">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-896">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-897">現在の <see cref="T:System.Type" /> で宣言または継承されているすべてのパブリック イベントを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-897">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-898">現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているすべてのパブリック イベントを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-898">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="20716-899">または</span><span class="sxs-lookup"><span data-stu-id="20716-899">-or-</span></span> 
<span data-ttu-id="20716-900">現在の <see cref="T:System.Reflection.EventInfo" /> にパブリック イベントがない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-900">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-901">パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-901">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="20716-902">それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-902">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-903"><xref:System.Type.GetEvents%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でイベントを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-903">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-904">コードは、イベントが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-904">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-905">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-905">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="20716-906">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-906">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-907">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-907">Member Type</span></span>|<span data-ttu-id="20716-908">静的</span><span class="sxs-lookup"><span data-stu-id="20716-908">Static</span></span>|<span data-ttu-id="20716-909">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-909">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-910">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-910">Constructor</span></span>|<span data-ttu-id="20716-911">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-911">No</span></span>|<span data-ttu-id="20716-912">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-912">No</span></span>|  
|<span data-ttu-id="20716-913">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-913">Field</span></span>|<span data-ttu-id="20716-914">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-914">No</span></span>|<span data-ttu-id="20716-915">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-915">Yes.</span></span> <span data-ttu-id="20716-916">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-916">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-917">Event</span><span class="sxs-lookup"><span data-stu-id="20716-917">Event</span></span>|<span data-ttu-id="20716-918">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-918">Not applicable</span></span>|<span data-ttu-id="20716-919">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-919">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-920">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-920">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-921">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-921">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-922">方法</span><span class="sxs-lookup"><span data-stu-id="20716-922">Method</span></span>|<span data-ttu-id="20716-923">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-923">No</span></span>|<span data-ttu-id="20716-924">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-924">Yes.</span></span> <span data-ttu-id="20716-925">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-925">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-926">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-926">Nested Type</span></span>|<span data-ttu-id="20716-927">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-927">No</span></span>|<span data-ttu-id="20716-928">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-928">No</span></span>|  
|<span data-ttu-id="20716-929">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-929">Property</span></span>|<span data-ttu-id="20716-930">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-930">Not applicable</span></span>|<span data-ttu-id="20716-931">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-931">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-932">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-932">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-933">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-933">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-934">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-934">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-935">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-935">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-936">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-936">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-937">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-937">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-938">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-938">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-939">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.EventInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-939">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-940">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-940">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-941">次の例では、<xref:System.Reflection.EventInfo> オブジェクトの配列を取得し、`Button` クラスのすべてのイベントを取得して、イベント名を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-941">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="20716-942">Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-942">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-943">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-943">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="20716-944">または</span><span class="sxs-lookup"><span data-stu-id="20716-944">-or-</span></span>

 <span data-ttu-id="20716-945">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-945"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-946">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-946">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-947">現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているイベントのうち、指定したバインディング制約に一致するすべてのイベントを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-947">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="20716-948">または</span><span class="sxs-lookup"><span data-stu-id="20716-948">-or-</span></span> 
<span data-ttu-id="20716-949">現在の <see cref="T:System.Reflection.EventInfo" /> にイベントが存在しないか、またはイベントの中にバインディング制約に一致するものがない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-949">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-950"><xref:System.Type.GetEvents%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でイベントを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-950">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-951">コードは、イベントが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-951">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-952">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるイベントを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-952">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-953">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-953">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-954">検索にパブリックイベントを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-954">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="20716-955">検索に非パブリックイベント (プライベート、内部、および保護されたイベント) を含めるには、`BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-955">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="20716-956">基底クラスのプロテクトイベントと内部イベントのみが返されます。基底クラスのプライベートイベントは返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-956">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="20716-957">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-957">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-958">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-958">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-959">単純に継承されたイベントではなく、<xref:System.Type>で宣言されたイベントのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-959">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-960">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-960">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-961">パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-961">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="20716-962">それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-962">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-963">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.EventInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-963">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-964">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-964">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-965">次の例では、指定したバインディングフラグに一致する <xref:System.Reflection.EventInfo> オブジェクトの配列を取得し、`Button` クラスのすべてのイベントを取得して、イベント名を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-965">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="20716-966">Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-966">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-967">現在の <see cref="T:System.Type" /> の特定のフィールドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-967">Gets a specific field of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-968">取得するデータ フィールドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-968">The string containing the name of the data field to get.</span></span></param>
        <summary><span data-ttu-id="20716-969">指定した名前のパブリック フィールドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-969">Searches for the public field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="20716-970">指定した名前のパブリック フィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-970">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-971">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-971">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-972">検索には、パブリックの静的およびパブリックインスタンスフィールドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-972">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="20716-973">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.FieldInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-973">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-974">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のフィールドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-974">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-975">次の例では、指定されたクラスの `Type` オブジェクトを取得し、フィールドの <xref:System.Reflection.FieldInfo> オブジェクトを取得して、フィールドの値を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-975">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-976"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-976"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-977">この <see cref="T:System.Type" /> オブジェクトは、<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> メソッドがまだ呼び出されていない <see cref="T:System.Reflection.Emit.TypeBuilder" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-977">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-978">取得するデータ フィールドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-978">The string containing the name of the data field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-979">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-979">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-980">または</span><span class="sxs-lookup"><span data-stu-id="20716-980">-or-</span></span> 
 <span data-ttu-id="20716-981"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-981"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="20716-982">指定したバインディング制約を使用して、指定したフィールドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-982">Searches for the specified field, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-983">指定した要件と一致するフィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-983">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-984">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-984">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-985">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-985">Member Type</span></span>|<span data-ttu-id="20716-986">静的</span><span class="sxs-lookup"><span data-stu-id="20716-986">Static</span></span>|<span data-ttu-id="20716-987">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-987">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-988">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-988">Constructor</span></span>|<span data-ttu-id="20716-989">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-989">No</span></span>|<span data-ttu-id="20716-990">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-990">No</span></span>|  
|<span data-ttu-id="20716-991">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-991">Field</span></span>|<span data-ttu-id="20716-992">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-992">No</span></span>|<span data-ttu-id="20716-993">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-993">Yes.</span></span> <span data-ttu-id="20716-994">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-994">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-995">Event</span><span class="sxs-lookup"><span data-stu-id="20716-995">Event</span></span>|<span data-ttu-id="20716-996">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-996">Not applicable</span></span>|<span data-ttu-id="20716-997">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-997">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-998">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-998">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-999">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-999">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1000">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1000">Method</span></span>|<span data-ttu-id="20716-1001">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1001">No</span></span>|<span data-ttu-id="20716-1002">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1002">Yes.</span></span> <span data-ttu-id="20716-1003">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1003">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1004">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1004">Nested Type</span></span>|<span data-ttu-id="20716-1005">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1005">No</span></span>|<span data-ttu-id="20716-1006">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1006">No</span></span>|  
|<span data-ttu-id="20716-1007">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1007">Property</span></span>|<span data-ttu-id="20716-1008">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1008">Not applicable</span></span>|<span data-ttu-id="20716-1009">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1009">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1010">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1010">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1011">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1011">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1012">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1012">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1013">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1013">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1014">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1014">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1015">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1015">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1016">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1016">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-1017">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるフィールドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1017">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1018">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1018">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1019">検索にパブリックフィールドを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1019">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="20716-1020">`BindingFlags.NonPublic` を指定すると、パブリックでないフィールド (プライベート、内部、および保護されたフィールド) を検索に含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1020">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="20716-1021">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1021">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-1022">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1022">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-1023">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-1023">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-1024">単純に継承されたフィールドではなく、<xref:System.Type>で宣言されたフィールドのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1024">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1025">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1025">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-1026">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.FieldInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1026">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1027">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のフィールドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1028">次の例では、指定されたクラスの `Type` オブジェクトを取得し、指定したバインディングフラグと一致するフィールドの <xref:System.Reflection.FieldInfo> オブジェクトを取得し、フィールドの値を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1028">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1029"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1029"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1030">現在の <see cref="T:System.Type" /> のフィールドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1030">Gets the fields of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1031">現在の <see cref="T:System.Type" /> のすべてのパブリック フィールドを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1031">Returns all the public fields of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-1032">現在の <see cref="T:System.Reflection.FieldInfo" /> に対して定義されているすべてのパブリック フィールドを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1032">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="20716-1033">または</span><span class="sxs-lookup"><span data-stu-id="20716-1033">-or-</span></span> 
<span data-ttu-id="20716-1034">現在の <see cref="T:System.Reflection.FieldInfo" /> に対してパブリック フィールドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1034">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1035"><xref:System.Type.GetFields%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でフィールドを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1035">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1036">この順序は変化するため、コードは返されるフィールドの順序に依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1036">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1037">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1037">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1038">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1038">Member Type</span></span>|<span data-ttu-id="20716-1039">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1039">Static</span></span>|<span data-ttu-id="20716-1040">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1040">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1041">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1041">Constructor</span></span>|<span data-ttu-id="20716-1042">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1042">No</span></span>|<span data-ttu-id="20716-1043">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1043">No</span></span>|  
|<span data-ttu-id="20716-1044">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1044">Field</span></span>|<span data-ttu-id="20716-1045">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1045">No</span></span>|<span data-ttu-id="20716-1046">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1046">Yes.</span></span> <span data-ttu-id="20716-1047">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1047">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1048">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1048">Event</span></span>|<span data-ttu-id="20716-1049">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1049">Not applicable</span></span>|<span data-ttu-id="20716-1050">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1050">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1051">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1051">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1052">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1052">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1053">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1053">Method</span></span>|<span data-ttu-id="20716-1054">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1054">No</span></span>|<span data-ttu-id="20716-1055">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1055">Yes.</span></span> <span data-ttu-id="20716-1056">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1056">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1057">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1057">Nested Type</span></span>|<span data-ttu-id="20716-1058">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1058">No</span></span>|<span data-ttu-id="20716-1059">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1059">No</span></span>|  
|<span data-ttu-id="20716-1060">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1060">Property</span></span>|<span data-ttu-id="20716-1061">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1061">Not applicable</span></span>|<span data-ttu-id="20716-1062">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1062">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1063">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1063">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1064">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1064">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1065">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1065">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1066">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1066">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1067">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1067">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1068">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1068">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1069">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1069">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-1070">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.FieldInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1070">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1071">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のパブリックフィールドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1071">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1072">次の例は、`GetFields()` メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1072">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-1073">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1073">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="20716-1074">または</span><span class="sxs-lookup"><span data-stu-id="20716-1074">-or-</span></span>

 <span data-ttu-id="20716-1075">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1075"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-1076">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているフィールドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1076">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1077">現在の <see cref="T:System.Type" /> に対して定義されているフィールドのうち、指定したバインディング制約に一致するすべてのフィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1077">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="20716-1078">または</span><span class="sxs-lookup"><span data-stu-id="20716-1078">-or-</span></span> 
<span data-ttu-id="20716-1079">現在の <see cref="T:System.Reflection.FieldInfo" /> に対してフィールドが定義されていないか、または定義されているフィールドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1079">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="20716-1080">`GetFields(BindingFlags)` オーバーロードでプロパティ情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、および少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1080">For the `GetFields(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="20716-1081">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるフィールドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1081">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
- <span data-ttu-id="20716-1082">インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1082">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="20716-1083">静的メソッドを含めるには `BindingFlags.Static` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1083">Specify `BindingFlags.Static` to include static methods.</span></span> 
    
- <span data-ttu-id="20716-1084">検索にパブリックフィールドを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1084">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
- <span data-ttu-id="20716-1085">`BindingFlags.NonPublic` を指定すると、パブリックでないフィールド (プライベート、内部、および保護されたフィールド) を検索に含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1085">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="20716-1086">基底クラスの protected フィールドと internal フィールドのみが返されます。基底クラスのプライベートフィールドは返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1086">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
- <span data-ttu-id="20716-1087">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1087">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="20716-1088">空の <xref:System.Reflection.PropertyInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1088">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

<span data-ttu-id="20716-1089">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1089">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="20716-1090">単純に継承されたフィールドではなく、<xref:System.Type>で宣言されたフィールドのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1090">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
<span data-ttu-id="20716-1091">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1091">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="20716-1092"><xref:System.Type.GetFields%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でフィールドを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1092">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1093">この順序は変化するため、コードは返されるフィールドの順序に依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1093">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  

 <span data-ttu-id="20716-1094">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.FieldInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1094">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1095">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のパブリックフィールドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1095">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
## Examples  
 <span data-ttu-id="20716-1096">次の例は、`GetFields(BindingFlags)` メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1096">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1097">クローズ ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1097">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="20716-1098">ジェネリック型の型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1098">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span></span> <span data-ttu-id="20716-1099">現在の型がジェネリック型でない場合は空の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1099">Returns an empty array if the current type is not a generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1100">配列要素は、ジェネリック型の型引数のリストに出現する順序で返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1100">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="20716-1101">現在の型が構築されたクローズ型である場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A> プロパティが `false`を返す場合)、<xref:System.Type.GetGenericArguments%2A> メソッドによって返される配列には、ジェネリック型定義のジェネリック型パラメーターに割り当てられた型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1101">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="20716-1102">現在の型がジェネリック型の定義の場合、配列には型パラメーターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1102">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="20716-1103">現在の型がオープン構築型である場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`を返します)、特定の型が、外側のジェネリック型または外側のジェネリックメソッドの型パラメーターと型パラメーターのすべてに割り当てられていない場合、配列には型と型の両方のパラメーターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1103">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="20716-1104"><xref:System.Type.IsGenericParameter%2A> プロパティを使用して、それらを区別します。</span><span class="sxs-lookup"><span data-stu-id="20716-1104">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="20716-1105">このシナリオのデモについては、<xref:System.Type.ContainsGenericParameters%2A> プロパティのコード例を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1105">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="20716-1106">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1106">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1107">次のコード例では、<xref:System.Type.GetGenericArguments%2A> メソッドを使用して、構築された型の型引数と、そのジェネリック型定義の型パラメーターを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1107">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="20716-1108">このコード例は、<xref:System.Type.IsGenericTypeDefinition%2A> プロパティ用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="20716-1108">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="20716-1109">サンプル出力については、大きな例を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1109">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-1110">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-1110">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="20716-1111">派生クラスには実装を指定しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1111">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-1112">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-1112">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-1113">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-1113">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1114">現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1114">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="20716-1115">現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1115">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1116">ジェネリック型パラメーターの各制約は、<xref:System.Type> オブジェクトとして表されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1116">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="20716-1117">制約が基底クラスの制約であるかどうかを判断するには、<xref:System.Type.IsClass%2A> プロパティを使用します。プロパティが `false`を返す場合、制約はインターフェイスの制約です。</span><span class="sxs-lookup"><span data-stu-id="20716-1117">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="20716-1118">型パラメーターにクラスの制約とインターフェイスの制約がない場合は、空の配列が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1118">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="20716-1119">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1119">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1120">次のコード例では、異なる制約を持つ2つの型パラメーターを持つジェネリック型 `Test` を定義しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1120">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="20716-1121">プログラムの実行時には、<xref:System.Type.GenericParameterAttributes%2A> プロパティと <xref:System.Type.GetGenericParameterConstraints%2A> メソッドを使用して制約が検査されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1121">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-1122">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1122">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="20716-1123">つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1123">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-1124">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-1124">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public abstract Type GetGenericTypeDefinition ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetGenericTypeDefinition () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetGenericTypeDefinition();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1125">現在のジェネリック型を構築する元になるジェネリック型定義を表す <see cref="T:System.Type" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1125">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span></span></summary>
        <returns><span data-ttu-id="20716-1126">現在の型を構築する元になるジェネリック型を表す <see cref="T:System.Type" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-1126">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1127">ジェネリック型定義は、他の型を構築できるテンプレートです。</span><span class="sxs-lookup"><span data-stu-id="20716-1127">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="20716-1128">たとえば、ジェネリック型定義から `G<T>` (構文でC#表されます。 Visual Basic または `generic <typename T> ref class G` で `G(Of T)` C++)、型を構築およびインスタンス化できます (`G<int>` で`G(Of Integer)`)。</span><span class="sxs-lookup"><span data-stu-id="20716-1128">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="20716-1129">この構築された型を表す <xref:System.Type> オブジェクトがある場合、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドはジェネリック型の定義を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1129">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="20716-1130">同じ型引数を使用して、同じジェネリック型定義から2つの構築型が作成された場合、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドは、両方の型に対して同じ <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1130">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="20716-1131">ジェネリック型定義を既に表す <xref:System.Type> オブジェクトで <xref:System.Type.GetGenericTypeDefinition%2A> メソッドを呼び出すと、現在の <xref:System.Type>が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1131">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20716-1132">ジェネリック型の配列は、それ自体がジェネリックではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1132">An array of generic types is not itself generic.</span></span> <span data-ttu-id="20716-1133">C#コード `A<int>[] v;` または Visual Basic コード `Dim v() As A(Of Integer)`では、変数 `v` の型はジェネリックではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1133">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="20716-1134"><xref:System.Type.GetGenericTypeDefinition%2A>を呼び出す前に、型がジェネリックであるかどうかを判断するには、<xref:System.Type.IsGenericType%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-1134">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="20716-1135">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1135">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1136">次のコード例では、通常のインスタンス作成を使用して構築された型のインスタンスを作成した後、<xref:System.Type.GetType%2A> メソッドと <xref:System.Type.GetGenericTypeDefinition%2A> メソッドを使用して、構築された型とジェネリック型定義を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1136">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="20716-1137">この例では、ジェネリック <xref:System.Collections.Generic.Dictionary%602> 型を使用します。構築された型は、文字列キーを持つ `Test` オブジェクトの <xref:System.Collections.Generic.Dictionary%602> を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-1137">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-1138">現在の型はジェネリック型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1138">The current type is not a generic type.</span></span>  <span data-ttu-id="20716-1139">つまり、<see cref="P:System.Type.IsGenericType" /> は <see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1139">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-1140">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-1140">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="20716-1141">派生クラスには実装を指定しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1141">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-1142">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-1142">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-1143">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-1143">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1144">このインスタンスのハッシュ コードを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1144">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="20716-1145">このインスタンスのハッシュ コード。</span><span class="sxs-lookup"><span data-stu-id="20716-1145">The hash code for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1146">このメソッドは、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="20716-1146">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1147">次の例では、`System.Windows.Forms.Button` クラスのハッシュコードを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1147">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1148">現在の <see cref="T:System.Type" /> で実装または継承されている特定のインターフェイスを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1148">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1149">取得するインターフェイスの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1149">The string containing the name of the interface to get.</span></span> <span data-ttu-id="20716-1150">ジェネリック インターフェイスの場合、これは完全修飾名です。</span><span class="sxs-lookup"><span data-stu-id="20716-1150">For generic interfaces, this is the mangled name.</span></span></param>
        <summary><span data-ttu-id="20716-1151">指定した名前のインターフェイスを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1151">Searches for the interface with the specified name.</span></span></summary>
        <returns><span data-ttu-id="20716-1152">現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1152">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1153">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1153">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="20716-1154">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Type> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1154">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1155">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、インターフェイスの制約と、クラスまたはインターフェイスの制約から継承されたインターフェイスを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1155">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1156">ジェネリックインターフェイスの場合、`name` パラメーターは、完全に修飾された名前になります。最後に、アクサングラーブ (\`) と型パラメーターの数で終わります。</span><span class="sxs-lookup"><span data-stu-id="20716-1156">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="20716-1157">これは、ジェネリックインターフェイスの定義と構築されたジェネリックインターフェイスの両方に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-1157">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="20716-1158">たとえば、`IExample<T>` (Visual Basic で`IExample(Of T)`) または `IExample<string>` (`IExample(Of String)` で Visual Basic) を検索するには、``"IExample`1"``を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1158">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1159">次のコード例では、<xref:System.Type.GetInterface%28System.String%29> メソッドを使用して、<xref:System.Runtime.Serialization.IDeserializationCallback> インターフェイスの <xref:System.Collections.Hashtable> クラスを検索し、インターフェイスのメソッドを一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1159">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="20716-1160">このコード例では、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> メソッドのオーバーロードと <xref:System.Type.GetInterfaceMap%2A> メソッドも示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1160">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1161"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1161"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1162">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-1162">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1163">取得するインターフェイスの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1163">The string containing the name of the interface to get.</span></span> <span data-ttu-id="20716-1164">ジェネリック インターフェイスの場合、これは完全修飾名です。</span><span class="sxs-lookup"><span data-stu-id="20716-1164">For generic interfaces, this is the mangled name.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="20716-1165">単純なインターフェイス名を指定する <see langword="true" /> の部分 (名前空間が大文字と小文字を厳密に区別することを指定されている部分) で大文字と小文字の区別を無視する場合は、<paramref name="name" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1165"><see langword="true" /> to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span></span>  
  
<span data-ttu-id="20716-1166">または</span><span class="sxs-lookup"><span data-stu-id="20716-1166">-or-</span></span> 
 <span data-ttu-id="20716-1167"><see langword="false" /> のすべての部分の検索時に大文字と小文字を区別する場合は、<paramref name="name" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1167"><see langword="false" /> to perform a case-sensitive search for all parts of <paramref name="name" />.</span></span></param>
        <summary><span data-ttu-id="20716-1168">派生クラスでオーバーライドされた場合、インターフェイス名の大文字と小文字を区別するかどうかを指定して、指定したインターフェイスを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1168">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span></span></summary>
        <returns><span data-ttu-id="20716-1169">現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1169">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1170">`ignoreCase` パラメーターは、名前空間ではなく、単純なインターフェイス名にのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1170">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="20716-1171">名前空間を指定する `name` の部分には、正しい case が必要です。そうでない場合、インターフェイスが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1171">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="20716-1172">たとえば、文字列 "system.icomparable" は <xref:System.IComparable> インターフェイスを検出しますが、文字列 "system.icomparable" は検索しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1172">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="20716-1173">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Type> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1173">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1174">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、インターフェイスの制約と、クラスまたはインターフェイスの制約から継承されたインターフェイスを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1174">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1175">ジェネリックインターフェイスの場合、`name` パラメーターは、完全に修飾された名前になります。最後に、アクサングラーブ (\`) と型パラメーターの数で終わります。</span><span class="sxs-lookup"><span data-stu-id="20716-1175">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="20716-1176">これは、ジェネリックインターフェイスの定義と構築されたジェネリックインターフェイスの両方に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-1176">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="20716-1177">たとえば、`IExample<T>` (Visual Basic で`IExample(Of T)`) または `IExample<string>` (`IExample(Of String)` で Visual Basic) を検索するには、`"IExample`1 "' を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1177">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1178">次のコード例では、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Collections.IEnumerable> インターフェイスの <xref:System.Collections.Hashtable> クラスの大文字と小文字を区別せずに検索を実行します。</span><span class="sxs-lookup"><span data-stu-id="20716-1178">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="20716-1179">このコード例では、<xref:System.Type.GetInterface%28System.String%29> メソッドのオーバーロードと <xref:System.Type.GetInterfaceMap%2A> メソッドも示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1179">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1180"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1180"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1181">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-1181">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="20716-1182">割り当ての取得対象であるインターフェイス型。</span><span class="sxs-lookup"><span data-stu-id="20716-1182">The interface type to retrieve a mapping for.</span></span></param>
        <summary><span data-ttu-id="20716-1183">指定したインターフェイス型に対するインターフェイスの割り当てを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1183">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="20716-1184"><paramref name="interfaceType" /> に対するインターフェイスの割り当てを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-1184">An object that represents the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1185">インターフェイスマップは、インターフェイスが、そのインターフェイスを実装するクラスの実際のメンバーにどのようにマップされるかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1185">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="20716-1186">現在の <xref:System.Type> が構築ジェネリック型を表している場合、型パラメーターは、このメソッドによって返される <xref:System.Reflection.InterfaceMapping> の要素内の適切な型引数に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="20716-1186">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1187">次の例では、<xref:System.Type.GetInterfaceMap%2A> メソッドを呼び出して、<xref:System.IFormatProvider> インターフェイスが <xref:System.Globalization.CultureInfo> メソッドにどのようにマップされるか、および <xref:System.IAppDomainSetup> インターフェイスが <xref:System.AppDomainSetup> プロパティにどのようにマップされるかを決定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1187">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="20716-1188"><xref:System.IAppDomainSetup> インターフェイスは一連のプロパティを定義するため、返された <xref:System.Reflection.InterfaceMapping> オブジェクトには、プロパティの get アクセサーと set アクセサーに対して個別の <xref:System.Reflection.MethodInfo> オブジェクトが含まれていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1188">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1189"><paramref name="interfaceType" /> は、現在の型では実装されていません。</span><span class="sxs-lookup"><span data-stu-id="20716-1189"><paramref name="interfaceType" /> is not implemented by the current type.</span></span>  
  
<span data-ttu-id="20716-1190">または</span><span class="sxs-lookup"><span data-stu-id="20716-1190">-or-</span></span> 
<span data-ttu-id="20716-1191"><paramref name="interfaceType" /> 引数は、インターフェイスを参照しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1191">The <paramref name="interfaceType" /> argument does not refer to an interface.</span></span>  
  
<span data-ttu-id="20716-1192">または</span><span class="sxs-lookup"><span data-stu-id="20716-1192">-or-</span></span>

<span data-ttu-id="20716-1193">現在のインスタンスまたは <paramref name="interfaceType" /> 引数はオープン ジェネリック型です。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1193">The current instance or <paramref name="interfaceType" /> argument is an open generic type; that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span>

<span data-ttu-id="20716-1194">または</span><span class="sxs-lookup"><span data-stu-id="20716-1194">-or-</span></span>


 <span data-ttu-id="20716-1195"><paramref name="interfaceType" /> ジェネリック インターフェイスで、現在の型は配列型です。</span><span class="sxs-lookup"><span data-stu-id="20716-1195"><paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1196"><paramref name="interfaceType" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1196"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-1197">現在の <see cref="T:System.Type" /> はジェネリック型パラメーターを表しています。つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="true" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1197">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-1198">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-1198">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="20716-1199">派生クラスには実装を指定しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1199">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1200">派生クラスによってオーバーライドされた場合、現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1200">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-1201">現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1201">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="20716-1202">または</span><span class="sxs-lookup"><span data-stu-id="20716-1202">-or-</span></span> 
<span data-ttu-id="20716-1203">現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1203">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1204"><xref:System.Type.GetInterfaces%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でインターフェイスを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1204">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1205">この順序は変化するため、コードはインターフェイスが返される順序に依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1205">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1206">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1206">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1207">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、インターフェイスの制約と、クラスまたはインターフェイスの制約から継承されたインターフェイスを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1207">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1208">次の例では、指定したクラスの型を取得し、その型によって実装または継承されるすべてのインターフェイスを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1208">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="20716-1209">Visual Basic の例をコンパイルするには、次のコンパイラコマンドを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-1209">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-1210">静的初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-1210">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1211">現在の <see cref="T:System.Type" /> のメンバーのうち、指定したメンバーを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1211">Gets the specified members of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1212">取得するパブリック メンバーの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1212">The string containing the name of the public members to get.</span></span></param>
        <summary><span data-ttu-id="20716-1213">指定した名前のパブリック メンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1213">Searches for the public members with the specified name.</span></span></summary>
        <returns><span data-ttu-id="20716-1214">指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1214">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1215">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1215">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-1216">検索には、パブリックな静的およびパブリックインスタンスのメンバーが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1216">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="20716-1217">メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1217">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="20716-1218"><xref:System.Type.GetMember%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1218">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1219">コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1219">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1220">このメソッドオーバーロードは、クラス初期化子 (静的コンストラクター) を検索しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1220">This method overload will not find class initializers (static constructor).</span></span> <span data-ttu-id="20716-1221">クラス初期化子を検索するには、<xref:System.Reflection.BindingFlags>を受け取るオーバーロードを使用&#124;し、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1221">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-1222"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-1222">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-1223">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1223">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1224">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1224">Member Type</span></span>|<span data-ttu-id="20716-1225">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1225">Static</span></span>|<span data-ttu-id="20716-1226">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1226">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1227">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1227">Constructor</span></span>|<span data-ttu-id="20716-1228">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1228">No</span></span>|<span data-ttu-id="20716-1229">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1229">No</span></span>|  
|<span data-ttu-id="20716-1230">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1230">Field</span></span>|<span data-ttu-id="20716-1231">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1231">No</span></span>|<span data-ttu-id="20716-1232">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1232">Yes.</span></span> <span data-ttu-id="20716-1233">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1233">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1234">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1234">Event</span></span>|<span data-ttu-id="20716-1235">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1235">Not applicable</span></span>|<span data-ttu-id="20716-1236">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1236">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1237">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1237">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1238">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1238">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1239">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1239">Method</span></span>|<span data-ttu-id="20716-1240">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1240">No</span></span>|<span data-ttu-id="20716-1241">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1241">Yes.</span></span> <span data-ttu-id="20716-1242">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1242">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1243">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1243">Nested Type</span></span>|<span data-ttu-id="20716-1244">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1244">No</span></span>|<span data-ttu-id="20716-1245">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1245">No</span></span>|  
|<span data-ttu-id="20716-1246">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1246">Property</span></span>|<span data-ttu-id="20716-1247">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1247">Not applicable</span></span>|<span data-ttu-id="20716-1248">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1248">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1249">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1249">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1250">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1250">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1251">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1251">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1252">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1252">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1253">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1253">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1254">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1254">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1255">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1255">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-1256">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MemberInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1256">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1257">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1257">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1258">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1258">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1259">たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1259">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1260">次の例では、C 文字で始まる `String` クラスのすべてのメンバーを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1260">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1261"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1261"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1262">取得するメンバーの名前を含む文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1262">The string containing the name of the members to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1263">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1263">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1264">または</span><span class="sxs-lookup"><span data-stu-id="20716-1264">-or-</span></span> 
 <span data-ttu-id="20716-1265">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1265"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-1266">指定したバインディング制約を使用して、指定したメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1266">Searches for the specified members, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1267">指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1267">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1268">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-1268">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="20716-1269">メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1269">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="20716-1270"><xref:System.Type.GetMember%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1270">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1271">コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1271">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1272">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1272">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1273">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1273">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1274">パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1274">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="20716-1275">検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1275">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="20716-1276">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1276">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-1277">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1277">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-1278">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-1278">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-1279">単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1279">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1280">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1280">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-1281">このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するには、`name`に対して "static &#124;コンストラクター" を指定し、`Or`の <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> する必要があります。`bindingAttr`</span><span class="sxs-lookup"><span data-stu-id="20716-1281">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="20716-1282"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-1282">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-1283">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MemberInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1283">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1284">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1284">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1285">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1285">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1286">たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1286">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1287">次の例では、C 文字で始まる `myString` クラスのすべてのパブリック静的メンバーを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1287">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1288"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1289">取得するメンバーの名前を含む文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1289">The string containing the name of the members to get.</span></span></param>
        <param name="type"><span data-ttu-id="20716-1290">検索対象の値。</span><span class="sxs-lookup"><span data-stu-id="20716-1290">The value to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1291">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1291">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1292">または</span><span class="sxs-lookup"><span data-stu-id="20716-1292">-or-</span></span> 
 <span data-ttu-id="20716-1293">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1293"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-1294">指定されたバインディング制約を使用して、指定されたメンバー型の指定されたメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1294">Searches for the specified members of the specified member type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1295">指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1295">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1296">メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1296">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="20716-1297"><xref:System.Type.GetMember%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1297">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1298">コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1298">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1299">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1299">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1300">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1300">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1301">パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1301">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="20716-1302">検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1302">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="20716-1303">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1303">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-1304">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1304">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-1305">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-1305">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-1306">単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1306">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1307">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1307">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-1308">このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するには、`name`の場合は "static コンストラクター"、`type`&#124;の場合は <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> の場合は <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>(`Or`で <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定する必要があります。`bindingAttr`</span><span class="sxs-lookup"><span data-stu-id="20716-1308">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="20716-1309"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-1309">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-1310">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MemberInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1310">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1311">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1311">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1312">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1312">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1313">たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1313">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1314">次の例では、C 文字で始まる `myString` クラスのすべてのメソッドが表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1314">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1315"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1315"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-1316">派生クラスにより実装が提供される必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1316">A derived class must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1317">現在の <see cref="T:System.Type" /> のメンバー (プロパティ、メソッド、フィールド、イベントなど) を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1317">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1318">現在の <see cref="T:System.Type" /> のすべてのパブリック メンバーを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1318">Returns all the public members of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-1319">現在の <see cref="T:System.Reflection.MemberInfo" /> のすべてのパブリック メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1319">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="20716-1320">または</span><span class="sxs-lookup"><span data-stu-id="20716-1320">-or-</span></span> 
<span data-ttu-id="20716-1321">現在の <see cref="T:System.Reflection.MemberInfo" /> にパブリック メンバーが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1321">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="20716-1322">メンバーには、プロパティ、メソッド、コンストラクター、フィールド、イベント、および入れ子にされた型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1322">Members include properties, methods, constructors, fields, events, and nested types.</span></span>
  
 <span data-ttu-id="20716-1323"><xref:System.Type.GetMembers%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1323">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1324">コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1324">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1325">このメソッドオーバーロードは、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>で `Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>) を使用して <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> メソッドのオーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-1325">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-1326">クラス初期化子 (静的コンストラクター) は見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1326">It will not find class initializers (static constructors).</span></span> <span data-ttu-id="20716-1327">クラス初期化子を検索するには、<xref:System.Type.GetMembers(System.Reflection.BindingFlags)> のオーバーロードを&#124;呼び出し、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1327">To find class initializers, call the <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> overload, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-1328"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-1328">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-1329">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1329">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1330">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1330">Member Type</span></span>|<span data-ttu-id="20716-1331">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1331">Static</span></span>|<span data-ttu-id="20716-1332">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1332">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1333">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1333">Constructor</span></span>|<span data-ttu-id="20716-1334">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1334">No</span></span>|<span data-ttu-id="20716-1335">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1335">No</span></span>|  
|<span data-ttu-id="20716-1336">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1336">Field</span></span>|<span data-ttu-id="20716-1337">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1337">No</span></span>|<span data-ttu-id="20716-1338">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1338">Yes.</span></span> <span data-ttu-id="20716-1339">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1339">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1340">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1340">Event</span></span>|<span data-ttu-id="20716-1341">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1341">Not applicable</span></span>|<span data-ttu-id="20716-1342">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1342">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1343">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1343">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1344">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1344">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1345">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1345">Method</span></span>|<span data-ttu-id="20716-1346">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1346">No</span></span>|<span data-ttu-id="20716-1347">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1347">Yes.</span></span> <span data-ttu-id="20716-1348">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1348">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1349">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1349">Nested Type</span></span>|<span data-ttu-id="20716-1350">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1350">No</span></span>|<span data-ttu-id="20716-1351">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1351">No</span></span>|  
|<span data-ttu-id="20716-1352">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1352">Property</span></span>|<span data-ttu-id="20716-1353">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1353">Not applicable</span></span>|<span data-ttu-id="20716-1354">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1354">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1355">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1355">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1356">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1356">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1357">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1357">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1358">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1358">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1359">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1359">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1360">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1360">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1361">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1361">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-1362">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MemberInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1362">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1363">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1363">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="20716-1364">次のコード例は、<xref:System.Type.GetMembers> メソッドのオーバーロードを使用して、指定したクラスのすべてのパブリックメンバーに関する情報を収集する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1364">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-1365">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1365">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1366">または</span><span class="sxs-lookup"><span data-stu-id="20716-1366">-or-</span></span> 
 <span data-ttu-id="20716-1367">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1367"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-1368">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1368">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1369">現在の <see cref="T:System.Reflection.MemberInfo" /> に対して定義されているメンバーのうち、指定したバインディング制約に一致するすべてのメンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1369">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="20716-1370">または</span><span class="sxs-lookup"><span data-stu-id="20716-1370">-or-</span></span> 
<span data-ttu-id="20716-1371">現在の <see cref="T:System.Type" /> に対してメンバーが定義されていないか、または定義されているメンバーの中にバインディング制約に一致するものが存在しない場合は、空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1371">An empty array if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="20716-1372">メンバーには、プロパティ、メソッド、コンストラクター、フィールド、イベント、および入れ子にされた型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1372">Members include properties, methods, constructors, fields, events, and nested types.</span></span>

<span data-ttu-id="20716-1373">`GetMethods(BindingFlags)` オーバーロードでメソッド情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>を含める必要があります。また、少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1373">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20716-1374">唯一の例外は <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>を使用したメソッド呼び出しで、入れ子になった型に関するメンバー情報が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1374">The sole exception is a method call with <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, which returns member information about nested types.</span></span>

<span data-ttu-id="20716-1375">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1375">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span> 

- <span data-ttu-id="20716-1376">インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1376">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="20716-1377">静的メソッドを含めるには `BindingFlags.Static` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1377">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="20716-1378">検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1378">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="20716-1379">検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1379">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="20716-1380">基底クラスのプロテクトメソッドと内部メソッドのみが返されます。基底クラスのプライベートメソッドは返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1380">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="20716-1381">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1381">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="20716-1382">空の <xref:System.Reflection.MethodInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1382">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>

<span data-ttu-id="20716-1383">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1383">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="20716-1384">単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1384">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
<span data-ttu-id="20716-1385">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1385">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="20716-1386"><xref:System.Type.GetMembers%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1386">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1387">コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1387">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  

 <span data-ttu-id="20716-1388">このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1388">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="20716-1389"><xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-1389">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="20716-1390">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MemberInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1390">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1391">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1391">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  

## Examples  
 <span data-ttu-id="20716-1392">次のコード例は、<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> メソッドオーバーロードを使用して、指定したクラスのすべてのパブリックインスタンスメンバーに関する情報を収集する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1392">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1393">現在の <see cref="T:System.Type" /> の特定のメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1393">Gets a specific method of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1394">取得するパブリック メソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1394">The string containing the name of the public method to get.</span></span></param>
        <summary><span data-ttu-id="20716-1395">指定した名前のパブリック メソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1395">Searches for the public method with the specified name.</span></span></summary>
        <returns><span data-ttu-id="20716-1396">指定した名前のパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1396">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1397">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1397">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-1398">検索には、パブリックの静的およびパブリックインスタンスメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-1398">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="20716-1399">メソッドがオーバーロードされ、複数のパブリックメソッドがある場合、<xref:System.Type.GetMethod%28System.String%29> メソッドは <xref:System.Reflection.AmbiguousMatchException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-1399">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="20716-1400">次の例では、<xref:System.Int32.ToString%2A?displayProperty=nameWithType> メソッドのパブリックオーバーロードが複数存在するため、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1400">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="20716-1401">一方、`Person.ToString` メソッドは <xref:System.Object.ToString%2A?displayProperty=nameWithType> をオーバーライドするため、オーバーロードされないため、<xref:System.Type.GetMethod%28System.String%29> メソッドは <xref:System.Reflection.MethodInfo> オブジェクトを取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1401">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="20716-1402">次のいずれかを実行して、特定のメソッドを取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1402">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="20716-1403"><xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> メソッドを呼び出し、メソッドを一意に識別する `bindingAttr` 引数を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1403">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="20716-1404">たとえば、型に静的およびインスタンスオーバーロードがあるために例外がスローされた場合は、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>の `bindingAttr` 引数を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1404">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="20716-1405">メソッドのパラメーターの型を定義する `types` パラメーターを含む <xref:System.Type.GetMethod%2A> メソッドのオーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-1405">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="20716-1406"><xref:System.Type.GetMethods> メソッドを呼び出して、型に属するすべてのパブリックメソッドを含む配列を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1406">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="20716-1407">その後、それを反復処理して、`name`という名前の重複するメソッドを識別できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1407">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="20716-1408">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1408">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1409">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1409">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1410">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1410">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1411">たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1411">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1412">次の例では、`MethodA`という名前のメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1412">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1413">指定した名前のメソッドが複数個見つかりました。</span><span class="sxs-lookup"><span data-stu-id="20716-1413">More than one method is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1414"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1414"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1415">取得するメソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1415">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1416">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1416">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1417">または</span><span class="sxs-lookup"><span data-stu-id="20716-1417">-or-</span></span> 
 <span data-ttu-id="20716-1418"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1418"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="20716-1419">指定したバインディング制約を使用して、指定したメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1419">Searches for the specified method, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1420">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1420">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1421">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1421">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1422">戻り値を取得するには、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> または <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1422">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1423">検索にパブリックメソッドを含めるには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1423">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="20716-1424">検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1424">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="20716-1425"><xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1425">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-1426">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1426">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-1428">単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> します。</span><span class="sxs-lookup"><span data-stu-id="20716-1428"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1429">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-1430">メソッドがオーバーロードされ、複数のオーバーロードが `bindingAttr` 引数で指定された制約を満たしている場合、メソッドは <xref:System.Reflection.AmbiguousMatchException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-1430">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="20716-1431">次の例では、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1431">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="20716-1432">`TestClass` 型には、`DisplayValue` メソッド、`DisplayValue(String)`、および `DisplayValue(String, Object[])`の2つのパブリックインスタンスオーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-1432">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="20716-1433">`TestClass` 型には、`Equals` メソッドの2つのパブリックインスタンスオーバーロードがあります。1つは <xref:System.Object>: `Equals(TestClass)` および `Equals(Object)`から継承されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1433">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="20716-1434">次のいずれかを実行して、特定のメソッドを取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1434">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="20716-1435">バインド制約を変更します。</span><span class="sxs-lookup"><span data-stu-id="20716-1435">Change the binding constraints.</span></span> <span data-ttu-id="20716-1436">前の例では、型によって宣言され、継承されていないメソッド `Equals` パブリックインスタンスを取得しようとすると、`Equals(TestClass)`が正常に取得されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1436">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="20716-1437">メソッドのパラメーターの型を定義する `types` パラメーターを含む <xref:System.Type.GetMethod%2A> メソッドのオーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-1437">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="20716-1438"><xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> メソッドを呼び出して、指定したバインディング属性を持つ型に属するすべてのメソッドを含む配列を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1438">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="20716-1439">その後、それを反復処理して、`name`という名前の重複するメソッドを識別できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1439">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="20716-1440">この方法は、前の例の <xref:System.Reflection.AmbiguousMatchException> 例外のハンドラーに示されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1440">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="20716-1441">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1441">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1442">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1442">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1443">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1443">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1444">たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1444">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1445">次の例では、指定したバインディングフラグと一致するメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1445">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1446">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-1446">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1447"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1447"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1448">取得するパブリック メソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1448">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1449">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1449">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="20716-1450">または</span><span class="sxs-lookup"><span data-stu-id="20716-1450">-or-</span></span> 
<span data-ttu-id="20716-1451">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1451">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="20716-1452">指定したパブリック メソッドのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1452">Searches for the specified public method whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="20716-1453">指定した引数型と一致するパラメーターが設定されたパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1453">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1454">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1454">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-1455">検索には、パブリックの静的およびパブリックインスタンスメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-1455">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1456">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1456">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-1457">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-1457">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-1458">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1458">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1459">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1459">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1460">`name` パラメーターに型引数を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1460">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="20716-1461">たとえば、コード `GetMethod("MyGenericMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyGenericMethod` という名前のメソッドではなく、テキスト名が "`MyGenericMethod<int>`" のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1461">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="20716-1462">代わりに、`types` 配列内の適切なパラメーターを指定して `GetMethod("MyGenericMethod")` を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-1462">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1463">次の例では、さまざまな引数の型を指定して、`MethodA`の特定のオーバーロードを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1463">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1464">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] の例では、`/unsafe` コンパイラオプションが必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-1464">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="20716-1465">次の例では、非ジェネリック型 (<xref:System.Collections.ArrayList> クラス) の `Add` メソッド、オープンジェネリック型 (<xref:System.Collections.Generic.List%601> クラス)、およびクローズジェネリック型 (`List(Of String)` 型) を表す <xref:System.Reflection.MethodInfo> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1465">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="20716-1466">この例では、適切な <xref:System.Reflection.MethodInfo> オブジェクトを取得する `GetAddMethod` メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="20716-1466">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="20716-1467">オープンジェネリック型の `types` 引数を指定するには、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-1467">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="20716-1468">クローズジェネリック型の `types` 引数を指定するために、<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1468">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1469">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</span><span class="sxs-lookup"><span data-stu-id="20716-1469">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1470"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1470"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1471">または</span><span class="sxs-lookup"><span data-stu-id="20716-1471">-or-</span></span> 
 <span data-ttu-id="20716-1472"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1472"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1473">または</span><span class="sxs-lookup"><span data-stu-id="20716-1473">-or-</span></span> 
<span data-ttu-id="20716-1474"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1474">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1475"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1475"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1476">取得するパブリック メソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1476">The string containing the name of the public method to get.</span></span></param>
        <param name="genericParameterCount"><span data-ttu-id="20716-1477">メソッドのジェネリック型パラメーターの数。</span><span class="sxs-lookup"><span data-stu-id="20716-1477">The number of generic type parameters of the method.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1478">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1478">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>

<span data-ttu-id="20716-1479">または</span><span class="sxs-lookup"><span data-stu-id="20716-1479">-or-</span></span>

<span data-ttu-id="20716-1480">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1480">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="20716-1481">指定したジェネリック パラメーターの数と引数の型に一致するパラメーターを持つ、指定したパブリック メソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1481">Searches for the specified public method whose parameters match the specified generic parameter count and argument types.</span></span></summary>
        <returns><span data-ttu-id="20716-1482">指定したジェネリック パラメーターの数と引数の型に一致するパラメーターを持つパブリック メソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1482">An object representing the public method whose parameters match the specified generic parameter count and argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1483"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1483"><paramref name="name" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1484">または</span><span class="sxs-lookup"><span data-stu-id="20716-1484">-or-</span></span>

<span data-ttu-id="20716-1485"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1485"><paramref name="types" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1486">または</span><span class="sxs-lookup"><span data-stu-id="20716-1486">-or-</span></span>

<span data-ttu-id="20716-1487"><paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1487">One of the elements in the <paramref name="types" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1488"><paramref name="genericParameterCount" /> は負の値です。</span><span class="sxs-lookup"><span data-stu-id="20716-1488"><paramref name="genericParameterCount" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1489">取得するパブリック メソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1489">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1490">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1490">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="20716-1491">または</span><span class="sxs-lookup"><span data-stu-id="20716-1491">-or-</span></span> 
<span data-ttu-id="20716-1492">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1492">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1493"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1493">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1494">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1494">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="20716-1495">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1495">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1496">指定したパブリック メソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1496">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="20716-1497">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1497">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1498">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1498">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-1499">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1499">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-1500">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1500">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-1501">検索には、パブリックの静的およびパブリックインスタンスメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-1501">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1502">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1502">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-1503">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-1503">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-1504">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1504">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1505">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1505">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1506">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1506">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1507">たとえば、コード `GetMethod("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1507">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="20716-1508">代わりに、`types` 配列内の適切なパラメーターを指定して `GetMethod("MyMethod")` を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-1508">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1509">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</span><span class="sxs-lookup"><span data-stu-id="20716-1509">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1510"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1510"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1511">または</span><span class="sxs-lookup"><span data-stu-id="20716-1511">-or-</span></span> 
 <span data-ttu-id="20716-1512"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1512"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1513">または</span><span class="sxs-lookup"><span data-stu-id="20716-1513">-or-</span></span> 
<span data-ttu-id="20716-1514"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1514">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1515"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1515"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-1516">または</span><span class="sxs-lookup"><span data-stu-id="20716-1516">-or-</span></span> 
 <span data-ttu-id="20716-1517"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1517"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1518">取得するパブリック メソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1518">The string containing the name of the public method to get.</span></span></param>
        <param name="genericParameterCount"><span data-ttu-id="20716-1519">メソッドのジェネリック型パラメーターの数。</span><span class="sxs-lookup"><span data-stu-id="20716-1519">The number of generic type parameters of the method.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1520">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1520">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>

<span data-ttu-id="20716-1521">または</span><span class="sxs-lookup"><span data-stu-id="20716-1521">-or-</span></span>

<span data-ttu-id="20716-1522">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1522">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1523"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1523">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1524">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1524">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="20716-1525">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1525">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1526">指定したジェネリック パラメーターの数、引数の型、および修飾子に一致するパラメーターを持つ、指定したパブリック メソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1526">Searches for the specified public method whose parameters match the specified generic parameter count, argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="20716-1527">指定したジェネリック パラメーターの数、引数の型、および修飾子に一致するパブリック メソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1527">An object representing the public method that matches the specified generic parameter count, argument types and modifiers, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1528"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1528"><paramref name="name" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1529">または</span><span class="sxs-lookup"><span data-stu-id="20716-1529">-or-</span></span>

<span data-ttu-id="20716-1530"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1530"><paramref name="types" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1531">または</span><span class="sxs-lookup"><span data-stu-id="20716-1531">-or-</span></span>

<span data-ttu-id="20716-1532"><paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1532">One of the elements in the <paramref name="types" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1533"><paramref name="genericParameterCount" /> は負の値です。</span><span class="sxs-lookup"><span data-stu-id="20716-1533"><paramref name="genericParameterCount" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags, binder As Binder, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1534">取得するメソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1534">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1535">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1535">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1536">または</span><span class="sxs-lookup"><span data-stu-id="20716-1536">-or-</span></span> 
 <span data-ttu-id="20716-1537"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1537"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-1538">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1538">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-1539">または</span><span class="sxs-lookup"><span data-stu-id="20716-1539">-or-</span></span> 
<span data-ttu-id="20716-1540"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-1540">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1541">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1541">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="20716-1542">または</span><span class="sxs-lookup"><span data-stu-id="20716-1542">-or-</span></span> 
<span data-ttu-id="20716-1543">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1543">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1544"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1544">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1545">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1545">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="20716-1546">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1546">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1547">指定したバインディング制約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1547">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1548">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1548">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1549">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1549">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-1550">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1550">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-1551">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1551">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1552">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1552">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1553">検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1553">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="20716-1554">検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1554">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="20716-1555">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1555">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-1556">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1556">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-1557">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-1557">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-1558">単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1558">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1559">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1559">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1560">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1560">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-1561">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-1561">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-1562">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1562">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1563">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1563">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1564">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1564">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1565">たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1565">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1566">次の例では、バインディング制約とさまざまな引数型を指定して、`MethodA`の特定のオーバーロードを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1566">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1567">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] の例では、`/unsafe` コンパイラオプションが必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-1567">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1568">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-1568">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1569"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1569"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1570">または</span><span class="sxs-lookup"><span data-stu-id="20716-1570">-or-</span></span> 
 <span data-ttu-id="20716-1571"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1571"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1572">または</span><span class="sxs-lookup"><span data-stu-id="20716-1572">-or-</span></span> 
<span data-ttu-id="20716-1573"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1573">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1574"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1574"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-1575">または</span><span class="sxs-lookup"><span data-stu-id="20716-1575">-or-</span></span> 
 <span data-ttu-id="20716-1576"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1576"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, bindingAttr As BindingFlags, binder As Binder, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1577">取得するパブリック メソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1577">The string containing the name of the public method to get.</span></span></param>
        <param name="genericParameterCount"><span data-ttu-id="20716-1578">メソッドのジェネリック型パラメーターの数。</span><span class="sxs-lookup"><span data-stu-id="20716-1578">The number of generic type parameters of the method.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1579">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1579">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="20716-1580">または</span><span class="sxs-lookup"><span data-stu-id="20716-1580">-or-</span></span>

<span data-ttu-id="20716-1581"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1581"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-1582">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1582">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>

<span data-ttu-id="20716-1583">または</span><span class="sxs-lookup"><span data-stu-id="20716-1583">-or-</span></span>

<span data-ttu-id="20716-1584"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-1584">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1585">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1585">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>

<span data-ttu-id="20716-1586">または</span><span class="sxs-lookup"><span data-stu-id="20716-1586">-or-</span></span>

<span data-ttu-id="20716-1587">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1587">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1588"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1588">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1589">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1589">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="20716-1590">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1590">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1591">指定したバインディング制約を使用して、指定したメソッドのうち、指定したジェネリック パラメーターの数、引数の型、および修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1591">Searches for the specified method whose parameters match the specified generic parameter count, argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1592">指定したジェネリック パラメーターの数、引数の型、修飾子、およびバインディングの制約に一致するメソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1592">An object representing the method that matches the specified generic parameter count, argument types, modifiers and binding constraints, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1593"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1593"><paramref name="name" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1594">または</span><span class="sxs-lookup"><span data-stu-id="20716-1594">-or-</span></span>

<span data-ttu-id="20716-1595"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1595"><paramref name="types" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1596">または</span><span class="sxs-lookup"><span data-stu-id="20716-1596">-or-</span></span>

<span data-ttu-id="20716-1597"><paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1597">One of the elements in the <paramref name="types" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1598"><paramref name="genericParameterCount" /> は負の値です。</span><span class="sxs-lookup"><span data-stu-id="20716-1598"><paramref name="genericParameterCount" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1599">取得するメソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1599">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1600">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1600">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1601">または</span><span class="sxs-lookup"><span data-stu-id="20716-1601">-or-</span></span> 
 <span data-ttu-id="20716-1602"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1602"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-1603">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1603">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-1604">または</span><span class="sxs-lookup"><span data-stu-id="20716-1604">-or-</span></span> 
<span data-ttu-id="20716-1605"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-1605">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="20716-1606">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-1606">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1607">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1607">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="20716-1608">または</span><span class="sxs-lookup"><span data-stu-id="20716-1608">-or-</span></span> 
<span data-ttu-id="20716-1609">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1609">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1610"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1610">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1611">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1611">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="20716-1612">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1612">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1613">指定したバインディング制約および指定した呼び出し規約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1613">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="20716-1614">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1614">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1615">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1615">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-1616">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1616">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-1617">次の表は、型に対してリフレクションを行うときに、`GetXXX` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1617">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1618">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1618">Member Type</span></span>|<span data-ttu-id="20716-1619">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1619">Static</span></span>|<span data-ttu-id="20716-1620">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1620">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1621">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1621">Constructor</span></span>|<span data-ttu-id="20716-1622">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1622">No</span></span>|<span data-ttu-id="20716-1623">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1623">No</span></span>|  
|<span data-ttu-id="20716-1624">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1624">Field</span></span>|<span data-ttu-id="20716-1625">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1625">No</span></span>|<span data-ttu-id="20716-1626">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1626">Yes.</span></span> <span data-ttu-id="20716-1627">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1627">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1628">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1628">Event</span></span>|<span data-ttu-id="20716-1629">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1629">Not applicable</span></span>|<span data-ttu-id="20716-1630">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1630">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1631">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1631">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1632">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1632">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1633">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1633">Method</span></span>|<span data-ttu-id="20716-1634">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1634">No</span></span>|<span data-ttu-id="20716-1635">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1635">Yes.</span></span> <span data-ttu-id="20716-1636">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1636">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1637">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1637">Nested Type</span></span>|<span data-ttu-id="20716-1638">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1638">No</span></span>|<span data-ttu-id="20716-1639">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1639">No</span></span>|  
|<span data-ttu-id="20716-1640">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1640">Property</span></span>|<span data-ttu-id="20716-1641">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1641">Not applicable</span></span>|<span data-ttu-id="20716-1642">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1642">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1643">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1643">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1644">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1644">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1645">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1645">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1646">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1646">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1647">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1647">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1648">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1648">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1649">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1649">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-1650">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1650">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1651">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1651">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1652">検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1652">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="20716-1653">検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1653">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="20716-1654">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1654">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-1655">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1655">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-1656">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-1656">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-1657">単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1657">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1658">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1658">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1659">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1659">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-1660">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-1660">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-1661">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1661">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1662">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1662">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1663">ジェネリックメソッドの場合は、`name`に型引数を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1663">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="20716-1664">たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1664">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1665">次の例では、バインディング制約、呼び出し規約、およびさまざまな引数型を指定して、`MethodA`の特定のオーバーロードを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1665">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1666">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] の例では、`/unsafe` コンパイラオプションが必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-1666">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1667">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-1667">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1668"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1668"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1669">または</span><span class="sxs-lookup"><span data-stu-id="20716-1669">-or-</span></span> 
 <span data-ttu-id="20716-1670"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1670"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-1671">または</span><span class="sxs-lookup"><span data-stu-id="20716-1671">-or-</span></span> 
<span data-ttu-id="20716-1672"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1672">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1673"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1673"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-1674">または</span><span class="sxs-lookup"><span data-stu-id="20716-1674">-or-</span></span> 
 <span data-ttu-id="20716-1675"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1675"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1676">取得するパブリック メソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1676">The string containing the name of the public method to get.</span></span></param>
        <param name="genericParameterCount"><span data-ttu-id="20716-1677">メソッドのジェネリック型パラメーターの数。</span><span class="sxs-lookup"><span data-stu-id="20716-1677">The number of generic type parameters of the method.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1678">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1678">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="20716-1679">または</span><span class="sxs-lookup"><span data-stu-id="20716-1679">-or-</span></span>

<span data-ttu-id="20716-1680"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1680"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-1681">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1681">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>

<span data-ttu-id="20716-1682">または</span><span class="sxs-lookup"><span data-stu-id="20716-1682">-or-</span></span>

<span data-ttu-id="20716-1683"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-1683">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="20716-1684">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-1684">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1685">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1685">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>

<span data-ttu-id="20716-1686">または</span><span class="sxs-lookup"><span data-stu-id="20716-1686">-or-</span></span>

<span data-ttu-id="20716-1687">パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</span><span class="sxs-lookup"><span data-stu-id="20716-1687">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1688"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1688">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1689">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1689">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="20716-1690">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1690">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1691">指定したバインディング制約および指定した呼び出し規約を使用して、指定したメソッドのうち、指定したジェネリック パラメーターの数、引数の型、および修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1691">Searches for the specified method whose parameters match the specified generic parameter count, argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="20716-1692">指定したジェネリック パラメーターの数、引数の型、修飾子、バインディングの制約、および呼び出し規約に一致するメソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1692">An object representing the method that matches the specified generic parameter count, argument types, modifiers, binding constraints and calling convention, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1693"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1693"><paramref name="name" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1694">または</span><span class="sxs-lookup"><span data-stu-id="20716-1694">-or-</span></span>

<span data-ttu-id="20716-1695"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1695"><paramref name="types" /> is <see langword="null" />.</span></span>

<span data-ttu-id="20716-1696">または</span><span class="sxs-lookup"><span data-stu-id="20716-1696">-or-</span></span>

<span data-ttu-id="20716-1697"><paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1697">One of the elements in the <paramref name="types" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1698"><paramref name="genericParameterCount" /> は負の値です。</span><span class="sxs-lookup"><span data-stu-id="20716-1698"><paramref name="genericParameterCount" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetMethodImpl (name As String, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1699">取得するメソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1699">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1700">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1700">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1701">または</span><span class="sxs-lookup"><span data-stu-id="20716-1701">-or-</span></span> 
 <span data-ttu-id="20716-1702"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1702"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-1703">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1703">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-1704">または</span><span class="sxs-lookup"><span data-stu-id="20716-1704">-or-</span></span> 
<span data-ttu-id="20716-1705"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-1705">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="20716-1706">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-1706">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1707">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1707">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="20716-1708">または</span><span class="sxs-lookup"><span data-stu-id="20716-1708">-or-</span></span> 
<span data-ttu-id="20716-1709">パラメーターをとらないメソッドを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-1709">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>  
  
<span data-ttu-id="20716-1710">または</span><span class="sxs-lookup"><span data-stu-id="20716-1710">-or-</span></span> 
 <span data-ttu-id="20716-1711">[https://login.microsoftonline.com/consumers/](<see langword="null" />)</span><span class="sxs-lookup"><span data-stu-id="20716-1711"><see langword="null" />.</span></span> <span data-ttu-id="20716-1712"><paramref name="types" /> が<see langword="null" /> の場合、引数は一致していません。</span><span class="sxs-lookup"><span data-stu-id="20716-1712">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1713"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1713">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1714">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1714">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1715">派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1715">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="20716-1716">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1716">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1717">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1717">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-1718">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1718">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-1719">`types` が`null` の場合、引数は一致していません。</span><span class="sxs-lookup"><span data-stu-id="20716-1719">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="20716-1720">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1720">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1721">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1721">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1722">検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1722">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="20716-1723">検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1723">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="20716-1724">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1724">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-1725">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1725">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-1726">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-1726">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-1727">単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1727">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1728">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1728">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-1729">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-1729">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1730"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1730"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-1731"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1731"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-1732">または</span><span class="sxs-lookup"><span data-stu-id="20716-1732">-or-</span></span> 
 <span data-ttu-id="20716-1733"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-1733"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-1734">または</span><span class="sxs-lookup"><span data-stu-id="20716-1734">-or-</span></span> 
 <span data-ttu-id="20716-1735"><paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1735"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-1736">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1736">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl (name As String, genericParameterCount As Integer, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1737">取得するメソッドの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1737">The string containing the name of the method to get.</span></span></param>
        <param name="genericParameterCount"><span data-ttu-id="20716-1738">メソッドのジェネリック型パラメーターの数。</span><span class="sxs-lookup"><span data-stu-id="20716-1738">The number of generic type parameters of the method.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1739">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1739">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="20716-1740">または</span><span class="sxs-lookup"><span data-stu-id="20716-1740">-or-</span></span>

<span data-ttu-id="20716-1741"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1741"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-1742">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-1742">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>

<span data-ttu-id="20716-1743">または</span><span class="sxs-lookup"><span data-stu-id="20716-1743">-or-</span></span>

<span data-ttu-id="20716-1744"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-1744">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="20716-1745">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-1745">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="20716-1746">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1746">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>

<span data-ttu-id="20716-1747">または</span><span class="sxs-lookup"><span data-stu-id="20716-1747">-or-</span></span>

<span data-ttu-id="20716-1748">パラメーターをとらないメソッドを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-1748">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>

<span data-ttu-id="20716-1749">または</span><span class="sxs-lookup"><span data-stu-id="20716-1749">-or-</span></span>

<span data-ttu-id="20716-1750">[https://login.microsoftonline.com/consumers/](<see langword="null" />)</span><span class="sxs-lookup"><span data-stu-id="20716-1750"><see langword="null" />.</span></span> <span data-ttu-id="20716-1751"><paramref name="types" /> が<see langword="null" /> の場合、引数は一致していません。</span><span class="sxs-lookup"><span data-stu-id="20716-1751">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-1752"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1752">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-1753">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1753">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-1754">派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定したジェネリック パラメーターの数、引数の型、修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1754">When overridden in a derived class, searches for the specified method whose parameters match the specified generic parameter count, argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="20716-1755">指定したジェネリック パラメーターの数、引数の型、修飾子、バインディングの制約、および呼び出し規約に一致するメソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1755">An object representing the method that matches the specified generic parameter count, argument types, modifiers, binding constraints and calling convention, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-1756">メソッドはオーバーライドし、派生クラスで呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1756">The method needs to be overriden and called in a derived class.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1757">現在の <see cref="T:System.Type" /> のメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1757">Gets the methods of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1758">現在の <see cref="T:System.Type" /> のすべてのパブリック メソッドを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1758">Returns all the public methods of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-1759">現在の <see cref="T:System.Reflection.MethodInfo" /> に対して定義されているすべてのパブリック メソッドを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1759">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="20716-1760">または</span><span class="sxs-lookup"><span data-stu-id="20716-1760">-or-</span></span> 
<span data-ttu-id="20716-1761">現在の <see cref="T:System.Reflection.MethodInfo" /> に対してパブリック メソッドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1761">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="20716-1762"><xref:System.Type.GetMethods%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメソッドを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1762">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1763">コードは、メソッドが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1763">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1764">コンストラクターは、この呼び出しによって返されるメソッドの配列には含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1764">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="20716-1765">`GetConstructors()` を個別に呼び出して、コンストラクターメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1765">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="20716-1766">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1766">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1767">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1767">Member Type</span></span>|<span data-ttu-id="20716-1768">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1768">Static</span></span>|<span data-ttu-id="20716-1769">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1769">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1770">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1770">Constructor</span></span>|<span data-ttu-id="20716-1771">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1771">No</span></span>|<span data-ttu-id="20716-1772">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1772">No</span></span>|  
|<span data-ttu-id="20716-1773">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1773">Field</span></span>|<span data-ttu-id="20716-1774">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1774">No</span></span>|<span data-ttu-id="20716-1775">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1775">Yes.</span></span> <span data-ttu-id="20716-1776">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1776">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1777">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1777">Event</span></span>|<span data-ttu-id="20716-1778">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1778">Not applicable</span></span>|<span data-ttu-id="20716-1779">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1779">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1780">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1780">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1781">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1781">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1782">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1782">Method</span></span>|<span data-ttu-id="20716-1783">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1783">No</span></span>|<span data-ttu-id="20716-1784">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1784">Yes.</span></span> <span data-ttu-id="20716-1785">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1785">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1786">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1786">Nested Type</span></span>|<span data-ttu-id="20716-1787">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1787">No</span></span>|<span data-ttu-id="20716-1788">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1788">No</span></span>|  
|<span data-ttu-id="20716-1789">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1789">Property</span></span>|<span data-ttu-id="20716-1790">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1790">Not applicable</span></span>|<span data-ttu-id="20716-1791">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1791">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1792">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1792">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1793">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1793">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1794">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1794">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1795">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1795">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1796">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1796">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1797">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1797">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1798">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1798">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1799">コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1799">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="20716-1800">パラメーターを省略できるのは、の呼び出し時だけです。</span><span class="sxs-lookup"><span data-stu-id="20716-1800">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="20716-1801">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MethodInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1801">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-1802">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1802">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-1803">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1803">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="20716-1804">または</span><span class="sxs-lookup"><span data-stu-id="20716-1804">-or-</span></span>

 <span data-ttu-id="20716-1805">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1805"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-1806">派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1806">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1807">現在の <see cref="T:System.Type" /> に対して定義されているメソッドのうち、指定したバインディング制約に一致するすべてのメソッドを表す <see cref="T:System.Reflection.MethodInfo" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1807">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="20716-1808">または</span><span class="sxs-lookup"><span data-stu-id="20716-1808">-or-</span></span> 
<span data-ttu-id="20716-1809">現在の <see cref="T:System.Type" /> に対してメソッドが定義されていないか、または定義されているメソッドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Reflection.MethodInfo" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1809">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="20716-1810">`GetMethods(BindingFlags)` オーバーロードでメソッド情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>を含める必要があります。また、少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1810">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 
  
 <span data-ttu-id="20716-1811">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1811">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
- <span data-ttu-id="20716-1812">インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1812">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="20716-1813">静的メソッドを含めるには `BindingFlags.Static` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1813">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="20716-1814">検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1814">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="20716-1815">検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1815">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="20716-1816">基底クラスのプロテクトメソッドと内部メソッドのみが返されます。基底クラスのプライベートメソッドは返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1816">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="20716-1817">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-1817">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="20716-1818">空の <xref:System.Reflection.MethodInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1818">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>
  
 <span data-ttu-id="20716-1819">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1819">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="20716-1820">単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-1820">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-1821">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1821">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="20716-1822"><xref:System.Type.GetMethods%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメソッドを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1822">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1823">コードは、メソッドが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1823">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  

<span data-ttu-id="20716-1824">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MethodInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1824">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
<span data-ttu-id="20716-1825">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1825">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="20716-1826">次の例では、2つのパブリックメソッドと1つのプロテクトメソッドを持つクラスを作成し、`MyTypeClass`に対応する `Type` オブジェクトを作成し、すべてのパブリックメソッドと非パブリックメソッドを取得し、それらの名前を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1826">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1827">現在の <see cref="T:System.Type" /> 内で入れ子になっている特定の型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1827">Gets a specific type nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1828">取得対象の入れ子にされた型の名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1828">The string containing the name of the nested type to get.</span></span></param>
        <summary><span data-ttu-id="20716-1829">指定した名前を持ち、入れ子にされたパブリックな型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1829">Searches for the public nested type with the specified name.</span></span></summary>
        <returns><span data-ttu-id="20716-1830">存在する場合は、指定された名前を持つ入れ子にされたパブリックな型を表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1830">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1831">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1831">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="20716-1832">`name`には、入れ子になったクラスの簡易名を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-1832">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="20716-1833">外側のクラスの名前で修飾しないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1833">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="20716-1834">入れ子になったジェネリッククラスの場合は、破損した名前を使用します。つまり、アクサングラーブと汎用引数の数を追加します。</span><span class="sxs-lookup"><span data-stu-id="20716-1834">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="20716-1835">たとえば、"Inner\`1" という文字列を使用して、入れ子になったジェネリッククラス `Inner<T>` (Visual Basic では`Inner(Of T)`) を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1835">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="20716-1836">型パラメーターには言語固有の構文を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1836">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="20716-1837">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1837">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1838">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1838">Member Type</span></span>|<span data-ttu-id="20716-1839">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1839">Static</span></span>|<span data-ttu-id="20716-1840">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1840">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1841">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1841">Constructor</span></span>|<span data-ttu-id="20716-1842">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1842">No</span></span>|<span data-ttu-id="20716-1843">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1843">No</span></span>|  
|<span data-ttu-id="20716-1844">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1844">Field</span></span>|<span data-ttu-id="20716-1845">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1845">No</span></span>|<span data-ttu-id="20716-1846">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1846">Yes.</span></span> <span data-ttu-id="20716-1847">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1847">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1848">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1848">Event</span></span>|<span data-ttu-id="20716-1849">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1849">Not applicable</span></span>|<span data-ttu-id="20716-1850">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1850">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1851">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1851">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1852">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1852">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1853">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1853">Method</span></span>|<span data-ttu-id="20716-1854">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1854">No</span></span>|<span data-ttu-id="20716-1855">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1855">Yes.</span></span> <span data-ttu-id="20716-1856">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1856">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1857">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1857">Nested Type</span></span>|<span data-ttu-id="20716-1858">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1858">No</span></span>|<span data-ttu-id="20716-1859">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1859">No</span></span>|  
|<span data-ttu-id="20716-1860">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1860">Property</span></span>|<span data-ttu-id="20716-1861">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1861">Not applicable</span></span>|<span data-ttu-id="20716-1862">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1862">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1863">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1863">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1864">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1864">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1865">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1865">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1866">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1866">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1867">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1867">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1868">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1868">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1869">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1869">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-1870">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1870">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="20716-1871">入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1871">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="20716-1872">これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-1872">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1873">現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。</span><span class="sxs-lookup"><span data-stu-id="20716-1873">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="20716-1874">これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1874">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="20716-1875">入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1875">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1876"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1876"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-1877">取得対象の入れ子にされた型の名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-1877">The string containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-1878">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1878">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1879">または</span><span class="sxs-lookup"><span data-stu-id="20716-1879">-or-</span></span> 
 <span data-ttu-id="20716-1880"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1880"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="20716-1881">派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、指定されている入れ子にされた型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1881">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1882">指定した要件と一致し、入れ子にされた型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1882">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1883">`name`には、入れ子になったクラスの簡易名を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-1883">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="20716-1884">外側のクラスの名前で修飾しないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1884">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="20716-1885">入れ子になったジェネリッククラスの場合は、破損した名前を使用します。つまり、アクサンアクセントとジェネリックパラメーターの数を追加します。</span><span class="sxs-lookup"><span data-stu-id="20716-1885">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="20716-1886">たとえば、"Inner\`1" という文字列を使用して、入れ子になったジェネリッククラス `Inner<T>` (Visual Basic では`Inner(Of T)`) を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1886">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="20716-1887">型パラメーターには言語固有の構文を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-1887">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="20716-1888">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含める入れ子にされた型を定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1888">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1889">戻り値を取得するには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> または <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1889">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1890">検索に入れ子になったパブリック型を含めるには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1890">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="20716-1891">検索で非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている) を含めるには、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1891">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="20716-1892">このメソッドは、現在の型の入れ子にされた型のみを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1892">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="20716-1893">現在の型の基底クラスは検索されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1893">It does not search the base classes of the current type.</span></span> <span data-ttu-id="20716-1894">基底クラスで入れ子になっている型を見つけるには、継承階層を調べて、各レベルで <xref:System.Type.GetNestedType%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1894">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="20716-1895"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1895"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="20716-1896"><xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> フラグまたは <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> フラグだけを指定してこのメソッドを呼び出すと、指定した入れ子にされた型が返され、他のフラグは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1896">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="20716-1897">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1897">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-1898">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1898">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="20716-1899">入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1899">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="20716-1900">これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-1900">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1901">現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。</span><span class="sxs-lookup"><span data-stu-id="20716-1901">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="20716-1902">これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1902">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="20716-1903">入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1903">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-1904"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-1904"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1905">現在の <see cref="T:System.Type" /> 内で入れ子になっている型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1905">Gets the types nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1906">現在の <see cref="T:System.Type" /> 内で入れ子になっているすべてのパブリック型を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1906">Returns the public types nested in the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-1907">現在の <see cref="T:System.Type" /> 内で入れ子になっているパブリック型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、現在の <see cref="T:System.Type" /> で入れ子になっているパブリック型がない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1907">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1908"><xref:System.Type.GetNestedTypes%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序で型を返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1908">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1909">コードは、型が返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1909">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1910">現在の型ですぐに入れ子になっているパブリック型のみが返されます。検索は再帰的ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1910">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="20716-1911">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1911">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1912">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1912">Member Type</span></span>|<span data-ttu-id="20716-1913">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1913">Static</span></span>|<span data-ttu-id="20716-1914">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1914">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1915">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1915">Constructor</span></span>|<span data-ttu-id="20716-1916">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1916">No</span></span>|<span data-ttu-id="20716-1917">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1917">No</span></span>|  
|<span data-ttu-id="20716-1918">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1918">Field</span></span>|<span data-ttu-id="20716-1919">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1919">No</span></span>|<span data-ttu-id="20716-1920">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1920">Yes.</span></span> <span data-ttu-id="20716-1921">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1921">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1922">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1922">Event</span></span>|<span data-ttu-id="20716-1923">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1923">Not applicable</span></span>|<span data-ttu-id="20716-1924">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1924">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1925">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1925">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1926">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1926">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-1927">方法</span><span class="sxs-lookup"><span data-stu-id="20716-1927">Method</span></span>|<span data-ttu-id="20716-1928">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1928">No</span></span>|<span data-ttu-id="20716-1929">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1929">Yes.</span></span> <span data-ttu-id="20716-1930">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-1930">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1931">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-1931">Nested Type</span></span>|<span data-ttu-id="20716-1932">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1932">No</span></span>|<span data-ttu-id="20716-1933">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1933">No</span></span>|  
|<span data-ttu-id="20716-1934">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-1934">Property</span></span>|<span data-ttu-id="20716-1935">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1935">Not applicable</span></span>|<span data-ttu-id="20716-1936">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1936">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-1937">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-1937">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1938">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1938">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-1939">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1939">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-1940">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-1940">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-1941">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1941">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-1942">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-1942">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-1943">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1943">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-1944">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1944">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="20716-1945">入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1945">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="20716-1946">これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-1946">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1947">現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。</span><span class="sxs-lookup"><span data-stu-id="20716-1947">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="20716-1948">これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1948">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="20716-1949">入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1949">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1950">次の例では、入れ子になったクラスと `MyClass`の `struct` を定義し、`MyClass`の型を使用して、入れ子にされた型のオブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1950">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-1951">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-1951">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-1952">または</span><span class="sxs-lookup"><span data-stu-id="20716-1952">-or-</span></span> 
 <span data-ttu-id="20716-1953"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-1953"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="20716-1954">派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> 内で入れ子になっている型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1954">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-1955">指定したバインディング制約と一致する現在の <see cref="T:System.Type" /> で入れ子にされたすべての型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、バインディング制約と一致する入れ子にされた型が見つからない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1955">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1956">入れ子になった型の検索は再帰的ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1956">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="20716-1957"><xref:System.Type.GetNestedTypes%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序で型を返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1957">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1958">コードは、型が返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1958">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1959">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含める入れ子にされた型を定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-1959">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-1960">戻り値を取得するには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> または <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1960">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="20716-1961">検索に入れ子になったパブリック型を含めるには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1961">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="20716-1962">検索で非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている) を含めるには、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-1962">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="20716-1963">このメソッドは、現在の型の入れ子にされた型のみを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1963">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="20716-1964">現在の型の基底クラスは検索されません。</span><span class="sxs-lookup"><span data-stu-id="20716-1964">It does not search the base classes of the current type.</span></span> <span data-ttu-id="20716-1965">基底クラスで入れ子になっている型を見つけるには、継承階層を調べて、各レベルで <xref:System.Type.GetNestedTypes%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1965">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="20716-1966"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1966"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="20716-1967"><xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> フラグまたは <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> フラグだけを指定してこのメソッドを呼び出すと、指定した入れ子にされた型が返され、他のフラグは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="20716-1967">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="20716-1968">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1968">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-1969">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-1969">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="20716-1970">入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1970">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="20716-1971">これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-1971">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-1972">現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。</span><span class="sxs-lookup"><span data-stu-id="20716-1972">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="20716-1973">これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。</span><span class="sxs-lookup"><span data-stu-id="20716-1973">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="20716-1974">入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-1974">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-1975">次の例では、2つの入れ子になったパブリッククラスと2つの入れ子になったプロテクトクラスを作成し、指定されたバインディング制約に一致するクラスの情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-1975">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-1976">現在の <see cref="T:System.Type" /> のプロパティを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-1976">Gets the properties of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-1977">現在の <see cref="T:System.Type" /> のすべてのパブリック プロパティを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-1977">Returns all the public properties of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-1978">現在の <see cref="T:System.Reflection.PropertyInfo" /> のすべてのパブリック プロパティを表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1978">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="20716-1979">または</span><span class="sxs-lookup"><span data-stu-id="20716-1979">-or-</span></span> 
<span data-ttu-id="20716-1980">現在の <see cref="T:System.Reflection.PropertyInfo" /> にパブリック プロパティが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-1980">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-1981">このオーバーロードの呼び出しは、Visual Basic 内の `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` C#と等しい `bindingAttr` 引数を使用して <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> オーバーロードを呼び出すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-1981">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="20716-1982">このメソッドは、すべてのパブリックインスタンスと静的プロパティを返します。このプロパティは、現在の <xref:System.Type> オブジェクトによって表される型と、基本型から継承されたプロパティの両方で定義されます。</span><span class="sxs-lookup"><span data-stu-id="20716-1982">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="20716-1983">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1983">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-1984">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-1984">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-1985"><xref:System.Type.GetProperties%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でプロパティを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-1985">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-1986">コードは、プロパティが返される順序に依存しないようにする必要があります。これは、順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-1986">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="20716-1987">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-1987">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-1988">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-1988">Member Type</span></span>|<span data-ttu-id="20716-1989">静的</span><span class="sxs-lookup"><span data-stu-id="20716-1989">Static</span></span>|<span data-ttu-id="20716-1990">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-1990">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-1991">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-1991">Constructor</span></span>|<span data-ttu-id="20716-1992">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1992">No</span></span>|<span data-ttu-id="20716-1993">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1993">No</span></span>|  
|<span data-ttu-id="20716-1994">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-1994">Field</span></span>|<span data-ttu-id="20716-1995">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-1995">No</span></span>|<span data-ttu-id="20716-1996">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-1996">Yes.</span></span> <span data-ttu-id="20716-1997">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-1997">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-1998">Event</span><span class="sxs-lookup"><span data-stu-id="20716-1998">Event</span></span>|<span data-ttu-id="20716-1999">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-1999">Not applicable</span></span>|<span data-ttu-id="20716-2000">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2000">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2001">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2001">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2002">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2002">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-2003">方法</span><span class="sxs-lookup"><span data-stu-id="20716-2003">Method</span></span>|<span data-ttu-id="20716-2004">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2004">No</span></span>|<span data-ttu-id="20716-2005">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2005">Yes.</span></span> <span data-ttu-id="20716-2006">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2006">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2007">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-2007">Nested Type</span></span>|<span data-ttu-id="20716-2008">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2008">No</span></span>|<span data-ttu-id="20716-2009">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2009">No</span></span>|  
|<span data-ttu-id="20716-2010">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2010">Property</span></span>|<span data-ttu-id="20716-2011">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2011">Not applicable</span></span>|<span data-ttu-id="20716-2012">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2012">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2013">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2013">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2014">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2014">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-2015">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2015">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-2016">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-2016">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-2017">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2017">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2018">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2018">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-2019">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2019">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-2020">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.PropertyInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2020">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2021">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2021">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-2022">`GetProperties` メソッドの使用例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2022">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="20716-2023">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-2023">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="20716-2024">または</span><span class="sxs-lookup"><span data-stu-id="20716-2024">-or-</span></span>

 <span data-ttu-id="20716-2025">空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2025"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="20716-2026">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2026">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-2027">現在の <see cref="T:System.Type" /> のプロパティのうち、指定したバインディング制約に一致するすべてのプロパティを表すオブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2027">An array of objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="20716-2028">または</span><span class="sxs-lookup"><span data-stu-id="20716-2028">-or-</span></span> 
<span data-ttu-id="20716-2029">現在の <see cref="T:System.Reflection.PropertyInfo" /> にプロパティが設定されていないか、またはプロパティの中でバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2029">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="20716-2030">`GetProperties(BindingFlags)` オーバーロードでプロパティ情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、および少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2030">For the `GetProperties(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="20716-2031">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2031">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
- <span data-ttu-id="20716-2032">インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2032">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="20716-2033">静的メソッドを含めるには `BindingFlags.Static` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2033">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="20716-2034">検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2034">Specify `BindingFlags.Public` to include public properties in the search.</span></span> <span data-ttu-id="20716-2035">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2035">A property is considered public to reflection if it has at least one accessor that is public.</span></span> 
  
- <span data-ttu-id="20716-2036">検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2036">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="20716-2037">基底クラスの protected プロパティと internal プロパティのみが返されます。基底クラスのプライベートプロパティは返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2037">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
- <span data-ttu-id="20716-2038">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-2038">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="20716-2039">空の <xref:System.Reflection.PropertyInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2039">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

 <span data-ttu-id="20716-2040">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2040">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="20716-2041">単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-2041">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-2042">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2042">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="20716-2043"><xref:System.Type.GetProperties%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でプロパティを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-2043">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="20716-2044">コードは、プロパティが返される順序に依存しないようにする必要があります。これは、順序が異なるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-2044">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  

 <span data-ttu-id="20716-2045">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.PropertyInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2045">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2046">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2046">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-2047">次の例では、6つのプロパティを含む `PropertyClass` という名前のクラスを定義しています。2つはパブリック、1つはプライベート、1つは保護、1つは内部 (Visual Basic では`Friend`)、もう1つは内部 (Visual Basic では`Protected Friend`) です。</span><span class="sxs-lookup"><span data-stu-id="20716-2047">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="20716-2048">次に、いくつかの基本的なプロパティ情報 (プロパティの名前と型、読み取り/書き込み可能かどうか、および指定されたバインディング制約に一致するプロパティの `get` と `set` のアクセサーの可視性) が表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2048">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-2049">現在の <see cref="T:System.Type" /> の特定のプロパティを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2049">Gets a specific property of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2050">取得するパブリック プロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2050">The string containing the name of the public property to get.</span></span></param>
        <summary><span data-ttu-id="20716-2051">指定した名前のパブリック プロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2051">Searches for the public property with the specified name.</span></span></summary>
        <returns><span data-ttu-id="20716-2052">指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2052">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2053">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2053">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-2054">検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2054">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="20716-2055">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2055">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-2056">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2056">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-2057">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2057">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2058">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2058">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="20716-2059"><xref:System.Reflection.AmbiguousMatchException> が発生する状況には、次のようなものがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2059">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="20716-2060">型には、同じ名前でパラメーターの数が異なる2つのインデックス付きプロパティが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2060">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="20716-2061">あいまいさを解決するには、パラメーターの型を指定する <xref:System.Type.GetProperty%2A> メソッドのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-2061">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="20716-2062">派生型は、`new` 修飾子 (Visual Basic で`Shadows`) を使用して、同じ名前の継承されたプロパティを非表示にするプロパティを宣言します。</span><span class="sxs-lookup"><span data-stu-id="20716-2062">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="20716-2063">あいまいさを解決するには、<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> メソッドオーバーロードを使用し、<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> フラグを追加して、継承されていないメンバーに検索を制限します。</span><span class="sxs-lookup"><span data-stu-id="20716-2063">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="20716-2064">インデクサーと既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2064">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="20716-2065">、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2065">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="20716-2066">たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2066">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="20716-2067">プロパティをオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2067">You can overload the property.</span></span>  
  
 <span data-ttu-id="20716-2068">でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2068">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="20716-2069">既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2069">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="20716-2070">ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2070">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="20716-2071">たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2071">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="20716-2072">以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2072">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="20716-2073">型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-2073">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="20716-2074">型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2074">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-2075">次の例では、ユーザー定義クラスの `Type` オブジェクトを取得し、そのクラスのプロパティを取得して、プロパティ名を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2075">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="20716-2076">内部的には、このプロパティは "Item" という名前でメタデータで参照されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2076">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="20716-2077">リフレクションを使用して `PropertyInfo` を取得しようとすると、`PropertyInfo` プロパティを正しく返すために、この内部名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2077">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2078">指定した名前のプロパティが複数個見つかりました。</span><span class="sxs-lookup"><span data-stu-id="20716-2078">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2079"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2079"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2080">取得するプロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2080">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-2081">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-2081">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-2082">または</span><span class="sxs-lookup"><span data-stu-id="20716-2082">-or-</span></span> 
<span data-ttu-id="20716-2083"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2083"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="20716-2084">指定されたバインディング制約を使用して、指定されたプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2084">Searches for the specified property, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-2085">指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2085">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2086">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2086">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-2087">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2087">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-2088">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2088">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-2089">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2089">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-2090">検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2090">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="20716-2091">検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2091">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="20716-2092">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-2092">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-2093">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2093">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-2094">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-2094">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-2095">単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-2095">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-2096">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2096">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-2097">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2097">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2098">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2098">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="20716-2099"><xref:System.Reflection.AmbiguousMatchException> が発生する状況には、次のようなものがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2099">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="20716-2100">型には、同じ名前でパラメーターの数が異なる2つのインデックス付きプロパティが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2100">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="20716-2101">あいまいさを解決するには、パラメーターの型を指定する <xref:System.Type.GetProperty%2A> メソッドのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-2101">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="20716-2102">派生型は、`new` 修飾子 (Visual Basic で`Shadows`) を使用して、同じ名前の継承されたプロパティを非表示にするプロパティを宣言します。</span><span class="sxs-lookup"><span data-stu-id="20716-2102">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="20716-2103">あいまいさを解決するには、<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> を含めて、継承されていないメンバーだけに検索を制限します。</span><span class="sxs-lookup"><span data-stu-id="20716-2103">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="20716-2104">インデクサーと既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2104">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="20716-2105">、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2105">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="20716-2106">たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2106">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="20716-2107">プロパティをオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2107">You can overload the property.</span></span>  
  
 <span data-ttu-id="20716-2108">でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2108">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="20716-2109">既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2109">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="20716-2110">ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2110">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="20716-2111">たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2111">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="20716-2112">以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2112">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="20716-2113">型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-2113">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="20716-2114">型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2114">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-2115">次の例では、ユーザー定義クラスの型を取得し、そのクラスのプロパティを取得して、指定されたバインディング制約に従ってプロパティ名を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2115">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2116">指定された名前を持ち、指定されたバインディング制約に一致する 1 つ以上のプロパティが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-2116">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2117"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2117"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2118">取得するパブリック プロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2118">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="20716-2119">プロパティの戻り値の型。</span><span class="sxs-lookup"><span data-stu-id="20716-2119">The return type of the property.</span></span></param>
        <summary><span data-ttu-id="20716-2120">指定した名前および戻り値の型を持つパブリック プロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2120">Searches for the public property with the specified name and return type.</span></span></summary>
        <returns><span data-ttu-id="20716-2121">指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2121">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2122">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2122">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-2123">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2123">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-2124">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2124">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-2125">検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2125">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="20716-2126">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2126">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2127">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2127">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="20716-2128">インデクサーと既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2128">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="20716-2129">、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2129">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="20716-2130">たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2130">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="20716-2131">プロパティをオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2131">You can overload the property.</span></span>  
  
 <span data-ttu-id="20716-2132">でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2132">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="20716-2133">既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2133">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="20716-2134">ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2134">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="20716-2135">たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2135">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="20716-2136">以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2136">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="20716-2137">型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-2137">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="20716-2138">型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2138">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-2139">次の例では、1つのプロパティを持つクラスを定義し、プロパティの名前と型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2139">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2140">指定した名前のプロパティが複数個見つかりました。</span><span class="sxs-lookup"><span data-stu-id="20716-2140">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2141"><paramref name="name" /> が <see langword="null" /> であるか、または <paramref name="returnType" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2141"><paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2142">取得するパブリック プロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2142">The string containing the name of the public property to get.</span></span></param>
        <param name="types"><span data-ttu-id="20716-2143">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2143">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="20716-2144">または</span><span class="sxs-lookup"><span data-stu-id="20716-2144">-or-</span></span> 
<span data-ttu-id="20716-2145">インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-2145">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="20716-2146">指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2146">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="20716-2147">指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2147">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2148">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2148">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-2149">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2149">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-2150">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2150">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-2151">検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2151">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="20716-2152">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2152">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2153">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2153">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="20716-2154">インデクサーと既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2154">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="20716-2155">、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2155">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="20716-2156">たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2156">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="20716-2157">プロパティをオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2157">You can overload the property.</span></span>  
  
 <span data-ttu-id="20716-2158">でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2158">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="20716-2159">既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2159">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="20716-2160">ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2160">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="20716-2161">たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2161">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="20716-2162">以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2162">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="20716-2163">型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-2163">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="20716-2164">型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2164">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-2165">次の例では、ユーザー定義クラスの `Type` オブジェクトを取得し、そのクラスのプロパティを取得して、`GetProperty`に渡される引数で指定されたプロパティの名前と型を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2165">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2166">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-2166">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2167"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2167"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-2168">または</span><span class="sxs-lookup"><span data-stu-id="20716-2168">-or-</span></span> 
 <span data-ttu-id="20716-2169"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2169"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2170"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2170"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="20716-2171"><paramref name="types" /> の要素は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2171">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2172">取得するパブリック プロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2172">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="20716-2173">プロパティの戻り値の型。</span><span class="sxs-lookup"><span data-stu-id="20716-2173">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="20716-2174">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2174">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="20716-2175">または</span><span class="sxs-lookup"><span data-stu-id="20716-2175">-or-</span></span> 
<span data-ttu-id="20716-2176">インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-2176">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="20716-2177">指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2177">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="20716-2178">指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2178">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2179">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2179">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-2180">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2180">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-2181">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2181">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-2182">検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2182">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="20716-2183">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2183">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2184">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2184">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="20716-2185">インデクサーと既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2185">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="20716-2186">、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2186">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="20716-2187">たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2187">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="20716-2188">プロパティをオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2188">You can overload the property.</span></span>  
  
 <span data-ttu-id="20716-2189">でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2189">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="20716-2190">既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2190">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="20716-2191">ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2191">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="20716-2192">たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2192">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="20716-2193">以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2193">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="20716-2194">型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-2194">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="20716-2195">型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2195">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2196">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-2196">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2197"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2197"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-2198">または</span><span class="sxs-lookup"><span data-stu-id="20716-2198">-or-</span></span> 
 <span data-ttu-id="20716-2199"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2199"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2200"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2200"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="20716-2201"><paramref name="types" /> の要素は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2201">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2202">取得するパブリック プロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2202">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="20716-2203">プロパティの戻り値の型。</span><span class="sxs-lookup"><span data-stu-id="20716-2203">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="20716-2204">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2204">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="20716-2205">または</span><span class="sxs-lookup"><span data-stu-id="20716-2205">-or-</span></span> 
<span data-ttu-id="20716-2206">インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-2206">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-2207"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2207">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-2208">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2208">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-2209">指定したパブリック プロパティのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2209">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="20716-2210">指定した要件と一致するパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2210">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2211">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2211">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-2212">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2212">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-2213">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2213">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-2214">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2214">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-2215">`name` の検索では大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2215">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="20716-2216">検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2216">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="20716-2217">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2217">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2218">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2218">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="20716-2219">インデクサーと既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2219">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="20716-2220">、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2220">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="20716-2221">たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2221">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="20716-2222">プロパティをオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2222">You can overload the property.</span></span>  
  
 <span data-ttu-id="20716-2223">でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2223">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="20716-2224">既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2224">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="20716-2225">ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2225">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="20716-2226">たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2226">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="20716-2227">以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2227">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="20716-2228">型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-2228">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="20716-2229">型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2229">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-2230">次の例では、`MyPropertyClass`に対応する `Type` オブジェクトを取得し、`GetProperty` メソッドに渡された引数を使用して、このクラスのインデックス付きプロパティを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2230">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2231">指定された名前を持ち、指定された引数の型および修飾子に一致する 2 つ以上のプロパティが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-2231">More than one property is found with the specified name and matching the specified argument types and modifiers.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2232"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2232"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-2233">または</span><span class="sxs-lookup"><span data-stu-id="20716-2233">-or-</span></span> 
 <span data-ttu-id="20716-2234"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2234"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2235"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2235"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-2236">または</span><span class="sxs-lookup"><span data-stu-id="20716-2236">-or-</span></span> 
 <span data-ttu-id="20716-2237"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2237"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-2238">または</span><span class="sxs-lookup"><span data-stu-id="20716-2238">-or-</span></span> 
 <span data-ttu-id="20716-2239"><paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2239"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="20716-2240"><paramref name="types" /> の要素は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2240">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags, binder As Binder, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2241">取得するプロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2241">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-2242">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-2242">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-2243">または</span><span class="sxs-lookup"><span data-stu-id="20716-2243">-or-</span></span> 
 <span data-ttu-id="20716-2244"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2244"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-2245">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2245">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-2246">または</span><span class="sxs-lookup"><span data-stu-id="20716-2246">-or-</span></span> 
<span data-ttu-id="20716-2247"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-2247">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="20716-2248">プロパティの戻り値の型。</span><span class="sxs-lookup"><span data-stu-id="20716-2248">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="20716-2249">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2249">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="20716-2250">または</span><span class="sxs-lookup"><span data-stu-id="20716-2250">-or-</span></span> 
<span data-ttu-id="20716-2251">インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-2251">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-2252"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2252">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-2253">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2253">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-2254">指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定された指定のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2254">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-2255">指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2255">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2256">パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2256">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="20716-2257">それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2257">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="20716-2258">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2258">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-2259">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2259">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-2260">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2260">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-2261">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-2261">Member Type</span></span>|<span data-ttu-id="20716-2262">静的</span><span class="sxs-lookup"><span data-stu-id="20716-2262">Static</span></span>|<span data-ttu-id="20716-2263">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-2263">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-2264">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-2264">Constructor</span></span>|<span data-ttu-id="20716-2265">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2265">No</span></span>|<span data-ttu-id="20716-2266">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2266">No</span></span>|  
|<span data-ttu-id="20716-2267">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-2267">Field</span></span>|<span data-ttu-id="20716-2268">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2268">No</span></span>|<span data-ttu-id="20716-2269">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2269">Yes.</span></span> <span data-ttu-id="20716-2270">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2270">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2271">Event</span><span class="sxs-lookup"><span data-stu-id="20716-2271">Event</span></span>|<span data-ttu-id="20716-2272">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2272">Not applicable</span></span>|<span data-ttu-id="20716-2273">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2273">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2274">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2274">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2275">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2275">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-2276">方法</span><span class="sxs-lookup"><span data-stu-id="20716-2276">Method</span></span>|<span data-ttu-id="20716-2277">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2277">No</span></span>|<span data-ttu-id="20716-2278">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2278">Yes.</span></span> <span data-ttu-id="20716-2279">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2279">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2280">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-2280">Nested Type</span></span>|<span data-ttu-id="20716-2281">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2281">No</span></span>|<span data-ttu-id="20716-2282">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2282">No</span></span>|  
|<span data-ttu-id="20716-2283">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2283">Property</span></span>|<span data-ttu-id="20716-2284">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2284">Not applicable</span></span>|<span data-ttu-id="20716-2285">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2285">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2286">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2286">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2287">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2287">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-2288">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2288">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-2289">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-2289">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-2290">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2290">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2291">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2291">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-2292">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2292">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-2293">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2293">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-2294">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2294">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-2295">検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2295">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="20716-2296">検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2296">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="20716-2297">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-2297">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-2298">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2298">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-2299">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-2299">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-2300">単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-2300">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-2301">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2301">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-2302">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2302">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="20716-2303">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2303">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="20716-2304">インデクサーと既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2304">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="20716-2305">、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2305">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="20716-2306">たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2306">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="20716-2307">プロパティをオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2307">You can overload the property.</span></span>  
  
 <span data-ttu-id="20716-2308">でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2308">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="20716-2309">既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2309">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="20716-2310">ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2310">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="20716-2311">たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2311">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="20716-2312">以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2312">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="20716-2313">型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-2313">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="20716-2314">型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2314">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2315">指定された名前を持ち、指定されたバインディング制約に一致する 1 つ以上のプロパティが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-2315">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2316"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2316"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-2317">または</span><span class="sxs-lookup"><span data-stu-id="20716-2317">-or-</span></span> 
 <span data-ttu-id="20716-2318"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2318"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2319"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2319"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-2320">または</span><span class="sxs-lookup"><span data-stu-id="20716-2320">-or-</span></span> 
 <span data-ttu-id="20716-2321"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2321"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-2322">または</span><span class="sxs-lookup"><span data-stu-id="20716-2322">-or-</span></span> 
 <span data-ttu-id="20716-2323"><paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2323"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="20716-2324"><paramref name="types" /> の要素は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2324">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPropertyImpl (name As String, bindingAttr As BindingFlags, binder As Binder, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-2325">取得するプロパティの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-2325">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="20716-2326">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-2326">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="20716-2327">または</span><span class="sxs-lookup"><span data-stu-id="20716-2327">-or-</span></span> 
 <span data-ttu-id="20716-2328"><see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2328"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-2329">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメンバーの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2329">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-2330">または</span><span class="sxs-lookup"><span data-stu-id="20716-2330">-or-</span></span> 
<span data-ttu-id="20716-2331"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-2331">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="20716-2332">プロパティの戻り値の型。</span><span class="sxs-lookup"><span data-stu-id="20716-2332">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="20716-2333">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2333">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="20716-2334">または</span><span class="sxs-lookup"><span data-stu-id="20716-2334">-or-</span></span> 
<span data-ttu-id="20716-2335">インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</span><span class="sxs-lookup"><span data-stu-id="20716-2335">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-2336"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2336">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="20716-2337">既定のバインダーでは、このパラメーターは処理されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2337">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="20716-2338">派生クラスによってオーバーライドされるときに、指定のバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されたプロパティを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2338">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="20716-2339">指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2339">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2340">既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2340">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="20716-2341">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2341">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-2342">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2342">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-2343">戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2343">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="20716-2344">検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2344">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="20716-2345">検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2345">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="20716-2346">`BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-2346">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="20716-2347">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2347">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-2348">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-2348">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-2349">単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-2349">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-2350">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2350">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-2351">指定された名前を持ち、指定されたバインディング制約に一致する 1 つ以上のプロパティが存在します。</span><span class="sxs-lookup"><span data-stu-id="20716-2351">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2352"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2352"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-2353">または</span><span class="sxs-lookup"><span data-stu-id="20716-2353">-or-</span></span> 
 <span data-ttu-id="20716-2354"><paramref name="types" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2354"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-2355">または</span><span class="sxs-lookup"><span data-stu-id="20716-2355">-or-</span></span> 
<span data-ttu-id="20716-2356"><paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2356">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2357"><paramref name="types" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2357"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-2358">または</span><span class="sxs-lookup"><span data-stu-id="20716-2358">-or-</span></span> 
 <span data-ttu-id="20716-2359"><paramref name="modifiers" /> に多次元配列が設定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2359"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="20716-2360">または</span><span class="sxs-lookup"><span data-stu-id="20716-2360">-or-</span></span> 
 <span data-ttu-id="20716-2361"><paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2361"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-2362">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" />、または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2362">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-2363">指定された型を表す <see cref="T:System.Type" /> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2363">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-2364">現在の <see cref="T:System.Type" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2364">Gets the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-2365">現在の <see cref="T:System.Type" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2365">The current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-2366">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-2366">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-2367">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-2367">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="20716-2368">取得する型のアセンブリ修飾名。</span><span class="sxs-lookup"><span data-stu-id="20716-2368">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="20716-2369">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Type.AssemblyQualifiedName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="20716-2369">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="20716-2370">型が現在実行されているアセンブリ内または mscorlib.dll/System.Private.CoreLib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="20716-2370">If the type is in the currently executing assembly or in mscorlib.dll/System.Private.CoreLib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <summary><span data-ttu-id="20716-2371">大文字と小文字を区別する検索を実行して、指定した名前の <see cref="T:System.Type" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2371">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="20716-2372">存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2372">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2373">アセンブリ修飾名がわかっている場合は、<xref:System.Type.GetType%2A> メソッドを使用して、別のアセンブリ内の型の <xref:System.Type> オブジェクトを取得できます。これは <xref:System.Type.AssemblyQualifiedName>から取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2373">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="20716-2374"><xref:System.Type.GetType%2A> により、`typeName`で指定されたアセンブリの読み込みが発生します。</span><span class="sxs-lookup"><span data-stu-id="20716-2374"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="20716-2375"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> メソッドを使用して <xref:System.Type> オブジェクトを取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2375">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="20716-2376">コンパイル時にプログラムによって認識されるアセンブリに型が含まれている場合は、のC# `typeof`、または Visual Basic の `GetType` 演算子を使用する方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="20716-2376">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="20716-2377">`typeName` が見つからない場合、<xref:System.Type.GetType%28System.String%29> メソッドを呼び出すと `null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2377">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="20716-2378">例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="20716-2378">It does not throw an exception.</span></span> <span data-ttu-id="20716-2379">例外がスローされるかどうかを制御するには、`throwOnError` パラメーターを持つ <xref:System.Type.GetType%2A> メソッドのオーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-2379">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="20716-2380"><xref:System.Type.GetType%2A> は、ディスクから読み込まれたアセンブリに対してのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="20716-2380"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="20716-2381"><xref:System.Reflection.Emit> サービスを使用して定義された動的アセンブリで定義されている型を検索するために <xref:System.Type.GetType%2A> を呼び出すと、一貫性のない動作が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2381">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="20716-2382">動作は、動的アセンブリが永続的であるかどうか、つまり、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 列挙体の `RunAndSave` アクセスモードまたは `Save` アクセスモードを使用して作成されたものかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="20716-2382">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="20716-2383">動的アセンブリが永続的で、`GetType` が呼び出される前にディスクに書き込まれた場合、ローダーはディスク上に保存されているアセンブリを検索し、そのアセンブリを読み込み、そのアセンブリから型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2383">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="20716-2384">`GetType` が呼び出されたときにアセンブリがディスクに保存されていない場合、メソッドは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2384">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="20716-2385">`GetType` は、一時的な動的アセンブリを認識しません。したがって、一時動的アセンブリの型を取得するために `GetType` を呼び出すと、`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2385">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="20716-2386">動的モジュールで `GetType` を使用するには、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントをサブスクライブして、保存する前に `GetType` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-2386">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="20716-2387">それ以外の場合は、メモリ内のアセンブリのコピーが2つ取得されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2387">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="20716-2388">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2388">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-2389">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-2389">Member Type</span></span>|<span data-ttu-id="20716-2390">静的</span><span class="sxs-lookup"><span data-stu-id="20716-2390">Static</span></span>|<span data-ttu-id="20716-2391">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-2391">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-2392">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-2392">Constructor</span></span>|<span data-ttu-id="20716-2393">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2393">No</span></span>|<span data-ttu-id="20716-2394">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2394">No</span></span>|  
|<span data-ttu-id="20716-2395">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-2395">Field</span></span>|<span data-ttu-id="20716-2396">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2396">No</span></span>|<span data-ttu-id="20716-2397">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2397">Yes.</span></span> <span data-ttu-id="20716-2398">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2398">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2399">Event</span><span class="sxs-lookup"><span data-stu-id="20716-2399">Event</span></span>|<span data-ttu-id="20716-2400">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2400">Not applicable</span></span>|<span data-ttu-id="20716-2401">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2401">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2402">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2402">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2403">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2403">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-2404">方法</span><span class="sxs-lookup"><span data-stu-id="20716-2404">Method</span></span>|<span data-ttu-id="20716-2405">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2405">No</span></span>|<span data-ttu-id="20716-2406">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2406">Yes.</span></span> <span data-ttu-id="20716-2407">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2407">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2408">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-2408">Nested Type</span></span>|<span data-ttu-id="20716-2409">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2409">No</span></span>|<span data-ttu-id="20716-2410">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2410">No</span></span>|  
|<span data-ttu-id="20716-2411">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2411">Property</span></span>|<span data-ttu-id="20716-2412">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2412">Not applicable</span></span>|<span data-ttu-id="20716-2413">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2413">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2414">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2414">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2415">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2415">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-2416">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2416">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-2417">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-2417">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-2418">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2418">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2419">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2419">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-2420">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2420">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-2421">配列または COM 型は、使用可能なクラスのテーブルに既に読み込まれていない限り、検索されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2421">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="20716-2422">`typeName` には、名前空間で修飾された型名か、アセンブリ名の指定を含むアセンブリ修飾名を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2422">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="20716-2423">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Type.AssemblyQualifiedName%2A>) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="20716-2423">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="20716-2424">名前空間が含まれているがアセンブリ名を含まない `typeName`、このメソッドは、呼び出し元のオブジェクトのアセンブリと mscorlib.dll/System.private.corelib をこの順序で検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2424">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and mscorlib.dll/System.Private.CoreLib.dll, in that order.</span></span> <span data-ttu-id="20716-2425">TypeName が部分的または完全なアセンブリ名で完全修飾されている場合、このメソッドは指定されたアセンブリを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2425">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="20716-2426">アセンブリに厳密な名前が付いている場合は、完全なアセンブリ名が必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-2426">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="20716-2427"><xref:System.Type.AssemblyQualifiedName%2A> プロパティは、入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2427">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="20716-2428">共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。</span><span class="sxs-lookup"><span data-stu-id="20716-2428">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2429">.NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="20716-2429">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="20716-2430">たとえば、"ProcessorArchitecture = msil" のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-2430">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="20716-2431">ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-2431">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="20716-2432"><xref:System.Reflection.AssemblyName> オブジェクトを作成し、それを <xref:System.Reflection.Assembly.Load%2A> メソッドの適切なオーバーロードに渡すことによって、型を読み込むこともできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2432">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="20716-2433">その後、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを使用して、アセンブリから型を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2433">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="20716-2434"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType> も参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2434">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="20716-2435">区切り記号</span><span class="sxs-lookup"><span data-stu-id="20716-2435">Delimiter</span></span>|<span data-ttu-id="20716-2436">意味</span><span class="sxs-lookup"><span data-stu-id="20716-2436">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="20716-2437">円記号 (\\)</span><span class="sxs-lookup"><span data-stu-id="20716-2437">Backslash (\\)</span></span>|<span data-ttu-id="20716-2438">エスケープ文字。</span><span class="sxs-lookup"><span data-stu-id="20716-2438">Escape character.</span></span>|  
|<span data-ttu-id="20716-2439">バックティック (')</span><span class="sxs-lookup"><span data-stu-id="20716-2439">Backtick (\`)</span></span>|<span data-ttu-id="20716-2440">ジェネリック型の名前の末尾にある型パラメーターの数を表す1桁以上の数字に先行します。</span><span class="sxs-lookup"><span data-stu-id="20716-2440">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="20716-2441">角かっこ ([])</span><span class="sxs-lookup"><span data-stu-id="20716-2441">Brackets ([])</span></span>|<span data-ttu-id="20716-2442">構築されたジェネリック型のジェネリック型引数リストを囲みます。型引数リスト内で、アセンブリ修飾型を囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-2442">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="20716-2443">コンマ (,)</span><span class="sxs-lookup"><span data-stu-id="20716-2443">Comma (,)</span></span>|<span data-ttu-id="20716-2444">アセンブリ名の前に指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2444">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="20716-2445">ピリオド (.)</span><span class="sxs-lookup"><span data-stu-id="20716-2445">Period (.)</span></span>|<span data-ttu-id="20716-2446">名前空間識別子を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2446">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="20716-2447">プラス記号 (+)</span><span class="sxs-lookup"><span data-stu-id="20716-2447">Plus sign (+)</span></span>|<span data-ttu-id="20716-2448">入れ子になったクラスの前に置きます。</span><span class="sxs-lookup"><span data-stu-id="20716-2448">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="20716-2449">たとえば、クラスの完全修飾名は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-2449">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="20716-2450">名前空間が TopNamespace. Sub + 名前空間の場合、文字列は、入れ子の区切り記号として解釈されないように、正符号 (+) の前にエスケープ文字 (\\) を付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2450">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="20716-2451">リフレクションは、この文字列を次のように出力します。</span><span class="sxs-lookup"><span data-stu-id="20716-2451">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="20716-2452">"+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。</span><span class="sxs-lookup"><span data-stu-id="20716-2452">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="20716-2453">この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2453">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="20716-2454"><xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-2454">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="20716-2455">型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2455"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="20716-2456">アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2456"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="20716-2457">型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2457">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="20716-2458">末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。</span><span class="sxs-lookup"><span data-stu-id="20716-2458">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="20716-2459">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</span><span class="sxs-lookup"><span data-stu-id="20716-2459">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="20716-2460">アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2460">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="20716-2461">ジェネリック型の名前は、バックティック (\`) で終わり、その後にジェネリック型引数の数を表す数字が続きます。</span><span class="sxs-lookup"><span data-stu-id="20716-2461">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="20716-2462">この名前の変形の目的は、同じスコープで発生する、同じ名前で型パラメーターの数が異なるジェネリック型をコンパイラがサポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="20716-2462">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="20716-2463">たとえば、リフレクションは、`Tuple(Of T0, T1)` 内のジェネリックメソッド `Tuple(Of T)` および Visual Basic、またはビジュアルC#内の `Tuple<T>` と組`\<T0, T1>` で、`Tuple`1` and `タプル`2` から破損した名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2463">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="20716-2464">ジェネリック型の場合、型引数リストは角かっこで囲まれ、型引数はコンマで区切られます。</span><span class="sxs-lookup"><span data-stu-id="20716-2464">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="20716-2465">たとえば、ジェネリック <xref:System.Collections.Generic.Dictionary%602> には、2つの型パラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2465">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="20716-2466"><xref:System.String> 型のキーを持つ `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように表されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2466">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="20716-2467">型引数リスト内でアセンブリ修飾型を指定するには、アセンブリ修飾型を角かっこで囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-2467">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="20716-2468">それ以外の場合、アセンブリ修飾名の一部を区切るコンマは、追加の型引数の区切りとして解釈されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2468">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="20716-2469">たとえば、`MyType` の <xref:System.Collections.Generic.Dictionary%602> を <xref:System.String>型のキーと共に次のように指定することができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2469">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="20716-2470">アセンブリ修飾型は、型パラメーターリスト内に出現する場合にのみ、角かっこで囲むことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2470">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="20716-2471">型パラメーターリスト内の修飾型および非修飾型のアセンブリを検索するための規則は、修飾された非修飾の非ジェネリック型の規則と同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-2471">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="20716-2472">Null 許容型は、ジェネリック型の特殊なケースです。</span><span class="sxs-lookup"><span data-stu-id="20716-2472">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="20716-2473">たとえば、null 値が許容される <xref:System.Int32> は、"System. Nullable ' 1 [system.string]" という文字列で表されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2473">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2474">、 C# C++、Visual Basic では、型演算子を使用して null 許容型を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2474">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="20716-2475">たとえば、null 値が許容される <xref:System.Boolean> 型は、 C#の `typeof(Nullable<bool>)` によっC++て返されます。また、の `Nullable<Boolean>::typeid`、および Visual Basic の `GetType(Nullable(Of Boolean))` によって返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2475">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="20716-2476">次の表は、さまざまな型の `GetType` で使用する構文を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2476">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="20716-2477">取得するには</span><span class="sxs-lookup"><span data-stu-id="20716-2477">To Get</span></span>|<span data-ttu-id="20716-2478">用途</span><span class="sxs-lookup"><span data-stu-id="20716-2478">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="20716-2479">Null 許容の <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="20716-2479">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="20716-2480">`MyType` するアンマネージポインター。</span><span class="sxs-lookup"><span data-stu-id="20716-2480">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="20716-2481">へのポインターへのアンマネージポインター `MyType`</span><span class="sxs-lookup"><span data-stu-id="20716-2481">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="20716-2482">`MyType` へのマネージポインターまたは参照</span><span class="sxs-lookup"><span data-stu-id="20716-2482">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="20716-2483">[https://login.microsoftonline.com/consumers/](`Type.GetType("MyType&")`)</span><span class="sxs-lookup"><span data-stu-id="20716-2483">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="20716-2484">ポインターとは異なり、参照は 1 つのレベルに制限されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2484">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="20716-2485">親クラスと入れ子になったクラス</span><span class="sxs-lookup"><span data-stu-id="20716-2485">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="20716-2486">下限が0の1次元配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2486">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="20716-2487">不明な下限を持つ1次元配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2487">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="20716-2488">N 次元配列</span><span class="sxs-lookup"><span data-stu-id="20716-2488">An n-dimensional array</span></span>|<span data-ttu-id="20716-2489">角かっこ内のコンマ (,) は、合計 n-1 回です。</span><span class="sxs-lookup"><span data-stu-id="20716-2489">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="20716-2490">たとえば、`System.Object[,,]` は3次元の `Object` 配列を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2490">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="20716-2491">1次元配列の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2491">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="20716-2492">下限が不明な四角形の2次元配列</span><span class="sxs-lookup"><span data-stu-id="20716-2492">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="20716-2493">1つの型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2493">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="20716-2494">2つの型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2494">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="20716-2495">2つのアセンブリ修飾型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2495">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="20716-2496">アセンブリ修飾型引数を持つアセンブリ修飾ジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2496">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="20716-2497">型引数が2つの型引数を持つジェネリック型であるジェネリック型。</span><span class="sxs-lookup"><span data-stu-id="20716-2497">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="20716-2498">次の例では、`System.Int32` の型を取得し、その型オブジェクトを使用して `System.Int32`の <xref:System.Type.FullName%2A> プロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2498">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2499"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2499"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-2500">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-2500">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2501"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2501"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="20716-2502">または</span><span class="sxs-lookup"><span data-stu-id="20716-2502">-or-</span></span> 
 <span data-ttu-id="20716-2503"><paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2503"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="20716-2504">または</span><span class="sxs-lookup"><span data-stu-id="20716-2504">-or-</span></span> 
 <span data-ttu-id="20716-2505"><paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-2505"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-2506"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2506"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="20716-2507"></see>Windows ストア アプリ用 .NET<see href="https://go.microsoft.com/fwlink/?LinkID=247912"> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="20716-2507">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="20716-2508">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2508">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="20716-2509">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2509">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="20716-2510">または</span><span class="sxs-lookup"><span data-stu-id="20716-2510">-or-</span></span>  
  
 <span data-ttu-id="20716-2511">共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="20716-2511">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-2512">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-2512">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="20716-2513">取得する型のアセンブリ修飾名。</span><span class="sxs-lookup"><span data-stu-id="20716-2513">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="20716-2514">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Type.AssemblyQualifiedName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="20716-2514">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="20716-2515">型が現在実行されているアセンブリ内または mscorlib.dll/System.Private.CoreLib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="20716-2515">If the type is in the currently executing assembly or in mscorlib.dll/System.Private.CoreLib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-2516">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2516"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="20716-2517">また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2517">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="20716-2518">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2518">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="20716-2519">大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2519">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="20716-2520">指定した名前を持つ型。</span><span class="sxs-lookup"><span data-stu-id="20716-2520">The type with the specified name.</span></span> <span data-ttu-id="20716-2521">型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2521">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="20716-2522">一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2522">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="20716-2523">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2523">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2524">アセンブリ修飾名がわかっている場合は、<xref:System.Type.GetType%2A> メソッドを使用して、別のアセンブリ内の型の <xref:System.Type> オブジェクトを取得できます。これは <xref:System.Type.AssemblyQualifiedName>から取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2524">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="20716-2525"><xref:System.Type.GetType%2A> により、`typeName`で指定されたアセンブリの読み込みが発生します。</span><span class="sxs-lookup"><span data-stu-id="20716-2525"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="20716-2526"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> メソッドを使用して <xref:System.Type> オブジェクトを取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2526">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="20716-2527">コンパイル時にプログラムによって認識されるアセンブリに型が含まれている場合は、のC# `typeof`、または Visual Basic の `GetType` 演算子を使用する方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="20716-2527">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="20716-2528">`GetType` は、ディスクから読み込まれたアセンブリに対してのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="20716-2528">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="20716-2529"><xref:System.Reflection.Emit> サービスを使用して定義された動的アセンブリで定義されている型を検索するために `GetType` を呼び出すと、一貫性のない動作が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2529">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="20716-2530">動作は、動的アセンブリが永続的であるかどうか、つまり、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 列挙体の `RunAndSave` アクセスモードまたは `Save` アクセスモードを使用して作成されたものかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="20716-2530">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="20716-2531">動的アセンブリが永続的で、`GetType` が呼び出される前にディスクに書き込まれた場合、ローダーはディスク上に保存されているアセンブリを検索し、そのアセンブリを読み込み、そのアセンブリから型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2531">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="20716-2532">`GetType` が呼び出されたときにアセンブリがディスクに保存されていない場合、メソッドは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2532">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="20716-2533">`GetType` は、一時的な動的アセンブリを認識しません。したがって、一時動的アセンブリの型を取得するために `GetType` を呼び出すと、`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2533">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="20716-2534">動的モジュールで `GetType` を使用するには、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントをサブスクライブして、保存する前に `GetType` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-2534">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="20716-2535">それ以外の場合は、メモリ内のアセンブリのコピーが2つ取得されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2535">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="20716-2536">`throwOnError` パラメーターは、型が見つからない場合の動作を指定します。また、「例外」セクションで説明されているように、他の特定の例外条件も抑制します。</span><span class="sxs-lookup"><span data-stu-id="20716-2536">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="20716-2537">`throwOnError`の値に関係なく、一部の例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2537">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="20716-2538">たとえば、型が見つかっても読み込むことができない場合、`throwOnError` が `false`場合でも、<xref:System.TypeLoadException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2538">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="20716-2539">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2539">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-2540">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-2540">Member Type</span></span>|<span data-ttu-id="20716-2541">静的</span><span class="sxs-lookup"><span data-stu-id="20716-2541">Static</span></span>|<span data-ttu-id="20716-2542">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-2542">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-2543">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-2543">Constructor</span></span>|<span data-ttu-id="20716-2544">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2544">No</span></span>|<span data-ttu-id="20716-2545">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2545">No</span></span>|  
|<span data-ttu-id="20716-2546">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-2546">Field</span></span>|<span data-ttu-id="20716-2547">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2547">No</span></span>|<span data-ttu-id="20716-2548">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2548">Yes.</span></span> <span data-ttu-id="20716-2549">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2549">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2550">Event</span><span class="sxs-lookup"><span data-stu-id="20716-2550">Event</span></span>|<span data-ttu-id="20716-2551">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2551">Not applicable</span></span>|<span data-ttu-id="20716-2552">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2552">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2553">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2553">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2554">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2554">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-2555">方法</span><span class="sxs-lookup"><span data-stu-id="20716-2555">Method</span></span>|<span data-ttu-id="20716-2556">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2556">No</span></span>|<span data-ttu-id="20716-2557">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2557">Yes.</span></span> <span data-ttu-id="20716-2558">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2558">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2559">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-2559">Nested Type</span></span>|<span data-ttu-id="20716-2560">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2560">No</span></span>|<span data-ttu-id="20716-2561">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2561">No</span></span>|  
|<span data-ttu-id="20716-2562">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2562">Property</span></span>|<span data-ttu-id="20716-2563">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2563">Not applicable</span></span>|<span data-ttu-id="20716-2564">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2564">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2565">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2565">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2566">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2566">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-2567">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2567">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-2568">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-2568">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-2569">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2569">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2570">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2570">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-2571">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2571">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-2572">配列または COM 型は、使用可能なクラスのテーブルに既に読み込まれていない限り、検索されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2572">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="20716-2573">`typeName` には、名前空間で修飾された型名か、アセンブリ名の指定を含むアセンブリ修飾名を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2573">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="20716-2574">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Type.AssemblyQualifiedName%2A>) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="20716-2574">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="20716-2575">名前空間が含まれているがアセンブリ名を含まない `typeName`、このメソッドは、呼び出し元のオブジェクトのアセンブリと mscorlib.dll/System.private.corelib をこの順序で検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2575">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and mscorlib.dll/System.Private.CoreLib.dll, in that order.</span></span> <span data-ttu-id="20716-2576">TypeName が部分的または完全なアセンブリ名で完全修飾されている場合、このメソッドは指定されたアセンブリを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2576">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="20716-2577">アセンブリに厳密な名前が付いている場合は、完全なアセンブリ名が必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-2577">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="20716-2578"><xref:System.Type.AssemblyQualifiedName%2A> プロパティは、入れ子にされた型、アセンブリ名、およびジェネリック引数を含む完全修飾型名を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2578">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="20716-2579">共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。</span><span class="sxs-lookup"><span data-stu-id="20716-2579">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2580">.NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="20716-2580">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="20716-2581">たとえば、"ProcessorArchitecture = msil" のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-2581">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="20716-2582">ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-2582">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="20716-2583"><xref:System.Reflection.AssemblyName> オブジェクトを作成し、それを <xref:System.Reflection.Assembly.Load%2A> メソッドの適切なオーバーロードに渡すことによって、型を読み込むこともできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2583">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="20716-2584">その後、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを使用して、アセンブリから型を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2584">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="20716-2585"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType> も参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2585">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="20716-2586">区切り記号</span><span class="sxs-lookup"><span data-stu-id="20716-2586">Delimiter</span></span>|<span data-ttu-id="20716-2587">意味</span><span class="sxs-lookup"><span data-stu-id="20716-2587">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="20716-2588">円記号 (\\)</span><span class="sxs-lookup"><span data-stu-id="20716-2588">Backslash (\\)</span></span>|<span data-ttu-id="20716-2589">エスケープ文字。</span><span class="sxs-lookup"><span data-stu-id="20716-2589">Escape character.</span></span>|  
|<span data-ttu-id="20716-2590">バックティック (')</span><span class="sxs-lookup"><span data-stu-id="20716-2590">Backtick (\`)</span></span>|<span data-ttu-id="20716-2591">ジェネリック型の名前の末尾にある型パラメーターの数を表す1桁以上の数字に先行します。</span><span class="sxs-lookup"><span data-stu-id="20716-2591">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="20716-2592">角かっこ ([])</span><span class="sxs-lookup"><span data-stu-id="20716-2592">Brackets ([])</span></span>|<span data-ttu-id="20716-2593">構築されたジェネリック型のジェネリック型引数リストを囲みます。型引数リスト内で、アセンブリ修飾型を囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-2593">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="20716-2594">コンマ (,)</span><span class="sxs-lookup"><span data-stu-id="20716-2594">Comma (,)</span></span>|<span data-ttu-id="20716-2595">アセンブリ名の前に指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2595">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="20716-2596">ピリオド (.)</span><span class="sxs-lookup"><span data-stu-id="20716-2596">Period (.)</span></span>|<span data-ttu-id="20716-2597">名前空間識別子を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2597">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="20716-2598">プラス記号 (+)</span><span class="sxs-lookup"><span data-stu-id="20716-2598">Plus sign (+)</span></span>|<span data-ttu-id="20716-2599">入れ子になったクラスの前に置きます。</span><span class="sxs-lookup"><span data-stu-id="20716-2599">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="20716-2600">たとえば、クラスの完全修飾名は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-2600">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="20716-2601">名前空間が TopNamespace. Sub + 名前空間の場合、文字列は、入れ子の区切り記号として解釈されないように、正符号 (+) の前にエスケープ文字 (\\) を付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2601">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="20716-2602">リフレクションは、この文字列を次のように出力します。</span><span class="sxs-lookup"><span data-stu-id="20716-2602">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="20716-2603">"+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。</span><span class="sxs-lookup"><span data-stu-id="20716-2603">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="20716-2604">この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2604">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="20716-2605"><xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-2605">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="20716-2606">型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2606"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="20716-2607">アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2607"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="20716-2608">型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2608">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="20716-2609">末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。</span><span class="sxs-lookup"><span data-stu-id="20716-2609">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="20716-2610">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</span><span class="sxs-lookup"><span data-stu-id="20716-2610">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="20716-2611">アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2611">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="20716-2612">ジェネリック型の名前は、バックティック (\`) で終わり、その後にジェネリック型引数の数を表す数字が続きます。</span><span class="sxs-lookup"><span data-stu-id="20716-2612">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="20716-2613">この名前の変形の目的は、同じスコープで発生する、同じ名前で型パラメーターの数が異なるジェネリック型をコンパイラがサポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="20716-2613">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="20716-2614">たとえば、リフレクションは、`Tuple(Of T0, T1)` 内のジェネリックメソッド `Tuple(Of T)` および Visual Basic、またはビジュアルC#内の `Tuple<T>` と組`\<T0, T1>` で、`Tuple`1` and `タプル`2` から破損した名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2614">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="20716-2615">ジェネリック型の場合、型引数リストは角かっこで囲まれ、型引数はコンマで区切られます。</span><span class="sxs-lookup"><span data-stu-id="20716-2615">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="20716-2616">たとえば、ジェネリック <xref:System.Collections.Generic.Dictionary%602> には、2つの型パラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2616">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="20716-2617"><xref:System.String> 型のキーを持つ `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように表されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2617">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="20716-2618">型引数リスト内でアセンブリ修飾型を指定するには、アセンブリ修飾型を角かっこで囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-2618">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="20716-2619">それ以外の場合、アセンブリ修飾名の一部を区切るコンマは、追加の型引数の区切りとして解釈されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2619">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="20716-2620">たとえば、<xref:System.String>型のキーを使用して、MyAssembly の `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように指定することができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2620">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="20716-2621">アセンブリ修飾型は、型パラメーターリスト内に出現する場合にのみ、角かっこで囲むことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2621">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="20716-2622">型パラメーターリスト内の修飾型および非修飾型のアセンブリを検索するための規則は、修飾された非修飾の非ジェネリック型の規則と同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-2622">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="20716-2623">Null 許容型は、ジェネリック型の特殊なケースです。</span><span class="sxs-lookup"><span data-stu-id="20716-2623">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="20716-2624">たとえば、null 値が許容される <xref:System.Int32> は、"System. Nullable ' 1 [system.string]" という文字列で表されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2624">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2625">、 C# C++、Visual Basic では、型演算子を使用して null 許容型を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2625">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="20716-2626">たとえば、null 値が許容される <xref:System.Boolean> 型は、 C#の `typeof(Nullable<bool>)` によっC++て返されます。また、の `Nullable<Boolean>::typeid`、および Visual Basic の `GetType(Nullable(Of Boolean))` によって返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2626">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="20716-2627">次の表は、さまざまな型の `GetType` で使用する構文を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2627">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="20716-2628">取得するには</span><span class="sxs-lookup"><span data-stu-id="20716-2628">To Get</span></span>|<span data-ttu-id="20716-2629">用途</span><span class="sxs-lookup"><span data-stu-id="20716-2629">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="20716-2630">Null 許容の <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="20716-2630">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="20716-2631">`MyType` するアンマネージポインター。</span><span class="sxs-lookup"><span data-stu-id="20716-2631">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="20716-2632">へのポインターへのアンマネージポインター `MyType`</span><span class="sxs-lookup"><span data-stu-id="20716-2632">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="20716-2633">`MyType` へのマネージポインターまたは参照</span><span class="sxs-lookup"><span data-stu-id="20716-2633">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="20716-2634">[https://login.microsoftonline.com/consumers/](`Type.GetType("MyType&")`)</span><span class="sxs-lookup"><span data-stu-id="20716-2634">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="20716-2635">ポインターとは異なり、参照は 1 つのレベルに制限されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2635">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="20716-2636">親クラスと入れ子になったクラス</span><span class="sxs-lookup"><span data-stu-id="20716-2636">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="20716-2637">下限が0の1次元配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2637">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="20716-2638">不明な下限を持つ1次元配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2638">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="20716-2639">N 次元配列</span><span class="sxs-lookup"><span data-stu-id="20716-2639">An n-dimensional array</span></span>|<span data-ttu-id="20716-2640">角かっこ内のコンマ (,) は、合計 n-1 回です。</span><span class="sxs-lookup"><span data-stu-id="20716-2640">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="20716-2641">たとえば、`System.Object[,,]` は3次元の `Object` 配列を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2641">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="20716-2642">2次元配列の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2642">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="20716-2643">下限が不明な四角形の2次元配列</span><span class="sxs-lookup"><span data-stu-id="20716-2643">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="20716-2644">1つの型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2644">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="20716-2645">2つの型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2645">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="20716-2646">2つのアセンブリ修飾型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2646">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="20716-2647">アセンブリ修飾型引数を持つアセンブリ修飾ジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2647">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="20716-2648">型引数が2つの型引数を持つジェネリック型であるジェネリック型。</span><span class="sxs-lookup"><span data-stu-id="20716-2648">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="20716-2649">次の例では、`System.Int32` の型を取得し、その型オブジェクトを使用して `System.Int32`の <xref:System.Type.FullName%2A> プロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2649">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="20716-2650">型オブジェクトが、存在しないアセンブリを参照している場合、この例では例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2650">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2651"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2651"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-2652">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-2652">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-2653"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-2653"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="20716-2654">または</span><span class="sxs-lookup"><span data-stu-id="20716-2654">-or-</span></span> 
 <span data-ttu-id="20716-2655"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2655"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="20716-2656">または</span><span class="sxs-lookup"><span data-stu-id="20716-2656">-or-</span></span> 
 <span data-ttu-id="20716-2657"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="20716-2657"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="20716-2658">または</span><span class="sxs-lookup"><span data-stu-id="20716-2658">-or-</span></span> 
 <span data-ttu-id="20716-2659"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2659"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="20716-2660">または</span><span class="sxs-lookup"><span data-stu-id="20716-2660">-or-</span></span> 
 <span data-ttu-id="20716-2661"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2661"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2662"><paramref name="throwOnError" /> が <see langword="true" /> で、<paramref name="typeName" /> に正しくない構文が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2662"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="20716-2663">例: "MyType[,\*,]"。</span><span class="sxs-lookup"><span data-stu-id="20716-2663">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="20716-2664">または</span><span class="sxs-lookup"><span data-stu-id="20716-2664">-or-</span></span> 
 <span data-ttu-id="20716-2665"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2665"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="20716-2666">または</span><span class="sxs-lookup"><span data-stu-id="20716-2666">-or-</span></span> 
 <span data-ttu-id="20716-2667"><paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2667"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="20716-2668">または</span><span class="sxs-lookup"><span data-stu-id="20716-2668">-or-</span></span> 
 <span data-ttu-id="20716-2669"><paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-2669"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="20716-2670"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2670"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="20716-2671"></see>Windows ストア アプリ用 .NET<see href="https://go.microsoft.com/fwlink/?LinkID=247912"> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="20716-2671">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="20716-2672">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2672">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="20716-2673">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2673">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="20716-2674">または</span><span class="sxs-lookup"><span data-stu-id="20716-2674">-or-</span></span>  
  
 <span data-ttu-id="20716-2675">共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="20716-2675">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-2676">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-2676">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="20716-2677">取得する型のアセンブリ修飾名。</span><span class="sxs-lookup"><span data-stu-id="20716-2677">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="20716-2678">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Type.AssemblyQualifiedName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="20716-2678">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="20716-2679">型が現在実行されているアセンブリ内または mscorlib.dll/System.Private.CoreLib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="20716-2679">If the type is in the currently executing assembly or in mscorlib.dll/System.Private.CoreLib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-2680">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2680"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="20716-2681">また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2681">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="20716-2682">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2682">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="20716-2683">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <paramref name="typeName" />。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2683"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="20716-2684">指定した名前を持つ <see cref="T:System.Type" /> を取得します。型が見つからない場合に例外をスローするかどうかと、大文字と小文字を区別する検索を実行するかどうかも指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2684">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="20716-2685">指定した名前を持つ型。</span><span class="sxs-lookup"><span data-stu-id="20716-2685">The type with the specified name.</span></span> <span data-ttu-id="20716-2686">型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2686">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="20716-2687">一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2687">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="20716-2688">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2688">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2689">アセンブリ修飾名がわかっている場合は、<xref:System.Type.GetType%2A> メソッドを使用して、別のアセンブリ内の型の <xref:System.Type> オブジェクトを取得できます。これは <xref:System.Type.AssemblyQualifiedName>から取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2689">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="20716-2690"><xref:System.Type.GetType%2A> により、`typeName`で指定されたアセンブリの読み込みが発生します。</span><span class="sxs-lookup"><span data-stu-id="20716-2690"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="20716-2691"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> メソッドを使用して <xref:System.Type> オブジェクトを取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2691">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="20716-2692">コンパイル時にプログラムによって認識されるアセンブリに型が含まれている場合は、のC# `typeof`、または Visual Basic の `GetType` 演算子を使用する方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="20716-2692">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="20716-2693">`GetType` は、ディスクから読み込まれたアセンブリに対してのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="20716-2693">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="20716-2694"><xref:System.Reflection.Emit> サービスを使用して定義された動的アセンブリで定義されている型を検索するために `GetType` を呼び出すと、一貫性のない動作が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2694">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="20716-2695">動作は、動的アセンブリが永続的であるかどうか、つまり、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 列挙体の `RunAndSave` アクセスモードまたは `Save` アクセスモードを使用して作成されたものかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="20716-2695">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="20716-2696">動的アセンブリが永続的で、`GetType` が呼び出される前にディスクに書き込まれた場合、ローダーはディスク上に保存されているアセンブリを検索し、そのアセンブリを読み込み、そのアセンブリから型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-2696">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="20716-2697">`GetType` が呼び出されたときにアセンブリがディスクに保存されていない場合、メソッドは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2697">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="20716-2698">`GetType` は、一時的な動的アセンブリを認識しません。したがって、一時動的アセンブリの型を取得するために `GetType` を呼び出すと、`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2698">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="20716-2699">動的モジュールで `GetType` を使用するには、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントをサブスクライブして、保存する前に `GetType` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-2699">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="20716-2700">それ以外の場合は、メモリ内のアセンブリのコピーが2つ取得されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2700">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="20716-2701">`throwOnError` パラメーターは、型が見つからない場合の動作を指定します。また、「例外」セクションで説明されているように、他の特定の例外条件も抑制します。</span><span class="sxs-lookup"><span data-stu-id="20716-2701">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="20716-2702">`throwOnError`の値に関係なく、一部の例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2702">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="20716-2703">たとえば、型が見つかっても読み込むことができない場合、`throwOnError` が `false`場合でも、<xref:System.TypeLoadException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2703">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="20716-2704">次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2704">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="20716-2705">メンバーの型</span><span class="sxs-lookup"><span data-stu-id="20716-2705">Member Type</span></span>|<span data-ttu-id="20716-2706">静的</span><span class="sxs-lookup"><span data-stu-id="20716-2706">Static</span></span>|<span data-ttu-id="20716-2707">非静的</span><span class="sxs-lookup"><span data-stu-id="20716-2707">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="20716-2708">Constructor</span><span class="sxs-lookup"><span data-stu-id="20716-2708">Constructor</span></span>|<span data-ttu-id="20716-2709">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2709">No</span></span>|<span data-ttu-id="20716-2710">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2710">No</span></span>|  
|<span data-ttu-id="20716-2711">フィールド</span><span class="sxs-lookup"><span data-stu-id="20716-2711">Field</span></span>|<span data-ttu-id="20716-2712">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2712">No</span></span>|<span data-ttu-id="20716-2713">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2713">Yes.</span></span> <span data-ttu-id="20716-2714">フィールドは、常に名前と署名で隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2714">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2715">Event</span><span class="sxs-lookup"><span data-stu-id="20716-2715">Event</span></span>|<span data-ttu-id="20716-2716">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2716">Not applicable</span></span>|<span data-ttu-id="20716-2717">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2717">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2718">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2718">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2719">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2719">See note 2 below.</span></span>|  
|<span data-ttu-id="20716-2720">方法</span><span class="sxs-lookup"><span data-stu-id="20716-2720">Method</span></span>|<span data-ttu-id="20716-2721">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2721">No</span></span>|<span data-ttu-id="20716-2722">はい。</span><span class="sxs-lookup"><span data-stu-id="20716-2722">Yes.</span></span> <span data-ttu-id="20716-2723">メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2723">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="20716-2724">入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="20716-2724">Nested Type</span></span>|<span data-ttu-id="20716-2725">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2725">No</span></span>|<span data-ttu-id="20716-2726">いいえ</span><span class="sxs-lookup"><span data-stu-id="20716-2726">No</span></span>|  
|<span data-ttu-id="20716-2727">プロパティ</span><span class="sxs-lookup"><span data-stu-id="20716-2727">Property</span></span>|<span data-ttu-id="20716-2728">適用なし</span><span class="sxs-lookup"><span data-stu-id="20716-2728">Not applicable</span></span>|<span data-ttu-id="20716-2729">共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-2729">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="20716-2730">リフレクションは、プロパティを名前で隠す、署名として扱います。</span><span class="sxs-lookup"><span data-stu-id="20716-2730">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2731">下記のメモ2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2731">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="20716-2732">名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2732">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="20716-2733">これは、バイナリ比較です。</span><span class="sxs-lookup"><span data-stu-id="20716-2733">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="20716-2734">リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2734">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="20716-2735">基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-2735">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="20716-2736">カスタム属性は、共通型システムの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2736">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="20716-2737">配列または COM 型は、使用可能なクラスのテーブルに既に読み込まれていない限り、検索されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2737">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="20716-2738">`typeName` には、名前空間で修飾された型名か、アセンブリ名の指定を含むアセンブリ修飾名を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2738">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="20716-2739">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Type.AssemblyQualifiedName%2A>) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="20716-2739">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="20716-2740">名前空間が含まれているがアセンブリ名を含まない `typeName`、このメソッドは、呼び出し元のオブジェクトのアセンブリと mscorlib.dll/System.private.corelib をこの順序で検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2740">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and mscorlib.dll/System.Private.CoreLib.dll, in that order.</span></span> <span data-ttu-id="20716-2741">TypeName が部分的または完全なアセンブリ名で完全修飾されている場合、このメソッドは指定されたアセンブリを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2741">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="20716-2742">アセンブリに厳密な名前が付いている場合は、完全なアセンブリ名が必要です。</span><span class="sxs-lookup"><span data-stu-id="20716-2742">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="20716-2743"><xref:System.Type.AssemblyQualifiedName%2A> プロパティは、入れ子にされた型、アセンブリ名、および型引数を含む完全修飾型名を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2743">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="20716-2744">共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。</span><span class="sxs-lookup"><span data-stu-id="20716-2744">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2745">.NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="20716-2745">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="20716-2746">たとえば、"ProcessorArchitecture = msil" のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-2746">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="20716-2747">ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-2747">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="20716-2748"><xref:System.Reflection.AssemblyName> オブジェクトを作成し、それを <xref:System.Reflection.Assembly.Load%2A> メソッドの適切なオーバーロードに渡すことによって、型を読み込むこともできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2748">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="20716-2749">その後、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを使用して、アセンブリから型を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2749">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="20716-2750"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType> も参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2750">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="20716-2751">区切り記号</span><span class="sxs-lookup"><span data-stu-id="20716-2751">Delimiter</span></span>|<span data-ttu-id="20716-2752">意味</span><span class="sxs-lookup"><span data-stu-id="20716-2752">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="20716-2753">円記号 (\\)</span><span class="sxs-lookup"><span data-stu-id="20716-2753">Backslash (\\)</span></span>|<span data-ttu-id="20716-2754">エスケープ文字。</span><span class="sxs-lookup"><span data-stu-id="20716-2754">Escape character.</span></span>|  
|<span data-ttu-id="20716-2755">バックティック (')</span><span class="sxs-lookup"><span data-stu-id="20716-2755">Backtick (\`)</span></span>|<span data-ttu-id="20716-2756">ジェネリック型の名前の末尾にある型パラメーターの数を表す1桁以上の数字に先行します。</span><span class="sxs-lookup"><span data-stu-id="20716-2756">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="20716-2757">角かっこ ([])</span><span class="sxs-lookup"><span data-stu-id="20716-2757">Brackets ([])</span></span>|<span data-ttu-id="20716-2758">構築されたジェネリック型のジェネリック型引数リストを囲みます。型引数リスト内で、アセンブリ修飾型を囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-2758">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="20716-2759">コンマ (,)</span><span class="sxs-lookup"><span data-stu-id="20716-2759">Comma (,)</span></span>|<span data-ttu-id="20716-2760">アセンブリ名の前に指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2760">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="20716-2761">ピリオド (.)</span><span class="sxs-lookup"><span data-stu-id="20716-2761">Period (.)</span></span>|<span data-ttu-id="20716-2762">名前空間識別子を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2762">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="20716-2763">プラス記号 (+)</span><span class="sxs-lookup"><span data-stu-id="20716-2763">Plus sign (+)</span></span>|<span data-ttu-id="20716-2764">入れ子になったクラスの前に置きます。</span><span class="sxs-lookup"><span data-stu-id="20716-2764">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="20716-2765">たとえば、クラスの完全修飾名は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-2765">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="20716-2766">名前空間が TopNamespace. Sub + 名前空間の場合、文字列は、入れ子の区切り記号として解釈されないように、正符号 (+) の前にエスケープ文字 (\\) を付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2766">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="20716-2767">リフレクションは、この文字列を次のように出力します。</span><span class="sxs-lookup"><span data-stu-id="20716-2767">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="20716-2768">"+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。</span><span class="sxs-lookup"><span data-stu-id="20716-2768">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="20716-2769">この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2769">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="20716-2770"><xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-2770">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="20716-2771">型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-2771"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="20716-2772">アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2772"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="20716-2773">型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2773">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="20716-2774">末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。</span><span class="sxs-lookup"><span data-stu-id="20716-2774">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="20716-2775">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</span><span class="sxs-lookup"><span data-stu-id="20716-2775">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="20716-2776">アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2776">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="20716-2777">ジェネリック型の名前は、バックティック (\`) で終わり、その後にジェネリック型引数の数を表す数字が続きます。</span><span class="sxs-lookup"><span data-stu-id="20716-2777">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="20716-2778">この名前の変形の目的は、同じスコープで発生する、同じ名前で型パラメーターの数が異なるジェネリック型をコンパイラがサポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="20716-2778">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="20716-2779">たとえば、リフレクションは、`Tuple(Of T0, T1)` 内のジェネリックメソッド `Tuple(Of T)` および Visual Basic、またはビジュアルC#内の `Tuple<T>` と組`\<T0, T1>` で、`Tuple`1` and `タプル`2` から破損した名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2779">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="20716-2780">ジェネリック型の場合、型引数リストは角かっこで囲まれ、型引数はコンマで区切られます。</span><span class="sxs-lookup"><span data-stu-id="20716-2780">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="20716-2781">たとえば、ジェネリック <xref:System.Collections.Generic.Dictionary%602> には、2つの型パラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-2781">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="20716-2782"><xref:System.String> 型のキーを持つ `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように表されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2782">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="20716-2783">型引数リスト内でアセンブリ修飾型を指定するには、アセンブリ修飾型を角かっこで囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-2783">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="20716-2784">それ以外の場合、アセンブリ修飾名の一部を区切るコンマは、追加の型引数の区切りとして解釈されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2784">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="20716-2785">たとえば、<xref:System.String>型のキーを使用して、MyAssembly の `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように指定することができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2785">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="20716-2786">アセンブリ修飾型は、型パラメーターリスト内に出現する場合にのみ、角かっこで囲むことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-2786">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="20716-2787">型パラメーターリスト内の修飾型および非修飾型のアセンブリを検索するための規則は、修飾された非修飾の非ジェネリック型の規則と同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-2787">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="20716-2788">Null 許容型は、ジェネリック型の特殊なケースです。</span><span class="sxs-lookup"><span data-stu-id="20716-2788">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="20716-2789">たとえば、null 値が許容される <xref:System.Int32> は、"System. Nullable ' 1 [system.string]" という文字列で表されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2789">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2790">、 C# C++、Visual Basic では、型演算子を使用して null 許容型を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2790">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="20716-2791">たとえば、null 値が許容される <xref:System.Boolean> 型は、 C#の `typeof(Nullable<bool>)` によっC++て返されます。また、の `Nullable<Boolean>::typeid`、および Visual Basic の `GetType(Nullable(Of Boolean))` によって返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2791">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="20716-2792">次の表は、さまざまな型の `GetType` で使用する構文を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2792">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="20716-2793">取得するには</span><span class="sxs-lookup"><span data-stu-id="20716-2793">To Get</span></span>|<span data-ttu-id="20716-2794">用途</span><span class="sxs-lookup"><span data-stu-id="20716-2794">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="20716-2795">Null 許容の <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="20716-2795">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="20716-2796">`MyType` するアンマネージポインター。</span><span class="sxs-lookup"><span data-stu-id="20716-2796">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="20716-2797">へのポインターへのアンマネージポインター `MyType`</span><span class="sxs-lookup"><span data-stu-id="20716-2797">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="20716-2798">`MyType` へのマネージポインターまたは参照</span><span class="sxs-lookup"><span data-stu-id="20716-2798">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="20716-2799">[https://login.microsoftonline.com/consumers/](`Type.GetType("MyType&")`)</span><span class="sxs-lookup"><span data-stu-id="20716-2799">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="20716-2800">ポインターとは異なり、参照は 1 つのレベルに制限されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2800">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="20716-2801">親クラスと入れ子になったクラス</span><span class="sxs-lookup"><span data-stu-id="20716-2801">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="20716-2802">下限が0の1次元配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2802">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="20716-2803">不明な下限を持つ1次元配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2803">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="20716-2804">N 次元配列</span><span class="sxs-lookup"><span data-stu-id="20716-2804">An n-dimensional array</span></span>|<span data-ttu-id="20716-2805">角かっこ内のコンマ (,) は、合計 n-1 回です。</span><span class="sxs-lookup"><span data-stu-id="20716-2805">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="20716-2806">たとえば、`System.Object[,,]` は3次元の `Object` 配列を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2806">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="20716-2807">2次元配列の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-2807">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="20716-2808">下限が不明な四角形の2次元配列</span><span class="sxs-lookup"><span data-stu-id="20716-2808">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="20716-2809">1つの型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2809">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="20716-2810">2つの型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2810">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="20716-2811">2つのアセンブリ修飾型引数を持つジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2811">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="20716-2812">アセンブリ修飾型引数を持つアセンブリ修飾ジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-2812">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="20716-2813">型引数が2つの型引数を持つジェネリック型であるジェネリック型。</span><span class="sxs-lookup"><span data-stu-id="20716-2813">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2814"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2814"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-2815">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-2815">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-2816"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-2816"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="20716-2817">または</span><span class="sxs-lookup"><span data-stu-id="20716-2817">-or-</span></span> 
 <span data-ttu-id="20716-2818"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2818"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="20716-2819">または</span><span class="sxs-lookup"><span data-stu-id="20716-2819">-or-</span></span> 
 <span data-ttu-id="20716-2820"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="20716-2820"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="20716-2821">または</span><span class="sxs-lookup"><span data-stu-id="20716-2821">-or-</span></span> 
 <span data-ttu-id="20716-2822"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2822"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="20716-2823">または</span><span class="sxs-lookup"><span data-stu-id="20716-2823">-or-</span></span> 
 <span data-ttu-id="20716-2824"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2824"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2825"><paramref name="throwOnError" /> が <see langword="true" /> で、<paramref name="typeName" /> に正しくない構文が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2825"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="20716-2826">例: "MyType[,\*,]"。</span><span class="sxs-lookup"><span data-stu-id="20716-2826">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="20716-2827">または</span><span class="sxs-lookup"><span data-stu-id="20716-2827">-or-</span></span> 
 <span data-ttu-id="20716-2828"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2828"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="20716-2829">または</span><span class="sxs-lookup"><span data-stu-id="20716-2829">-or-</span></span> 
 <span data-ttu-id="20716-2830"><paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2830"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="20716-2831">または</span><span class="sxs-lookup"><span data-stu-id="20716-2831">-or-</span></span> 
 <span data-ttu-id="20716-2832"><paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-2832"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="20716-2833"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2833"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="20716-2834">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2834">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="20716-2835">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2835">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="20716-2836">または</span><span class="sxs-lookup"><span data-stu-id="20716-2836">-or-</span></span>  
  
 <span data-ttu-id="20716-2837">共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="20716-2837">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-2838">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-2838">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="20716-2839">取得する型の名前。</span><span class="sxs-lookup"><span data-stu-id="20716-2839">The name of the type to get.</span></span> <span data-ttu-id="20716-2840"><paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2840">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="20716-2841"><paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または mscorlib.dll/System.Private.CoreLib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="20716-2841">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in mscorlib.dll/System.Private.CoreLib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="20716-2842">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="20716-2842">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="20716-2843"><paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2843">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="20716-2844"><paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2844">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="20716-2845"><paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2845">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="20716-2846">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="20716-2846">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="20716-2847">渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2847">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="20716-2848">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2848">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="20716-2849"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="20716-2849">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="20716-2850">アセンブリが指定されていない場合は、<paramref name="typeResolver" /> メソッドで指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2850">If no assembly is provided, the <paramref name="typeResolver" /> method can provide one.</span></span> <span data-ttu-id="20716-2851">このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2851">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="20716-2852">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="20716-2852">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <summary><span data-ttu-id="20716-2853">指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2853">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="20716-2854">指定された名前の型。型が見つからない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2854">The type with the specified name, or <see langword="null" /> if the type is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2855">このメソッドの使用シナリオと `assemblyResolver` および `typeResolver` パラメーターの詳細については、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2855">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2856">`typeName` が見つからない場合、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> メソッドを呼び出すと `null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2856">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="20716-2857">例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="20716-2857">It does not throw an exception.</span></span> <span data-ttu-id="20716-2858">例外がスローされるかどうかを制御するには、`throwOnError` パラメーターを持つ <xref:System.Type.GetType%2A> メソッドのオーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-2858">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="20716-2859">このメソッドのオーバーロードを呼び出すことは、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`throwOnError` と `ignoreCase` のパラメーターに `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-2859">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2860"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2860"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-2861">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-2861">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2862"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。</span><span class="sxs-lookup"><span data-stu-id="20716-2862">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="20716-2863">または</span><span class="sxs-lookup"><span data-stu-id="20716-2863">-or-</span></span> 
 <span data-ttu-id="20716-2864"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2864"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="20716-2865">または</span><span class="sxs-lookup"><span data-stu-id="20716-2865">-or-</span></span> 
 <span data-ttu-id="20716-2866"><paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2866"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="20716-2867">または</span><span class="sxs-lookup"><span data-stu-id="20716-2867">-or-</span></span> 
 <span data-ttu-id="20716-2868"><paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-2868"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-2869"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2869"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="20716-2870">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2870">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="20716-2871">または</span><span class="sxs-lookup"><span data-stu-id="20716-2871">-or-</span></span> 
 <span data-ttu-id="20716-2872"><paramref name="typeName" /> に無効なアセンブリ名が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2872"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="20716-2873">または</span><span class="sxs-lookup"><span data-stu-id="20716-2873">-or-</span></span> 
 <span data-ttu-id="20716-2874"><paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</span><span class="sxs-lookup"><span data-stu-id="20716-2874"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="20716-2875">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2875">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="20716-2876">または</span><span class="sxs-lookup"><span data-stu-id="20716-2876">-or-</span></span>  
  
 <span data-ttu-id="20716-2877">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="20716-2877">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="20716-2878">取得する型の名前。</span><span class="sxs-lookup"><span data-stu-id="20716-2878">The name of the type to get.</span></span> <span data-ttu-id="20716-2879"><paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2879">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="20716-2880"><paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または mscorlib.dll/System.Private.CoreLib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="20716-2880">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in mscorlib.dll/System.Private.CoreLib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="20716-2881">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="20716-2881">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="20716-2882"><paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2882">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="20716-2883"><paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2883">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="20716-2884"><paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2884">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="20716-2885">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="20716-2885">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="20716-2886">渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2886">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="20716-2887">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2887">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="20716-2888"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="20716-2888">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="20716-2889">アセンブリが指定されていない場合は、このメソッドで指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2889">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="20716-2890">このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2890">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="20716-2891">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="20716-2891">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-2892">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2892"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="20716-2893">また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2893">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="20716-2894">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2894">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="20716-2895">型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2895">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="20716-2896">指定した名前を持つ型。</span><span class="sxs-lookup"><span data-stu-id="20716-2896">The type with the specified name.</span></span> <span data-ttu-id="20716-2897">型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2897">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="20716-2898">一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2898">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="20716-2899">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2899">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2900">このメソッドの使用シナリオと `assemblyResolver` および `typeResolver` パラメーターの詳細については、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2900">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="20716-2901">このメソッドのオーバーロードを呼び出すことは、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`ignoreCase` パラメーターの `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-2901">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-2902"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-2902"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-2903">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-2903">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-2904"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-2904"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="20716-2905">または</span><span class="sxs-lookup"><span data-stu-id="20716-2905">-or-</span></span> 
 <span data-ttu-id="20716-2906"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2906"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="20716-2907">または</span><span class="sxs-lookup"><span data-stu-id="20716-2907">-or-</span></span> 
 <span data-ttu-id="20716-2908"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="20716-2908"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="20716-2909">または</span><span class="sxs-lookup"><span data-stu-id="20716-2909">-or-</span></span> 
 <span data-ttu-id="20716-2910"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2910"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="20716-2911">または</span><span class="sxs-lookup"><span data-stu-id="20716-2911">-or-</span></span> 
 <span data-ttu-id="20716-2912"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2912"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-2913"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。</span><span class="sxs-lookup"><span data-stu-id="20716-2913">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="20716-2914">または</span><span class="sxs-lookup"><span data-stu-id="20716-2914">-or-</span></span> 
 <span data-ttu-id="20716-2915"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 ("MyType[,\*,]" など) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2915"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="20716-2916">または</span><span class="sxs-lookup"><span data-stu-id="20716-2916">-or-</span></span> 
 <span data-ttu-id="20716-2917"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-2917"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="20716-2918">または</span><span class="sxs-lookup"><span data-stu-id="20716-2918">-or-</span></span> 
 <span data-ttu-id="20716-2919"><paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-2919"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="20716-2920">または</span><span class="sxs-lookup"><span data-stu-id="20716-2920">-or-</span></span> 
 <span data-ttu-id="20716-2921"><paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-2921"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="20716-2922"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2922"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span>  
  
<span data-ttu-id="20716-2923">または</span><span class="sxs-lookup"><span data-stu-id="20716-2923">-or-</span></span> 
 <span data-ttu-id="20716-2924"><paramref name="typeName" /> に無効なアセンブリ名が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-2924"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="20716-2925">または</span><span class="sxs-lookup"><span data-stu-id="20716-2925">-or-</span></span> 
 <span data-ttu-id="20716-2926"><paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</span><span class="sxs-lookup"><span data-stu-id="20716-2926"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="20716-2927">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-2927">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="20716-2928">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2928">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="20716-2929">または</span><span class="sxs-lookup"><span data-stu-id="20716-2929">-or-</span></span>  
  
 <span data-ttu-id="20716-2930">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="20716-2930">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="20716-2931">取得する型の名前。</span><span class="sxs-lookup"><span data-stu-id="20716-2931">The name of the type to get.</span></span> <span data-ttu-id="20716-2932"><paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2932">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="20716-2933"><paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または mscorlib.dll/System.Private.CoreLib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="20716-2933">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in mscorlib.dll/System.Private.CoreLib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="20716-2934">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="20716-2934">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="20716-2935"><paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2935">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="20716-2936"><paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2936">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="20716-2937"><paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2937">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="20716-2938">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="20716-2938">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="20716-2939">渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2939">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="20716-2940">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2940">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="20716-2941"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="20716-2941">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="20716-2942">アセンブリが指定されていない場合は、このメソッドで指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2942">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="20716-2943">このメソッドは、大文字小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには、<paramref name="ignoreCase" /> の値が渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2943">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="20716-2944">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="20716-2944">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-2945">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2945"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="20716-2946">また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-2946">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="20716-2947">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2947">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="20716-2948">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <paramref name="typeName" />。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="20716-2948"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="20716-2949">大文字と小文字を区別せずに検索を実行するかどうか、および型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2949">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="20716-2950">指定した名前を持つ型。</span><span class="sxs-lookup"><span data-stu-id="20716-2950">The type with the specified name.</span></span> <span data-ttu-id="20716-2951">型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2951">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="20716-2952">一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2952">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="20716-2953">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2953">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-2954">このメソッドオーバーロードとそれに関連付けられているオーバーロード (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> および <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) を使用して、<xref:System.Type.GetType%2A> メソッドの既定の実装をより柔軟な実装に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="20716-2954">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="20716-2955">型名とそれらを含むアセンブリの名前を解決する独自のメソッドを提供することで、次の操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2955">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="20716-2956">型の読み込み元のアセンブリのバージョンを制御します。</span><span class="sxs-lookup"><span data-stu-id="20716-2956">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="20716-2957">アセンブリ名を含まない型名を検索する別の場所を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-2957">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="20716-2958">部分的なアセンブリ名を使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="20716-2958">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="20716-2959">共通言語ランタイム (CLR) によって作成されていない <xref:System.Type?displayProperty=nameWithType> のサブクラスを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-2959">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="20716-2960">たとえば、バージョントレラントなシリアル化では、このメソッドを使用すると、部分名を使用して "最適" アセンブリを検索できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2960">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="20716-2961"><xref:System.Type.GetType%2A> メソッドの他のオーバーロードには、アセンブリ修飾型名が必要です。これにはバージョン番号が含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-2961">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="20716-2962">型システムの代替実装では、CLR によって作成されていない <xref:System.Type?displayProperty=nameWithType> のサブクラスを返すことが必要になる場合があります。<xref:System.Type.GetType%2A> メソッドの他のオーバーロードによって返されるすべての型は、ランタイム型です。</span><span class="sxs-lookup"><span data-stu-id="20716-2962">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="20716-2963">使用に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="20716-2963">Usage Notes</span></span>  
 <span data-ttu-id="20716-2964">このメソッドのオーバーロードとそれに関連付けられているオーバーロードは、`typeName` を型の名前とアセンブリの名前に解析し、名前を解決します。</span><span class="sxs-lookup"><span data-stu-id="20716-2964">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="20716-2965">アセンブリ名の解決は、アセンブリのコンテキストで型名を解決する必要があるため、型名の解決の前に発生します。</span><span class="sxs-lookup"><span data-stu-id="20716-2965">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-2966">アセンブリ修飾型名の概念に慣れていない場合は、<xref:System.Type.AssemblyQualifiedName%2A> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2966">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="20716-2967">`typeName` がアセンブリ修飾名でない場合、アセンブリ解決はスキップされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2967">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="20716-2968">修飾されていない型名は、mscorlib.dll/System.private.corelib または現在実行中のアセンブリのコンテキストで解決できます。また、必要に応じて、`typeResolver` パラメーターでアセンブリを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-2968">Unqualified type names can be resolved in the context of mscorlib.dll/System.Private.CoreLib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="20716-2969">さまざまな種類の名前解決にアセンブリ名を含めたり省略したりした場合の効果は、[[混合名の解決](#mixed_name_resolution)] セクションにテーブルとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2969">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="20716-2970">一般的な使用に関する注意事項:</span><span class="sxs-lookup"><span data-stu-id="20716-2970">General usage notes:</span></span>  
  
-   <span data-ttu-id="20716-2971">不明または信頼されていない呼び出し元からのものである場合は、メソッドを `assemblyResolver` に渡したり、`typeResolver` したりしないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-2971">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="20716-2972">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</span><span class="sxs-lookup"><span data-stu-id="20716-2972">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="20716-2973">不明または信頼されていない呼び出し元のメソッドを使用すると、悪意のあるコードの特権が昇格される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2973">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="20716-2974">`assemblyResolver` パラメーターまたは `typeResolver` パラメーターを省略した場合は、既定の解決を実行するメソッドに `throwOnError` パラメーターの値が渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2974">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="20716-2975">`throwOnError` が `true`場合、このメソッドは `typeResolver` が `null`を返したときに <xref:System.TypeLoadException> をスローし、<xref:System.IO.FileNotFoundException> が `assemblyResolver` を返したときに `null`をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-2975">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="20716-2976">このメソッドは、`assemblyResolver` および `typeResolver`によってスローされた例外をキャッチしません。</span><span class="sxs-lookup"><span data-stu-id="20716-2976">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="20716-2977">競合回避モジュールによってスローされる例外については、お客様が責任を負うものとします。</span><span class="sxs-lookup"><span data-stu-id="20716-2977">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="20716-2978">アセンブリの解決</span><span class="sxs-lookup"><span data-stu-id="20716-2978">Resolving Assemblies</span></span>  
 <span data-ttu-id="20716-2979">`assemblyResolver` メソッドは、`typeName`に含まれている文字列アセンブリ名を解析することによって生成される <xref:System.Reflection.AssemblyName> オブジェクトを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="20716-2979">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="20716-2980">`typeName` にアセンブリ名が含まれていない場合、`assemblyResolver` は呼び出されず、`typeResolver`に `null` が渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2980">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="20716-2981">`assemblyResolver` が指定されていない場合、アセンブリを検索するために標準のアセンブリプローブが使用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2981">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="20716-2982">`assemblyResolver` が指定されている場合、<xref:System.Type.GetType%2A> 方法では、標準のプローブは実行されません。その場合は、`assemblyResolver` が、渡すすべてのアセンブリを処理できることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2982">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="20716-2983">`assemblyResolver` メソッドは、アセンブリを解決できない場合に `null` を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-2983">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="20716-2984">`assemblyResolver` が `null`を返す場合、`typeResolver` は呼び出されず、それ以上の処理は行われません。さらに、`throwOnError` が `true`場合は、<xref:System.IO.FileNotFoundException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-2984">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="20716-2985">`assemblyResolver` に渡された <xref:System.Reflection.AssemblyName> が部分的な名前である場合、その1つ以上の部分が `null`ます。</span><span class="sxs-lookup"><span data-stu-id="20716-2985">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="20716-2986">たとえば、バージョンがない場合、<xref:System.Reflection.AssemblyName.Version%2A> プロパティは `null`になります。</span><span class="sxs-lookup"><span data-stu-id="20716-2986">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="20716-2987"><xref:System.Reflection.AssemblyName.Version%2A> プロパティ、<xref:System.Reflection.AssemblyName.CultureInfo%2A> プロパティ、および <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> メソッドがすべて `null`を返す場合は、アセンブリの簡易名のみが指定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-2987">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="20716-2988">`assemblyResolver` メソッドでは、アセンブリ名のすべての部分を使用または無視できます。</span><span class="sxs-lookup"><span data-stu-id="20716-2988">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="20716-2989">アセンブリ解決のさまざまなオプションの効果は、単純型名とアセンブリ修飾型名のために、[混合名前解決](#mixed_name_resolution)のセクションにテーブルとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2989">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="20716-2990">解決 (型を)</span><span class="sxs-lookup"><span data-stu-id="20716-2990">Resolving Types</span></span>  
 <span data-ttu-id="20716-2991">`typeName` がアセンブリ名を指定しない場合、`typeResolver` は常に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2991">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="20716-2992">`typeName` アセンブリ名を指定すると、アセンブリ名が正常に解決された場合にのみ `typeResolver` が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-2992">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="20716-2993">`assemblyResolver` または標準のアセンブリプローブが `null`を返した場合、`typeResolver` は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="20716-2993">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="20716-2994">`typeResolver` メソッドは、次の3つの引数を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="20716-2994">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="20716-2995">`typeName` にアセンブリ名が含まれていない場合に検索または `null` するアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="20716-2995">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="20716-2996">型の簡易名。</span><span class="sxs-lookup"><span data-stu-id="20716-2996">The simple name of the type.</span></span> <span data-ttu-id="20716-2997">入れ子にされた型の場合、これは最も外側の型になります。</span><span class="sxs-lookup"><span data-stu-id="20716-2997">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="20716-2998">ジェネリック型の場合、これはジェネリック型の単純な名前です。</span><span class="sxs-lookup"><span data-stu-id="20716-2998">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="20716-2999">型名の大文字と小文字の区別を無視する場合に `true` するブール値。</span><span class="sxs-lookup"><span data-stu-id="20716-2999">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="20716-3000">これらの引数の使用方法は、実装によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-3000">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="20716-3001">`typeResolver` メソッドは、型を解決できない場合に `null` を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3001">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="20716-3002">`typeResolver` が `null` を返し、`throwOnError` が `true`場合、この <xref:System.Type.GetType%2A> のオーバーロードは <xref:System.TypeLoadException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-3002">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="20716-3003">さまざまな型解決オプションの効果は、単純型とアセンブリ修飾型の名前について、[混在する名前解決](#mixed_name_resolution)のセクションにテーブルとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3003">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="20716-3004">入れ子になった型の解決</span><span class="sxs-lookup"><span data-stu-id="20716-3004">Resolving Nested Types</span></span>  
 <span data-ttu-id="20716-3005">`typeName` が入れ子にされた型である場合は、最も外側にある型の名前だけが `typeResolver`に渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3005">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="20716-3006">`typeResolver` がこの型を返すと、最も内側の入れ子にされた型が解決されるまで、<xref:System.Type.GetNestedType%2A> メソッドが再帰的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3006">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="20716-3007">ジェネリック型の解決</span><span class="sxs-lookup"><span data-stu-id="20716-3007">Resolving Generic Types</span></span>  
 <span data-ttu-id="20716-3008"><xref:System.Type.GetType%2A> は、ジェネリック型を解決するために再帰的に呼び出されます。まずジェネリック型自体を解決してから、その型引数を解決します。</span><span class="sxs-lookup"><span data-stu-id="20716-3008">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="20716-3009">型引数がジェネリックの場合は、型引数を解決するために <xref:System.Type.GetType%2A> が再帰的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3009">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="20716-3010">指定する `assemblyResolver` と `typeResolver` の組み合わせは、この再帰のすべてのレベルを解決できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3010">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="20716-3011">たとえば、`MyAssembly`の読み込みを制御する `assemblyResolver` を指定したとします。</span><span class="sxs-lookup"><span data-stu-id="20716-3011">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="20716-3012">ジェネリック型 `Dictionary<string, MyType>` (Visual Basic で`Dictionary(Of String, MyType)`) を解決するとします。</span><span class="sxs-lookup"><span data-stu-id="20716-3012">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="20716-3013">次のジェネリック型名を渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3013">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="20716-3014">アセンブリ修飾型引数は `MyType` のみであることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3014">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="20716-3015"><xref:System.Collections.Generic.Dictionary%602> クラスと <xref:System.String> クラスの名前はアセンブリ修飾されていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3015">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="20716-3016">`typeResolver` は、<xref:System.Collections.Generic.Dictionary%602> および <xref:System.String>の `null` を受け取るため、アセンブリまたは `null`のいずれかを処理できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3016">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="20716-3017">この場合、文字列を受け取る <xref:System.Type.GetType%2A> メソッドのオーバーロードを呼び出すことで処理できます。これは、非修飾型名の両方が mscorlib.dll/System.private.corelib にあるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-3017">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in mscorlib.dll/System.Private.CoreLib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="20716-3018">`assemblyResolver` メソッドは、ディクショナリ型および文字列型に対しては呼び出されません。これらの型名はアセンブリ修飾名ではないためです。</span><span class="sxs-lookup"><span data-stu-id="20716-3018">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="20716-3019">ここで、`System.String`ではなく、最初のジェネリック引数の型が `YourAssembly`から `YourType`とします。</span><span class="sxs-lookup"><span data-stu-id="20716-3019">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="20716-3020">このアセンブリは mscorlib.dll/System.private.corelib と現在実行されているアセンブリのどちらでもないため、アセンブリ修飾名を指定せずに `YourType` を解決することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3020">Because this assembly is neither mscorlib.dll/System.Private.CoreLib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="20716-3021">`assemblyResolve` は再帰的に呼び出されるため、この場合は処理できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3021">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="20716-3022">`MyAssembly`以外のアセンブリの `null` を返す代わりに、指定された <xref:System.Reflection.AssemblyName> オブジェクトを使用してアセンブリの読み込みが実行されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="20716-3022">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="20716-3023">「[使用状況のメモ](#usage_notes)」に戻ります。</span><span class="sxs-lookup"><span data-stu-id="20716-3023">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="20716-3024">型名の解決 (特殊文字を使用した)</span><span class="sxs-lookup"><span data-stu-id="20716-3024">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="20716-3025">アセンブリ修飾名では、特定の文字が特別な意味を持ちます。</span><span class="sxs-lookup"><span data-stu-id="20716-3025">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="20716-3026">単純型名にこれらの文字が含まれている場合、単純名がアセンブリ修飾名の一部であると、文字によって解析エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="20716-3026">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="20716-3027">解析エラーを回避するには、アセンブリ修飾名を <xref:System.Type.GetType%2A> メソッドに渡す前に、円記号を使用して特殊文字をエスケープする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3027">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="20716-3028">たとえば、型に `Strange]Type`という名前が付いている場合は、次のように、角かっこの前にエスケープ文字を追加する必要があります: `Strange\]Type`。</span><span class="sxs-lookup"><span data-stu-id="20716-3028">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3029">これらの特殊文字を含む名前は Visual Basic またはC#で作成できませんが、Microsoft 中間言語 (MSIL) を使用して作成することも、動的アセンブリを出力することによって作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3029">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="20716-3030">次の表は、型名の特殊文字を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3030">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="20716-3031">文字</span><span class="sxs-lookup"><span data-stu-id="20716-3031">Character</span></span>|<span data-ttu-id="20716-3032">意味</span><span class="sxs-lookup"><span data-stu-id="20716-3032">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="20716-3033">`,` (コンマ)</span><span class="sxs-lookup"><span data-stu-id="20716-3033">`,` (comma)</span></span>|<span data-ttu-id="20716-3034">アセンブリ修飾名の区切り記号。</span><span class="sxs-lookup"><span data-stu-id="20716-3034">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="20716-3035">`[]` (角かっこ)</span><span class="sxs-lookup"><span data-stu-id="20716-3035">`[]` (square brackets)</span></span>|<span data-ttu-id="20716-3036">サフィックスペアとして、は配列型を示します。区切り記号のペアとして、ジェネリック引数リストとアセンブリ修飾名を囲みます。</span><span class="sxs-lookup"><span data-stu-id="20716-3036">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="20716-3037">`&` (アンパサンド)</span><span class="sxs-lookup"><span data-stu-id="20716-3037">`&` (ampersand)</span></span>|<span data-ttu-id="20716-3038">サフィックスとして、型が参照型であることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3038">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="20716-3039">`*` (アスタリスク)</span><span class="sxs-lookup"><span data-stu-id="20716-3039">`*` (asterisk)</span></span>|<span data-ttu-id="20716-3040">サフィックスとして、型がポインター型であることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3040">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="20716-3041">`+` (プラス)</span><span class="sxs-lookup"><span data-stu-id="20716-3041">`+` (plus)</span></span>|<span data-ttu-id="20716-3042">入れ子にされた型の区切り記号。</span><span class="sxs-lookup"><span data-stu-id="20716-3042">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="20716-3043">`\` (円記号)</span><span class="sxs-lookup"><span data-stu-id="20716-3043">`\` (backslash)</span></span>|<span data-ttu-id="20716-3044">エスケープ文字。</span><span class="sxs-lookup"><span data-stu-id="20716-3044">Escape character.</span></span>|  
  
 <span data-ttu-id="20716-3045"><xref:System.Type.AssemblyQualifiedName%2A> などのプロパティは、正しくエスケープされた文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3045">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="20716-3046">正しくエスケープされた文字列を <xref:System.Type.GetType%2A> メソッドに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3046">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="20716-3047">さらに、<xref:System.Type.GetType%2A> メソッドは、`typeResolver`、および既定の型解決メソッドに正しくエスケープされた名前を渡します。</span><span class="sxs-lookup"><span data-stu-id="20716-3047">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="20716-3048">`typeResolver`でエスケープ解除された名前と名前を比較する必要がある場合は、エスケープ文字を削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3048">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="20716-3049">「[使用状況のメモ](#usage_notes)」に戻ります。</span><span class="sxs-lookup"><span data-stu-id="20716-3049">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="20716-3050">混合名前解決</span><span class="sxs-lookup"><span data-stu-id="20716-3050">Mixed Name Resolution</span></span>  
 <span data-ttu-id="20716-3051">次の表は、`typeName`内の型名とアセンブリ名のすべての組み合わせについて、`assemblyResolver`、`typeResolver`、および既定の名前解決の相互作用をまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="20716-3051">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="20716-3052">型名の内容</span><span class="sxs-lookup"><span data-stu-id="20716-3052">Contents of type name</span></span>|<span data-ttu-id="20716-3053">アセンブリリゾルバーメソッド</span><span class="sxs-lookup"><span data-stu-id="20716-3053">Assembly resolver method</span></span>|<span data-ttu-id="20716-3054">型リゾルバーメソッド</span><span class="sxs-lookup"><span data-stu-id="20716-3054">Type resolver method</span></span>|<span data-ttu-id="20716-3055">結果</span><span class="sxs-lookup"><span data-stu-id="20716-3055">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="20716-3056">型、アセンブリ</span><span class="sxs-lookup"><span data-stu-id="20716-3056">type, assembly</span></span>|<span data-ttu-id="20716-3057">null</span><span class="sxs-lookup"><span data-stu-id="20716-3057">null</span></span>|<span data-ttu-id="20716-3058">null</span><span class="sxs-lookup"><span data-stu-id="20716-3058">null</span></span>|<span data-ttu-id="20716-3059"><xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドのオーバーロードを呼び出すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-3059">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="20716-3060">型、アセンブリ</span><span class="sxs-lookup"><span data-stu-id="20716-3060">type, assembly</span></span>|<span data-ttu-id="20716-3061">指示</span><span class="sxs-lookup"><span data-stu-id="20716-3061">provided</span></span>|<span data-ttu-id="20716-3062">null</span><span class="sxs-lookup"><span data-stu-id="20716-3062">null</span></span>|<span data-ttu-id="20716-3063">`assemblyResolver` はアセンブリを返すか、アセンブリを解決できない場合は `null` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3063">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="20716-3064">アセンブリが解決された場合、<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドのオーバーロードを使用して、アセンブリから型を読み込みます。それ以外の場合、型の解決は試行されません。</span><span class="sxs-lookup"><span data-stu-id="20716-3064">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="20716-3065">型、アセンブリ</span><span class="sxs-lookup"><span data-stu-id="20716-3065">type, assembly</span></span>|<span data-ttu-id="20716-3066">null</span><span class="sxs-lookup"><span data-stu-id="20716-3066">null</span></span>|<span data-ttu-id="20716-3067">指示</span><span class="sxs-lookup"><span data-stu-id="20716-3067">provided</span></span>|<span data-ttu-id="20716-3068">アセンブリ名を <xref:System.Reflection.AssemblyName> オブジェクトに変換し、<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> メソッドオーバーロードを呼び出してアセンブリを取得する場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-3068">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="20716-3069">アセンブリが解決された場合は、`typeResolver`に渡されます。それ以外の場合、`typeResolver` は呼び出されず、型の解決を試行することはありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3069">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="20716-3070">型、アセンブリ</span><span class="sxs-lookup"><span data-stu-id="20716-3070">type, assembly</span></span>|<span data-ttu-id="20716-3071">指示</span><span class="sxs-lookup"><span data-stu-id="20716-3071">provided</span></span>|<span data-ttu-id="20716-3072">指示</span><span class="sxs-lookup"><span data-stu-id="20716-3072">provided</span></span>|<span data-ttu-id="20716-3073">`assemblyResolver` はアセンブリを返すか、アセンブリを解決できない場合は `null` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3073">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="20716-3074">アセンブリが解決された場合は、`typeResolver`に渡されます。それ以外の場合、`typeResolver` は呼び出されず、型の解決を試行することはありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3074">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="20716-3075">type</span><span class="sxs-lookup"><span data-stu-id="20716-3075">type</span></span>|<span data-ttu-id="20716-3076">null (指定)</span><span class="sxs-lookup"><span data-stu-id="20716-3076">null, provided</span></span>|<span data-ttu-id="20716-3077">null</span><span class="sxs-lookup"><span data-stu-id="20716-3077">null</span></span>|<span data-ttu-id="20716-3078"><xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドのオーバーロードを呼び出すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-3078">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="20716-3079">アセンブリ名が指定されていないため、mscorlib.dll/System.private.corelib と現在実行中のアセンブリのみが検索されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3079">Because the assembly name is not provided, only mscorlib.dll/System.Private.CoreLib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="20716-3080">`assemblyResolver` が指定されている場合は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3080">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="20716-3081">type</span><span class="sxs-lookup"><span data-stu-id="20716-3081">type</span></span>|<span data-ttu-id="20716-3082">null (指定)</span><span class="sxs-lookup"><span data-stu-id="20716-3082">null, provided</span></span>|<span data-ttu-id="20716-3083">指示</span><span class="sxs-lookup"><span data-stu-id="20716-3083">provided</span></span>|<span data-ttu-id="20716-3084">`typeResolver` が呼び出され、アセンブリの `null` が渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3084">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="20716-3085">`typeResolver` は、その目的のために読み込むアセンブリを含む、任意のアセンブリから型を提供できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3085">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="20716-3086">`assemblyResolver` が指定されている場合は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3086">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="20716-3087">アセンブリ (assembly)</span><span class="sxs-lookup"><span data-stu-id="20716-3087">assembly</span></span>|<span data-ttu-id="20716-3088">null (指定)</span><span class="sxs-lookup"><span data-stu-id="20716-3088">null, provided</span></span>|<span data-ttu-id="20716-3089">null (指定)</span><span class="sxs-lookup"><span data-stu-id="20716-3089">null, provided</span></span>|<span data-ttu-id="20716-3090">アセンブリ名がアセンブリ修飾型名であるかのように解析されるため、<xref:System.IO.FileLoadException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3090">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="20716-3091">これにより、無効なアセンブリ名が生成されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3091">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="20716-3092">に戻る:[使用状況に関するメモ](#usage_notes)、[アセンブリの解決](#resolving_assemblies)、[型の解決](#resolving_types)。</span><span class="sxs-lookup"><span data-stu-id="20716-3092">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-3093"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3093"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-3094">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-3094">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-3095"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3095"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="20716-3096">または</span><span class="sxs-lookup"><span data-stu-id="20716-3096">-or-</span></span> 
 <span data-ttu-id="20716-3097"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3097"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="20716-3098">または</span><span class="sxs-lookup"><span data-stu-id="20716-3098">-or-</span></span> 
 <span data-ttu-id="20716-3099"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="20716-3099"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="20716-3100">または</span><span class="sxs-lookup"><span data-stu-id="20716-3100">-or-</span></span> 
 <span data-ttu-id="20716-3101"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-3101"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="20716-3102">または</span><span class="sxs-lookup"><span data-stu-id="20716-3102">-or-</span></span> 
 <span data-ttu-id="20716-3103"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3103"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3104"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。</span><span class="sxs-lookup"><span data-stu-id="20716-3104">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="20716-3105">または</span><span class="sxs-lookup"><span data-stu-id="20716-3105">-or-</span></span> 
 <span data-ttu-id="20716-3106"><paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 ("MyType[,\*,]" など) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3106"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="20716-3107">または</span><span class="sxs-lookup"><span data-stu-id="20716-3107">-or-</span></span> 
 <span data-ttu-id="20716-3108"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3108"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="20716-3109">または</span><span class="sxs-lookup"><span data-stu-id="20716-3109">-or-</span></span> 
 <span data-ttu-id="20716-3110"><paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-3110"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="20716-3111">または</span><span class="sxs-lookup"><span data-stu-id="20716-3111">-or-</span></span> 
 <span data-ttu-id="20716-3112"><paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3112"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="20716-3113"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-3113"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="20716-3114">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-3114">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="20716-3115">または</span><span class="sxs-lookup"><span data-stu-id="20716-3115">-or-</span></span> 
 <span data-ttu-id="20716-3116"><paramref name="typeName" /> に無効なアセンブリ名が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3116"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="20716-3117">または</span><span class="sxs-lookup"><span data-stu-id="20716-3117">-or-</span></span> 
 <span data-ttu-id="20716-3118"><paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</span><span class="sxs-lookup"><span data-stu-id="20716-3118"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="20716-3119">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3119">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="20716-3120">または</span><span class="sxs-lookup"><span data-stu-id="20716-3120">-or-</span></span>  
  
 <span data-ttu-id="20716-3121">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="20716-3121">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="20716-3122">型を確認する対象のオブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-3122">An array of objects whose types to determine.</span></span></param>
        <summary><span data-ttu-id="20716-3123">指定した配列内のオブジェクトの型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3123">Gets the types of the objects in the specified array.</span></span></summary>
        <returns><span data-ttu-id="20716-3124"><paramref name="args" /> 内の対応する要素の型を表す <see cref="T:System.Type" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-3124">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="20716-3125">次のコード例は、<xref:System.Type.GetTypeArray%2A> メソッドを使用して、配列の要素の型を一覧表示する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3125">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-3126"><paramref name="args" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3126"><paramref name="args" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-3127">または</span><span class="sxs-lookup"><span data-stu-id="20716-3127">-or-</span></span> 
<span data-ttu-id="20716-3128"><paramref name="args" /> の要素の 1 つ以上が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3128">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-3129">クラスの初期化子が呼び出され、少なくとも 1 つは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-3129">The class initializers are invoked and at least one throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeCode (type As Type) As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="20716-3130">基になる型コードを取得する対象となる型。</span><span class="sxs-lookup"><span data-stu-id="20716-3130">The type whose underlying type code to get.</span></span></param>
        <summary><span data-ttu-id="20716-3131">指定した <see cref="T:System.Type" /> の基になる型コードを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3131">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-3132"><paramref name="type" /> が <see langword="null" /> の場合、基になる型または <see cref="F:System.TypeCode.Empty" /> のコード。</span><span class="sxs-lookup"><span data-stu-id="20716-3132">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3133"><xref:System.Type>から継承する場合は、<xref:System.Type.GetTypeCodeImpl%2A> メソッドをオーバーライドすることによって、このメソッドの動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3133">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3134">次のコード例は、<xref:System.TypeCode> 列挙型の使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3134">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="20716-3135">`WriteObjectInfo` メソッド内のデシジョンブロックでは、<xref:System.Object> パラメーターの <xref:System.TypeCode> が検査され、適切なメッセージがコンソールに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3135">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-3136">この <see cref="T:System.Type" /> インスタンスの基になる型コードを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3136">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span></span></summary>
        <returns><span data-ttu-id="20716-3137">基になる型の型コード。</span><span class="sxs-lookup"><span data-stu-id="20716-3137">The type code of the underlying type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3138">このメソッドは、`static` ( C#) または `Shared` (Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> メソッドの実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="20716-3138">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="20716-3139"><xref:System.Type>から継承する場合は、このメソッドをオーバーライドして、<xref:System.Type.GetTypeCode%2A>の独自の実装を提供できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3139">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-3140">指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3140">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="20716-3141">取得する型の CLSID。</span><span class="sxs-lookup"><span data-stu-id="20716-3141">The CLSID of the type to get.</span></span></param>
        <summary><span data-ttu-id="20716-3142">指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3142">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="20716-3143">CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3143"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3144"><xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。</span><span class="sxs-lookup"><span data-stu-id="20716-3144">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="20716-3145">COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3145">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="20716-3146"><xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3146">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="20716-3147"><xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3147">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="20716-3148">アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="20716-3148">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="20716-3149"><xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する`__ComObject` を表す <xref:System.Type> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3149">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="20716-3150"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="20716-3150">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="20716-3151">例については、図を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3151">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="20716-3152"><xref:System.Type.GetTypeFromCLSID%28System.Guid%29> のオーバーロードは、`clsid` 引数に基づいて <xref:System.Type> オブジェクトをインスタンス化するときに発生する可能性のある例外を無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-3152">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="20716-3153">`clsid` がレジストリに見つからない場合は、例外がスローされないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3153">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3154">次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、microsoft word アプリケーションを表す COM 型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3154">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="20716-3155">次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。</span><span class="sxs-lookup"><span data-stu-id="20716-3155">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="20716-3156">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="20716-3156">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="20716-3157">COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3157">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="20716-3158">メソッドは、.NET Framework オブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって、その <see cref="T:System.Type" /> オブジェクトを使用して型インスタンスを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3158">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="20716-3159">[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="20716-3159">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="20716-3160">代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3160">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="20716-3161">取得する型の CLSID。</span><span class="sxs-lookup"><span data-stu-id="20716-3161">The CLSID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-3162">発生した例外をすべてスローする場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3162"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="20716-3163">または</span><span class="sxs-lookup"><span data-stu-id="20716-3163">-or-</span></span> 
 <span data-ttu-id="20716-3164">発生した例外をすべて無視する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3164"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="20716-3165">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したクラス ID (CLSID) に関連付けられた型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3165">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="20716-3166">CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3166"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3167"><xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。</span><span class="sxs-lookup"><span data-stu-id="20716-3167">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="20716-3168">COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3168">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="20716-3169"><xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3169">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="20716-3170"><xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3170">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="20716-3171">アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="20716-3171">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="20716-3172"><xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する `__ComObject` を表す <xref:System.Type> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3172">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="20716-3173"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="20716-3173">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="20716-3174">例については、図を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3174">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="20716-3175">`throwOnError`に `true` を指定すると、<xref:System.OutOfMemoryException> などの例外がスローされますが、登録されていない Clsid では失敗しません。</span><span class="sxs-lookup"><span data-stu-id="20716-3175">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3176">次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、microsoft word アプリケーションを表す COM 型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3176">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="20716-3177">次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。</span><span class="sxs-lookup"><span data-stu-id="20716-3177">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="20716-3178">型の読み込み中にエラーが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3178">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="20716-3179">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="20716-3179">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="20716-3180">COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3180">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="20716-3181">メソッドは、.NET Framework オブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって、その <see cref="T:System.Type" /> オブジェクトを使用して型インスタンスを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3181">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="20716-3182">[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="20716-3182">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="20716-3183">代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3183">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="20716-3184">取得する型の CLSID。</span><span class="sxs-lookup"><span data-stu-id="20716-3184">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="20716-3185">型の読み込み元のサーバー。</span><span class="sxs-lookup"><span data-stu-id="20716-3185">The server from which to load the type.</span></span> <span data-ttu-id="20716-3186">サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3186">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="20716-3187">指定したサーバーから、指定したクラス ID (CLSID) に関連付けられている型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3187">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span></span></summary>
        <returns><span data-ttu-id="20716-3188">CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3188"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3189"><xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。</span><span class="sxs-lookup"><span data-stu-id="20716-3189">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="20716-3190">COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3190">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="20716-3191"><xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3191">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="20716-3192"><xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3192">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="20716-3193">アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="20716-3193">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="20716-3194"><xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する `__ComObject` を表す <xref:System.Type> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3194">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="20716-3195"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="20716-3195">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3196">次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、computer17.central.contoso.com という名前のサーバーから microsoft word アプリケーションを表す COM 型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3196">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="20716-3197">次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。</span><span class="sxs-lookup"><span data-stu-id="20716-3197">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="20716-3198">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="20716-3198">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="20716-3199">COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3199">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="20716-3200">メソッドは、.NET Framework オブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって、その <see cref="T:System.Type" /> オブジェクトを使用して型インスタンスを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3200">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="20716-3201">[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="20716-3201">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="20716-3202">代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3202">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="20716-3203">取得する型の CLSID。</span><span class="sxs-lookup"><span data-stu-id="20716-3203">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="20716-3204">型の読み込み元のサーバー。</span><span class="sxs-lookup"><span data-stu-id="20716-3204">The server from which to load the type.</span></span> <span data-ttu-id="20716-3205">サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3205">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-3206">発生した例外をすべてスローする場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3206"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="20716-3207">または</span><span class="sxs-lookup"><span data-stu-id="20716-3207">-or-</span></span> 
 <span data-ttu-id="20716-3208">発生した例外をすべて無視する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3208"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="20716-3209">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したクラス ID (CLSID) に関連付けられた型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3209">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="20716-3210">CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3210"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3211"><xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。</span><span class="sxs-lookup"><span data-stu-id="20716-3211">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="20716-3212">COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3212">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="20716-3213"><xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3213">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="20716-3214"><xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3214">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="20716-3215">アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="20716-3215">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="20716-3216"><xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する `__ComObject` を表す <xref:System.Type> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3216">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="20716-3217"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="20716-3217">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="20716-3218">`throwOnError`に `true` を指定すると、<xref:System.OutOfMemoryException> などの例外がスローされますが、登録されていない Clsid では失敗しません。</span><span class="sxs-lookup"><span data-stu-id="20716-3218">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3219">次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、computer17.central.contoso.com という名前のサーバーから microsoft word アプリケーションを表す COM 型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3219">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="20716-3220">次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。</span><span class="sxs-lookup"><span data-stu-id="20716-3220">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="20716-3221">型の読み込み中にエラーが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3221">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="20716-3222">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="20716-3222">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="20716-3223">COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3223">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="20716-3224"><see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> メソッドは、特定のマネージオブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、その <see cref="T:System.Type" /> オブジェクトを使用して、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって型インスタンスを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3224">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="20716-3225">[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="20716-3225">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="20716-3226">代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3226">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="20716-3227">型を参照するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3227">The object that refers to the type.</span></span></param>
        <summary><span data-ttu-id="20716-3228">指定した型ハンドルによって参照される型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3228">Gets the type referenced by the specified type handle.</span></span></summary>
        <returns><span data-ttu-id="20716-3229">指定した <see cref="T:System.RuntimeTypeHandle" /> によって参照される型。または <paramref name="handle" /> の <see cref="P:System.RuntimeTypeHandle.Value" /> プロパティが <see langword="null" /> の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3229">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3230">ハンドルは、取得されたアプリケーションドメインでのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3230">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3231">次の例では、<xref:System.Type.GetTypeFromHandle%2A> メソッドを使用して、<xref:System.Type.GetTypeHandle%2A> メソッドによって提供される <xref:System.RuntimeTypeHandle> から <xref:System.Type> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3231">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-3232">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-3232">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-3233">指定したプログラム ID (ProgID) に関連付けられている型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3233">Gets the type associated with the specified program identifier (ProgID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="20716-3234">取得する型の ProgID。</span><span class="sxs-lookup"><span data-stu-id="20716-3234">The ProgID of the type to get.</span></span></param>
        <summary><span data-ttu-id="20716-3235">指定したプログラム ID (ProgID) に関連付けられている型を取得し、<see cref="T:System.Type" /> の読み込み中にエラーが発生した場合は null を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3235">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-3236"><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したクラス ProgID に関連付けられている型。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3236">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3237">このメソッドは、COM をサポートするために用意されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3237">This method is provided for COM support.</span></span> <span data-ttu-id="20716-3238">Progid は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。</span><span class="sxs-lookup"><span data-stu-id="20716-3238">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3239"><paramref name="progID" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3239"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="20716-3240">取得する型の ProgID。</span><span class="sxs-lookup"><span data-stu-id="20716-3240">The ProgID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-3241">発生した例外をすべてスローする場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3241"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="20716-3242">または</span><span class="sxs-lookup"><span data-stu-id="20716-3242">-or-</span></span> 
 <span data-ttu-id="20716-3243">発生した例外をすべて無視する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3243"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="20716-3244">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したプログラム ID (ProgID) に関連付けられた型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3244">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="20716-3245"><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (ProgID) に関連付けられている型。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3245">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3246">このメソッドは、COM をサポートするために用意されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3246">This method is provided for COM support.</span></span> <span data-ttu-id="20716-3247">プログラム Id は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。</span><span class="sxs-lookup"><span data-stu-id="20716-3247">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3248">次の例では、progid が無効な場合に例外をスローするかどうかを指定して、ProgID を渡すことによって型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3248">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="20716-3249">この例では、ProgID に関連する ClassID と、該当するすべての例外メッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3249">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3250"><paramref name="progID" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3250"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="20716-3251">指定された ProgID が登録されていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3251">The specified ProgID is not registered.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="20716-3252">取得する型の ProgID。</span><span class="sxs-lookup"><span data-stu-id="20716-3252">The progID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="20716-3253">型の読み込み元のサーバー。</span><span class="sxs-lookup"><span data-stu-id="20716-3253">The server from which to load the type.</span></span> <span data-ttu-id="20716-3254">サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3254">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="20716-3255">指定したサーバーから、指定したプログラム ID (progID) に関連付けられている型を取得し、型の読み込み中にエラーが発生した場合は null を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3255">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span></span></summary>
        <returns><span data-ttu-id="20716-3256"><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3256">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3257">このメソッドは、COM をサポートするために用意されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3257">This method is provided for COM support.</span></span> <span data-ttu-id="20716-3258">プログラム Id は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。</span><span class="sxs-lookup"><span data-stu-id="20716-3258">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3259">次の例では、ProgID とサーバー名を渡して型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3259">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="20716-3260">次に、ProgID に関連する ClassID を表示します。 ProgID またはサーバー名が無効な場合は、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-3260">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3261"><paramref name="prodID" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3261"><paramref name="prodID" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="20716-3262">取得する <see cref="T:System.Type" /> のプログラム ID。</span><span class="sxs-lookup"><span data-stu-id="20716-3262">The progID of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="server"><span data-ttu-id="20716-3263">型の読み込み元のサーバー。</span><span class="sxs-lookup"><span data-stu-id="20716-3263">The server from which to load the type.</span></span> <span data-ttu-id="20716-3264">サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3264">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="20716-3265">発生した例外をすべてスローする場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3265"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="20716-3266">または</span><span class="sxs-lookup"><span data-stu-id="20716-3266">-or-</span></span> 
 <span data-ttu-id="20716-3267">発生した例外をすべて無視する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3267"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="20716-3268">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したプログラム ID (ProgID) に関連付けられた型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3268">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="20716-3269"><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3269">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3270">このメソッドは、COM をサポートするために用意されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3270">This method is provided for COM support.</span></span> <span data-ttu-id="20716-3271">プログラム Id は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。</span><span class="sxs-lookup"><span data-stu-id="20716-3271">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3272">次の例では、ProgID とサーバー名を渡して型を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3272">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="20716-3273">次に、progid に関連する ClassID が表示されます。 ProgID またはサーバー名が無効である場合に例外をスローするかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3273">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3274"><paramref name="progID" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3274"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="20716-3275">指定された progID が登録されていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3275">The specified progID is not registered.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="20716-3276">型ハンドルの取得対象となるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3276">The object for which to get the type handle.</span></span></param>
        <summary><span data-ttu-id="20716-3277">指定したオブジェクトの <see cref="T:System.Type" /> のハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3277">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span></span></summary>
        <returns><span data-ttu-id="20716-3278">指定した <see cref="T:System.Type" /> の <see cref="T:System.Object" /> のハンドル。</span><span class="sxs-lookup"><span data-stu-id="20716-3278">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3279">ハンドルは、取得されたアプリケーションドメインでのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3279">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3280">次の例では、`MyClass1`クラスを定義し、そのインスタンスを取得して、オブジェクトのランタイムハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3280">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-3281"><paramref name="o" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3281"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3282"><see cref="T:System.Type" /> に関連付けられている GUID を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3282">Gets the GUID associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="20716-3283"><see cref="T:System.Type" /> に関連付けられている GUID。</span><span class="sxs-lookup"><span data-stu-id="20716-3283">The GUID associated with the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3284">GUID は、<xref:System.Runtime.InteropServices.GuidAttribute> 属性を使用して型に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="20716-3284">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3285">次の例では、パブリックメソッドを使用して `MyClass1` クラスを作成し、`MyClass1`に対応する `Type` オブジェクトを作成し、`GUID` クラスの `Type` プロパティを使用して <xref:System.Guid> 構造体を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3285">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3286">現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列、ポインター、または参照渡しかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3286">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <value><span data-ttu-id="20716-3287"><see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3287"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3288">たとえば、「GetType ("Int32 []")」と入力します。HasElementType は `true`を返しますが、タイプ GetType ("Int32") です。HasElementType は `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3288">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="20716-3289">また、HasElementType は、"Int32 \*" と "Int32 &" の `true` も返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3289">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="20716-3290">現在の <xref:System.Type> がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3290">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3291">次の例では、オブジェクトが配列、参照型、またはポインターであるかどうかに応じて、`true` または `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3291">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-3292">派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.HasElementType" /> プロパティを実装し、現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列やポインターであるか、参照渡しかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3292">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="20716-3293"><see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3293"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3294">たとえば、「GetType ("Int32 []")」と入力します。HasElementTypeImpl は `true`を返しますが、タイプ GetType ("Int32") です。HasElementTypeImpl は `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3294">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="20716-3295">また、HasElementTypeImpl では、"Int32 \*" と "Int32 &" の `true` も返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3295">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3296">次の例では、`HasElementTypeImpl` メソッドをオーバーライドする `MyTypeDelegator`クラスを定義しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3296">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="20716-3297">Main クラスは、`HasElementType` プロパティを確認し、要素の型を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3297">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-3298">現在の <see cref="T:System.Type" /> の特定のメンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-3298">Invokes a specific member of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-3299">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-3299">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="20716-3300">または</span><span class="sxs-lookup"><span data-stu-id="20716-3300">-or-</span></span> 
<span data-ttu-id="20716-3301">既定メンバーを呼び出すための空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="20716-3301">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="20716-3302">または</span><span class="sxs-lookup"><span data-stu-id="20716-3302">-or-</span></span> 
<span data-ttu-id="20716-3303"><see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-3303">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="20716-3304">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-3304">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="20716-3305">アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。</span><span class="sxs-lookup"><span data-stu-id="20716-3305">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="20716-3306">検索の種類を指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3306">The type of lookup need not be specified.</span></span> <span data-ttu-id="20716-3307">検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3307">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-3308">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3308">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-3309">または</span><span class="sxs-lookup"><span data-stu-id="20716-3309">-or-</span></span> 
<span data-ttu-id="20716-3310"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-3310">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="20716-3311">可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</span><span class="sxs-lookup"><span data-stu-id="20716-3311">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="20716-3312">指定したメンバーを呼び出す対象となるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3312">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="20716-3313">呼び出すメンバーに渡される引数を格納する配列。</span><span class="sxs-lookup"><span data-stu-id="20716-3313">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <summary><span data-ttu-id="20716-3314">指定したバインディング制約を使用し、指定した引数リストと照合して、指定したメンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-3314">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span></span></summary>
        <returns><span data-ttu-id="20716-3315">呼び出されるメンバーの戻り値を表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3315">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="20716-3316"><xref:System.Type.InvokeMember%2A> を使用してジェネリックメソッドを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3316">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="20716-3317">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3317">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-3318">パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3318">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="20716-3319">`BindingFlags.NonPublic` を指定すると、パブリックでないメンバー (つまり、プライベートメンバーとプロテクトメンバー) を検索に含めることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3319">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="20716-3320">階層の上位に静的メンバーを含めるには、`BindingFlags.FlattenHierarchy` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3320">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="20716-3321">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3321">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-3322">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-3322">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-3323">単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3323">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-3324">次の <xref:System.Reflection.BindingFlags> の呼び出しフラグを使用して、メンバーに対して実行するアクションを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3324">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="20716-3325">コンストラクターを呼び出すように `CreateInstance` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3325">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="20716-3326">`name` は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3326">`name` is ignored.</span></span> <span data-ttu-id="20716-3327">他の呼び出しフラグと共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3327">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="20716-3328">コンストラクターや型の初期化子ではなく、メソッドを呼び出すように `InvokeMethod` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3328">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="20716-3329">`SetField` または `SetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3329">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="20716-3330">`InvokeMethod` が単独で指定されている場合、`BindingFlags.Public`、`BindingFlags.Instance`、および `BindingFlags.Static` が自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3330">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="20716-3331">フィールドの値を取得 `GetField`。</span><span class="sxs-lookup"><span data-stu-id="20716-3331">`GetField` to get the value of a field.</span></span> <span data-ttu-id="20716-3332">`SetField`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3332">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="20716-3333">フィールドの値を設定 `SetField`。</span><span class="sxs-lookup"><span data-stu-id="20716-3333">`SetField` to set the value of a field.</span></span> <span data-ttu-id="20716-3334">`GetField`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3334">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="20716-3335">プロパティを取得するために `GetProperty` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3335">`GetProperty` to get a property.</span></span> <span data-ttu-id="20716-3336">`SetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3336">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="20716-3337">プロパティを設定する `SetProperty` ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3337">`SetProperty` to set a property.</span></span> <span data-ttu-id="20716-3338">`GetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3338">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="20716-3339">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3339">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-3340">次の両方の条件に該当する場合は、メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3340">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="20716-3341">メソッド宣言内のパラメーターの数は、`args` 配列内の引数の数と等しくなります (既定の引数がメンバーに対して定義され、`BindingFlags.OptionalParamBinding` が指定されている場合を除く)。</span><span class="sxs-lookup"><span data-stu-id="20716-3341">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="20716-3342">各引数の型は、バインダーによってパラメーターの型に変換できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3342">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="20716-3343">バインダーは、一致するすべてのメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-3343">The binder will find all of the matching methods.</span></span> <span data-ttu-id="20716-3344">これらのメソッドは、要求されたバインディングの種類 (<xref:System.Reflection.BindingFlags> 値 `InvokeMethod`、`GetProperty`など) に基づいて検出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3344">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="20716-3345">メソッドのセットは、バインダーで定義されている名前、引数の数、および一連の検索修飾子によってフィルター処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3345">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="20716-3346">メソッドが選択されると、呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3346">After the method is selected, it is invoked.</span></span> <span data-ttu-id="20716-3347">その時点でアクセシビリティがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3347">Accessibility is checked at that point.</span></span> <span data-ttu-id="20716-3348">検索では、メソッドに関連付けられているアクセシビリティ属性に基づいて検索されるメソッドのセットを制御できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3348">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="20716-3349"><xref:System.Reflection.Binder> クラスの <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> メソッドは、呼び出されるメソッドを選択する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="20716-3349">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="20716-3350">既定のバインダーでは、最も限定的な一致が選択されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3350">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="20716-3351">完全に信頼されたコードでは、アクセス制限は無視されます。つまり、プライベートコンストラクター、メソッド、フィールド、およびプロパティには、コードが完全に信頼されている場合は常に <xref:System.Reflection> を通じてアクセスおよび呼び出しを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3351">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="20716-3352">`Type.InvokeMember` を使用すると、<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>を指定することによってフィールドを特定の値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3352">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20716-3353">たとえば、F という名前のパブリックインスタンスフィールドをクラス C に設定し、F が `String`である場合は、次のようなコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3353">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="20716-3354">F が `String[]`である場合は、次のようなコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3354">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="20716-3355">これにより、フィールド F がこの新しい配列に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3355">which will initialize the field F to this new array.</span></span> <span data-ttu-id="20716-3356">また、`Type.InvokeMember` を使用して、値のインデックスを指定し、次のようなコードを使用して次の値を指定することによって、配列内の位置を設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3356">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="20716-3357">これにより、F が保持する配列内の文字列 "z" が文字列 "b" に変更されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3357">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="20716-3358">`IDispatch` メンバーを呼び出す場合は、"[DispID = # #]" という文字列形式を使用して、メンバー名の代わりに DispID を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3358">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="20716-3359">たとえば、MyComMethod の DispID が3の場合、"MyComMethod" ではなく "[DispID = 3]" という文字列を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3359">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="20716-3360">メンバーを DispID で呼び出す方が、メンバーを名前で検索するよりも高速です。</span><span class="sxs-lookup"><span data-stu-id="20716-3360">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="20716-3361">複雑な集計シナリオでは、DispID が目的のメンバーを呼び出す唯一の方法である場合があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3361">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3362">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されている場合、および非パブリックメンバーの許可セットが呼び出し元の許可セットまたはサブセットに制限されている場合に、このメソッドを使用して非パブリックメンバーにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3362">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="20716-3363">(「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。</span><span class="sxs-lookup"><span data-stu-id="20716-3363">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="20716-3364">この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3364">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3365">次の例では、`InvokeMember` を使用して、型のメンバーにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="20716-3365">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-3366"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3366"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3367"><paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3367"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="20716-3368">または</span><span class="sxs-lookup"><span data-stu-id="20716-3368">-or-</span></span> 
 <span data-ttu-id="20716-3369"><paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3369"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3370">または</span><span class="sxs-lookup"><span data-stu-id="20716-3370">-or-</span></span> 
 <span data-ttu-id="20716-3371"><paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3371"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3372">または</span><span class="sxs-lookup"><span data-stu-id="20716-3372">-or-</span></span> 
 <span data-ttu-id="20716-3373"><paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3373"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="20716-3374">または</span><span class="sxs-lookup"><span data-stu-id="20716-3374">-or-</span></span> 
 <span data-ttu-id="20716-3375"><paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3375"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3376">または</span><span class="sxs-lookup"><span data-stu-id="20716-3376">-or-</span></span> 
 <span data-ttu-id="20716-3377"><paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3377"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3378">または</span><span class="sxs-lookup"><span data-stu-id="20716-3378">-or-</span></span> 
 <span data-ttu-id="20716-3379"><paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3379"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="20716-3380">または</span><span class="sxs-lookup"><span data-stu-id="20716-3380">-or-</span></span> 
<span data-ttu-id="20716-3381">COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-3381">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="20716-3382">または</span><span class="sxs-lookup"><span data-stu-id="20716-3382">-or-</span></span> 
<span data-ttu-id="20716-3383">名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3383">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="20716-3384">指定されたメンバーは、クラス初期化子です。</span><span class="sxs-lookup"><span data-stu-id="20716-3384">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="20716-3385">フィールドまたはプロパティが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3385">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="20716-3386"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3386">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="20716-3387">または</span><span class="sxs-lookup"><span data-stu-id="20716-3387">-or-</span></span> 
<span data-ttu-id="20716-3388">現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3388">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="20716-3389">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</span><span class="sxs-lookup"><span data-stu-id="20716-3389">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-3390">複数のメソッドがバインディングの基準と一致します。</span><span class="sxs-lookup"><span data-stu-id="20716-3390">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-3391">現在、.NET Compact Framework は、このメソッドをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3391">The .NET Compact Framework does not currently support this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-3392"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-3392">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="20716-3393">つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3393">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object(), culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-3394">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-3394">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="20716-3395">または</span><span class="sxs-lookup"><span data-stu-id="20716-3395">-or-</span></span> 
<span data-ttu-id="20716-3396">既定メンバーを呼び出すための空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="20716-3396">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="20716-3397">または</span><span class="sxs-lookup"><span data-stu-id="20716-3397">-or-</span></span> 
<span data-ttu-id="20716-3398"><see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-3398">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="20716-3399">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-3399">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="20716-3400">アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。</span><span class="sxs-lookup"><span data-stu-id="20716-3400">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="20716-3401">検索の種類を指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3401">The type of lookup need not be specified.</span></span> <span data-ttu-id="20716-3402">検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3402">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-3403">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3403">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-3404">または</span><span class="sxs-lookup"><span data-stu-id="20716-3404">-or-</span></span> 
<span data-ttu-id="20716-3405"><see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-3405">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="20716-3406">可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</span><span class="sxs-lookup"><span data-stu-id="20716-3406">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="20716-3407">指定したメンバーを呼び出す対象となるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3407">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="20716-3408">呼び出すメンバーに渡される引数を格納する配列。</span><span class="sxs-lookup"><span data-stu-id="20716-3408">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="culture"><span data-ttu-id="20716-3409">使用するグローバリゼーション ロケールを表すオブジェクト。これは、<see cref="T:System.String" /> 型の数値を <see cref="T:System.Double" /> に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3409">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span></span>  
  
<span data-ttu-id="20716-3410">または</span><span class="sxs-lookup"><span data-stu-id="20716-3410">-or-</span></span> 
<span data-ttu-id="20716-3411">現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-3411">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <summary><span data-ttu-id="20716-3412">指定したバインディング制約を使用し、指定したメンバーのうち、指定した引数リストおよびカルチャと一致するメンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-3412">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span></span></summary>
        <returns><span data-ttu-id="20716-3413">呼び出されるメンバーの戻り値を表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3413">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3414">既定のバインダーでは <xref:System.Globalization.CultureInfo> (`culture` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`culture`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3414">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3415"><xref:System.Type.InvokeMember%2A> を使用してジェネリックメソッドを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3415">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="20716-3416">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3416">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-3417">パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3417">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="20716-3418">検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3418">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="20716-3419">階層の上位に静的メンバーを含めるには、`BindingFlags.FlattenHierarchy` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3419">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="20716-3420">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3420">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-3421">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-3421">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-3422">単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3422">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-3423">次の <xref:System.Reflection.BindingFlags> の呼び出しフラグを使用して、メンバーに対して実行するアクションを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3423">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="20716-3424">コンストラクターを呼び出すように `CreateInstance` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3424">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="20716-3425">`name` は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3425">`name` is ignored.</span></span> <span data-ttu-id="20716-3426">他の呼び出しフラグと共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3426">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="20716-3427">コンストラクターや型の初期化子ではなく、メソッドを呼び出すように `InvokeMethod` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3427">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="20716-3428">`SetField` または `SetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3428">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="20716-3429">`InvokeMethod` が単独で指定されている場合、`BindingFlags.Public`、`BindingFlags.Instance`、および `BindingFlags.Static` が自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3429">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="20716-3430">フィールドの値を取得 `GetField`。</span><span class="sxs-lookup"><span data-stu-id="20716-3430">`GetField` to get the value of a field.</span></span> <span data-ttu-id="20716-3431">`SetField`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3431">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="20716-3432">フィールドの値を設定 `SetField`。</span><span class="sxs-lookup"><span data-stu-id="20716-3432">`SetField` to set the value of a field.</span></span> <span data-ttu-id="20716-3433">`GetField`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3433">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="20716-3434">プロパティを取得するために `GetProperty` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3434">`GetProperty` to get a property.</span></span> <span data-ttu-id="20716-3435">`SetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3435">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="20716-3436">プロパティを設定する `SetProperty` ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3436">`SetProperty` to set a property.</span></span> <span data-ttu-id="20716-3437">`GetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3437">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="20716-3438">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3438">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-3439">次の両方の条件に該当する場合は、メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3439">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="20716-3440">メソッド宣言内のパラメーターの数は、`args` 配列内の引数の数と等しくなります (既定の引数がメンバーに対して定義され、`BindingFlags.OptionalParamBinding` が指定されている場合を除く)。</span><span class="sxs-lookup"><span data-stu-id="20716-3440">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="20716-3441">各引数の型は、バインダーによってパラメーターの型に変換できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3441">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="20716-3442">バインダーは、一致するすべてのメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-3442">The binder will find all of the matching methods.</span></span> <span data-ttu-id="20716-3443">これらのメソッドは、要求されたバインディングの種類 (<xref:System.Reflection.BindingFlags> 値 `InvokeMethod`、`GetProperty`など) に基づいて検出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3443">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="20716-3444">メソッドのセットは、バインダーで定義されている名前、引数の数、および一連の検索修飾子によってフィルター処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3444">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="20716-3445">メソッドが選択されると、呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3445">After the method is selected, it is invoked.</span></span> <span data-ttu-id="20716-3446">その時点でアクセシビリティがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3446">Accessibility is checked at that point.</span></span> <span data-ttu-id="20716-3447">検索では、メソッドに関連付けられているアクセシビリティ属性に基づいて検索されるメソッドのセットを制御できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3447">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="20716-3448"><xref:System.Reflection.Binder> クラスの <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> メソッドは、呼び出されるメソッドを選択する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="20716-3448">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="20716-3449">既定のバインダーでは、最も限定的な一致が選択されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3449">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="20716-3450">完全に信頼されたコードでは、アクセス制限は無視されます。つまり、プライベートコンストラクター、メソッド、フィールド、およびプロパティには、コードが完全に信頼されている場合は常に、リフレクションを介してアクセスして呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3450">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="20716-3451">`Type.InvokeMember` を使用すると、<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>を指定することによってフィールドを特定の値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3451">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20716-3452">たとえば、F という名前のパブリックインスタンスフィールドをクラス C に設定し、F が `String` である場合は、次のようなコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3452">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="20716-3453">F が `String[]`である場合は、次のようなコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3453">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="20716-3454">これにより、フィールド F がこの新しい配列に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3454">which will initialize the field F to this new array.</span></span> <span data-ttu-id="20716-3455">また、`Type.InvokeMember` を使用して、値のインデックスを指定し、次のようなコードを使用して次の値を指定することによって、配列内の位置を設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3455">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="20716-3456">これにより、F が保持する配列内の文字列 "z" が文字列 "b" に変更されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3456">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="20716-3457">`IDispatch` メンバーを呼び出す場合は、"[DispID = # #]" という文字列形式を使用して、メンバー名の代わりに DispID を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3457">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="20716-3458">たとえば、MyComMethod の DispID が3の場合、"MyComMethod" ではなく "[DispID = 3]" という文字列を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3458">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="20716-3459">メンバーを DispID で呼び出す方が、メンバーを名前で検索するよりも高速です。</span><span class="sxs-lookup"><span data-stu-id="20716-3459">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="20716-3460">複雑な集計シナリオでは、DispID が目的のメンバーを呼び出す唯一の方法である場合があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3460">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3461">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されている場合、および非パブリックメンバーの許可セットが呼び出し元の許可セットまたはサブセットに制限されている場合に、このメソッドを使用して非パブリックメンバーにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3461">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="20716-3462">(「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。</span><span class="sxs-lookup"><span data-stu-id="20716-3462">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="20716-3463">この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3463">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-3464"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3464"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3465"><paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3465"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="20716-3466">または</span><span class="sxs-lookup"><span data-stu-id="20716-3466">-or-</span></span> 
 <span data-ttu-id="20716-3467"><paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3467"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3468">または</span><span class="sxs-lookup"><span data-stu-id="20716-3468">-or-</span></span> 
 <span data-ttu-id="20716-3469"><paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3469"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3470">または</span><span class="sxs-lookup"><span data-stu-id="20716-3470">-or-</span></span> 
 <span data-ttu-id="20716-3471"><paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3471"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="20716-3472">または</span><span class="sxs-lookup"><span data-stu-id="20716-3472">-or-</span></span> 
 <span data-ttu-id="20716-3473"><paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3473"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3474">または</span><span class="sxs-lookup"><span data-stu-id="20716-3474">-or-</span></span> 
 <span data-ttu-id="20716-3475"><paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3475"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3476">または</span><span class="sxs-lookup"><span data-stu-id="20716-3476">-or-</span></span> 
 <span data-ttu-id="20716-3477"><paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3477"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="20716-3478">または</span><span class="sxs-lookup"><span data-stu-id="20716-3478">-or-</span></span> 
<span data-ttu-id="20716-3479">COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-3479">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="20716-3480">または</span><span class="sxs-lookup"><span data-stu-id="20716-3480">-or-</span></span> 
<span data-ttu-id="20716-3481">名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3481">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="20716-3482">指定されたメンバーは、クラス初期化子です。</span><span class="sxs-lookup"><span data-stu-id="20716-3482">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="20716-3483">フィールドまたはプロパティが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3483">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="20716-3484"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3484">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="20716-3485">または</span><span class="sxs-lookup"><span data-stu-id="20716-3485">-or-</span></span> 
<span data-ttu-id="20716-3486">現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3486">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="20716-3487">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</span><span class="sxs-lookup"><span data-stu-id="20716-3487">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-3488">複数のメソッドがバインディングの基準と一致します。</span><span class="sxs-lookup"><span data-stu-id="20716-3488">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-3489"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-3489">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="20716-3490">つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3490">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, namedParameters As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="20716-3491">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-3491">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="20716-3492">または</span><span class="sxs-lookup"><span data-stu-id="20716-3492">-or-</span></span> 
<span data-ttu-id="20716-3493">既定メンバーを呼び出すための空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="20716-3493">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="20716-3494">または</span><span class="sxs-lookup"><span data-stu-id="20716-3494">-or-</span></span> 
<span data-ttu-id="20716-3495"><see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</span><span class="sxs-lookup"><span data-stu-id="20716-3495">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="20716-3496">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="20716-3496">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="20716-3497">アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。</span><span class="sxs-lookup"><span data-stu-id="20716-3497">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="20716-3498">検索の種類を指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3498">The type of lookup need not be specified.</span></span> <span data-ttu-id="20716-3499">検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3499">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="20716-3500">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3500">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="20716-3501">または</span><span class="sxs-lookup"><span data-stu-id="20716-3501">-or-</span></span> 
<span data-ttu-id="20716-3502"><see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 (Visual Basic の場合は Nothing)。</span><span class="sxs-lookup"><span data-stu-id="20716-3502">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="20716-3503">可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</span><span class="sxs-lookup"><span data-stu-id="20716-3503">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="20716-3504">指定したメンバーを呼び出す対象となるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3504">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="20716-3505">呼び出すメンバーに渡される引数を格納する配列。</span><span class="sxs-lookup"><span data-stu-id="20716-3505">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="modifiers"><span data-ttu-id="20716-3506"><paramref name="args" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="20716-3506">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="20716-3507">パラメーターに関連付けられた属性は、メンバーのシグネチャに格納されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3507">A parameter's associated attributes are stored in the member's signature.</span></span>  
  
<span data-ttu-id="20716-3508">既定のバインダーは、COM コンポーネントを呼び出す場合のみ、このパラメーターを処理します。</span><span class="sxs-lookup"><span data-stu-id="20716-3508">The default binder processes this parameter only when calling a COM component.</span></span></param>
        <param name="culture"><span data-ttu-id="20716-3509">使用するロケールを表す <see cref="T:System.Globalization.CultureInfo" /> オブジェクト。これは、String 型の数値を Double に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3509">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span></span>  
  
<span data-ttu-id="20716-3510">または</span><span class="sxs-lookup"><span data-stu-id="20716-3510">-or-</span></span> 
<span data-ttu-id="20716-3511">現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</span><span class="sxs-lookup"><span data-stu-id="20716-3511">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="20716-3512"><paramref name="args" /> 配列内の値が渡されるパラメーターの名前を格納する配列。</span><span class="sxs-lookup"><span data-stu-id="20716-3512">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed.</span></span></param>
        <summary><span data-ttu-id="20716-3513">派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用し、指定した引数リスト、修飾子、カルチャと照合して、指定されたメンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-3513">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span></span></summary>
        <returns><span data-ttu-id="20716-3514">呼び出されるメンバーの戻り値を表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3514">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3515">`InvokeMember` は、コンストラクターメンバーまたはメソッドメンバーを呼び出し、プロパティメンバーを取得または設定し、データフィールドメンバーを取得または設定します。または、配列メンバーの要素を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3515">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3516"><xref:System.Type.InvokeMember%2A> を使用してジェネリックメソッドを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3516">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="20716-3517">`IDispatch` メンバーを呼び出す場合は、"[DispID = # #]" という文字列形式を使用して、メンバー名の代わりに DispID を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3517">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="20716-3518">たとえば、MyComMethod の DispID が3の場合、"MyComMethod" ではなく "[DispID = 3]" という文字列を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3518">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="20716-3519">メンバーを DispID で呼び出す方が、メンバーを名前で検索するよりも高速です。</span><span class="sxs-lookup"><span data-stu-id="20716-3519">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="20716-3520">複雑な集計シナリオでは、DispID が目的のメンバーを呼び出す唯一の方法である場合があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3520">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="20716-3521">既定のバインダーでは、<xref:System.Reflection.ParameterModifier> または <xref:System.Globalization.CultureInfo> (`modifiers` パラメーターと `culture` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers` と `culture`を処理するカスタムバインダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3521">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="20716-3522">`ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3522">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="20716-3523">`namedParameters` 配列の各パラメーターは、`args` 配列内の対応する要素の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3523">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="20716-3524">`args` の長さが `namedParameters` の長さより大きい場合、残りの引数の値は順番に渡されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3524">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="20716-3525">`namedParameters` 配列は、入力配列内の引数の順序を変更するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3525">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="20716-3526">たとえば、メソッド `M(string a, int b)` (Visual Basic で`M(ByVal a As String, ByVal b As Integer)`) と入力 `{ 42, "x" }`配列が指定されている場合、`args` に配列 `{ "b", "a" }` が指定されていれば、入力配列をそのまま `namedParameters`に渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3526">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="20716-3527">次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3527">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="20716-3528">パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3528">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="20716-3529">検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3529">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="20716-3530">階層の上位に静的メンバーを含めるには、`BindingFlags.FlattenHierarchy` を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3530">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="20716-3531">次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3531">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="20716-3532">`BindingFlags.IgnoreCase` `name`の場合は無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-3532">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="20716-3533">単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3533">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="20716-3534">次の <xref:System.Reflection.BindingFlags> の呼び出しフラグを使用して、メンバーに対して実行するアクションを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3534">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="20716-3535">コンストラクターを呼び出すように `CreateInstance` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3535">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="20716-3536">`name` は無視されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3536">`name` is ignored.</span></span> <span data-ttu-id="20716-3537">他の呼び出しフラグと共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3537">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="20716-3538">コンストラクターや型の初期化子ではなく、メソッドを呼び出すように `InvokeMethod` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3538">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="20716-3539">`SetField` または `SetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3539">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="20716-3540">`InvokeMethod` が単独で指定されている場合、`BindingFlags.Public`、`BindingFlags.Instance`、および `BindingFlags.Static` が自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3540">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="20716-3541">フィールドの値を取得 `GetField`。</span><span class="sxs-lookup"><span data-stu-id="20716-3541">`GetField` to get the value of a field.</span></span> <span data-ttu-id="20716-3542">`SetField`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3542">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="20716-3543">フィールドの値を設定 `SetField`。</span><span class="sxs-lookup"><span data-stu-id="20716-3543">`SetField` to set the value of a field.</span></span> <span data-ttu-id="20716-3544">`GetField`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3544">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="20716-3545">プロパティを取得するために `GetProperty` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3545">`GetProperty` to get a property.</span></span> <span data-ttu-id="20716-3546">`SetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3546">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="20716-3547">プロパティを設定する `SetProperty` ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3547">`SetProperty` to set a property.</span></span> <span data-ttu-id="20716-3548">`GetProperty`では無効です。</span><span class="sxs-lookup"><span data-stu-id="20716-3548">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="20716-3549">詳細については、「 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3549">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="20716-3550">次の両方の条件に該当する場合は、メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3550">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="20716-3551">メソッド宣言内のパラメーターの数は、`args` 配列内の引数の数と等しくなります (既定の引数がメンバーに対して定義され、`BindingFlags.OptionalParamBinding` が指定されている場合を除く)。</span><span class="sxs-lookup"><span data-stu-id="20716-3551">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="20716-3552">各引数の型は、バインダーによってパラメーターの型に変換できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3552">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="20716-3553">バインダーは、一致するすべてのメソッドを検索します。</span><span class="sxs-lookup"><span data-stu-id="20716-3553">The binder will find all of the matching methods.</span></span> <span data-ttu-id="20716-3554">これらのメソッドは、要求されたバインディングの種類 (<xref:System.Reflection.BindingFlags> 値 `InvokeMethod`、`GetProperty`など) に基づいて検出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3554">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="20716-3555">メソッドのセットは、バインダーで定義されている名前、引数の数、および一連の検索修飾子によってフィルター処理されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3555">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="20716-3556">メソッドが選択されると、呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3556">After the method is selected, it is invoked.</span></span> <span data-ttu-id="20716-3557">その時点でアクセシビリティがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3557">Accessibility is checked at that point.</span></span> <span data-ttu-id="20716-3558">検索では、メソッドに関連付けられているアクセシビリティ属性に基づいて検索されるメソッドのセットを制御できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3558">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="20716-3559"><xref:System.Reflection.Binder> クラスの <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> メソッドは、呼び出されるメソッドを選択する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="20716-3559">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="20716-3560">既定のバインダーでは、最も限定的な一致が選択されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3560">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="20716-3561">`InvokeMember` を使用すると、既定値を持つパラメーターを使用してメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3561">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="20716-3562">これらのメソッドにバインドするには、リフレクションで <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3562">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="20716-3563">既定値を持つパラメーターの場合は、別の値を指定するか、既定値を使用するように <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3563">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="20716-3564">たとえば、MyMethod (int x, float y = 2.0) などのメソッドについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="20716-3564">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="20716-3565">1番目の引数だけを使用してこのメソッドを呼び出すには、3番目のバインドフラグの1つを渡し、2つの引数を渡します。つまり、最初の引数の場合は4、2番目の引数の場合は `Missing.Value` します。</span><span class="sxs-lookup"><span data-stu-id="20716-3565">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="20716-3566">`Missing.Value`を使用しない限り、`Invoke` メソッドで省略可能なパラメーターを省略することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3566">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="20716-3567">この操作を行う必要がある場合は、代わりに `InvokeMember` を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3567">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="20716-3568">完全に信頼されたコードでは、アクセス制限は無視されます。つまり、プライベートコンストラクター、メソッド、フィールド、およびプロパティには、コードが完全に信頼されている場合は常に <xref:System.Reflection> を通じてアクセスおよび呼び出しを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3568">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="20716-3569">`Type.InvokeMember` を使用すると、<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>を指定することによってフィールドを特定の値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3569">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20716-3570">たとえば、F という名前のパブリックインスタンスフィールドをクラス C に設定し、F が `String`である場合は、次のようなコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3570">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="20716-3571">F が `String[]`である場合は、次のようなコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3571">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="20716-3572">これにより、フィールド F がこの新しい配列に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3572">which will initialize the field F to this new array.</span></span> <span data-ttu-id="20716-3573">また、`Type.InvokeMember` を使用して、値のインデックスを指定し、次のようなコードを使用して次の値を指定することによって、配列内の位置を設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3573">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="20716-3574">これにより、F が保持する配列内の文字列 "z" が文字列 "b" に変更されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3574">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3575">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されている場合、および非パブリックメンバーの許可セットが呼び出し元の許可セットまたはサブセットに制限されている場合に、このメソッドを使用して非パブリックメンバーにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3575">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="20716-3576">(「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。</span><span class="sxs-lookup"><span data-stu-id="20716-3576">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="20716-3577">この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3577">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-3578"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3578"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3579"><paramref name="args" /> と <paramref name="modifiers" /> の長さが同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3579"><paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span></span>  
  
<span data-ttu-id="20716-3580">または</span><span class="sxs-lookup"><span data-stu-id="20716-3580">-or-</span></span> 
 <span data-ttu-id="20716-3581"><paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3581"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="20716-3582">または</span><span class="sxs-lookup"><span data-stu-id="20716-3582">-or-</span></span> 
 <span data-ttu-id="20716-3583"><paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3583"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3584">または</span><span class="sxs-lookup"><span data-stu-id="20716-3584">-or-</span></span> 
 <span data-ttu-id="20716-3585"><paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3585"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3586">または</span><span class="sxs-lookup"><span data-stu-id="20716-3586">-or-</span></span> 
 <span data-ttu-id="20716-3587"><paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3587"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="20716-3588">または</span><span class="sxs-lookup"><span data-stu-id="20716-3588">-or-</span></span> 
 <span data-ttu-id="20716-3589"><paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3589"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3590">または</span><span class="sxs-lookup"><span data-stu-id="20716-3590">-or-</span></span> 
 <span data-ttu-id="20716-3591"><paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3591"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="20716-3592">または</span><span class="sxs-lookup"><span data-stu-id="20716-3592">-or-</span></span> 
 <span data-ttu-id="20716-3593"><paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3593"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="20716-3594">または</span><span class="sxs-lookup"><span data-stu-id="20716-3594">-or-</span></span> 
<span data-ttu-id="20716-3595">名前付きパラメーター配列が、引数配列よりも長くなっています。</span><span class="sxs-lookup"><span data-stu-id="20716-3595">The named parameter array is larger than the argument array.</span></span>  
  
<span data-ttu-id="20716-3596">または</span><span class="sxs-lookup"><span data-stu-id="20716-3596">-or-</span></span> 
<span data-ttu-id="20716-3597">COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-3597">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="20716-3598">または</span><span class="sxs-lookup"><span data-stu-id="20716-3598">-or-</span></span> 
<span data-ttu-id="20716-3599">名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3599">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="20716-3600">指定されたメンバーは、クラス初期化子です。</span><span class="sxs-lookup"><span data-stu-id="20716-3600">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="20716-3601">フィールドまたはプロパティが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3601">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="20716-3602"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3602">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="20716-3603">または</span><span class="sxs-lookup"><span data-stu-id="20716-3603">-or-</span></span> 
<span data-ttu-id="20716-3604"><paramref name="namedParameters" /> の中で引数名が指定されているメンバーが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3604">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span></span>  
  
<span data-ttu-id="20716-3605">または</span><span class="sxs-lookup"><span data-stu-id="20716-3605">-or-</span></span> 
<span data-ttu-id="20716-3606">現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3606">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="20716-3607">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</span><span class="sxs-lookup"><span data-stu-id="20716-3607">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="20716-3608">複数のメソッドがバインディングの基準と一致します。</span><span class="sxs-lookup"><span data-stu-id="20716-3608">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-3609"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="20716-3609">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="20716-3610">つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3610">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3611"><see cref="T:System.Type" /> が抽象型で、オーバーライドする必要があるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3611">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span></span></summary>
        <value><span data-ttu-id="20716-3612"><see langword="true" /> が抽象である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3612"><see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3613"><xref:System.Type.IsAbstract%2A> プロパティは、次の場合に `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3613">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="20716-3614">現在の型は abstract です。つまり、インスタンス化することはできませんが、派生クラスの基底クラスとしてのみ機能できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3614">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="20716-3615">でC#は、抽象クラスは[abstract](~/docs/csharp/language-reference/keywords/abstract.md)キーワードでマークされます。Visual Basic では、 [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)キーワードでマークされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3615">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="20716-3616">現在の型はインターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="20716-3616">The current type is an interface.</span></span>  
  
 <span data-ttu-id="20716-3617">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3617">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3618">次の例では、次の型を表す <xref:System.Type> オブジェクトの配列を作成します。指定されたオブジェクトが `abstract`場合、contains 型は `true` を返します。それ以外の場合は `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3618">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="20716-3619">`AbstractClass`、抽象クラス (でC#は `abstract` としてマークされ、Visual Basic では `MustInherit`)。</span><span class="sxs-lookup"><span data-stu-id="20716-3619">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="20716-3620">`DerivedClass`、`AbstractClass`から継承するクラスです。</span><span class="sxs-lookup"><span data-stu-id="20716-3620">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="20716-3621">`SingleClass`、継承できないクラスです。</span><span class="sxs-lookup"><span data-stu-id="20716-3621">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="20716-3622">`sealed` として定義さC#れ、Visual Basic で `NotInheritable` ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3622">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="20716-3623">`ITypeInfo`インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="20716-3623">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="20716-3624">`ImplementingClass`、`ITypeInfo` インターフェイスを実装するクラスです。</span><span class="sxs-lookup"><span data-stu-id="20716-3624">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="20716-3625">メソッドは、`AbstractClass`、抽象クラス、および `ITypeInfo`インターフェイスの `true` のみを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3625">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3626"><see langword="AnsiClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3626">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="20716-3627"><see langword="true" />に、文字列書式属性として<see langword="AnsiClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3627"><see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3628"><xref:System.Reflection.TypeAttributes.StringFormatMask> は、文字列形式の属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3628">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="20716-3629">文字列形式属性は、文字列の解釈方法を定義することで相互運用性を強化します。</span><span class="sxs-lookup"><span data-stu-id="20716-3629">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="20716-3630">現在の <xref:System.Type> がジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に関連します。</span><span class="sxs-lookup"><span data-stu-id="20716-3630">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3631">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-3631">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-3632">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3632">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3633">次の例では、フィールド情報を取得し、`AnsiClass` 属性を確認します。</span><span class="sxs-lookup"><span data-stu-id="20716-3633">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public virtual bool IsArray { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsArray As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsArray { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3634">型が配列かどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3634">Gets a value that indicates whether the type is an array.</span></span></summary>
        <value><span data-ttu-id="20716-3635">現在の型が配列である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3635"><see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3636"><xref:System.Type.IsArray%2A> プロパティは、<xref:System.Array> クラスの `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3636">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="20716-3637">また、現在のインスタンスが、コレクション型を表す <xref:System.Type> オブジェクト、または <xref:System.Collections.IEnumerable> や <xref:System.Collections.Generic.IEnumerable%601>などのコレクションを使用するように設計されたインターフェイスである場合にも `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3637">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="20716-3638">配列を確認するには、次のようなコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3638">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="20716-3639">現在の型がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3639">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3640">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-3640">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3641">次の例では、<xref:System.Type.IsArray%2A> プロパティの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3641">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-3642">派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsArray" /> プロパティを実装し、<see cref="T:System.Type" /> が配列かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3642">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns><span data-ttu-id="20716-3643"><see langword="true" /> が配列である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3643"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3644"><xref:System.Array> クラスのインスタンスは、配列ではなくオブジェクトであるため、`false` を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3644">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3645">次の例では、`MyTypeDelegator` クラスの `IsArrayImpl` メソッドをオーバーライドし、変数が配列であるかどうかを確認し、結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3645">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="20716-3646">現在の型と比較する型。</span><span class="sxs-lookup"><span data-stu-id="20716-3646">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="20716-3647">指定された型のインスタンスを現在の型の変数に割り当てることができるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3647">Determines whether an instance of a specified type can be assigned to a variable of the current type.</span></span></summary>
        <returns><span data-ttu-id="20716-3648"><see langword="true" /> が返されるのは、以下のいずれかの条件が満たされる場合です。</span><span class="sxs-lookup"><span data-stu-id="20716-3648"><see langword="true" /> if any of the following conditions is true:</span></span> <span data-ttu-id="20716-3649">
-   <paramref name="c" /> と現在のインスタンスが同じ型を表す。</span><span class="sxs-lookup"><span data-stu-id="20716-3649">
-   <paramref name="c" /> and the current instance represent the same type.</span></span>  
  <span data-ttu-id="20716-3650">
-   <paramref name="c" /> が、現在のインスタンスから直接または間接に派生している。</span><span class="sxs-lookup"><span data-stu-id="20716-3650">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span> <span data-ttu-id="20716-3651"><paramref name="c" /> が現在のインスタンスから継承している場合は、現在のインスタンスから直接派生し、<paramref name="c" /> が現在のインスタンスから継承している 1 つ以上のクラスの連続から継承している場合は、現在のインスタンスから間接的に派生します。</span><span class="sxs-lookup"><span data-stu-id="20716-3651"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
<span data-ttu-id="20716-3652">-   現在のインスタンスが、<paramref name="c" /> が実装するインターフェイスである。</span><span class="sxs-lookup"><span data-stu-id="20716-3652">-   The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  <span data-ttu-id="20716-3653">
-   <paramref name="c" /> がジェネリック型パラメーターであり、現在のインスタンスが <paramref name="c" /> の定数の 1 つを表している。</span><span class="sxs-lookup"><span data-stu-id="20716-3653">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span>  
  <span data-ttu-id="20716-3654">
-   <paramref name="c" /> が値型を表し、現在のインスタンスが <c>Nullable&lt;c&gt;</c> (Visual Basic では <c>Nullable(Of c)</c>) を表している。</span><span class="sxs-lookup"><span data-stu-id="20716-3654">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span>  
  
 <span data-ttu-id="20716-3655"><see langword="false" /> が返されるのは、これらの条件がいずれも満たされない場合、または <paramref name="c" /> が <see langword="null" /> である場合です。</span><span class="sxs-lookup"><span data-stu-id="20716-3655"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3656"><xref:System.Type.IsAssignableFrom%2A> メソッドを使用すると、`c` のインスタンスを現在の型のインスタンスに割り当てることができるかどうかを判断できます。メソッドは、次の例に示すように、デザイン時に型が不明で、条件付き割り当てが可能なオブジェクトを処理する場合に最も役立ちます。</span><span class="sxs-lookup"><span data-stu-id="20716-3656">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="20716-3657">このメソッドにより、次のようなコード行が実行時に実行されるようになり、<xref:System.InvalidCastException> 例外や同様の例外がスローされることはありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3657">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="20716-3658">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3658">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3659">ジェネリック型定義は、閉じた構築型から割り当てることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3659">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="20716-3660">つまり、閉じた構築型 `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual Basic) を `MyGenericList<T>`型の変数に割り当てることはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3660">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="20716-3661">`c` パラメーターの型が <xref:System.Reflection.Emit.TypeBuilder>の場合、結果は構築される型に基づきます。</span><span class="sxs-lookup"><span data-stu-id="20716-3661">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="20716-3662">次のコード例は、`B`という名前のビルドされた型を使用してこれを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3662">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="20716-3663">次の例は、定義されたクラス、整数配列、ジェネリックを使用して `IsAssignableFrom` メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3663">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  

 <span data-ttu-id="20716-3664">次の例では、現在のインスタンスは、<xref:System.IO.Stream> クラスを表す <xref:System.Type> オブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="20716-3664">In the following example, the current instance is a <xref:System.Type> object that represents the <xref:System.IO.Stream> class.</span></span> <span data-ttu-id="20716-3665">`GenericWithConstraint` は、ジェネリック型パラメーターが <xref:System.IO.Stream>型である必要があるジェネリック型です。</span><span class="sxs-lookup"><span data-stu-id="20716-3665">`GenericWithConstraint` is a generic type whose generic type parameter must be of type <xref:System.IO.Stream>.</span></span> <span data-ttu-id="20716-3666">ジェネリック型パラメーターを `IsAssignableFrom` メソッドに渡すことは、ジェネリック型パラメーターのインスタンスを <xref:System.IO.Stream> オブジェクトに割り当てることができることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3666">Passing its generic type parameter to the `IsAssignableFrom` method indicates that an instance of the generic type parameter can be assigned to an <xref:System.IO.Stream> object.</span></span>
  
 [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
 [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  

  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3667"><see langword="AutoClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3667">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="20716-3668"><see langword="true" />に、文字列書式属性として<see langword="AutoClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3668"><see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3669"><xref:System.Reflection.TypeAttributes.StringFormatMask> は、文字列形式の属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3669">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="20716-3670">文字列形式属性は、文字列の解釈方法を定義することで相互運用性を強化します。</span><span class="sxs-lookup"><span data-stu-id="20716-3670">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="20716-3671">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3671">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3672">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-3672">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-3673">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3673">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3674">現在の型のフィールドが、共通言語ランタイムによって自動的に配置されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3674">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span></span></summary>
        <value><span data-ttu-id="20716-3675">現在の型の <see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3675"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3676">このプロパティは便宜上提供されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3676">This property is provided as a convenience.</span></span> <span data-ttu-id="20716-3677">または、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 列挙値を使用して型レイアウト属性を選択し、<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> が設定されているかどうかをテストすることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3677">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="20716-3678"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 列挙値は、型のフィールドがどのようにメモリにレイアウトされるかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3678">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="20716-3679">動的な型の場合は、型を作成するときに <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3679">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="20716-3680">コードでは、<xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> 列挙値と共に型に適用して、ランタイムがクラスをレイアウトするための適切な方法を決定できるようにします。</span><span class="sxs-lookup"><span data-stu-id="20716-3680">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3681"><xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを使用して、<xref:System.Runtime.InteropServices.StructLayoutAttribute> が型に適用されているかどうかを判断することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3681">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="20716-3682">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3682">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3683">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値はによって決定され `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="20716-3683">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="20716-3684">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3684">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3685">次の例では、型のインスタンスを作成し、<xref:System.Type.IsAutoLayout%2A> プロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3685">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="20716-3686">メタデータと自己言及的なコンポーネント</span><span class="sxs-lookup"><span data-stu-id="20716-3686">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public virtual bool IsByRef { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRef As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRef { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3687"><see cref="T:System.Type" /> が参照渡しかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3687">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <value><span data-ttu-id="20716-3688"><see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3688"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3689">実際の型を取得するには、参照によって渡された型を逆参照し、その型の <xref:System.Type.GetElementType%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-3689">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3690">次の例では、`IsByRef` プロパティを使用して、指定した型が参照によって渡されるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="20716-3690">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="20716-3691">この例では、`HasElementTypeImpl` メソッドをオーバーライドする `MyTypeDelegator`クラスを定義しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3691">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="20716-3692">Main クラスは、`HasElementType` プロパティを確認し、要素の型を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3692">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-3693">派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3693">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="20716-3694"><see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3694"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3695">型が byref に似た構造体であるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3695">Gets a value that indicates whether the type is a byref-like structure.</span></span></summary>
        <value><span data-ttu-id="20716-3696"><see cref="T:System.Type" /> が byref に似た構造体である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3696"><see langword="true" /> if the <see cref="T:System.Type" /> is a a byref-like structure; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
<span data-ttu-id="20716-3697">Byref と同様の構造体は、のC#`ref struct` キーワードを使用して宣言されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3697">Byref-like structures are declared using `ref struct` keyword in C#.</span></span> <span data-ttu-id="20716-3698">Byref に似た構造体のインスタンスをマネージヒープに配置することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3698">An instance of the byref-like structure can't be placed on the managed heap.</span></span> <span data-ttu-id="20716-3699">詳細については、「 [Ref struct](~/docs/csharp/language-reference/builtin-types/struct.md#ref-struct)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3699">For more information, see [Ref struct](~/docs/csharp/language-reference/builtin-types/struct.md#ref-struct).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3700"><see cref="T:System.Type" /> がクラスまたはデリゲートである (つまり値型やインターフェイスではない) かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3700">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span></span></summary>
        <value><span data-ttu-id="20716-3701"><see langword="true" /> がクラスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3701"><see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3702">このプロパティは、クラスとデリゲートの `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3702">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="20716-3703">このメソッドは、ボックス化されている場合でも、値型 (構造体と列挙型) の `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3703">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="20716-3704">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3704">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.</span></span> <span data-ttu-id="20716-3705">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義がクラス定義である場合に `true` を返します。つまり、インターフェイスまたは値の型は定義されません。</span><span class="sxs-lookup"><span data-stu-id="20716-3705">If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3706">このプロパティは、<xref:System.Enum> クラスと <xref:System.ValueType> クラスを表す `Type` インスタンスの `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3706">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="20716-3707">これら2つのクラスは、それぞれ列挙型と値型の基本型ですが、列挙型または値型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3707">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="20716-3708">詳細については、<xref:System.Type.IsValueType%2A> プロパティおよび <xref:System.Type.IsEnum%2A> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3708">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="20716-3709"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 列挙値は、型宣言をクラスまたはインターフェイスと区別します。ただし、クラスと値の型はどちらも、<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> 属性でマークされます。</span><span class="sxs-lookup"><span data-stu-id="20716-3709">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="20716-3710">型の Attributes プロパティの値を取得し、<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 値を使用して、型が値型ではなくクラスであるかどうかを判断する場合は、<xref:System.Type.IsValueType%2A> プロパティも呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3710">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="20716-3711"><xref:System.Reflection.TypeAttributes> 列挙型の例には、anexample だけでなく、追加情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3711">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="20716-3712">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-3712">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3713">次の例では、型のインスタンスを作成し、型がクラスであるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3713">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3714"><see cref="T:System.Type" /> が COM オブジェクトかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3714">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <value><span data-ttu-id="20716-3715"><see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3715"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3716">このメソッドは、オブジェクトではないため、COM インターフェイスの `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3716">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="20716-3717">COM インターフェイスは Microsoft .NET Framework オブジェクトによって実装できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3717">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="20716-3718">[Tlbimp.exe (タイプライブラリインポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールを使用して、com クラスを読み込んで、その com クラスの `Type` オブジェクトを取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3718">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="20716-3719">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3719">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3720">たとえば、現在の <xref:System.Type> が `MyGenericType<int`> (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3720">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-3721">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3721">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-3722">派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsCOMObject" /> プロパティを実装し、<see cref="T:System.Type" /> が COM オブジェクトかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3722">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns><span data-ttu-id="20716-3723"><see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3723"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3724">このメソッドは、オブジェクトではないため、COM インターフェイスの `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3724">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="20716-3725">COM インターフェイスは Microsoft .NET Framework オブジェクトによって実装できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3725">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public abstract bool IsConstructedGenericType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3726">このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3726">Gets a value that indicates whether this object represents a constructed generic type.</span></span> <span data-ttu-id="20716-3727">構築ジェネリック型のインスタンスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3727">You can create instances of a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="20716-3728">このオブジェクトが構築ジェネリック型を表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3728"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3729">構築されたジェネリック型には、そのすべてのジェネリック型パラメーターに対して明示的な型が指定されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3729">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="20716-3730">クローズジェネリック型とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="20716-3730">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="20716-3731">このプロパティが `true`場合は、現在の型のインスタンスを作成できます。`false`すると、できません。</span><span class="sxs-lookup"><span data-stu-id="20716-3731">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3732"><see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3732">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <value><span data-ttu-id="20716-3733"><see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3733"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3734">コンテキストは、クラスメンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを適用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3734">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="20716-3735">リモート処理コンテキストの詳細については、「<xref:System.Runtime.Remoting.Contexts.Context>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3735">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="20716-3736">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3736">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3737">次の例は、<xref:System.Type> クラスの `IsContextful`、<xref:System.Type.IsMarshalByRef%2A>、および <xref:System.Type.IsPrimitive%2A> の各プロパティを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3737">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="20716-3738">このメソッドは、指定された型をコンテキストでホストできるかどうか、参照によってマーシャリングできるかどうか、および型がプリミティブデータ型であるかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="20716-3738">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-3739"><see cref="P:System.Type.IsContextful" /> プロパティを実装し、<see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3739">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <returns><span data-ttu-id="20716-3740"><see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3740"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3741">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3741">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="20716-3742">コンテキストは、クラスメンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを適用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3742">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3743">次の例は、`IsContextfulImpl` メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3743">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberSignature Language="C#" Value="public bool IsEnum { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3744">現在の <see cref="T:System.Type" /> が列挙体であるどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3744">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span></span></summary>
        <value><span data-ttu-id="20716-3745">現在の <see langword="true" /> が列挙体を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3745"><see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3746">このプロパティは、列挙体の `true` を返します。ただし、<xref:System.Enum> 型自体に対しては返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-3746">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="20716-3747">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3747">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3748">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-3748">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-3749">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3749">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3750">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-3750">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3751">次の例では、`IsEnum` プロパティの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3751">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="20716-3752">テスト対象の値。</span><span class="sxs-lookup"><span data-stu-id="20716-3752">The value to be tested.</span></span></param>
        <summary><span data-ttu-id="20716-3753">指定された値が現在の列挙型に存在するかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3753">Returns a value that indicates whether the specified value exists in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="20716-3754">指定された値が現在の列挙型のメンバーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3754"><see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-3755">現在の型は列挙型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3755">The current type is not an enumeration.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-3756"><paramref name="value" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-3756"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-3757"><paramref name="value" /> は、列挙体の基になる型にできない型です。</span><span class="sxs-lookup"><span data-stu-id="20716-3757"><paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="20716-3758">現在の型と等しいかどうかをテストする COM 型。</span><span class="sxs-lookup"><span data-stu-id="20716-3758">The COM type that is tested for equivalence with the current type.</span></span></param>
        <summary><span data-ttu-id="20716-3759">2 つの COM 型が同じ ID を持ち、型の同値の対象になるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3759">Determines whether two COM types have the same identity and are eligible for type equivalence.</span></span></summary>
        <returns><span data-ttu-id="20716-3760">両方の COM 型が等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3760"><see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="20716-3761">このメソッドは、一方の型が実行のために読み込まれたアセンブリに存在し、もう一方の型がリフレクションのみのコンテキストに読み込まれたアセンブリに存在する場合にも <see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3761">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3762">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、共通言語ランタイムは、マネージアセンブリに COM 型の型情報を直接埋め込むことをサポートしています。これは、マネージアセンブリが相互運用機能アセンブリから COM 型の型情報を取得する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="20716-3762">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="20716-3763">埋め込まれる型情報にはマネージド アセンブリに実際に使用される型とメンバーのみが含まれるため、2 つのマネージド アセンブリで同じ COM 型の表示が非常に異なることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="20716-3763">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="20716-3764">マネージド アセンブリごとに、COM 型の表示を表す異なる <xref:System.Type> オブジェクトが与えられます。</span><span class="sxs-lookup"><span data-stu-id="20716-3764">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="20716-3765">共通言語ランタイムでは、インターフェイス、構造、列挙、委任といった異なる表示間で型の等価性が与えられます。</span><span class="sxs-lookup"><span data-stu-id="20716-3765">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="20716-3766">型の等価性とは、マネージド アセンブリ間で渡される COM オブジェクトを受け取り側のアセンブリで適切なマネージド型に変換できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="20716-3766">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="20716-3767"><xref:System.Type.IsEquivalentTo%2A> メソッドを使用すると、アセンブリは、別のアセンブリから取得された COM オブジェクトが、最初のアセンブリ独自の埋め込み相互運用型の1つと同じ COM id を持つことを判別できます。したがって、その型にキャストできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3767">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="20716-3768">詳細については、「[型の等価性と埋め込み相互運用機能型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3768">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3769">現在の型のフィールドが、明示的に指定したオフセット位置に配置されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3769">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span></span></summary>
        <value><span data-ttu-id="20716-3770">現在の型の <see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3770"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3771">このプロパティは便宜上提供されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3771">This property is provided as a convenience.</span></span> <span data-ttu-id="20716-3772">または、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 列挙値を使用して型レイアウト属性を選択し、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> が設定されているかどうかをテストすることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3772">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="20716-3773"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 列挙値は、型のフィールドがどのようにメモリにレイアウトされるかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3773">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="20716-3774">動的な型の場合は、型を作成するときに <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3774">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="20716-3775">コードでは、<xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 列挙値と共に型に適用して、フィールドを開始するオフセットが明示的に指定されるように指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3775">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3776"><xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを使用して、<xref:System.Runtime.InteropServices.StructLayoutAttribute> が型に適用されているかどうかを判断することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3776">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="20716-3777">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3777">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3778">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-3778">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-3779">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3779">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3780">次の例では、型のインスタンスを作成し、その <xref:System.Type.IsExplicitLayout%2A> プロパティの値を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3780">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="20716-3781">`MySystemTime` クラスを使用します。これは、<xref:System.Runtime.InteropServices.StructLayoutAttribute>のコード例にも含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-3781">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="20716-3782">メタデータと自己言及的なコンポーネント</span><span class="sxs-lookup"><span data-stu-id="20716-3782">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3783">現在の <see cref="T:System.Type" /> が、ジェネリック メソッドの定義の型パラメーターを表すかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3783">Gets a value that indicates whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic method.</span></span></summary>
        <value><span data-ttu-id="20716-3784"><see cref="T:System.Type" /> オブジェクトがジェネリックメソッド定義の型パラメーターを表している場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3784"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public abstract bool IsGenericParameter { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsGenericParameter { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3785">現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表しているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3785">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span></span></summary>
        <value><span data-ttu-id="20716-3786"><see langword="true" /> オブジェクトがジェネリック型定義またはジェネリック メソッド定義の型パラメーターを表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3786"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3787">ジェネリック型パラメーターを表す <xref:System.Type> オブジェクトは、ジェネリック型定義を表す <xref:System.Type> オブジェクトの <xref:System.Type.GetGenericArguments%2A> メソッド、またはジェネリックメソッド定義を表す <xref:System.Reflection.MethodInfo> オブジェクトの <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> メソッドを呼び出すことによって取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3787"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="20716-3788">ジェネリック型またはメソッドの定義の場合、<xref:System.Type.IsGenericParameter%2A> プロパティは、結果として得られる配列のすべての要素に対して `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3788">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="20716-3789">構築された閉じた型またはメソッドの場合、<xref:System.Type.IsGenericParameter%2A> プロパティは <xref:System.Type.GetGenericArguments%2A> メソッドによって返される配列のすべての要素に対して `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3789">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="20716-3790">構築されたオープン型またはメソッドの場合、配列の一部の要素は特定の型である場合もあれば、型パラメーターである場合もあります。</span><span class="sxs-lookup"><span data-stu-id="20716-3790">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="20716-3791">型パラメーターの型と `true` の `false` を返す <xref:System.Type.IsGenericParameter%2A>。</span><span class="sxs-lookup"><span data-stu-id="20716-3791"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="20716-3792"><xref:System.Type.ContainsGenericParameters%2A> プロパティのコード例は、型と型パラメーターが混在するジェネリッククラスを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3792">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="20716-3793">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3793">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3794">次の例では、<xref:System.Type.IsGenericParameter%2A> プロパティを使用して、ジェネリック型のジェネリック型パラメーターをテストします。</span><span class="sxs-lookup"><span data-stu-id="20716-3794">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-3795">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-3795">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-3796">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-3796">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3797">現在の型がジェネリック型かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3797">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="20716-3798">現在の型がジェネリック型である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3798"><see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3799"><xref:System.Type.IsGenericType%2A> プロパティを使用して、<xref:System.Type> オブジェクトがジェネリック型を表すかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3799">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="20716-3800"><xref:System.Type.ContainsGenericParameters%2A> プロパティを使用して、<xref:System.Type> オブジェクトがオープン構築型またはクローズ構築型を表しているかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3800">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3801">イミディエイト型がジェネリックでない場合、<xref:System.Type.IsGenericType%2A> プロパティは `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3801">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="20716-3802">たとえば、要素が型 `A<int>` (Visual Basic の`A(Of Integer)`) である配列は、それ自体がジェネリック型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3802">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="20716-3803">次の表は、一般的なリフレクションで使用される一般的な用語の不変条件をまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="20716-3803">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="20716-3804">期間</span><span class="sxs-lookup"><span data-stu-id="20716-3804">Term</span></span>|<span data-ttu-id="20716-3805">インバリアント</span><span class="sxs-lookup"><span data-stu-id="20716-3805">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="20716-3806">ジェネリック型定義</span><span class="sxs-lookup"><span data-stu-id="20716-3806">generic type definition</span></span>|<span data-ttu-id="20716-3807"><xref:System.Type.IsGenericTypeDefinition%2A> プロパティが `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3807">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3808">ジェネリック型を定義します。</span><span class="sxs-lookup"><span data-stu-id="20716-3808">Defines a generic type.</span></span> <span data-ttu-id="20716-3809">構築された型を作成するには、ジェネリック型定義を表す <xref:System.Type> オブジェクトの <xref:System.Type.MakeGenericType%2A> メソッドを呼び出し、型引数の配列を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3809">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="20716-3810"><xref:System.Type.MakeGenericType%2A> は、ジェネリック型の定義でのみ呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-3810"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="20716-3811">ジェネリック型定義はジェネリック型です (<xref:System.Type.IsGenericType%2A> プロパティは `true`) が、逆の場合は true になりません。</span><span class="sxs-lookup"><span data-stu-id="20716-3811">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="20716-3812">ジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-3812">generic type</span></span>|<span data-ttu-id="20716-3813"><xref:System.Type.IsGenericType%2A> プロパティが `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3813">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3814">には、ジェネリック型定義、オープン構築型、またはクローズ構築型を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3814">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="20716-3815">要素型がジェネリックである配列型は、それ自体がジェネリック型ではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3815">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="20716-3816">これは、ジェネリック型へのポインターを表す <xref:System.Type> オブジェクトにも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-3816">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="20716-3817">構築された型を開く</span><span class="sxs-lookup"><span data-stu-id="20716-3817">open constructed type</span></span>|<span data-ttu-id="20716-3818"><xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3818">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3819">例としては、割り当てられていない型パラメーターを持つジェネリック型、ジェネリック型定義またはオープン構築型で入れ子にされた型、または <xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`型引数を持つジェネリック型があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3819">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3820">オープン構築型のインスタンスを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3820">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="20716-3821">すべてのオープン構築型がジェネリックではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3821">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="20716-3822">たとえば、要素型がジェネリック型定義である配列はジェネリックではなく、オープン構築型へのポインターはジェネリックではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3822">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="20716-3823">閉じた構築型</span><span class="sxs-lookup"><span data-stu-id="20716-3823">closed constructed type</span></span>|<span data-ttu-id="20716-3824"><xref:System.Type.ContainsGenericParameters%2A> プロパティが `false` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3824">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="20716-3825">再帰的に検査するときに、型に割り当てられていないジェネリックパラメーターがありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3825">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="20716-3826">ジェネリック型パラメーター</span><span class="sxs-lookup"><span data-stu-id="20716-3826">generic type parameter</span></span>|<span data-ttu-id="20716-3827"><xref:System.Type.IsGenericParameter%2A> プロパティが `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3827">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3828"><xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3828">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3829">ジェネリック型定義で、後で割り当てられる型のプレースホルダー。</span><span class="sxs-lookup"><span data-stu-id="20716-3829">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="20716-3830">ジェネリック型引数</span><span class="sxs-lookup"><span data-stu-id="20716-3830">generic type argument</span></span>|<span data-ttu-id="20716-3831">には、ジェネリック型パラメーターを含む任意の型を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3831">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="20716-3832">型引数は、構築されたジェネリック型を作成するときに <xref:System.Type.MakeGenericType%2A> メソッドに渡される <xref:System.Type> オブジェクトの配列として指定されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3832">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="20716-3833">結果の型のインスタンスを作成する場合は、すべての型引数に対して <xref:System.Type.ContainsGenericParameters%2A> プロパティを `false` する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-3833">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="20716-3834">次のコード例と表は、これらの用語と不変条件の一部を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3834">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="20716-3835">`Derived` クラスは、その基本型が型引数リストに型パラメーターと型パラメーターが混在する構築型であるため、特に重要です。</span><span class="sxs-lookup"><span data-stu-id="20716-3835">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="20716-3836">次の表は、クラス `Base`、`Derived`、および `G`を使用して構築する例を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3836">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="20716-3837">C++とC#のコードが同じ場合は、1つのエントリのみが表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3837">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="20716-3838">例</span><span class="sxs-lookup"><span data-stu-id="20716-3838">Example</span></span>|<span data-ttu-id="20716-3839">インバリアント</span><span class="sxs-lookup"><span data-stu-id="20716-3839">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="20716-3840">この型の場合:</span><span class="sxs-lookup"><span data-stu-id="20716-3840">For this type:</span></span><br /><br /> <span data-ttu-id="20716-3841"><xref:System.Type.IsGenericType%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3841"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3842"><xref:System.Type.IsGenericTypeDefinition%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3842"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3843"><xref:System.Type.ContainsGenericParameters%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3843"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="20716-3844">この型の場合:</span><span class="sxs-lookup"><span data-stu-id="20716-3844">For this type:</span></span><br /><br /> <span data-ttu-id="20716-3845"><xref:System.Type.IsGenericType%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3845"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3846"><xref:System.Type.IsGenericTypeDefinition%2A> が `false` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3846"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="20716-3847"><xref:System.Type.ContainsGenericParameters%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3847"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="20716-3848">変数の型 `d`:</span><span class="sxs-lookup"><span data-stu-id="20716-3848">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="20716-3849">`d` が配列であるため、<xref:System.Type.IsGenericType%2A> が `false`。</span><span class="sxs-lookup"><span data-stu-id="20716-3849"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="20716-3850"><xref:System.Type.IsGenericTypeDefinition%2A> が `false` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3850"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="20716-3851"><xref:System.Type.ContainsGenericParameters%2A> が `false` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3851"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="20716-3852">`T`、`U`、`V` (表示されるすべての場所)</span><span class="sxs-lookup"><span data-stu-id="20716-3852">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="20716-3853"><xref:System.Type.IsGenericParameter%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3853"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3854">型パラメーターをジェネリック型に制約する方法がないため、<xref:System.Type.IsGenericType%2A> が `false` ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3854"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="20716-3855"><xref:System.Type.IsGenericTypeDefinition%2A> が `false` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3855"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="20716-3856">`T`、`U`、および `V` はそれ自体がジェネリック型パラメーターであるため、<xref:System.Type.ContainsGenericParameters%2A> が `true` ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3856"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="20716-3857">これは、後で型引数に代入されるものを意味しません。</span><span class="sxs-lookup"><span data-stu-id="20716-3857">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="20716-3858">フィールドの型 `F`</span><span class="sxs-lookup"><span data-stu-id="20716-3858">The type of field `F`</span></span>|<span data-ttu-id="20716-3859"><xref:System.Type.IsGenericType%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3859"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="20716-3860">`G`の型パラメーターに型が割り当てられているため、<xref:System.Type.IsGenericTypeDefinition%2A> が `false`。</span><span class="sxs-lookup"><span data-stu-id="20716-3860"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="20716-3861">これは、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出した場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-3861">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="20716-3862"><xref:System.Type.ContainsGenericParameters%2A> が `true` のは、フィールド `F` の型に、オープン構築型の型引数があるためです。</span><span class="sxs-lookup"><span data-stu-id="20716-3862"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="20716-3863">構築された型は、その型引数 (つまり、`Base`) がジェネリック型定義であるため、オープンです。</span><span class="sxs-lookup"><span data-stu-id="20716-3863">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="20716-3864">これは、<xref:System.Type.IsGenericType%2A> プロパティの再帰的な性質を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3864">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="20716-3865">入れ子になったクラス `Nested`</span><span class="sxs-lookup"><span data-stu-id="20716-3865">The nested class `Nested`</span></span>|<span data-ttu-id="20716-3866"><xref:System.Type.IsGenericType%2A> は、ジェネリック型に入れ子になっているため、`Nested` クラスに独自のジェネリック型パラメーターがない場合でも `true`ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3866"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="20716-3867"><xref:System.Type.IsGenericTypeDefinition%2A> が `true` です。</span><span class="sxs-lookup"><span data-stu-id="20716-3867"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="20716-3868">つまり、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出して、それを囲む型の型パラメーター `Derived`を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3868">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="20716-3869">外側の型 (`Derived`) にジェネリック型パラメーターが含まれているため、<xref:System.Type.ContainsGenericParameters%2A> が `true`。</span><span class="sxs-lookup"><span data-stu-id="20716-3869"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="20716-3870">これは、<xref:System.Type.ContainsGenericParameters%2A> プロパティの再帰的な性質を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3870">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="20716-3871">次のコード例では、「解説」で説明されている型の <xref:System.Type.IsGenericType%2A>、<xref:System.Type.IsGenericTypeDefinition%2A>、<xref:System.Type.IsGenericParameter%2A>、および <xref:System.Type.ContainsGenericParameters%2A> の各プロパティの値を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3871">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="20716-3872">プロパティ値の説明については、「解説」の表を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3872">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-3873">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-3873">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-3874">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-3874">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3875">現在の <see cref="T:System.Type" /> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3875">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="20716-3876"><see langword="true" /> オブジェクトがジェネリック型定義を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3876"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3877">ジェネリック型定義は、他の型を構築できるテンプレートです。</span><span class="sxs-lookup"><span data-stu-id="20716-3877">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="20716-3878">たとえば、ジェネリック型定義 `G<T>` (構文でC#表されます。 Visual Basic または `generic <typename T> ref class G` で `G(Of T)` C++)、`G<int>` の型を含むジェネリック引数リストを使用して`G(Of Integer)` メソッドを呼び出すことによって、型 Visual Basic (<xref:System.Type.MakeGenericType%2A> で <xref:System.Int32>) を構築およびインスタンス化できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3878">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="20716-3879">この構築された型を表す <xref:System.Type> オブジェクトがある場合、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドはジェネリック型の定義を再び取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3879">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="20716-3880">現在の型から新しい型を作成できるかどうかを判断するには、<xref:System.Type.IsGenericTypeDefinition%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3880">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="20716-3881"><xref:System.Type.IsGenericTypeDefinition%2A> プロパティが `true`を返す場合、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出して新しいジェネリック型を作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3881">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="20716-3882">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3882">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3883">次の例では、ジェネリック型定義であるかどうかなど、型に関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3883">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="20716-3884">情報は、構築された型、ジェネリック型定義、および通常の型について表示されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3884">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-3885">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-3885">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-3886">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-3886">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3887">現在の <see cref="T:System.Type" /> が、ジェネリック型の定義の型パラメーターを表すかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3887">Gets a value that indicates whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type.</span></span></summary>
        <value><span data-ttu-id="20716-3888"><see cref="T:System.Type" /> オブジェクトがジェネリック型定義の型パラメーターを表している場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-3888"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3889"><see cref="T:System.Type" /> に <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性が適用されているかどうかを示す (つまり、COM タイプ ライブラリからインポートされたかどうかを示す) 値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3889">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span></span></summary>
        <value><span data-ttu-id="20716-3890"><see langword="true" /> が <see cref="T:System.Type" /> を持っている場合は <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3890"><see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3891">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3891">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3892">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値はによって決定され `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="20716-3892">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="20716-3893">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3893">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="20716-3894">現在の型と比較するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-3894">The object to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="20716-3895">指定したオブジェクトが現在の <see cref="T:System.Type" /> のインスタンスかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3895">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-3896"><see langword="true" /> が返されるのは、現在の <see langword="Type" /> が <paramref name="o" /> によって表されるオブジェクトの継承可能な階層内にある場合、または現在の <see langword="Type" /> が <paramref name="o" /> によって実装されているインターフェイスである場合です。</span><span class="sxs-lookup"><span data-stu-id="20716-3896"><see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span></span> <span data-ttu-id="20716-3897"><see langword="false" /> が返されるのは、これらの条件のいずれも満たされない場合、または <paramref name="o" /> が <see langword="null" /> であるか、現在の <see langword="Type" /> がオープン ジェネリック型である (つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返す) 場合です。</span><span class="sxs-lookup"><span data-stu-id="20716-3897"><see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3898">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3898">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3899">構築された型は、そのジェネリック型定義のインスタンスではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3899">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="20716-3900">つまり、`MyGenericList<int>` (Visual Basic で`MyGenericList(Of Integer)`) は `MyGenericList<T>` のインスタンス (`MyGenericList(Of T)` では Visual Basic) ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-3900">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3901">`IsInstanceOfType` メソッドの使用例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3901">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3902"><see cref="T:System.Type" /> がインターフェイスである (つまり値型やクラスではない) ことを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3902">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span></span></summary>
        <value><span data-ttu-id="20716-3903"><see langword="true" /> がインターフェイスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3903"><see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3904"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask> は、型宣言をクラス、インターフェイス、または値型として識別します。</span><span class="sxs-lookup"><span data-stu-id="20716-3904">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="20716-3905">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3905">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3906">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-3906">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3907">次の例では、インターフェイスを作成し、インターフェイス型を確認して、クラスに `IsInterface` プロパティが設定されているかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3907">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3908">現在の型のフィールドが、定義済みまたはメタデータに対して出力された順序で、連続して配置されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3908">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span></span></summary>
        <value><span data-ttu-id="20716-3909">現在の型の <see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3909"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3910">このプロパティは便宜上提供されています。</span><span class="sxs-lookup"><span data-stu-id="20716-3910">This property is provided as a convenience.</span></span> <span data-ttu-id="20716-3911">または、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 列挙値を使用して型レイアウト属性を選択し、<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> が設定されているかどうかをテストすることもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3911">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="20716-3912"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 列挙値は、型のフィールドがどのようにメモリにレイアウトされるかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3912">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="20716-3913">動的な型の場合は、型を作成するときに <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> を指定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-3913">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="20716-3914">コードで、<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 列挙値を使用して <xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を型に適用し、レイアウトがシーケンシャルであることを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-3914">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3915"><xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを使用して、<xref:System.Runtime.InteropServices.StructLayoutAttribute> が型に適用されているかどうかを判断することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-3915">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="20716-3916">詳細については、共通言語基盤 (CLI) のドキュメント「パーティション II: メタデータの定義とセマンティクス」の9.1.2 のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3916">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="20716-3917">ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3917">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="20716-3918">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3918">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-3919">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-3919">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-3920">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3920">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3921">次の例では、<xref:System.Runtime.InteropServices.StructLayoutAttribute> クラスの <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 列挙値が設定されているクラスのインスタンスを作成し、<xref:System.Type.IsLayoutSequential%2A> プロパティをチェックして、結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3921">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="20716-3922">メタデータと自己言及的なコンポーネント</span><span class="sxs-lookup"><span data-stu-id="20716-3922">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3923"><see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3923">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <value><span data-ttu-id="20716-3924"><see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3924"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="20716-3925">次の例は、<xref:System.Type> クラスの <xref:System.Type.IsContextful%2A>、`IsMarshalByRef`、および <xref:System.Type.IsPrimitive%2A> の各プロパティを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3925">The following example demonstrates the <xref:System.Type.IsContextful%2A>, `IsMarshalByRef`, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="20716-3926">このメソッドは、指定された型をコンテキストでホストできるかどうか、参照によってマーシャリングできるかどうか、および型がプリミティブデータ型であるかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="20716-3926">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-3927"><see cref="P:System.Type.IsMarshalByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-3927">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <returns><span data-ttu-id="20716-3928"><see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3928"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3929">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-3929">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3930">次の例では、指定された型が参照によってマーシャリングされているかどうかを判断し、その結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-3930">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3931">現在の <see cref="T:System.Type" /> オブジェクトが、別の型の定義内に入れ子になっている定義で定義された型を表しているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3931">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span></span></summary>
        <value><span data-ttu-id="20716-3932"><see langword="true" /> が別の型に入れ子になっている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3932"><see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3933"><xref:System.Type.IsNested%2A> プロパティは、可視性に関係なく、すべての入れ子にされた型の `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3933">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="20716-3934">入れ子と表示を同時にテストするには、関連するプロパティ <xref:System.Type.IsNestedAssembly%2A>、<xref:System.Type.IsNestedFamily%2A>、<xref:System.Type.IsNestedFamANDAssem%2A>、<xref:System.Type.IsNestedFamORAssem%2A>、<xref:System.Type.IsNestedPrivate%2A>、または <xref:System.Type.IsNestedPublic%2A>を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-3934">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3935"><xref:System.Reflection.TypeAttributes.VisibilityMask> 列挙体メンバーは、型の可視性属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3935">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3936">次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-3936">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="20716-3937">次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3937">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3938"><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3938">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span></span></summary>
        <value><span data-ttu-id="20716-3939"><see langword="true" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3939"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3940">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3940">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3941"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3941"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3942">次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-3942">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="20716-3943">次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3943">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3944"><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3944">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span></span></summary>
        <value><span data-ttu-id="20716-3945"><see langword="true" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3945"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3946">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3946">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3947"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3947"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-3948">およびC# Visual Basic 言語には、独自のアセンブリ内の保護された型に対してのみ表示される入れ子になった型を定義できるセマンティクスは含まれていません。</span><span class="sxs-lookup"><span data-stu-id="20716-3948">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="20716-3949">で可視性C#を `protected internal` し、Visual Basic で可視性を `Protected Friend` して、同じアセンブリ内の保護された型と型の両方に表示される入れ子になった型を定義します。</span><span class="sxs-lookup"><span data-stu-id="20716-3949">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="20716-3950"><xref:System.Type> オブジェクトのファミリは、同じ <xref:System.Type> とそのサブタイプのすべてのオブジェクトとして定義されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3950">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3951">次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-3951">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="20716-3952">次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3952">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3953"><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3953">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span></span></summary>
        <value><span data-ttu-id="20716-3954"><see langword="true" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3954"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3955">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3955">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3956"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3956"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="20716-3957"><xref:System.Type> オブジェクトのファミリは、完全に同じ <xref:System.Type> とそのサブタイプのすべてのオブジェクトとして定義されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3957">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3958">次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-3958">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="20716-3959">次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3959">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3960"><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3960">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span></span></summary>
        <value><span data-ttu-id="20716-3961"><see langword="true" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3961"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3962">型の可視性がC#または Visual Basic の `Protected Friend` `protected internal` 場合、<xref:System.Type.IsNestedFamORAssem%2A> プロパティは `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3962">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="20716-3963">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3963">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3964"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3964"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="20716-3965"><xref:System.Type> オブジェクトのファミリは、完全に同じ <xref:System.Type> とそのサブタイプのすべてのオブジェクトとして定義されます。</span><span class="sxs-lookup"><span data-stu-id="20716-3965">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3966">次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-3966">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="20716-3967">次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3967">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3968"><see cref="T:System.Type" /> が入れ子になっていて、プライベートとして宣言されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3968">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span></span></summary>
        <value><span data-ttu-id="20716-3969"><see langword="true" /> が入れ子になっていて、プライベートとして宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3969"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3970">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3970">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3971"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3971"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3972">次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-3972">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="20716-3973">次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3973">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3974">クラスが入れ子になっていて、パブリックとして宣言されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3974">Gets a value indicating whether a class is nested and declared public.</span></span></summary>
        <value><span data-ttu-id="20716-3975">クラスが入れ子になっていて、パブリックとして宣言されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3975"><see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3976">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3976">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-3977"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-3977"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3978">次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-3978">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="20716-3979">次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3979">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-3980"><see cref="T:System.Type" /> がパブリックとして宣言されていないかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3980">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span></span></summary>
        <value><span data-ttu-id="20716-3981"><see langword="true" /> がパブリックとして宣言されていなくて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-3981"><see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-3982">このプロパティは、入れ子にされた型では使用しないでください。代わりに、<xref:System.Type.IsNestedPublic%2A> プロパティを使用してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3982">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="20716-3983">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-3983">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-3984">この例では、`IsNotPublic` プロパティを使用して、型の可視性を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-3984">This example uses the `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="20716-3985">次のコード例は、入れ子になったクラスに `IsPublic` と `IsNotPublic` を使用できない理由を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-3985">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="20716-3986">入れ子になったクラスの場合は、`IsPublic` と `IsNotPublic` の結果を無視し、`IsNestedPublic` と `IsNestedPrivate`の結果のみに注意してください。</span><span class="sxs-lookup"><span data-stu-id="20716-3986">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="20716-3987">このコード片のリフレクション出力は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="20716-3987">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="20716-3988">クラス</span><span class="sxs-lookup"><span data-stu-id="20716-3988">Class</span></span>|<span data-ttu-id="20716-3989">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="20716-3989">IsNotPublic</span></span>|<span data-ttu-id="20716-3990">IsPublic</span><span class="sxs-lookup"><span data-stu-id="20716-3990">IsPublic</span></span>|<span data-ttu-id="20716-3991">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="20716-3991">IsNestedPublic</span></span>|<span data-ttu-id="20716-3992">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="20716-3992">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="20716-3993">A</span><span class="sxs-lookup"><span data-stu-id="20716-3993">A</span></span>|<span data-ttu-id="20716-3994">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-3994">FALSE</span></span>|<span data-ttu-id="20716-3995">TRUE</span><span class="sxs-lookup"><span data-stu-id="20716-3995">TRUE</span></span>|<span data-ttu-id="20716-3996">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-3996">FALSE</span></span>|<span data-ttu-id="20716-3997">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-3997">FALSE</span></span>|  
|<span data-ttu-id="20716-3998">B</span><span class="sxs-lookup"><span data-stu-id="20716-3998">B</span></span>|<span data-ttu-id="20716-3999">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-3999">FALSE</span></span>|<span data-ttu-id="20716-4000">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-4000">FALSE</span></span>|<span data-ttu-id="20716-4001">TRUE</span><span class="sxs-lookup"><span data-stu-id="20716-4001">TRUE</span></span>|<span data-ttu-id="20716-4002">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-4002">FALSE</span></span>|  
|<span data-ttu-id="20716-4003">C</span><span class="sxs-lookup"><span data-stu-id="20716-4003">C</span></span>|<span data-ttu-id="20716-4004">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-4004">FALSE</span></span>|<span data-ttu-id="20716-4005">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-4005">FALSE</span></span>|<span data-ttu-id="20716-4006">FALSE</span><span class="sxs-lookup"><span data-stu-id="20716-4006">FALSE</span></span>|<span data-ttu-id="20716-4007">TRUE</span><span class="sxs-lookup"><span data-stu-id="20716-4007">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public virtual bool IsPointer { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPointer As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsPointer { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4008"><see cref="T:System.Type" /> がポインターかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4008">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <value><span data-ttu-id="20716-4009"><see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4009"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4010">現在の <xref:System.Type> がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4010">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="20716-4011">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-4011">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4012">次の例は、`IsPointer` プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4012">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-4013">派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPointer" /> プロパティを実装し、<see cref="T:System.Type" /> がポインターかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-4013">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns><span data-ttu-id="20716-4014"><see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4014"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4015"><see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4015">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <value><span data-ttu-id="20716-4016"><see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4016"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4017">プリミティブ型は、<xref:System.Boolean>、<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>、<xref:System.IntPtr>、<xref:System.UIntPtr>、<xref:System.Char>、<xref:System.Double>、<xref:System.Single>です。</span><span class="sxs-lookup"><span data-stu-id="20716-4017">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="20716-4018">現在の <xref:System.Type> がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4018">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4019">次の例は、<xref:System.Type> クラスの <xref:System.Type.IsContextful%2A>、<xref:System.Type.IsMarshalByRef%2A>、および `IsPrimitive` の各プロパティを示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4019">The following example demonstrates the <xref:System.Type.IsContextful%2A>, <xref:System.Type.IsMarshalByRef%2A>, and `IsPrimitive` properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="20716-4020">このメソッドは、指定された型をコンテキストでホストできるかどうか、参照によってマーシャリングできるかどうか、および型がプリミティブデータ型であるかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="20716-4020">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-4021">派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPrimitive" /> プロパティを実装し、<see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-4021">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns><span data-ttu-id="20716-4022"><see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4022"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4023">プリミティブ型は、<xref:System.Boolean>、<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>、<xref:System.Char>、<xref:System.Double>、および <xref:System.Single>です。</span><span class="sxs-lookup"><span data-stu-id="20716-4023">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4024">次の例では、指定された型がプリミティブ型であるかどうかを判断し、結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4024">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4025"><see cref="T:System.Type" /> がパブリックとして宣言されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4025">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span></span></summary>
        <value><span data-ttu-id="20716-4026"><see langword="true" /> がパブリックとして宣言されていて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4026"><see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4027">入れ子になった型では使用しないでください。代わりに <xref:System.Type.IsNestedPublic%2A> を使用してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4027">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="20716-4028">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4028">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="20716-4029"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。</span><span class="sxs-lookup"><span data-stu-id="20716-4029"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4030">次の例では、`MyTestClass`のインスタンスを作成し、`IsPublic` プロパティをチェックして、結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4030">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="20716-4031">入れ子になったクラスの場合は、`IsPublic` と `IsNotPublic` の結果を無視し、<xref:System.Type.IsNestedPublic%2A> と <xref:System.Type.IsNestedPrivate%2A>の結果のみに注意してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4031">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4032"><see cref="T:System.Type" /> が sealed として宣言されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4032">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span></span></summary>
        <value><span data-ttu-id="20716-4033"><see langword="true" /> が sealed として宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4033"><see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4034">現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4034">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4035">次の例では、`sealed` クラスのインスタンスを作成し、`IsSealed` プロパティをチェックして、結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4035">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4036">現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4036">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="20716-4037">現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型が透過的な場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4037"><see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4038"><xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>、および <xref:System.Type.IsSecurityTransparent%2A> の各プロパティは、共通言語ランタイム (CLR) によって決定された、現在の信頼レベルでの型の透明度レベルを報告します。</span><span class="sxs-lookup"><span data-stu-id="20716-4038">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="20716-4039">これらのプロパティの組み合わせを次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4039">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="20716-4040">セキュリティ レベル</span><span class="sxs-lookup"><span data-stu-id="20716-4040">Security level</span></span>|<span data-ttu-id="20716-4041">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="20716-4041">IsSecurityCritical</span></span>|<span data-ttu-id="20716-4042">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="20716-4042">IsSecuritySafeCritical</span></span>|<span data-ttu-id="20716-4043">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="20716-4043">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="20716-4044">Critical</span><span class="sxs-lookup"><span data-stu-id="20716-4044">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="20716-4045">安全クリティカル</span><span class="sxs-lookup"><span data-stu-id="20716-4045">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="20716-4046">透明</span><span class="sxs-lookup"><span data-stu-id="20716-4046">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="20716-4047">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</span><span class="sxs-lookup"><span data-stu-id="20716-4047">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20716-4048">部分信頼アセンブリの場合、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。</span><span class="sxs-lookup"><span data-stu-id="20716-4048">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="20716-4049">アセンブリが部分的に信頼されたアプリケーションドメイン (たとえば、サンドボックス化されたアプリケーションドメイン) に読み込まれる場合、ランタイムはアセンブリのセキュリティ注釈を無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-4049">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="20716-4050">アセンブリとそのすべての型は透過的として扱われます。</span><span class="sxs-lookup"><span data-stu-id="20716-4050">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="20716-4051">ランタイムは、アセンブリが完全に信頼されたアプリケーションドメイン (たとえば、デスクトップアプリケーションの既定のアプリケーションドメイン) に読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意します。</span><span class="sxs-lookup"><span data-stu-id="20716-4051">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="20716-4052">これに対し、信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前のアセンブリ) は、アプリケーションドメインの信頼レベルに関係なく、常に完全信頼で読み込まれます。したがって、現在の信頼レベルは常に完全に信頼されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4052">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="20716-4053">アセンブリとアプリケーションドメインの現在の信頼レベルを確認するには、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> の各プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4053">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="20716-4054">リフレクションと透明度の詳細については、「[リフレクションのセキュリティに関する考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4054">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="20716-4055">透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4055">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="20716-4056">リフレクションに関するセキュリティ上の考慮事項</span><span class="sxs-lookup"><span data-stu-id="20716-4056">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="20716-4057">.NET Framework におけるセキュリティの変更点</span><span class="sxs-lookup"><span data-stu-id="20716-4057">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4058">現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4058">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="20716-4059">現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型がセキュリティ クリティカルまたは透過的な場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4059"><see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4060"><xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>、および <xref:System.Type.IsSecurityTransparent%2A> の各プロパティは、共通言語ランタイム (CLR) によって決定された、現在の信頼レベルでの型の透明度レベルを報告します。</span><span class="sxs-lookup"><span data-stu-id="20716-4060">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="20716-4061">これらのプロパティの組み合わせを次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4061">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="20716-4062">セキュリティ レベル</span><span class="sxs-lookup"><span data-stu-id="20716-4062">Security level</span></span>|<span data-ttu-id="20716-4063">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="20716-4063">IsSecurityCritical</span></span>|<span data-ttu-id="20716-4064">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="20716-4064">IsSecuritySafeCritical</span></span>|<span data-ttu-id="20716-4065">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="20716-4065">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="20716-4066">Critical</span><span class="sxs-lookup"><span data-stu-id="20716-4066">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="20716-4067">安全クリティカル</span><span class="sxs-lookup"><span data-stu-id="20716-4067">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="20716-4068">透明</span><span class="sxs-lookup"><span data-stu-id="20716-4068">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="20716-4069">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</span><span class="sxs-lookup"><span data-stu-id="20716-4069">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20716-4070">部分信頼アセンブリの場合、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。</span><span class="sxs-lookup"><span data-stu-id="20716-4070">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="20716-4071">アセンブリが部分的に信頼されたアプリケーションドメイン (たとえば、サンドボックス化されたアプリケーションドメイン) に読み込まれる場合、ランタイムはアセンブリのセキュリティ注釈を無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-4071">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="20716-4072">アセンブリとそのすべての型は透過的として扱われます。</span><span class="sxs-lookup"><span data-stu-id="20716-4072">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="20716-4073">ランタイムは、アセンブリが完全に信頼されたアプリケーションドメイン (たとえば、デスクトップアプリケーションの既定のアプリケーションドメイン) に読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意します。</span><span class="sxs-lookup"><span data-stu-id="20716-4073">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="20716-4074">これに対し、信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前のアセンブリ) は、アプリケーションドメインの信頼レベルに関係なく、常に完全信頼で読み込まれます。したがって、現在の信頼レベルは常に完全に信頼されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4074">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="20716-4075">アセンブリとアプリケーションドメインの現在の信頼レベルを確認するには、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> の各プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4075">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="20716-4076">リフレクションと透明度の詳細については、「[リフレクションのセキュリティに関する考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4076">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="20716-4077">透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4077">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="20716-4078">リフレクションに関するセキュリティ上の考慮事項</span><span class="sxs-lookup"><span data-stu-id="20716-4078">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="20716-4079">.NET Framework におけるセキュリティの変更点</span><span class="sxs-lookup"><span data-stu-id="20716-4079">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4080">現在の型が現在の信頼レベルで透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4080">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="20716-4081">現在の型が現在の信頼レベルで透過的セキュリティである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4081"><see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4082">このプロパティが `true`を返す場合、<xref:System.Type.IsSecurityCritical%2A> プロパティと <xref:System.Type.IsSecuritySafeCritical%2A> プロパティは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4082">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="20716-4083"><xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>、および <xref:System.Type.IsSecurityTransparent%2A> の各プロパティは、共通言語ランタイム (CLR) によって決定された、現在の信頼レベルでの型の透明度レベルを報告します。</span><span class="sxs-lookup"><span data-stu-id="20716-4083">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="20716-4084">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</span><span class="sxs-lookup"><span data-stu-id="20716-4084">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20716-4085">部分信頼アセンブリの場合、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。</span><span class="sxs-lookup"><span data-stu-id="20716-4085">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="20716-4086">アセンブリが部分的に信頼されたアプリケーションドメイン (たとえば、サンドボックス化されたアプリケーションドメイン) に読み込まれる場合、ランタイムはアセンブリのセキュリティ注釈を無視します。</span><span class="sxs-lookup"><span data-stu-id="20716-4086">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="20716-4087">アセンブリとそのすべての型は透過的として扱われます。</span><span class="sxs-lookup"><span data-stu-id="20716-4087">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="20716-4088">ランタイムは、アセンブリが完全に信頼されたアプリケーションドメイン (たとえば、デスクトップアプリケーションの既定のアプリケーションドメイン) に読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意します。</span><span class="sxs-lookup"><span data-stu-id="20716-4088">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="20716-4089">これに対し、信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前のアセンブリ) は、アプリケーションドメインの信頼レベルに関係なく、常に完全信頼で読み込まれます。したがって、現在の信頼レベルは常に完全に信頼されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4089">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="20716-4090">アセンブリとアプリケーションドメインの現在の信頼レベルを確認するには、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> の各プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4090">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="20716-4091">リフレクションと透明度の詳細については、「[リフレクションのセキュリティに関する考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4091">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="20716-4092">透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4092">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="20716-4093">リフレクションに関するセキュリティ上の考慮事項</span><span class="sxs-lookup"><span data-stu-id="20716-4093">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="20716-4094">.NET Framework におけるセキュリティの変更点</span><span class="sxs-lookup"><span data-stu-id="20716-4094">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSerializable { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4095"><see cref="T:System.Type" /> をシリアル化できるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4095">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span></span></summary>
        <value><span data-ttu-id="20716-4096"><see langword="true" /> をシリアル化できる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4096"><see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="20716-4097">.NET Standard で定義されている型は、<xref:System.SerializableAttribute>でマークされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4097">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="20716-4098">代わりに、各 .NET 実装で、型をシリアル化できるかどうかが決定されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4098">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="20716-4099">実行時には、<xref:System.Type.IsSerializable%2A> プロパティを使用して、その実装が型のインスタンスのシリアル化をサポートしているかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4099">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="20716-4100">詳細と例については、「 [.NET Standard オブジェクトがシリアル化可能かどうかを判断する方法](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4100">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="20716-4101">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4101">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-4102">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-4102">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-4103">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4103">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4104">次の例では、`MyTestClass` クラスのインスタンスを作成し、[Serializable] 属性を設定し、`true` または `false`の `IsSerializable` プロパティをチェックします。</span><span class="sxs-lookup"><span data-stu-id="20716-4104">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4105">型が署名型かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4105">Gets a value that indicates whether the type is a signature type.</span></span></summary>
        <value><span data-ttu-id="20716-4106"><see cref="T:System.Type" /> が署名の種類である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-4106"><see langword="true" /> if the <see cref="T:System.Type" /> is a signature type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="20716-4107">シグネチャ型は制限付きの型であり、<xref:System.Type.GetMethod%2A> メソッドに渡すことができますが、その他のリフレクション機能のほとんどはサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4107">A signature type is a restricted type that can be passed to the <xref:System.Type.GetMethod%2A> method but does not support most of the other reflection functionality.</span></span> <span data-ttu-id="20716-4108">たとえば、<xref:System.Type.MakeGenericMethodParameter%2A> メソッドを呼び出すことによって、ジェネリックメソッドのパラメーターに対応する署名の種類のインスタンスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4108">For example, you can obtain the signature type instance corresponding to the generic method parameter by calling the <xref:System.Type.MakeGenericMethodParameter%2A> method.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4109">型が特別な処理を必要とする名前を持っているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4109">Gets a value indicating whether the type has a name that requires special handling.</span></span></summary>
        <value><span data-ttu-id="20716-4110">型の名前が特別な処理を必要とする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4110"><see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4111">名前の先頭にアンダースコア文字 (_)、プロパティアクセサー、および演算子のオーバーロードメソッドが含まれている場合は、一部のコンパイラで特別な処理が必要となる可能性がある型の例です。</span><span class="sxs-lookup"><span data-stu-id="20716-4111">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="20716-4112">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4112">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-4113">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-4113">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-4114">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4114">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="20716-4115">現在の型と比較する型。</span><span class="sxs-lookup"><span data-stu-id="20716-4115">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="20716-4116">現在の <see cref="T:System.Type" /> が、指定した <see cref="T:System.Type" /> から派生しているかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-4116">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-4117">現在の <see langword="Type" /> が <paramref name="c" /> から派生している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4117"><see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="20716-4118"><see langword="false" /> と現在の <paramref name="c" /> とが等価の場合も、このメソッドは <see langword="Type" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4118">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4119"><xref:System.Type.IsSubclassOf%2A> メソッドを呼び出して、次のいずれかを決定できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4119">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="20716-4120">あるクラスが別のクラスから派生しているかどうか。</span><span class="sxs-lookup"><span data-stu-id="20716-4120">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="20716-4121">型が <xref:System.ValueType>から派生しているかどうか。</span><span class="sxs-lookup"><span data-stu-id="20716-4121">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="20716-4122">ただし、<xref:System.Type.IsValueType%2A> は、型が値型であるかどうかを判断するより効率的な方法です。</span><span class="sxs-lookup"><span data-stu-id="20716-4122">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="20716-4123">型が <xref:System.Enum>から派生しているかどうか。</span><span class="sxs-lookup"><span data-stu-id="20716-4123">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="20716-4124">ただし、<xref:System.Type.IsEnum%2A> メソッドは、型が列挙型であるかどうかを判断するより効率的な方法です。</span><span class="sxs-lookup"><span data-stu-id="20716-4124">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="20716-4125">型がデリゲートであるかどうか、つまり、<xref:System.Delegate> または <xref:System.MulticastDelegate>のどちらから派生するかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4125">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="20716-4126"><xref:System.Type.IsSubclassOf%2A> メソッドを使用して、インターフェイスが別のインターフェイスから派生しているかどうか、またはクラスがインターフェイスを実装しているかどうかを判断することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-4126">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="20716-4127">次の例に示すように、その目的には <xref:System.Type.IsAssignableFrom%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4127">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="20716-4128">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合は、クラス制約を継承するか、クラス制約がない場合は <xref:System.Object?displayProperty=nameWithType> から派生します。</span><span class="sxs-lookup"><span data-stu-id="20716-4128">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-4129">インターフェイスと共に使用する場合を除き、<xref:System.Type.IsSubclassOf%2A> は <xref:System.Type.IsAssignableFrom%2A>の逆です。</span><span class="sxs-lookup"><span data-stu-id="20716-4129">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="20716-4130">つまり、`t1.IsSubclassOf(t2)` が `true`場合、`t2.IsAssignableFrom(t1)` も `true`ます。</span><span class="sxs-lookup"><span data-stu-id="20716-4130">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="20716-4131">このメソッドは、派生クラスによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="20716-4131">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4132">次の例では、`Class1` という名前のクラスと、`DerivedC1`という名前の派生クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4132">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="20716-4133"><xref:System.Type.IsSubclassOf%2A> メソッドを呼び出して、`DerivedC1` が `Class1`のサブクラスであることを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4133">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-4134"><paramref name="c" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4134"><paramref name="c" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4135">型が、下限が 0 の 1 次元配列のみを表すことができる配列型であるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4135">Gets a value that indicates whether the type is an array type that can represent only a single-dimensional array with a zero lower bound.</span></span></summary>
        <value><span data-ttu-id="20716-4136">現在の <see cref="T:System.Type" /> が、下限がゼロの1次元配列のみを表すことができる配列型である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-4136"><see langword="true" /> if the current <see cref="T:System.Type" /> is an array type that can represent only a single-dimensional array with a zero lower bound; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4137">型が型定義かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4137">Gets a value that indicates whether the type is a type definition.</span></span></summary>
        <value><span data-ttu-id="20716-4138">現在の <see cref="T:System.Type" /> が型定義である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-4138"><see langword="true" /> if the current <see cref="T:System.Type" /> is a type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4139"><xref:System.Type> インスタンスは、他の型に基づいて要求時に構築される型とは対照的に、アセンブリで直接定義された型を表す型定義です。</span><span class="sxs-lookup"><span data-stu-id="20716-4139">A <xref:System.Type> instance is a type definition if it represents the type directly defined in assembly, in contrast to types that are constructed on demand based on other types.</span></span> <span data-ttu-id="20716-4140">たとえば、プリミティブ型、クラス、構造体、ジェネリック型の定義は型定義ですが、配列、参照、ポインター、またはインスタンス化されたジェネリック型は使用できません。</span><span class="sxs-lookup"><span data-stu-id="20716-4140">For example, a primitive type, class, structure, or generic type definition is a type definition, but an array, reference, pointer, or instantiated generic type isn't.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4141"><see langword="UnicodeClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4141">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="20716-4142"><see langword="true" />に、文字列書式属性として<see langword="UnicodeClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4142"><see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4143"><xref:System.Reflection.TypeAttributes.StringFormatMask> は、文字列形式の属性を選択するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4143">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="20716-4144">文字列形式属性は、文字列の解釈方法を定義することで相互運用性を強化します。</span><span class="sxs-lookup"><span data-stu-id="20716-4144">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="20716-4145">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4145">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-4146">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-4146">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-4147">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4147">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4148"><see cref="T:System.Type" /> が値型かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4148">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span></span></summary>
        <value><span data-ttu-id="20716-4149"><see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4149"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4150">値型は、ビットのシーケンスとして表現される型です。値型はクラスまたはインターフェイスではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4150">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="20716-4151">値型は、一部のプログラミング言語では "struct" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="20716-4151">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="20716-4152">列挙型は、値型の特殊なケースです。</span><span class="sxs-lookup"><span data-stu-id="20716-4152">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="20716-4153">このプロパティは、<xref:System.ValueType> が値型ではないため、<xref:System.ValueType> クラスの `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4153">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="20716-4154">これはすべての値型の基底クラスであるため、任意の値型を割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-4154">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="20716-4155">これは、<xref:System.ValueType> 自体が値型の場合はできません。</span><span class="sxs-lookup"><span data-stu-id="20716-4155">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="20716-4156">値型は <xref:System.ValueType>型のフィールドに割り当てられるときにボックス化されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4156">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="20716-4157">このプロパティは、列挙に対して `true` を返しますが、<xref:System.Enum> 型自体にはを返しません。</span><span class="sxs-lookup"><span data-stu-id="20716-4157">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="20716-4158">この動作を示す例については、「<xref:System.Type.IsEnum%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4158">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="20716-4159">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-4159">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4160">次の例では、`MyEnum`型の変数を作成し、`IsValueType` プロパティをチェックして、結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4160">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-4161"><see cref="P:System.Type.IsValueType" /> プロパティを実装するとともに、<see cref="T:System.Type" /> が値型である (つまり、クラスやインターフェイスでない) かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-4161">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span></span></summary>
        <returns><span data-ttu-id="20716-4162"><see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4162"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4163">このメソッドは、代替型システムの実装を可能にするために用意されています。</span><span class="sxs-lookup"><span data-stu-id="20716-4163">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="20716-4164">通常、アプリケーションコードでは使用されません。</span><span class="sxs-lookup"><span data-stu-id="20716-4164">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4165">型が多次元配列を表すことができるか、任意の下限を持つ 1 つの配列を表すことができる配列型であるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4165">Gets a value that indicates whether the type is an array type that can represent a multi-dimensional array or an array with an arbitrary lower bound.</span></span></summary>
        <value><span data-ttu-id="20716-4166">現在の <see cref="T:System.Type" /> が多次元配列または任意の下限を持つ配列を表すことのできる配列型である場合に <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</span><span class="sxs-lookup"><span data-stu-id="20716-4166"><see langword="true" /> if the current <see cref="T:System.Type" /> is an array type that can represent a multi-dimensional array or an array with an arbitrary lower bound; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="20716-4167">このプロパティの値が配列型に `true` 場合は、任意の下限を持つ1次元配列または多次元配列インスタンスを作成するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4167">If the value of this property is `true` for an array type, it can be used to create single-dimensional or multi-dimensional array instances with arbitrary lower bounds.</span></span> <span data-ttu-id="20716-4168">それ以外の場合、配列型は、下限が0の1次元配列のインスタンスを作成するためにのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4168">Otherwise, the array type can only be used to create instances of single-dimensional arrays with a zero lower bound.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4169"><see cref="T:System.Type" /> にアセンブリの外側のコードからアクセスできるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4169">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span></span></summary>
        <value><span data-ttu-id="20716-4170">現在の<see langword="true" /> がパブリック型である場合、またはすべての包含する型がパブリックであるような入れ子にされたパブリック型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4170"><see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4171">このプロパティを使用して、型がコンポーネントアセンブリのパブリックインターフェイスの一部であるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="20716-4171">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4172">次のコード例では、2つのクラスをテストします。そのうちの1つのみがアセンブリの外部で参照できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4172">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="20716-4173">現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4173">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-4174">下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4174">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="20716-4175">下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4175">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4176"><xref:System.Type.MakeArrayType%2A> メソッドは、実行時に要素型が計算される配列型を生成する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="20716-4176">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="20716-4177">**メモ**共通言語ランタイムは、ベクター (つまり、常に0から始まる1次元配列) と多次元配列を区別します。</span><span class="sxs-lookup"><span data-stu-id="20716-4177">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="20716-4178">常に1つの次元のみを持つベクターは、次元が1つしかない多次元配列と同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4178">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="20716-4179">このメソッドオーバーロードはベクター型の作成にのみ使用でき、ベクター型を作成する唯一の方法です。</span><span class="sxs-lookup"><span data-stu-id="20716-4179">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="20716-4180">多次元配列型を作成するには、<xref:System.Type.MakeArrayType%28System.Int32%29> メソッドオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4180">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4181">次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4181">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-4182">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4182">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="20716-4183">派生クラスには実装を指定しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="20716-4183">Derived classes must provide an implementation.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-4184">現在の型は <see cref="T:System.TypedReference" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4184">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="20716-4185">または</span><span class="sxs-lookup"><span data-stu-id="20716-4185">-or-</span></span> 
<span data-ttu-id="20716-4186">現在の型は <see langword="ByRef" /> 型です。</span><span class="sxs-lookup"><span data-stu-id="20716-4186">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="20716-4187">つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4187">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType (int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType(int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="20716-4188">配列の次元数。</span><span class="sxs-lookup"><span data-stu-id="20716-4188">The number of dimensions for the array.</span></span> <span data-ttu-id="20716-4189">この数値は 32 以下である必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-4189">This number must be less than or equal to 32.</span></span></param>
        <summary><span data-ttu-id="20716-4190">次元数を指定して現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4190">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="20716-4191">次元数を指定して現在の型の配列を表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4191">An object representing an array of the current type, with the specified number of dimensions.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4192"><xref:System.Type.MakeArrayType%2A> メソッドは、実行時に要素型が計算される配列型を生成する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="20716-4192">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-4193">共通言語ランタイムは、ベクター (つまり、常に0から始まる1次元配列) と多次元配列を区別します。</span><span class="sxs-lookup"><span data-stu-id="20716-4193">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="20716-4194">常に1つの次元のみを持つベクターは、次元が1つしかない多次元配列と同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4194">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="20716-4195">このメソッドオーバーロードを使用してベクター型を作成することはできません。`rank` が1の場合、このメソッドオーバーロードは、1つの次元を持つ多次元配列型を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4195">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="20716-4196">ベクター型を作成するには、<xref:System.Type.MakeArrayType> メソッドオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4196">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4197">次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4197">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="20716-4198"><paramref name="rank" /> が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4198"><paramref name="rank" /> is invalid.</span></span> <span data-ttu-id="20716-4199">たとえば、0 または負の値です。</span><span class="sxs-lookup"><span data-stu-id="20716-4199">For example, 0 or negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-4200">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4200">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-4201">現在の型は <see cref="T:System.TypedReference" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4201">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="20716-4202">または</span><span class="sxs-lookup"><span data-stu-id="20716-4202">-or-</span></span> 
<span data-ttu-id="20716-4203">現在の型は <see langword="ByRef" /> 型です。</span><span class="sxs-lookup"><span data-stu-id="20716-4203">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="20716-4204">つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4204">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span>  
  
<span data-ttu-id="20716-4205">または</span><span class="sxs-lookup"><span data-stu-id="20716-4205">-or-</span></span> 
 <span data-ttu-id="20716-4206"><paramref name="rank" /> が 32 を超えています。</span><span class="sxs-lookup"><span data-stu-id="20716-4206"><paramref name="rank" /> is greater than 32.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public abstract Type MakeByRefType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeByRefType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeByRefType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-4207"><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4207">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="20716-4208"><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4208">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4209"><xref:System.Type.MakeByRefType%2A> メソッドを使用すると、パラメーターリストの `ref` 型 (Visual Basic に`ByRef`) を生成することができます。</span><span class="sxs-lookup"><span data-stu-id="20716-4209">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="20716-4210">Microsoft 中間言語 (MSIL) の構文を使用して、現在の <xref:System.Type> オブジェクトが <xref:System.Int32>を表している場合、このメソッドは `Int32&`を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4210">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4211">次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4211">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-4212">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4212">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-4213">現在の型は <see cref="T:System.TypedReference" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4213">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="20716-4214">または</span><span class="sxs-lookup"><span data-stu-id="20716-4214">-or-</span></span> 
<span data-ttu-id="20716-4215">現在の型は <see langword="ByRef" /> 型です。</span><span class="sxs-lookup"><span data-stu-id="20716-4215">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="20716-4216">つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4216">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="position"><span data-ttu-id="20716-4217">型指定されたパラメーターの位置。</span><span class="sxs-lookup"><span data-stu-id="20716-4217">The typed parameter position.</span></span></param>
        <summary><span data-ttu-id="20716-4218">ジェネリック パラメーター参照を表すために、<see cref="Overload:System.Type.GetMethod" /> メソッドの <c>Type []</c> 配列パラメーターに渡すことができる署名型オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4218">Returns a signature type object that can be passed into the <c>Type[]</c> array parameter of a <see cref="Overload:System.Type.GetMethod" /> method to represent a generic parameter reference.</span></span></summary>
        <returns><span data-ttu-id="20716-4219">ジェネリック パラメーター参照を表すために、<see cref="Overload:System.Type.GetMethod" /> メソッドの <c>Type []</c> 配列パラメーターに渡すことができる署名型オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4219">A signature type object that can be passed into the <c>Type[]</c> array parameter of a <see cref="Overload:System.Type.GetMethod" /> method to represent a generic parameter reference.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="20716-4220"><paramref name="position" /> は負の値です。</span><span class="sxs-lookup"><span data-stu-id="20716-4220"><paramref name="position" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition"><span data-ttu-id="20716-4221">ジェネリック型定義。</span><span class="sxs-lookup"><span data-stu-id="20716-4221">The generic type definition.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="20716-4222">型引数の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-4222">An array of type arguments.</span></span></param>
        <summary><span data-ttu-id="20716-4223">型メンバーの問い合わせで署名の型の利用を完全にサポートするための Reflection の再実装をサードパーティに許可するジェネリック署名の型を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4223">Creates a generic signature type, which allows third party reimplementations of Reflection to fully support the use of signature types in querying type members.</span></span></summary>
        <returns><span data-ttu-id="20716-4224">ジェネリック署名の型。</span><span class="sxs-lookup"><span data-stu-id="20716-4224">A generic signature type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public abstract Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="20716-4225">現在のジェネリック型の型パラメーターに置き換えられる型の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-4225">An array of types to be substituted for the type parameters of the current generic type.</span></span></param>
        <summary><span data-ttu-id="20716-4226">型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を表す <see cref="T:System.Type" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4226">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="20716-4227"><paramref name="typeArguments" /> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4227">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4228"><xref:System.Type.MakeGenericType%2A> メソッドを使用すると、特定の型をジェネリック型定義の型パラメーターに割り当て、特定の構築型を表す <xref:System.Type> オブジェクトを作成するコードを記述できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4228">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="20716-4229">この <xref:System.Type> オブジェクトを使用して、構築された型のランタイムインスタンスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4229">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="20716-4230"><xref:System.Type.MakeGenericType%2A> で構築された型は開くことができます。つまり、一部の型引数は、それを囲むジェネリックメソッドまたは型の型パラメーターにすることができます。</span><span class="sxs-lookup"><span data-stu-id="20716-4230">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="20716-4231">動的アセンブリを出力するときに、このようなオープン構築型を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-4231">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="20716-4232">たとえば、次のコードでは、クラス `Base` と `Derived` を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="20716-4232">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="20716-4233">動的アセンブリ内の `Derived` を生成するには、その基本型を構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-4233">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="20716-4234">これを行うには、クラス `Base`を表す <xref:System.Type> オブジェクトの <xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。これには、ジェネリック型引数 <xref:System.Int32> および `V` からの型パラメーター `Derived`を使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4234">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="20716-4235">型とジェネリック型パラメーターはどちらも <xref:System.Type> オブジェクトによって表されるため、両方を含む配列を <xref:System.Type.MakeGenericType%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="20716-4235">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-4236">`Base<int, V>` などの構築された型は、コードを出力するときに便利ですが、ジェネリック型定義ではないため、この型の <xref:System.Type.MakeGenericType%2A> メソッドを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-4236">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="20716-4237">インスタンス化できる閉じた構築型を作成するには、まず <xref:System.Type.GetGenericTypeDefinition%2A> メソッドを呼び出して、ジェネリック型定義を表す <xref:System.Type> オブジェクトを取得し、必要な型引数を指定して <xref:System.Type.MakeGenericType%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-4237">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="20716-4238"><xref:System.Type.MakeGenericType%2A> によって返される <xref:System.Type> オブジェクトは、結果の構築型の <xref:System.Object.GetType%2A> メソッドを呼び出すことによって取得される <xref:System.Type> と同じか、同じ型引数を使用して同じジェネリック型定義から作成された任意の構築型の <xref:System.Object.GetType%2A> メソッドと同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-4238">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20716-4239">ジェネリック型の配列は、それ自体がジェネリック型ではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4239">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="20716-4240">`C<T>[]` (Visual Basic の`Dim ac() As C(Of T)`) などの配列型で <xref:System.Type.MakeGenericType%2A> を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-4240">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="20716-4241">クローズジェネリック型を `C<T>[]`から構築するには、<xref:System.Type.GetElementType%2A> を呼び出して、ジェネリック型の定義 `C<T>`を取得します。ジェネリック型定義の <xref:System.Type.MakeGenericType%2A> を呼び出して、構築された型を作成します。最後に、構築された型の <xref:System.Type.MakeArrayType%2A> メソッドを呼び出して、配列型を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4241">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="20716-4242">ポインター型と `ref` 型 (Visual Basic の`ByRef`) にも同じことが当てはまります。</span><span class="sxs-lookup"><span data-stu-id="20716-4242">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="20716-4243">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4243">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="20716-4244">Nested Types</span><span class="sxs-lookup"><span data-stu-id="20716-4244">Nested Types</span></span>  
 <span data-ttu-id="20716-4245">ジェネリック型が、 C# C++、または Visual Basic を使用して定義されている場合、その入れ子にされた型はすべてジェネリックになります。</span><span class="sxs-lookup"><span data-stu-id="20716-4245">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="20716-4246">これは、入れ子にされた型が独自の型パラメーターを持たない場合でも当てはまります。これは、3つのすべての言語に、入れ子にされた型の型パラメーターリストに含まれる型の型パラメーターが含まれているためです。</span><span class="sxs-lookup"><span data-stu-id="20716-4246">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="20716-4247">次のクラスについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="20716-4247">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="20716-4248">入れ子になったクラス `Inner` の型パラメーターリストには、`T` と `U`の2つの型パラメーターがあります。1つ目は、外側のクラスの型パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="20716-4248">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="20716-4249">同様に、入れ子になったクラスの型パラメーターリスト `Innermost1` には、`T`、`U`、および `V`の3つの型パラメーターがあり、その外側のクラスからの `T` と `U` があります。</span><span class="sxs-lookup"><span data-stu-id="20716-4249">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="20716-4250">入れ子になったクラス `Innermost2` には、`T` と `U`の2つの型パラメーターがあります。これらは、外側のクラスから取得されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4250">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="20716-4251">外側の型のパラメーターリストに複数の型パラメーターがある場合は、すべての型パラメーターが入れ子になった型の型パラメーターリストに含まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-4251">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="20716-4252">入れ子になった型のジェネリック型の定義からジェネリック型を構築するには、外側のすべての型の型引数配列を連結して、最も外側のジェネリック型から始まり、入れ子になった型自体の型引数配列で終了する (独自の型パラメーターがある場合) ことによって、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-4252">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="20716-4253">`Innermost1`のインスタンスを作成するには、T、U、V に割り当てられる3つの型を含む配列を使用して、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。`Innermost2`のインスタンスを作成するには、T と U に割り当てられる2つの型を含む配列を使用して、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="20716-4253">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="20716-4254">これらの言語は、外側の型の型パラメーターを使用して入れ子になった型のフィールドを定義できるように、それを囲む型の型パラメーターをこの方法で反映します。</span><span class="sxs-lookup"><span data-stu-id="20716-4254">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="20716-4255">それ以外の場合、型パラメーターは入れ子にされた型の本体内のスコープ内にありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4255">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="20716-4256">動的アセンブリまたは[Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)を使用して、外側の型の型パラメーターを伝達せずに入れ子にされた型を定義することができます。</span><span class="sxs-lookup"><span data-stu-id="20716-4256">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="20716-4257">次の MSIL アセンブラーのコードについて考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="20716-4257">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="20716-4258">この例では、型パラメーターがスコープに含まれていないため、クラス `Innermost`で `T` 型または `U` 型のフィールドを定義することはできません。</span><span class="sxs-lookup"><span data-stu-id="20716-4258">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="20716-4259">次のアセンブラコードでは、、Visual Basic、およびC++ C#で定義されている場合に動作するように、入れ子になったクラスを定義しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4259">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="20716-4260">[Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して、高レベル言語で定義されている入れ子になったクラスを確認し、この名前付けスキームを観察できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4260">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4261">次の例では、<xref:System.Type.MakeGenericType%2A> メソッドを使用して、<xref:System.Collections.Generic.Dictionary%602> 型のジェネリック型定義から構築された型を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4261">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="20716-4262">構築された型は、文字列キーを持つ `Test` オブジェクトの <xref:System.Collections.Generic.Dictionary%602> を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-4262">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="20716-4263">現在の型はジェネリック型の定義を表していません。</span><span class="sxs-lookup"><span data-stu-id="20716-4263">The current type does not represent a generic type definition.</span></span> <span data-ttu-id="20716-4264">つまり、<see cref="P:System.Type.IsGenericTypeDefinition" /> は <see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4264">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-4265"><paramref name="typeArguments" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4265"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="20716-4266">または</span><span class="sxs-lookup"><span data-stu-id="20716-4266">-or-</span></span> 
<span data-ttu-id="20716-4267"><paramref name="typeArguments" /> のどの要素も <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4267">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-4268"><paramref name="typeArguments" /> 内の要素数は現在のジェネリック型定義の型パラメーター数と同じではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4268">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span></span>  
  
<span data-ttu-id="20716-4269">または</span><span class="sxs-lookup"><span data-stu-id="20716-4269">-or-</span></span> 
<span data-ttu-id="20716-4270"><paramref name="typeArguments" /> のいずれかの要素が、現在のジェネリック型の対応する型パラメーターに指定された制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4270">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span></span>  
  
<span data-ttu-id="20716-4271">または</span><span class="sxs-lookup"><span data-stu-id="20716-4271">-or-</span></span> 
 <span data-ttu-id="20716-4272"><paramref name="typeArguments" /> には、ポインター型 (<see cref="P:System.Type.IsPointer" /> は <see langword="true" /> を返します)、参照渡し型 (<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します)、または <see cref="T:System.Void" /> である要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-4272"><paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-4273">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4273">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="20716-4274">派生クラスには実装を指定しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="20716-4274">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="20716-4275">リフレクションとジェネリック型</span><span class="sxs-lookup"><span data-stu-id="20716-4275">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="20716-4276">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</span><span class="sxs-lookup"><span data-stu-id="20716-4276">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public abstract Type MakePointerType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakePointerType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakePointerType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-4277">現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4277">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="20716-4278">現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4278">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4279"><xref:System.Type.MakePointerType%2A> メソッドは、パラメーターリストのポインター型を生成する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="20716-4279">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="20716-4280">Microsoft 中間言語 (MSIL) の構文を使用して、現在の <xref:System.Type> オブジェクトが <xref:System.Int32>を表している場合、このメソッドは `Int32*`を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4280">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4281">次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。</span><span class="sxs-lookup"><span data-stu-id="20716-4281">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-4282">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4282">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-4283">現在の型は <see cref="T:System.TypedReference" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4283">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="20716-4284">または</span><span class="sxs-lookup"><span data-stu-id="20716-4284">-or-</span></span> 
<span data-ttu-id="20716-4285">現在の型は <see langword="ByRef" /> 型です。</span><span class="sxs-lookup"><span data-stu-id="20716-4285">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="20716-4286">つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4286">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4287">このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4287">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></summary>
        <value><span data-ttu-id="20716-4288">このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値。</span><span class="sxs-lookup"><span data-stu-id="20716-4288">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4289">このプロパティは <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="20716-4289">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20716-4290">したがって、<xref:System.Type.GetMembers%2A> によって返される配列などの <xref:System.Reflection.MemberInfo> オブジェクトのセットを調べると、指定されたメンバーが入れ子になった型である場合、<xref:System.Reflection.MemberInfo.MemberType%2A> プロパティによって <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> が返されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4290">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="20716-4291">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4291">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="20716-4292">たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。</span><span class="sxs-lookup"><span data-stu-id="20716-4292">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="20716-4293">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4294">次のコード例では、`GetMember` メソッドのパラメーターとして `MemberType` フィールドを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4294">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4295"><see cref="T:System.Type" /> 情報に不足している値を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-4295">Represents a missing value in the <see cref="T:System.Type" /> information.</span></span> <span data-ttu-id="20716-4296">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="20716-4296">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4297">パラメーターの既定値を取得するには、リフレクションを使用した呼び出しに `Missing` フィールドを使用します。</span><span class="sxs-lookup"><span data-stu-id="20716-4297">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="20716-4298">パラメーター値に `Missing` フィールドが渡され、そのパラメーターに既定値がない場合は、<xref:System.ArgumentException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-4298">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4299">次のコード例では、`Missing` フィールドを使用して、既定の引数を持つメソッドを呼び出す方法を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4299">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="20716-4300">このコードを実行すると、次の出力が生成されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4300">This code produces the following output:</span></span>  
  
 <span data-ttu-id="20716-4301">a = 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="20716-4301">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="20716-4302">a = 10 b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="20716-4302">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="20716-4303">a = 10 b = 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="20716-4303">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4304">現在の <see cref="T:System.Type" /> が定義されているモジュール (DLL) を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4304">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span></span></summary>
        <value><span data-ttu-id="20716-4305">現在の <see cref="T:System.Type" /> が定義されているモジュールです。</span><span class="sxs-lookup"><span data-stu-id="20716-4305">The module in which the current <see cref="T:System.Type" /> is defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4306">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義が定義されているモジュールを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4306">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="20716-4307">たとえば、`MyGenericStack<int>`のインスタンスを作成した場合、構築された型の <xref:System.Type.Module%2A> プロパティは `MyGenericStack<T>` が定義されているモジュールを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4307">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="20716-4308">同様に、現在の <xref:System.Type> がジェネリックパラメーター `T`を表している場合、このプロパティは `T`を定義するジェネリック型を含むアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4308">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4309">次の例は、<xref:System.Type.Namespace%2A> と `Module` のプロパティと <xref:System.Type>の <xref:System.Type.ToString%2A> メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4309">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4310">派生クラスでオーバーライドされると、現在の型の名前を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4310">When overridden in a derived class, gets the name of the current type.</span></span></summary>
        <value><span data-ttu-id="20716-4311">現在の型の名前。</span><span class="sxs-lookup"><span data-stu-id="20716-4311">The name of the current type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4312"><see cref="T:System.Type" /> の名前空間を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4312">Gets the namespace of the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="20716-4313"><see cref="T:System.Type" /> の名前空間。現在のインスタンスに名前空間がない場合、または現在のインスタンスがジェネリック パラメーターを表す場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4313">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4314">名前空間は論理的なデザイン時の名前付けの便宜です。主にアプリケーションでスコープを定義し、1つの階層構造でクラスやその他の型を整理するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="20716-4314">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="20716-4315">ランタイムの視点から見ると、名前空間はありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4315">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="20716-4316">現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義を含む名前空間を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4316">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="20716-4317">同様に、現在の <xref:System.Type> がジェネリックパラメーター `T`を表している場合、このプロパティは `T`を定義するジェネリック型定義を含む名前空間を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4317">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="20716-4318">現在の <xref:System.Type> オブジェクトがジェネリックパラメーターを表している場合、このプロパティは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4318">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4319">次の例は、`Namespace` と <xref:System.Type.Module%2A> のプロパティと <xref:System.Type>の <xref:System.Type.ToString%2A> メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4319">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-4320">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-4320">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="20716-4321">比較する最初のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4321">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="20716-4322">比較する 2 番目のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4322">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="20716-4323">2 つの <see cref="T:System.Type" /> オブジェクトが等しいかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4323">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="20716-4324"><see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4324"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="20716-4325">比較する最初のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4325">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="20716-4326">比較する 2 番目のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4326">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="20716-4327">2 つの <see cref="T:System.Type" /> オブジェクトが等しくないかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4327">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="20716-4328"><see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4328"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4329">このメンバーを取得するために使用したクラス オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4329">Gets the class object that was used to obtain this member.</span></span></summary>
        <value><span data-ttu-id="20716-4330">この <see langword="Type" /> オブジェクトを取得するために使用した <see cref="T:System.Type" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4330">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4331"><xref:System.Type> オブジェクトの場合、このプロパティの値は常に <xref:System.Type.DeclaringType%2A> プロパティの値と同じになります。</span><span class="sxs-lookup"><span data-stu-id="20716-4331">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4332">この例では、入れ子になったクラスのリフレクションされた型を表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4332">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="20716-4333">取得する <see cref="T:System.Type" /> のアセンブリ修飾名。</span><span class="sxs-lookup"><span data-stu-id="20716-4333">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="throwIfNotFound"><span data-ttu-id="20716-4334">型が見つからない場合に <see cref="T:System.TypeLoadException" /> をスローするには <see langword="true" />。型が見つからない場合に <see langword="null" /> を返すには <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4334"><see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span></span> <span data-ttu-id="20716-4335">また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4335">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="20716-4336">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4336">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="20716-4337">大文字と小文字を区別せずに <paramref name="typeName" /> の検索を実行するには <see langword="true" />。大文字と小文字を区別して <paramref name="typeName" /> の検索を実行するには <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4337"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />; <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="20716-4338">大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4338">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span></span> <span data-ttu-id="20716-4339">型は実行ではなくリフレクションのためだけに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-4339">The type is loaded for reflection only, not for execution.</span></span></summary>
        <returns><span data-ttu-id="20716-4340">存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4340">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span> <span data-ttu-id="20716-4341">型が見つからない場合、<paramref name="throwIfNotFound" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-4341">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="20716-4342">一部の場合は、<paramref name="throwIfNotFound" /> の値に関係なく、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-4342">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span></span> <span data-ttu-id="20716-4343">「例外」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4343">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4344">型を含むアセンブリがリフレクションのみのコンテキストにまだ読み込まれていない場合、<xref:System.Type.ReflectionOnlyGetType%2A> メソッドを使用することは、最初にリフレクションのためにアセンブリを読み込み、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> メソッドを使用して、アセンブリの <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを呼び出すことによって型を読み込むことと同じです。</span><span class="sxs-lookup"><span data-stu-id="20716-4344">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="20716-4345">アセンブリ修飾名の詳細については、「<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> プロパティ」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4345">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="20716-4346">型名の指定の詳細については、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4346">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="20716-4347">アセンブリが実行のために既に読み込まれている場合は、別のコピーがリフレクションのみのコンテキストに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="20716-4347">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="20716-4348">`throwIfNotFound` パラメーターは、型が見つからない場合の動作を指定します。また、「例外」セクションで説明されているように、他の特定の例外条件も抑制します。</span><span class="sxs-lookup"><span data-stu-id="20716-4348">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="20716-4349">`throwIfNotFound`の値に関係なく、一部の例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-4349">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="20716-4350">たとえば、アセンブリが有効でない場合、`throwIfNotFound` が `false`場合でも、<xref:System.BadImageFormatException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="20716-4350">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="20716-4351">リフレクションのみのコンテキストの使用方法の詳細については、「[方法: リフレクションのみのコンテキストにアセンブリを読み込む](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4351">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="20716-4352"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="20716-4352"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="20716-4353">クラス初期化子が呼び出され、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="20716-4353">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="20716-4354"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。型が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="20716-4354"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="20716-4355">または</span><span class="sxs-lookup"><span data-stu-id="20716-4355">-or-</span></span> 
 <span data-ttu-id="20716-4356"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-4356"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="20716-4357">または</span><span class="sxs-lookup"><span data-stu-id="20716-4357">-or-</span></span> 
 <span data-ttu-id="20716-4358"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="20716-4358"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="20716-4359">または</span><span class="sxs-lookup"><span data-stu-id="20716-4359">-or-</span></span> 
 <span data-ttu-id="20716-4360"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-4360"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="20716-4361">または</span><span class="sxs-lookup"><span data-stu-id="20716-4361">-or-</span></span> 
 <span data-ttu-id="20716-4362"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> オブジェクトの配列を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4362"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="20716-4363"><paramref name="typeName" /> にはアセンブリ名は含まれません。</span><span class="sxs-lookup"><span data-stu-id="20716-4363"><paramref name="typeName" /> does not include the assembly name.</span></span>  
  
<span data-ttu-id="20716-4364">または</span><span class="sxs-lookup"><span data-stu-id="20716-4364">-or-</span></span> 
 <span data-ttu-id="20716-4365"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。 <paramref name="typeName" /> に正しくない構文 ("MyType[,\*,]" など) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="20716-4365"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="20716-4366">または</span><span class="sxs-lookup"><span data-stu-id="20716-4366">-or-</span></span> 
 <span data-ttu-id="20716-4367"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4367"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="20716-4368">または</span><span class="sxs-lookup"><span data-stu-id="20716-4368">-or-</span></span> 
 <span data-ttu-id="20716-4369"><paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。</span><span class="sxs-lookup"><span data-stu-id="20716-4369"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="20716-4370">または</span><span class="sxs-lookup"><span data-stu-id="20716-4370">-or-</span></span> 
 <span data-ttu-id="20716-4371"><paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4371"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="20716-4372"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-4372"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="20716-4373">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="20716-4373">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="20716-4374">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4374">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="20716-4375">または</span><span class="sxs-lookup"><span data-stu-id="20716-4375">-or-</span></span>  
  
 <span data-ttu-id="20716-4376">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="20716-4376">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="20716-4377">.NET Core のみ: このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4377">.NET Core only: This member is not supported.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="20716-4378">完全修飾型名の指定</span><span class="sxs-lookup"><span data-stu-id="20716-4378">Specifying Fully Qualified Type Names</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md"><span data-ttu-id="20716-4379">方法 : リフレクションのみのコンテキストにアセンブリを読み込む</span><span class="sxs-lookup"><span data-stu-id="20716-4379">How to: Load Assemblies into the Reflection-Only Context</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4380">現在の型のレイアウトを説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4380">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span></span></summary>
        <value><span data-ttu-id="20716-4381">現在の型のレイアウト機能全体を説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4381">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4382"><xref:System.Runtime.InteropServices.StructLayoutAttribute> は <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドによって返されません。</span><span class="sxs-lookup"><span data-stu-id="20716-4382"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="20716-4383">代わりに、このプロパティを使用して取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4383">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4384">次のコード例では、まず、特別なレイアウト属性を持つクラス、構造体、および構造体を定義します (構造体はクラス内で入れ子になっています)。</span><span class="sxs-lookup"><span data-stu-id="20716-4384">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="20716-4385">この例では、<xref:System.Type.StructLayoutAttribute%2A> プロパティを使用して、各型の <xref:System.Runtime.InteropServices.StructLayoutAttribute> を取得し、属性のプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4385">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-4386">呼び出されたメソッドは基底クラスでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4386">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="20716-4387">将来利用するために予約されています。</span><span class="sxs-lookup"><span data-stu-id="20716-4387">Reserved for future use.</span></span> <span data-ttu-id="20716-4388">IID_NULL にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-4388">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="20716-4389">マッピング対象として渡される名前の配列。</span><span class="sxs-lookup"><span data-stu-id="20716-4389">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="20716-4390">マッピングされる名前のカウント。</span><span class="sxs-lookup"><span data-stu-id="20716-4390">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="20716-4391">名前を解釈するロケール コンテキスト。</span><span class="sxs-lookup"><span data-stu-id="20716-4391">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="20716-4392">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</span><span class="sxs-lookup"><span data-stu-id="20716-4392">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="20716-4393">一連の名前を対応する一連のディスパッチ識別子に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="20716-4393">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4394">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-4394">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="20716-4395">`IDispatch::GetIDsOfNames`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4395">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="20716-4396">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4396">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="20716-4397">返される型情報。</span><span class="sxs-lookup"><span data-stu-id="20716-4397">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="20716-4398">型情報のロケール ID。</span><span class="sxs-lookup"><span data-stu-id="20716-4398">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="20716-4399">要求された型情報オブジェクトへのポインター。</span><span class="sxs-lookup"><span data-stu-id="20716-4399">A pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="20716-4400">オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</span><span class="sxs-lookup"><span data-stu-id="20716-4400">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4401">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-4401">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="20716-4402">`IDispatch::GetTypeInfo`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4402">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="20716-4403">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4403">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.GetTypeInfoCount : uint32 -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="20716-4404">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</span><span class="sxs-lookup"><span data-stu-id="20716-4404">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="20716-4405">オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4405">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4406">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-4406">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="20716-4407">`IDispatch::GetTypeInfoCount`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4407">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="20716-4408">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4408">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="20716-4409">メンバーを識別します。</span><span class="sxs-lookup"><span data-stu-id="20716-4409">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="20716-4410">将来利用するために予約されています。</span><span class="sxs-lookup"><span data-stu-id="20716-4410">Reserved for future use.</span></span> <span data-ttu-id="20716-4411">IID_NULL にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="20716-4411">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="20716-4412">引数を解釈する対象のロケール コンテキスト。</span><span class="sxs-lookup"><span data-stu-id="20716-4412">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="20716-4413">呼び出しのコンテキストを記述するフラグ。</span><span class="sxs-lookup"><span data-stu-id="20716-4413">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="20716-4414">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</span><span class="sxs-lookup"><span data-stu-id="20716-4414">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="20716-4415">結果が格納される場所へのポインター。</span><span class="sxs-lookup"><span data-stu-id="20716-4415">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="20716-4416">例外情報を格納する構造体へのポインター。</span><span class="sxs-lookup"><span data-stu-id="20716-4416">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="20716-4417">エラーが存在する最初の引数のインデックス。</span><span class="sxs-lookup"><span data-stu-id="20716-4417">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="20716-4418">オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="20716-4418">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4419">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="20716-4419">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="20716-4420">`IDispatch::Invoke`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="20716-4420">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="20716-4421">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4421">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="20716-4422">現在の <see langword="String" /> の名前を表す <see langword="Type" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4422">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span></span></summary>
        <returns><span data-ttu-id="20716-4423">現在の <see cref="T:System.String" /> の名前を表す <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="20716-4423">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4424">このメソッドは、すべてのプリミティブ型の完全修飾共通言語ランタイム名前空間と名前を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4424">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="20716-4425">たとえば、命令のC#場合、`(long)0.Type().ToString()` は単に "int64" ではなく "system.string" を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4425">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="20716-4426">現在の <xref:System.Type> がジェネリック型を表している場合、型とその型引数は、名前空間と入れ子になった型によって修飾されますが、アセンブリによって修飾されることはありません。</span><span class="sxs-lookup"><span data-stu-id="20716-4426">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="20716-4427">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは型パラメーターの非修飾名を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4427">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4428">次の例は、<xref:System.Type.Namespace%2A> と <xref:System.Type.Module%2A> のプロパティと <xref:System.Type>の `ToString` メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="20716-4428">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="20716-4429">次の例では、`ToString` メソッドによって返される文字列と、<xref:System.Type.Name%2A>、<xref:System.Type.FullName%2A>、および <xref:System.Type.AssemblyQualifiedName%2A> プロパティを比較します。</span><span class="sxs-lookup"><span data-stu-id="20716-4429">The following example compares the strings returned by the `ToString` method and the <xref:System.Type.Name%2A>, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberSignature Language="C#" Value="public abstract RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4430">現在の <see cref="T:System.Type" /> のハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4430">Gets the handle for the current <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="20716-4431">現在の <see cref="T:System.Type" /> のハンドル。</span><span class="sxs-lookup"><span data-stu-id="20716-4431">The handle for the current <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4432">`TypeHandle` は、型を表す内部データ構造へのポインターをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="20716-4432">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="20716-4433">このハンドルは、プロセスの有効期間中に一意です。</span><span class="sxs-lookup"><span data-stu-id="20716-4433">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="20716-4434">ハンドルは、取得されたアプリケーションドメインでのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="20716-4434">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20716-4435">次の例では、対応する型のハンドルを返し、ハンドルから型を取得して表示するメソッドにハンドルを渡します。</span><span class="sxs-lookup"><span data-stu-id="20716-4435">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="20716-4436">現在、.NET Compact Framework は、このプロパティをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="20716-4436">The .NET Compact Framework does not currently support this property.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4437">型の初期化子を取得します。</span><span class="sxs-lookup"><span data-stu-id="20716-4437">Gets the initializer for the type.</span></span></summary>
        <value><span data-ttu-id="20716-4438"><see cref="T:System.Type" /> のクラス コンストラクターの名前を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="20716-4438">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20716-4439">クラス初期化子は、<xref:System.Type.FindMembers%2A> メソッド、またはパラメーターとして <xref:System.Type.GetConstructors%2A> を受け取る <xref:System.Type.GetMember%2A>、<xref:System.Type.GetMembers%2A>、<xref:System.Type.GetConstructor%2A>、および <xref:System.Reflection.BindingFlags> メソッドのオーバーロードを介して使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="20716-4439">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="20716-4440">現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="20716-4440">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="20716-4441">この型を表す共通言語ランタイムによって提供された型を示します。</span><span class="sxs-lookup"><span data-stu-id="20716-4441">Indicates the type provided by the common language runtime that represents this type.</span></span></summary>
        <value><span data-ttu-id="20716-4442"><see cref="T:System.Type" /> の基になるシステム型。</span><span class="sxs-lookup"><span data-stu-id="20716-4442">The underlying system type for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
