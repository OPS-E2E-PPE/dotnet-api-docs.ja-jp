<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fda117282a8cf98232eadc5cbba6dd1815db7a41" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78683849" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Lazy`1&lt;T&gt; extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="System.Core" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="System.Core" FromVersion="4.0.0.0" To="mscorlib" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
    <TypeForwarding From="System.Core" FromVersion="2.0.5.0" To="mscorlib" ToVersion="2.0.5.0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">遅延初期化されるオブジェクトの型。</typeparam>
    <summary>遅延初期化のサポートを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 遅延初期化を使用すると、大量またはリソースを消費するオブジェクトの作成や、リソースを集中的に使用するタスクの実行を遅らせることができます。特に、プログラムの有効期間中にこのような作成や実行が行われない場合があります。  
  
 遅延初期化を準備するには、<xref:System.Lazy%601>のインスタンスを作成します。 作成した <xref:System.Lazy%601> オブジェクトの型引数は、遅延を初期化するオブジェクトの型を指定します。 <xref:System.Lazy%601> オブジェクトの作成に使用するコンストラクターによって、初期化の特性が決まります。 遅延初期化は、<xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> プロパティへの初回のアクセス時に発生します。  
  
 ほとんどの場合、コンストラクターの選択は、次の2つの質問に対する回答に依存します。  
  
-   遅延初期化されたオブジェクトには、複数のスレッドからアクセスしますか。 その場合、<xref:System.Lazy%601> オブジェクトによって、任意のスレッドで作成される可能性があります。 既定の動作でスレッドセーフ <xref:System.Lazy%601> オブジェクトを作成する単純なコンストラクターの1つを使用できます。これにより、遅延インスタンス化されたオブジェクトの1つのインスタンスだけが、アクセスしようとしているスレッドの数に関係なく作成されます。 スレッドセーフではない <xref:System.Lazy%601> オブジェクトを作成するには、スレッドセーフを指定できないようにするコンストラクターを使用する必要があります。  
  
    > [!CAUTION]
    >  <xref:System.Lazy%601> オブジェクトをスレッドセーフにすると、遅延初期化オブジェクトは保護されません。 遅延初期化されたオブジェクトに複数のスレッドがアクセスできる場合は、そのプロパティとメソッドを、マルチスレッドアクセスに対して安全にする必要があります。  
  
-   遅延初期化には多数のコードが必要です。また、遅延初期化オブジェクトには、必要なすべての処理を行うパラメーターなしのコンストラクターがあり、例外はスローされません。 初期化コードを記述する必要がある場合、または例外を処理する必要がある場合は、ファクトリメソッドを受け取るコンストラクターのいずれかを使用します。 ファクトリメソッドに初期化コードを記述します。  
  
 次の表は、これらの2つの要因に基づいて、選択するコンストラクターを示しています。  
  
|オブジェクトにアクセスする|初期化コードが必要ない場合 (パラメーターなしのコンストラクター)、を使用します。|初期化コードが必要な場合は、を使用します。|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|複数のスレッド|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|1つのスレッド|`isThreadSafe` を `false`に設定して <xref:System.Lazy%601.%23ctor%28System.Boolean%29> します。|`isThreadSafe` を `false`に設定して <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> します。|  
  
 ラムダ式を使用して、ファクトリメソッドを指定できます。 これにより、すべての初期化コードが1つの場所に保持されます。 ラムダ式は、遅延初期化オブジェクトのコンストラクターに渡す引数を含め、コンテキストをキャプチャします。  
  
 **例外のキャッシュ**ファクトリメソッドを使用すると、例外がキャッシュされます。 つまり、最初にスレッドが <xref:System.Lazy%601> オブジェクトの <xref:System.Lazy%601.Value%2A> プロパティにアクセスしようとしたときに、ファクトリメソッドが例外をスローした場合、以降のすべての試行で同じ例外がスローされます。 これにより、<xref:System.Lazy%601.Value%2A> プロパティへのすべての呼び出しで同じ結果が生成されるため、異なるスレッドで異なる結果が得られる場合に発生する軽度のエラーを回避できます。 <xref:System.Lazy%601> は、通常は起動時に初期化された実際の `T` を表します。 その前の時点でのエラーは、通常、致命的です。 回復可能なエラーが発生する可能性がある場合は、遅延初期化を使用していない場合と同様に、初期化ルーチン (この場合はファクトリメソッド) に再試行ロジックを作成することをお勧めします。  
  
 **ロックの代替手段**場合によっては、<xref:System.Lazy%601> オブジェクトの既定のロック動作のオーバーヘッドを回避する必要があります。 まれに、デッドロックが発生する可能性があります。 このような場合は、<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> または <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンストラクターを使用して、<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>を指定できます。 これにより、<xref:System.Lazy%601> オブジェクトは、スレッドが同時に <xref:System.Lazy%601.Value%2A> プロパティを呼び出す場合に、複数のスレッドのそれぞれに遅延初期化オブジェクトのコピーを作成できます。 <xref:System.Lazy%601> オブジェクトは、すべてのスレッドが遅延初期化オブジェクトの同じインスタンスを使用し、使用されていないインスタンスを破棄することを保証します。 したがって、ロックのオーバーヘッドを減らすコストは、プログラムが高価なオブジェクトの余分なコピーを作成して破棄することがあります。 ほとんどの場合、このことはほとんどありません。 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンストラクターと <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンストラクターの例では、この動作を示しています。  
  
> [!IMPORTANT]
>  <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>を指定した場合、ファクトリメソッドを指定しても、例外はキャッシュされません。  
  
 **同等のコンストラクター**<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>の使用を有効にするだけでなく、<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンストラクターと <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンストラクターは、他のコンストラクターの機能を複製することができます。 次の表に、同等の動作を生成するパラメーター値を示します。  
  
|<xref:System.Lazy%601> オブジェクトを作成するには|`LazyThreadSafetyMode` `mode` パラメーターを持つコンストラクターの場合は `mode` をに設定します。|ブール `isThreadSafe` パラメーターを持つコンストラクターの場合は、`isThreadSafe` をに設定します。|スレッドセーフパラメーターのないコンストラクターの場合|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|完全なスレッドセーフはロックを使用して、1つのスレッドだけが値を初期化するようにします。|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|このようなコンストラクターはすべて、完全にスレッドセーフです。|  
|スレッドセーフではありません。|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|該当なし。|  
|完全なスレッドセーフ値を初期化するスレッドの競合。|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|該当なし。|該当なし。|  
  
 **その他の機能**スレッド静的フィールドでの <xref:System.Lazy%601> の使用、またはプロパティのバッキングストアとしての使用の詳細については、「[レイジー初期化](~/docs/framework/performance/lazy-initialization.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Lazy%601> クラスを使用して、複数のスレッドからのアクセスでレイジー初期化を行う方法を示します。  
  
> [!NOTE]
>  この例では、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> コンストラクターを使用します。 また、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> コンストラクター (`isThreadSafe`の `true` を指定) と <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンストラクター (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> に `mode`を指定) の使用方法も示します。 別のコンストラクターに切り替えるには、コメントアウトするコンストラクターを変更するだけです。  
>   
>  同じコンストラクターを使用した例外キャッシュの例については、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> コンストラクターに関する説明を参照してください。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの4つの主要なセクションでは、初期化子、ファクトリメソッド、実際の初期化、およびオブジェクトの作成時にメッセージを表示する `LargeObject` クラスのコンストラクターの作成について説明します。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 ファクトリメソッドは、さらに初期化するためのプレースホルダーを使用して、オブジェクトの作成を示します。  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 次に示すように、ラムダ関数を使用すると、最初の2つのコードセクションを組み合わせることができます。  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 この例では、遅延初期化が発生する前に、不確定な期間が経過する可能性があることを示すために一時停止します。 **Enter キーを**押すと、この例では3つのスレッドを作成して開始します。 3つのすべてのスレッドで使用される `ThreadProc` メソッドは、<xref:System.Lazy%601.Value%2A> プロパティを呼び出します。 これが初めて発生したときに、`LargeObject` インスタンスが作成されます。  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 コードの最後のキーセクションを含む `LargeObject` クラスのコンストラクターは、メッセージを表示し、初期化中のスレッドの id を記録します。 プログラムからの出力は、完全なコードリストの最後に表示されます。  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>既定では、<see cref="T:System.Lazy`1" /> クラスのすべてのパブリックメンバーとプロテクトメンバーはスレッドセーフであり、複数のスレッドから同時に使用できます。 これらのスレッドセーフの保証は、必要に応じて、型のコンストラクターへのパラメーターを使用して、インスタンスごとに削除することができます。</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生した場合、ターゲットの型のパラメーターなしのコンストラクターが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して作成されたインスタンスは、複数のスレッドから同時に使用できます。  
  
 このコンストラクターを使用して初期化された <xref:System.Lazy%601> インスタンスのスレッドセーフモードは <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>です。 スレッドセーフモードでは、複数のスレッドが <xref:System.Lazy%601> インスタンスを初期化しようとしたときの動作が記述されます。  
  
 このコンストラクターを使用して作成された <xref:System.Lazy%601> インスタンスは、例外をキャッシュしません。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 このコンストラクターの使用例を次に示します。 また、<xref:System.Lazy%601.%23ctor%28System.Boolean%29> コンストラクター (`isThreadSafe`の `true` を指定) と <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンストラクター (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> に `mode`を指定) の使用方法についても説明します。 別のコンストラクターに切り替えるには、コメントアウトするコンストラクターを変更するだけです。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 この例の2つの重要なコード行は、初期化子と実際の初期化を作成することです。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 この例では、<xref:System.Threading.ManualResetEvent> オブジェクトでブロックされる3つのスレッドを作成して開始します。これにより、この例では、スレッドをすべて一度に解放できます。 すべての3つのスレッドが使用する `ThreadProc` メソッドは、<xref:System.Lazy%601.Value%2A> プロパティを呼び出して `LargeObject` インスタンスを取得します。  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 <xref:System.Lazy%601> クラスは、1つのスレッドだけが `LargeObject` インスタンスを作成できるように、ロックを提供します。 この例では、他のスレッドがすべて同じインスタンスを取得することを示しています。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">このインスタンスを複数のスレッドで同時に使用できるようにする場合は <see langword="true" />。インスタンスを一度に 1 つのスレッドでしか使用できないようにする場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生した場合、ターゲットの型のパラメーターなしのコンストラクターと指定された初期化モードが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して初期化された <xref:System.Lazy%601> インスタンスのスレッドセーフモードは、`isThreadSafe` が `true`されている場合は <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> ます。それ以外の場合、モードは <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>です。 スレッドセーフモードでは、複数のスレッドが <xref:System.Lazy%601> インスタンスを初期化しようとしたときの動作が記述されます。 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> モードを指定するには、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> または <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンストラクターを使用します。  
  
 このコンストラクターを使用して作成された <xref:System.Lazy%601> インスタンスは、例外をキャッシュしません。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、遅延初期化されたオブジェクトへのすべてのアクセスが同じスレッドで発生するシナリオについて、スレッドセーフではないレイジー初期化子を作成しています。 また、<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンストラクターの使用方法も示します (`mode`の <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> を指定します。 別のコンストラクターに切り替えるには、コメントアウトされているコンストラクターを変更するだけです。  
  
> [!NOTE]
>  このコンストラクターをマルチスレッドシナリオで使用する方法を示すコード (`isThreadSafe`の `true` を指定する) については、<xref:System.Lazy%601.%23ctor> コンストラクターの例を参照してください。  
  
 この例では、遅延して初期化される `LargeObject` クラスを定義します。 この例では、`Main` メソッドで <xref:System.Lazy%601> インスタンスを作成して一時停止します。 **Enter**キーを押すと、この例では <xref:System.Lazy%601> インスタンスの <xref:System.Lazy%601.Value%2A> プロパティにアクセスします。これにより、初期化が発生します。 `LargeObject` クラスのコンストラクターは、コンソールメッセージを表示します。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要に応じて、遅延初期化の値を生成するために呼び出されるデリゲート。</param>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生すると、指定された初期化関数が使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して作成されたインスタンスは、複数のスレッドから同時に使用できます。  
  
 このコンストラクターを使用して初期化された <xref:System.Lazy%601> インスタンスのスレッドセーフモードは <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>です。 スレッドセーフモードでは、複数のスレッドが <xref:System.Lazy%601> インスタンスを初期化しようとしたときの動作が記述されます。  
  
 `valueFactory` によってスローされる例外はキャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、例外キャッシュによるレイジー初期化を行う方法を示します。 また、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> コンストラクター (`isThreadSafe`の `true` を指定) と <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンストラクター (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> に `mode`を指定) の使用方法も示します。 別のコンストラクターに切り替えるには、コメントアウトするコンストラクターを変更するだけです。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの3つの重要なセクションでは、初期化子、実際の初期化、および `LargeObject` クラスのコンストラクターを作成して、例外のキャッシュを示します。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 この例では、3つのスレッドを作成して開始します。 すべての3つのスレッドが使用する `ThreadProc` メソッドは、<xref:System.Lazy%601.Value%2A> プロパティを呼び出して `LargeObject` インスタンスを取得します。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 `LargeObject` クラスのコンストラクターでは、コードの3番目のキーセクションは、`LargeObject` インスタンスが最初に作成されたときに例外をスローしますが、それ以降はインスタンスの作成が可能になります。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 この例を実行すると、`LargeObject` のインスタンスを作成しようとする最初のスレッドが失敗し、例外がキャッチされます。 次のスレッドによってインスタンスが正常に作成されても、<xref:System.Lazy%601> オブジェクトによって例外がキャッシュされていることが予想される場合があります。 このため、3つのすべてのスレッドが例外をスローします。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> が <see langword="null" />です。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">スレッド セーフ モードを指定する列挙値の 1 つ。</param>
        <summary><paramref name="T" /> のパラメーターなしのコンストラクターと指定されたスレッド セーフ モードを使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Lazy%601> インスタンスのスレッドセーフモードでは、複数のスレッドが <xref:System.Lazy%601> インスタンスを初期化しようとしたときの動作について説明します。  
  
 このコンストラクターを使用して作成された <xref:System.Lazy%601> インスタンスは、例外をキャッシュしません。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、複数のスレッドによるオブジェクトの作成を遅延させるレイジー初期化子を作成する方法を示します。 インスタンスの作成には複数のスレッドが成功することがありますが、すべてのスレッドは最初に作成されたインスタンスを使用します。  
  
> [!NOTE]
>  シングルスレッドシナリオでこのコンストラクターを使用する方法を示す例 (`mode`の <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> を指定する) については、<xref:System.Lazy%601.%23ctor%28System.Boolean%29> コンストラクターを参照してください。 このコンストラクターを使用して、マルチスレッドの `mode`<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> シナリオで競合状態の代わりにロックを行う方法を示す例については、「<xref:System.Lazy%601.%23ctor> コンストラクター」を参照してください。  
  
 この例では、複数のスレッドによって遅延的に初期化される `LargeObject` クラスを定義します。 コードの3つの重要なセクションは、初期化子、実際の初期化、および `LargeObject` クラスのコンストラクターとファイナライザーの作成を示しています。 `Main` メソッドの先頭で、`LargeObject`の遅延初期化を実行する <xref:System.Lazy%601> オブジェクトを作成します。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 この例では、<xref:System.Threading.ManualResetEvent> オブジェクトでブロックされる3つのスレッドを作成して開始します。これにより、この例では、スレッドをすべて一度に解放できます。 3つのすべてのスレッドで使用される `ThreadProc` メソッドでは、<xref:System.Lazy%601.Value%2A> プロパティを呼び出すと `LargeObject` インスタンスが作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>指定された <xref:System.Lazy%601> インスタンスのコンストラクターでは、3つのすべてのスレッドで `LargeObject` インスタンスを作成できます。 この例では、`LargeObject` クラスのコンストラクターとファイナライザーにコンソールメッセージを表示することによってこれを示します。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 ただし、<xref:System.Lazy%601> オブジェクトは、すべてのスレッドで使用されるインスタンスが1つだけであることを保証します。 この例の出力は、3つのすべてのスレッドが同じインスタンスを使用しており、他の2つのインスタンスがガベージコレクションによって再利用できることを示しています。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> に無効な値が含まれています。</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">使用される、事前に初期化された値。</param>
        <summary>事前に初期化され、指定された値を使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
このコンストラクターを使用して作成されたインスタンスは、複数のスレッドが同時に使用できます。
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要に応じて、遅延初期化の値を生成するために呼び出されるデリゲート。</param>
        <param name="isThreadSafe">このインスタンスを複数のスレッドで同時に使用できるようにする場合は <see langword="true" />。このインスタンスを一度に 1 つのスレッドでしか使用できないようにする場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生すると、指定された初期化関数と初期化モードが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して初期化された <xref:System.Lazy%601> インスタンスのスレッドセーフモードは、`isThreadSafe` が `true`されている場合は <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> ます。それ以外の場合、モードは <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>です。 スレッドセーフモードでは、複数のスレッドが <xref:System.Lazy%601> インスタンスを初期化しようとしたときの動作が記述されます。  
  
 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> モードを指定するには、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> または <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンストラクターを使用します。  
  
 `valueFactory` によってスローされる例外はキャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、単一のスレッドを使用するシナリオで、このコンストラクターを使用して、例外のキャッシュによるレイジー初期化を行う方法を示します。 また、<xref:System.Lazy%601.%23ctor%2A> コンストラクターの使用方法も示します (`mode`の <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> を指定します)。 このコンストラクターに切り替えるには、コメントアウトされているコンストラクターを変更するだけです。  
  
> [!NOTE]
>  このコンストラクターをマルチスレッドシナリオで使用する方法を示すコード (`isThreadSafe`の `true` を指定する) については、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> コンストラクターの例を参照してください。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの3つの重要なセクションでは、初期化子、実際の初期化、および `LargeObject` クラスのコンストラクターを作成して、例外のキャッシュを示します。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 コンストラクターの呼び出しでは、`isThreadSafe` パラメーターが `false`ため、<xref:System.Lazy%601> はスレッドセーフではありません。 この例では、スレッドセーフではないため、同じスレッドで <xref:System.Lazy%601.Value%2A> プロパティを3回呼び出します。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 `LargeObject` クラスのコンストラクターでは、コードの3番目のキーセクションは、`LargeObject` インスタンスが最初に作成されたときに例外をスローしますが、それ以降はインスタンスの作成が可能になります。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 この例を実行すると、最初に `LargeObject` のインスタンスを作成しようとして失敗し、例外がキャッチされます。 次の試行は成功したと思われるかもしれませんが、<xref:System.Lazy%601> オブジェクトによって例外がキャッシュされています。 このため、3回すべての試行で例外がスローされます。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> が <see langword="null" />です。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要に応じて、遅延初期化の値を生成するために呼び出されるデリゲート。</param>
        <param name="mode">スレッド セーフ モードを指定する列挙値の 1 つ。</param>
        <summary>指定された初期化関数とスレッド セーフ モードを使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Lazy%601> インスタンスのスレッドセーフモードでは、複数のスレッドが <xref:System.Lazy%601> インスタンスを初期化しようとしたときの動作について説明します。  
  
 `valueFactory` によってスローされる例外は、`mode` が <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>ない限りキャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、複数のスレッドによるオブジェクトの作成を遅延させるレイジー初期化子を作成する方法を示します。 インスタンスの作成には複数のスレッドが成功することがありますが、すべてのスレッドは最初に作成されたインスタンスを使用します。 また、この例では、<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>を指定しても例外がキャッシュされないことを示しています。これは、遅延作成型のパラメーターなしのコンストラクターではなく、関数によって初期化が実行される場合でも同様です。  
  
> [!NOTE]
>  シングルスレッドシナリオでこのコンストラクターを使用する方法を示す例 (`mode`の <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> を指定する) については、<xref:System.Lazy%601.%23ctor%28System.Boolean%29> コンストラクターを参照してください。 このコンストラクターを使用して、マルチスレッドの `mode`<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> シナリオで競合状態の代わりにロックを行う方法を示す例については、「<xref:System.Lazy%601.%23ctor> コンストラクター」を参照してください。  
  
 この例では、複数のスレッドによって遅延的に初期化される `LargeObject` クラスを定義します。 コードの4つのセクションでは、初期化子、実際の初期化、初期化関数、`LargeObject` クラスのコンストラクターとファイナライザーの作成について説明します。 `Main` メソッドの先頭で、`LargeObject`の遅延初期化を実行する <xref:System.Lazy%601> オブジェクトを作成します。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 レイジー初期化子は、関数を使用して初期化を実行します。 この場合、`LargeObject` クラスのパラメーターなしのコンストラクターがないため、関数が必要です。  
  
 この例では、<xref:System.Threading.ManualResetEvent> オブジェクトでブロックされる3つのスレッドを作成して開始します。これにより、この例では、スレッドをすべて一度に解放できます。 3つのすべてのスレッドで使用される `ThreadProc` メソッドでは、<xref:System.Lazy%601.Value%2A> プロパティを呼び出すと `LargeObject` インスタンスが作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 コードの3番目のキーセクションでは、遅延初期化関数を呼び出して `LargeObject` インスタンスを作成します。 関数は、初めて呼び出されたときに例外をスローします。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 その他の <xref:System.Threading.LazyThreadSafetyMode> 設定では、初期化関数でハンドルされない例外がキャッシュされます。 ただし、<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> は例外のキャッシュを抑制します。 この例の出力は、オブジェクトの初期化が成功したことを示しています。  
  
> [!NOTE]
>  通常、例外メッセージは、他のスレッドがオブジェクトを正常に初期化したことを示すメッセージの後に表示されます。 これは、例外のスローとキャッチによって発生する遅延に起因します。  
  
 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>指定された <xref:System.Lazy%601> インスタンスのコンストラクターでは、3つのすべてのスレッドで `LargeObject` インスタンスを作成できます。 この例では、`LargeObject` クラスのコンストラクターとファイナライザーにコンソールメッセージを表示することによってこれを示します。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> オブジェクトは、すべてのスレッドで使用されるインスタンスが1つだけであることを保証します (初期化関数が例外をスローするスレッドを除く)。 この例の出力はこれを示しています。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> に無効な値が含まれています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> が <see langword="null" />です。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Lazy`1" /> インスタンスに対して値が作成されているかどうかを示す値を取得します。</summary>
        <value>この <see cref="T:System.Lazy`1" /> インスタンスに対して値が作成されている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Lazy%601> インスタンスの遅延初期化が発生すると、値が作成されるか、または例外がスローされます。 例外がスローされた場合、<xref:System.Lazy%601> インスタンスの後続の動作は、例外キャッシュが有効になっているかどうかによって異なります。 初期化関数を指定していないコンストラクターを使用して <xref:System.Lazy%601> インスタンスが作成された場合、例外キャッシュは有効になりません。 後続の <xref:System.Lazy%601> の初期化は成功する可能性があり、初期化が正常に行われると、<xref:System.Lazy%601.IsValueCreated%2A> プロパティは `true`を返します。 <xref:System.Lazy%601> インスタンスが、<xref:System.Lazy%601> コンストラクターの `valueFactory` パラメーターによって指定された初期化関数を使用して作成された場合、例外キャッシュはスレッドセーフモードによって制御されます。  
  
-   モードが <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> または <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>の場合、<xref:System.Lazy%601> インスタンスを初期化する機会はもうありません。 例外が発生し、初期化関数でハンドルされない場合、その例外はキャッシュされ、<xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> プロパティの後続のアクセス時に再スローされます。 例外がスローされた場合は値が作成されないため、このような場合 <xref:System.Lazy%601.IsValueCreated%2A> は `false`を返します。  
  
-   モードが <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>場合、初期化関数 (またはパラメーターなしのコンストラクター) の実行に成功した最初のスレッドが <xref:System.Lazy%601> インスタンスの値を作成します。 初期化関数が1つのスレッドで例外をスローした場合でも、他のスレッドは <xref:System.Lazy%601> インスタンスの初期化を試みることができます。 値が作成されるまで、<xref:System.Lazy%601.IsValueCreated%2A> プロパティは `false`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの <see cref="P:System.Lazy`1.Value" /> プロパティの文字列形式を作成して返します。</summary>
        <returns>値が作成された (つまり、<see cref="M:System.Object.ToString" /> プロパティが <see langword="true" /> を返す) 場合は、このインスタンスの <see cref="P:System.Lazy`1.Value" /> プロパティに対して <see cref="P:System.Lazy`1.IsValueCreated" /> メソッドを呼び出した結果。 それ以外の場合は、値が作成されていないことを示す文字列です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すと、初期化は行われません。  
  
 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>、または <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> コンストラクターの `valueFactory` パラメーターに指定されたファクトリメソッドが `null`を返す場合は、遅延初期化後に <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> プロパティを `null` できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><see cref="P:System.Lazy`1.Value" /> プロパティが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Lazy`1" /> インスタンスの遅延初期化された値を取得します。</summary>
        <value>現在の <see cref="T:System.Lazy`1" /> インスタンスの遅れて初期化される値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> プロパティが `false`の場合、<xref:System.Lazy%601.Value%2A> プロパティにアクセスすると、強制的に初期化されます。  
  
 <xref:System.Lazy%601.Value%2A> プロパティは、一覧表示されている例外に加えて、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>、または <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> コンストラクターの `valueFactory` パラメーターに渡されたファクトリメソッドによってスローされた未処理の例外をスローできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><see cref="T:System.Lazy`1" /> インスタンスは、遅延初期化されている型のパラメーターなしのコンストラクターを使用して初期化されており、コンストラクターに対するアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMemberException"><see cref="T:System.Lazy`1" /> インスタンスは、遅延初期化されている型のパラメーターなしのコンストラクターを使用して初期化されており、この型にはパブリックのパラメーターのないコンストラクターがありません。</exception>
        <exception cref="T:System.InvalidOperationException">初期化関数はこのインスタンスの <see cref="P:System.Lazy`1.Value" /> にアクセスしようとします。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
  </Members>
</Type>
