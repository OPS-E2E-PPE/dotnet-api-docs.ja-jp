<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1cbaac51e2d67a2a333fc68e2a9e671bf8377ab9" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73400008" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="4116d-101">アプリケーションの実行中に発生したエラーを表します。</span><span class="sxs-lookup"><span data-stu-id="4116d-101">Represents errors that occur during application execution.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-102">このクラスは、すべての例外の基本クラスです。</span><span class="sxs-lookup"><span data-stu-id="4116d-102">This class is the base class for all exceptions.</span></span> <span data-ttu-id="4116d-103">エラーが発生した場合、システムまたは現在実行中のアプリケーションは、エラーに関する情報を含む例外をスローすることによって、エラーを報告します。</span><span class="sxs-lookup"><span data-stu-id="4116d-103">When an error occurs, either the system or the currently executing application reports it by throwing an exception that contains information about the error.</span></span> <span data-ttu-id="4116d-104">例外がスローされた後は、アプリケーションまたは既定の例外ハンドラーによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-104">After an exception is thrown, it is handled by the application or by the default exception handler.</span></span>  
  
 <span data-ttu-id="4116d-105">このセクションの内容:</span><span class="sxs-lookup"><span data-stu-id="4116d-105">In this section:</span></span>  
  
 <span data-ttu-id="4116d-106">[エラーと例外](#Errors) </span><span class="sxs-lookup"><span data-stu-id="4116d-106">[Errors and exceptions](#Errors) </span></span>  
 <span data-ttu-id="4116d-107">[Try/catch ブロック](#TryCatch) </span><span class="sxs-lookup"><span data-stu-id="4116d-107">[Try/catch blocks](#TryCatch) </span></span>  
 <span data-ttu-id="4116d-108">[例外の種類の機能](#Features) </span><span class="sxs-lookup"><span data-stu-id="4116d-108">[Exception type features](#Features) </span></span>  
 <span data-ttu-id="4116d-109">[Exception クラスのプロパティ](#Properties) </span><span class="sxs-lookup"><span data-stu-id="4116d-109">[Exception class properties](#Properties) </span></span>  
 <span data-ttu-id="4116d-110">[パフォーマンスに関する考慮事項](#Performance) </span><span class="sxs-lookup"><span data-stu-id="4116d-110">[Performance considerations](#Performance) </span></span>  
 <span data-ttu-id="4116d-111">[例外を再スロー](#Rethrow) </span><span class="sxs-lookup"><span data-stu-id="4116d-111">[Re-throwing an exception](#Rethrow) </span></span>  
 <span data-ttu-id="4116d-112">[標準例外の選択](#Standard) </span><span class="sxs-lookup"><span data-stu-id="4116d-112">[Choosing standard exceptions](#Standard) </span></span>  
 [<span data-ttu-id="4116d-113">カスタム例外の実装</span><span class="sxs-lookup"><span data-stu-id="4116d-113">Implementing custom exceptions</span></span>](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a><span data-ttu-id="4116d-114">エラーと例外</span><span class="sxs-lookup"><span data-stu-id="4116d-114">Errors and exceptions</span></span>  
 <span data-ttu-id="4116d-115">実行時エラーは、さまざまな理由で発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-115">Run-time errors can occur for a variety of reasons.</span></span> <span data-ttu-id="4116d-116">ただし、すべてのエラーをコード内で例外として処理する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="4116d-116">However, not all errors should be handled as exceptions in your code.</span></span> <span data-ttu-id="4116d-117">ここでは、実行時に発生する可能性があるエラーのカテゴリと、それらに対処するための適切な方法を示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-117">Here are some categories of errors that can occur at run time and the appropriate ways to respond to them.</span></span>  
  
-   <span data-ttu-id="4116d-118">**使用エラー。**</span><span class="sxs-lookup"><span data-stu-id="4116d-118">**Usage errors.**</span></span> <span data-ttu-id="4116d-119">使用エラーは、例外が発生する可能性があるプログラムロジックのエラーを表します。</span><span class="sxs-lookup"><span data-stu-id="4116d-119">A usage error represents an error in program logic that can result in an exception.</span></span> <span data-ttu-id="4116d-120">ただし、エラーは例外処理ではなく、問題のあるコードを変更することによって対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-120">However, the error should be addressed not through exception handling but by modifying the faulty code.</span></span> <span data-ttu-id="4116d-121">たとえば、次の例の <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドのオーバーライドは、`obj` 引数が常に null 以外である必要があることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="4116d-121">For example, the override of the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method in the following example assumes that the `obj` argument must always be non-null.</span></span>  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <span data-ttu-id="4116d-122">`obj` が `null` 場合に結果として生成される <xref:System.NullReferenceException> 例外は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> のオーバーライドを呼び出して再コンパイルする前に、null を明示的にテストするようにソースコードを変更することで排除できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-122">The <xref:System.NullReferenceException> exception that results when `obj` is `null` can be eliminated by modifying the source code to explicitly test for null before calling the <xref:System.Object.Equals%2A?displayProperty=nameWithType> override and then re-compiling.</span></span> <span data-ttu-id="4116d-123">次の例には、`null` の引数を処理する、修正されたソースコードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="4116d-123">The following example contains the corrected source code that handles a `null` argument.</span></span>  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     <span data-ttu-id="4116d-124">使用エラーに対して例外処理を使用する代わりに、<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> メソッドを使用してデバッグビルドの使用エラーを識別し、<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> メソッドを使用してデバッグビルドとリリースビルドの両方で使用エラーを識別できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-124">Instead of using exception handling for usage errors, you can use the <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> method to identify usage errors in debug builds, and the <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> method to identify usage errors in both debug and release builds.</span></span> <span data-ttu-id="4116d-125">詳細については、「[マネージド コードのアサーション](/visualstudio/debugger/assertions-in-managed-code)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-125">For more information, see [Assertions in Managed Code](/visualstudio/debugger/assertions-in-managed-code).</span></span>  
  
-   <span data-ttu-id="4116d-126">**プログラムエラーです。**</span><span class="sxs-lookup"><span data-stu-id="4116d-126">**Program errors.**</span></span> <span data-ttu-id="4116d-127">プログラムエラーは、バグのないコードを記述することによって必ずしも回避できないランタイムエラーです。</span><span class="sxs-lookup"><span data-stu-id="4116d-127">A program error is a run-time error that cannot necessarily be avoided by writing bug-free code.</span></span>  
  
     <span data-ttu-id="4116d-128">場合によっては、プログラムエラーによって予期されるエラー条件またはルーチンエラーが反映されることがあります。</span><span class="sxs-lookup"><span data-stu-id="4116d-128">In some cases, a program error may reflect an expected or routine error condition.</span></span> <span data-ttu-id="4116d-129">この場合、プログラムエラーに対処するために例外処理を使用せずに、操作を再試行することができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-129">In this case, you may want to avoid using exception handling to deal with the program error and instead retry the operation.</span></span> <span data-ttu-id="4116d-130">たとえば、ユーザーが特定の形式で日付を入力することが想定されている場合、<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> メソッドを呼び出すことによって日付文字列を解析できます。このメソッドは、<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> メソッドを使用する代わりに、解析操作が成功したかどうかを示す <xref:System.Boolean> 値を返します。日付文字列を <xref:System.DateTime> 値に変換できない場合に <xref:System.FormatException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-130">For example, if the user is expected to input a date in a particular format, you can parse the date string by calling the <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> method, which returns a <xref:System.Boolean> value that indicates whether the parse operation succeeded, instead of using the <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> method, which throws a <xref:System.FormatException> exception if the date string cannot be converted to a <xref:System.DateTime> value.</span></span> <span data-ttu-id="4116d-131">同様に、存在しないファイルを開こうとした場合は、最初に <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> メソッドを呼び出して、ファイルが存在するかどうかを確認し、存在しない場合は、ユーザーに作成を希望するかどうかを確認するメッセージを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-131">Similarly, if a user tries to open a file that does not exist, you can first call the <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> method to check whether the file exists and, if it does not, prompt the user whether he or she wants to create it.</span></span>  
  
     <span data-ttu-id="4116d-132">それ以外の場合、プログラムエラーには、コードで処理できる予期しないエラー状態が反映されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-132">In other cases, a program error reflects an unexpected error condition that can be handled in your code.</span></span> <span data-ttu-id="4116d-133">たとえば、ファイルが存在することを確認した場合でも、ファイルを開く前に削除するか、破損している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-133">For example, even if you've checked to ensure that a file exists, it may be deleted before you can open it, or it may be corrupted.</span></span> <span data-ttu-id="4116d-134">この場合、<xref:System.IO.StreamReader> オブジェクトをインスタンス化するか、<xref:System.IO.File.Open%2A> メソッドを呼び出すことによってファイルを開こうとすると、<xref:System.IO.FileNotFoundException> 例外がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-134">In that case, trying to open the file by instantiating a <xref:System.IO.StreamReader> object or calling the <xref:System.IO.File.Open%2A> method may throw a <xref:System.IO.FileNotFoundException> exception.</span></span> <span data-ttu-id="4116d-135">このような場合は、例外処理を使用してエラーから復旧する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-135">In these cases, you should use exception handling to recover from the error.</span></span>  
  
-   <span data-ttu-id="4116d-136">**システムエラー。**</span><span class="sxs-lookup"><span data-stu-id="4116d-136">**System failures.**</span></span> <span data-ttu-id="4116d-137">システム障害は、プログラムによって意味のない方法で処理できない実行時エラーです。</span><span class="sxs-lookup"><span data-stu-id="4116d-137">A system failure is a run-time error that cannot be handled programmatically in a meaningful way.</span></span> <span data-ttu-id="4116d-138">たとえば、共通言語ランタイムが追加のメモリを割り当てられない場合、どのメソッドでも <xref:System.OutOfMemoryException> 例外がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-138">For example, any method can throw an <xref:System.OutOfMemoryException> exception if the common language runtime is unable to allocate additional memory.</span></span> <span data-ttu-id="4116d-139">通常、システム障害は例外処理を使用しても処理されません。</span><span class="sxs-lookup"><span data-stu-id="4116d-139">Ordinarily, system failures are not handled by using exception handling.</span></span> <span data-ttu-id="4116d-140">代わりに、<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> などのイベントを使用して、<xref:System.Environment.FailFast%2A?displayProperty=nameWithType> メソッドを呼び出して例外情報をログに記録し、アプリケーションが終了する前にエラーをユーザーに通知することができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-140">Instead, you may be able to use an event such as <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> and call the <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> method to log exception information and notify the user of the failure before the application terminates.</span></span>  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a><span data-ttu-id="4116d-141">Try ブロックと catch ブロック</span><span class="sxs-lookup"><span data-stu-id="4116d-141">Try/catch blocks</span></span>  
 <span data-ttu-id="4116d-142">共通言語ランタイムは、例外をオブジェクトとして表現し、プログラムコードと例外処理コードを `try` ブロックと `catch` ブロックに分離することに基づいて、例外処理モデルを提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-142">The common language runtime provides an exception handling model that is based on the representation of exceptions as objects, and the separation of program code and exception handling code into `try` blocks and `catch` blocks.</span></span> <span data-ttu-id="4116d-143">1つまたは複数の `catch` ブロックがあり、それぞれが特定の種類の例外を処理するように設計されています。または、別のブロックよりも具体的な例外をキャッチするように設計された1つのブロックを指定できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-143">There can be one or more `catch` blocks, each designed to handle a particular type of exception, or one block designed to catch a more specific exception than another block.</span></span>  
  
 <span data-ttu-id="4116d-144">アプリケーションコードのブロックの実行中に発生した例外をアプリケーションが処理する場合は、コードを `try` ステートメント内に配置し、`try` ブロックと呼ばれる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-144">If an application handles exceptions that occur during the execution of a block of application code, the code must be placed within a `try` statement and is called a `try` block.</span></span> <span data-ttu-id="4116d-145">`try` ブロックによってスローされた例外を処理するアプリケーションコードは、`catch` ステートメント内に配置され、`catch` ブロックと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="4116d-145">Application code that handles exceptions thrown by a `try` block is placed within a `catch` statement and is called a `catch` block.</span></span> <span data-ttu-id="4116d-146">0個以上の `catch` ブロックが `try` ブロックに関連付けられており、各 `catch` ブロックには、処理する例外の種類を決定する型フィルターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="4116d-146">Zero or more `catch` blocks are associated with a `try` block, and each `catch` block includes a type filter that determines the types of exceptions it handles.</span></span>  
  
 <span data-ttu-id="4116d-147">`try` ブロックで例外が発生すると、システムは、例外を処理する `catch` ブロックを見つけるまで、関連付けられている `catch` ブロックをアプリケーションコードに出現する順序で検索します。</span><span class="sxs-lookup"><span data-stu-id="4116d-147">When an exception occurs in a `try` block, the system searches the associated `catch` blocks in the order they appear in application code, until it locates a `catch` block that handles the exception.</span></span> <span data-ttu-id="4116d-148">Catch ブロックの型フィルターで `T` またはその派生元で `T` あるすべての型が指定されている場合、`catch` ブロックは型 `T` の例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="4116d-148">A `catch` block handles an exception of type `T` if the type filter of the catch block specifies `T` or any type that `T` derives from.</span></span> <span data-ttu-id="4116d-149">例外を処理する最初の `catch` ブロックが検出されると、システムは検索を停止します。</span><span class="sxs-lookup"><span data-stu-id="4116d-149">The system stops searching after it finds the first `catch` block that handles the exception.</span></span> <span data-ttu-id="4116d-150">このため、アプリケーションコードでは、このセクションの後の例に示すように、型を処理する `catch` ブロックを、その基本型を処理する `catch` ブロックの前に指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-150">For this reason, in application code, a `catch` block that handles a type must be specified before a `catch` block that handles its base types, as demonstrated in the example that follows this section.</span></span> <span data-ttu-id="4116d-151">`System.Exception` を処理する catch ブロックが最後に指定されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-151">A catch block that handles `System.Exception` is specified last.</span></span>  
  
 <span data-ttu-id="4116d-152">現在の `try` ブロックに関連付けられている `catch` ブロックで例外がハンドルされず、現在の `try` ブロックが現在の呼び出しの他の `try` ブロック内に入れ子になっている場合は、次に外側にある `catch` ブロックに関連付けられている `try` ブロック。検索されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-152">If none of the `catch` blocks associated with the current `try` block handle the exception, and the current `try` block is nested within other `try` blocks in the current call, the `catch` blocks associated with the next enclosing `try` block are searched.</span></span> <span data-ttu-id="4116d-153">例外の `catch` ブロックが見つからない場合は、現在の呼び出しで前の入れ子レベルが検索されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-153">If no `catch` block for the exception is found, the system searches previous nesting levels in the current call.</span></span> <span data-ttu-id="4116d-154">現在の呼び出しで例外の `catch` ブロックが見つからない場合は、例外が呼び出し履歴に渡され、例外を処理する `catch` ブロックの前のスタックフレームが検索されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-154">If no `catch` block for the exception is found in the current call, the exception is passed up the call stack, and the previous stack frame is searched for a `catch` block that handles the exception.</span></span> <span data-ttu-id="4116d-155">呼び出し履歴の検索は、例外が処理されるか、または呼び出し履歴にフレームが存在しなくなるまで続行されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-155">The search of the call stack continues until the exception is handled or until no more frames exist on the call stack.</span></span> <span data-ttu-id="4116d-156">例外を処理する `catch` ブロックを検出せずにコールスタックの一番上に到達した場合、既定の例外ハンドラーはそれを処理してアプリケーションを終了します。</span><span class="sxs-lookup"><span data-stu-id="4116d-156">If the top of the call stack is reached without finding a `catch` block that handles the exception, the default exception handler handles it and the application terminates.</span></span>  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a><span data-ttu-id="4116d-157">例外の種類の機能</span><span class="sxs-lookup"><span data-stu-id="4116d-157">Exception type features</span></span>  
 <span data-ttu-id="4116d-158">例外の種類では、次の機能がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-158">Exception types support the following features:</span></span>  
  
-   <span data-ttu-id="4116d-159">人間が判読できる、エラーを説明するテキスト。</span><span class="sxs-lookup"><span data-stu-id="4116d-159">Human-readable text that describes the error.</span></span> <span data-ttu-id="4116d-160">例外が発生すると、ランタイムは、エラーの性質をユーザーに通知し、問題を解決するためのアクションを提案するためのテキストメッセージを使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="4116d-160">When an exception occurs, the runtime makes a text message available to inform the user of the nature of the error and to suggest action to resolve the problem.</span></span> <span data-ttu-id="4116d-161">このテキストメッセージは、exception オブジェクトの <xref:System.Exception.Message%2A> プロパティに保持されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-161">This text message is held in the <xref:System.Exception.Message%2A> property of the exception object.</span></span> <span data-ttu-id="4116d-162">例外オブジェクトの作成時に、その特定の例外の詳細を記述するテキスト文字列をコンストラクターに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-162">During the creation of the exception object, you can pass a text string to the constructor to describe the details of that particular exception.</span></span> <span data-ttu-id="4116d-163">コンストラクターにエラーメッセージ引数が指定されていない場合は、既定のエラーメッセージが使用されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-163">If no error message argument is supplied to the constructor, the default error message is used.</span></span> <span data-ttu-id="4116d-164">詳細については、<xref:System.Exception.Message%2A> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-164">For more information, see the <xref:System.Exception.Message%2A> property.</span></span>  
  
-   <span data-ttu-id="4116d-165">例外がスローされたときの呼び出し履歴の状態。</span><span class="sxs-lookup"><span data-stu-id="4116d-165">The state of the call stack when the exception was thrown.</span></span> <span data-ttu-id="4116d-166"><xref:System.Exception.StackTrace%2A> プロパティには、コード内でエラーが発生した場所を判断するために使用できるスタックトレースが含まれています。</span><span class="sxs-lookup"><span data-stu-id="4116d-166">The <xref:System.Exception.StackTrace%2A> property carries a stack trace that can be used to determine where the error occurs in the code.</span></span> <span data-ttu-id="4116d-167">スタックトレースでは、呼び出されたすべてのメソッドと、呼び出しが行われたソースファイル内の行番号が一覧表示されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-167">The stack trace lists all the called methods and the line numbers in the source file where the calls are made.</span></span>  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a><span data-ttu-id="4116d-168">Exception クラスのプロパティ</span><span class="sxs-lookup"><span data-stu-id="4116d-168">Exception class properties</span></span>  
 <span data-ttu-id="4116d-169"><xref:System.Exception> クラスには、コードの場所、種類、ヘルプファイル、例外の理由 (<xref:System.Exception.StackTrace%2A>、<xref:System.Exception.InnerException%2A>、<xref:System.Exception.Message%2A>、<xref:System.Exception.HelpLink%2A>、<xref:System.Exception.HResult%2A>、<xref:System.Exception.Source%2A>、<xref:System.Exception.TargetSite%2A>) を識別するためのプロパティが多数含まれています。、、および <xref:System.Exception.Data%2A>ます。</span><span class="sxs-lookup"><span data-stu-id="4116d-169">The <xref:System.Exception> class includes a number of properties that help identify the code location, the type, the help file, and the reason for the exception: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, and <xref:System.Exception.Data%2A>.</span></span>  
  
 <span data-ttu-id="4116d-170">2つ以上の例外の間に因果関係が存在する場合、<xref:System.Exception.InnerException%2A> プロパティはこの情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="4116d-170">When a causal relationship exists between two or more exceptions, the <xref:System.Exception.InnerException%2A> property maintains this information.</span></span> <span data-ttu-id="4116d-171">外側の例外は、この内部例外に応答してスローされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-171">The outer exception is thrown in response to this inner exception.</span></span> <span data-ttu-id="4116d-172">外側の例外を処理するコードでは、前の内部例外の情報を使用して、エラーをより適切に処理できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-172">The code that handles the outer exception can use the information from the earlier inner exception to handle the error more appropriately.</span></span> <span data-ttu-id="4116d-173">例外に関する補足情報は、<xref:System.Exception.Data%2A> プロパティにキーと値のペアのコレクションとして格納できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-173">Supplementary information about the exception can be stored as a collection of key/value pairs in the <xref:System.Exception.Data%2A> property.</span></span>  
  
 <span data-ttu-id="4116d-174">例外オブジェクトの作成時にコンストラクターに渡されるエラーメッセージ文字列はローカライズされ、<xref:System.Resources.ResourceManager> クラスを使用してリソースファイルから渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-174">The error message string that is passed to the constructor during the creation of the exception object should be localized and can be supplied from a resource file by using the <xref:System.Resources.ResourceManager> class.</span></span> <span data-ttu-id="4116d-175">ローカライズされたリソースの詳細については、「[サテライトアセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)」および「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」のトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-175">For more information about localized resources, see the [Creating Satellite Assemblies](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) and [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) topics.</span></span>  
  
 <span data-ttu-id="4116d-176">例外が発生した理由に関する詳細情報をユーザーに提供するために、<xref:System.Exception.HelpLink%2A> プロパティは、ヘルプファイルへの URL (または URN) を保持できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-176">To provide the user with extensive information about why the exception occurred, the <xref:System.Exception.HelpLink%2A> property can hold a URL (or URN) to a help file.</span></span>  
  
 <span data-ttu-id="4116d-177"><xref:System.Exception> クラスでは、値0x80131500 を持つ HRESULT COR_E_EXCEPTION を使用します。</span><span class="sxs-lookup"><span data-stu-id="4116d-177">The <xref:System.Exception> class uses the HRESULT COR_E_EXCEPTION, which has the value 0x80131500.</span></span>  
  
 <span data-ttu-id="4116d-178"><xref:System.Exception> クラスのインスタンスの初期プロパティ値の一覧については、「<xref:System.Exception.%23ctor%2A> コンストラクター」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-178">For a list of initial property values for an instance of the <xref:System.Exception> class, see the <xref:System.Exception.%23ctor%2A> constructors.</span></span>  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a><span data-ttu-id="4116d-179">パフォーマンスに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="4116d-179">Performance considerations</span></span>  
 <span data-ttu-id="4116d-180">例外をスローまたは処理すると、大量のシステムリソースと実行時間が消費されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-180">Throwing or handling an exception consumes a significant amount of system resources and execution time.</span></span> <span data-ttu-id="4116d-181">例外をスローするのは、予測可能なイベントやフロー制御を処理するのではなく、本当に特別な条件を処理する場合のみです。</span><span class="sxs-lookup"><span data-stu-id="4116d-181">Throw exceptions only to handle truly extraordinary conditions, not to handle predictable events or flow control.</span></span> <span data-ttu-id="4116d-182">たとえば、クラスライブラリを開発している場合など、メソッドの引数が無効である場合は例外をスローすることが妥当です。有効なパラメーターを使用してメソッドを呼び出すことが想定されているためです。</span><span class="sxs-lookup"><span data-stu-id="4116d-182">For example, in some cases, such as when you're developing a class library, it's reasonable to throw an exception if a method argument is invalid, because you expect your method to be called with valid parameters.</span></span> <span data-ttu-id="4116d-183">無効なメソッド引数が使用エラーの結果でない場合は、異常が発生したことを意味します。</span><span class="sxs-lookup"><span data-stu-id="4116d-183">An invalid method argument, if it is not the result of a usage error, means that something extraordinary has occurred.</span></span> <span data-ttu-id="4116d-184">逆に、ユーザーの入力が無効な場合は、ユーザーが無効なデータを頻繁に入力することが予想されるため、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="4116d-184">Conversely, do not throw an exception if user input is invalid, because you can expect users to occasionally enter invalid data.</span></span> <span data-ttu-id="4116d-185">代わりに、ユーザーが有効な入力を入力できるように再試行メカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-185">Instead, provide a retry mechanism so users can enter valid input.</span></span> <span data-ttu-id="4116d-186">また、例外を使用して使用エラーを処理する必要もありません。</span><span class="sxs-lookup"><span data-stu-id="4116d-186">Nor should you use exceptions to handle usage errors.</span></span> <span data-ttu-id="4116d-187">代わりに、[アサーション](/visualstudio/debugger/assertions-in-managed-code)を使用して、使用エラーを特定し、修正します。</span><span class="sxs-lookup"><span data-stu-id="4116d-187">Instead, use [assertions](/visualstudio/debugger/assertions-in-managed-code) to identify and correct usage errors.</span></span>  
  
 <span data-ttu-id="4116d-188">また、リターンコードが十分である場合は、例外をスローしないでください。リターンコードを例外に変換しないでください。また、例外を定期的にキャッチせず、無視して処理を続行することもありません。</span><span class="sxs-lookup"><span data-stu-id="4116d-188">In addition, do not throw an exception when a return code is sufficient; do not convert a return code to an exception; and do not routinely catch an exception, ignore it, and then continue processing.</span></span>  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a><span data-ttu-id="4116d-189">例外の再スロー</span><span class="sxs-lookup"><span data-stu-id="4116d-189">Re-throwing an exception</span></span>  
 <span data-ttu-id="4116d-190">多くの場合、例外ハンドラーは、例外を呼び出し元に渡すだけです。</span><span class="sxs-lookup"><span data-stu-id="4116d-190">In many cases, an exception handler simply wants to pass the exception on to the caller.</span></span> <span data-ttu-id="4116d-191">これは、最も頻繁に発生します。</span><span class="sxs-lookup"><span data-stu-id="4116d-191">This most often occurs in:</span></span>  
  
-   <span data-ttu-id="4116d-192">さらに、クラスライブラリは、.NET Framework クラスライブラリまたはその他のクラスライブラリのメソッドの呼び出しをラップします。</span><span class="sxs-lookup"><span data-stu-id="4116d-192">A class library that in turn wraps calls to methods in the .NET Framework class library or other class libraries.</span></span>  
  
-   <span data-ttu-id="4116d-193">致命的な例外が発生したアプリケーションまたはライブラリ。</span><span class="sxs-lookup"><span data-stu-id="4116d-193">An application or library that encounters a fatal exception.</span></span> <span data-ttu-id="4116d-194">例外ハンドラーは例外をログに記録し、例外を再スローすることができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-194">The exception handler can log the exception and then re-throw the exception.</span></span>  
  
 <span data-ttu-id="4116d-195">例外を再スローするには、のC# [throw](~/docs/csharp/language-reference/keywords/throw.md)ステートメントと、式を含まない Visual Basic の[throw](~/docs/visual-basic/language-reference/statements/throw-statement.md)ステートメントを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4116d-195">The recommended way to re-throw an exception is to simply use the [throw](~/docs/csharp/language-reference/keywords/throw.md) statement in C# and the [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) statement in Visual Basic without including an expression.</span></span> <span data-ttu-id="4116d-196">これにより、例外が呼び出し元に反映されるときに、すべてのコールスタック情報が保持されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-196">This ensures that all call stack information is preserved when the exception is propagated to the caller.</span></span> <span data-ttu-id="4116d-197">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-197">The following example illustrates this.</span></span> <span data-ttu-id="4116d-198">文字列の拡張メソッド `FindOccurrences`は、引数を事前に検証せずに、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> の1つ以上の呼び出しをラップします。</span><span class="sxs-lookup"><span data-stu-id="4116d-198">A string extension method, `FindOccurrences`, wraps one or more calls to <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> without validating its arguments beforehand.</span></span>  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 <span data-ttu-id="4116d-199">その後、呼び出し元は `FindOccurrences` を2回呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4116d-199">A caller then calls `FindOccurrences` twice.</span></span> <span data-ttu-id="4116d-200">`FindOccurrences`の2回目の呼び出しでは、呼び出し元は検索文字列として `null` を渡します。この場合、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> メソッドは <xref:System.ArgumentNullException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-200">In the second call to `FindOccurrences`, the caller passes a `null` as the search string, which cases the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> method to throw an <xref:System.ArgumentNullException> exception.</span></span> <span data-ttu-id="4116d-201">この例外は、`FindOccurrences` メソッドによって処理され、呼び出し元に渡されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-201">This exception is handled by the `FindOccurrences` method and passed back to the caller.</span></span> <span data-ttu-id="4116d-202">Throw ステートメントは式なしで使用されるため、この例の出力は、呼び出し履歴が保持されていることを示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-202">Because the throw statement is used with no expression, the output from the example shows that the call stack is preserved.</span></span>  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 <span data-ttu-id="4116d-203">これに対し、を使用して例外が再スローされる場合は、</span><span class="sxs-lookup"><span data-stu-id="4116d-203">In contrast, if the exception is re-thrown by using the</span></span>  
  
```csharp
throw e;
```  
  
```vb  
Throw e  
```  
  
 <span data-ttu-id="4116d-204">ステートメント、完全な呼び出し履歴は保持されず、例では次の出力が生成されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-204">statement, the full call stack is not preserved, and the example would generate the following output:</span></span>  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 <span data-ttu-id="4116d-205">もう少し厄介な方法は、新しい例外をスローし、元の例外の呼び出し履歴情報を内部例外で保持することです。</span><span class="sxs-lookup"><span data-stu-id="4116d-205">A slightly more cumbersome alternative is to throw a new exception, and to preserve the original exception's call stack information in an inner exception.</span></span> <span data-ttu-id="4116d-206">呼び出し元は、新しい例外の <xref:System.Exception.InnerException%2A> プロパティを使用して、元の例外に関するスタックフレームやその他の情報を取得できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-206">The caller can then use the new exception's <xref:System.Exception.InnerException%2A> property to retrieve stack frame and other information about the original exception.</span></span> <span data-ttu-id="4116d-207">この場合、throw ステートメントは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="4116d-207">In this case, the throw statement is:</span></span>  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 <span data-ttu-id="4116d-208">次の例外ハンドラーに示すように、例外を処理するユーザーコードは、<xref:System.Exception.InnerException%2A> プロパティに元の例外に関する情報が含まれていることを認識している必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-208">The user code that handles the exception has to know that the <xref:System.Exception.InnerException%2A> property contains information about the original exception, as the following exception handler illustrates.</span></span>  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a><span data-ttu-id="4116d-209">標準例外の選択</span><span class="sxs-lookup"><span data-stu-id="4116d-209">Choosing standard exceptions</span></span>  
 <span data-ttu-id="4116d-210">例外をスローする必要がある場合は、カスタム例外を実装するのではなく、.NET Framework で既存の例外の種類を使用することがよくあります。</span><span class="sxs-lookup"><span data-stu-id="4116d-210">When you have to throw an exception, you can often use an existing exception type in the .NET Framework instead of implementing a custom exception.</span></span> <span data-ttu-id="4116d-211">次の2つの条件下では、標準の例外の種類を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-211">You should use a standard exception type under these two conditions:</span></span>  
  
-   <span data-ttu-id="4116d-212">使用エラー (つまり、メソッドを呼び出している開発者によって作成されたプログラムロジックのエラー) によって発生した例外をスローしています。</span><span class="sxs-lookup"><span data-stu-id="4116d-212">You are throwing an exception that is caused by a usage error (that is, by an error in program logic made by the developer who is calling your method).</span></span> <span data-ttu-id="4116d-213">通常は、<xref:System.ArgumentException>、<xref:System.ArgumentNullException>、<xref:System.InvalidOperationException>、<xref:System.NotSupportedException>などの例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-213">Typically, you would throw an exception such as <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, or <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="4116d-214">例外オブジェクトをインスタンス化するときに例外オブジェクトのコンストラクターに渡す文字列は、開発者が修正できるようにエラーを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-214">The string you supply to the exception object's constructor when instantiating the exception object should describe the error so that the developer can fix it.</span></span> <span data-ttu-id="4116d-215">詳細については、<xref:System.Exception.Message%2A> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-215">For more information, see the <xref:System.Exception.Message%2A> property.</span></span>  
  
-   <span data-ttu-id="4116d-216">既存の .NET Framework 例外を使用して呼び出し元に伝達できるエラーを処理しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-216">You are handling an error that can be communicated to the caller with an existing .NET Framework exception.</span></span> <span data-ttu-id="4116d-217">できるだけ多くの派生された例外をスローする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-217">You should throw the most derived exception possible.</span></span> <span data-ttu-id="4116d-218">たとえば、メソッドで引数が列挙型の有効なメンバーである必要がある場合は、<xref:System.ArgumentException>ではなく <xref:System.ComponentModel.InvalidEnumArgumentException> (最も派生クラス) をスローする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-218">For example, if a method requires an argument to be a valid member of an enumeration type, you should throw an <xref:System.ComponentModel.InvalidEnumArgumentException> (the most derived class) rather than an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="4116d-219">次の表に、一般的な例外の種類と、それらをスローする条件を示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-219">The following table lists common exception types and the conditions under which you would throw them.</span></span>  
  
|<span data-ttu-id="4116d-220">例外</span><span class="sxs-lookup"><span data-stu-id="4116d-220">Exception</span></span>|<span data-ttu-id="4116d-221">条件</span><span class="sxs-lookup"><span data-stu-id="4116d-221">Condition</span></span>|  
|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="4116d-222">メソッドに渡された null 以外の引数が無効です。</span><span class="sxs-lookup"><span data-stu-id="4116d-222">A non-null argument that is passed to a method is invalid.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="4116d-223">メソッドに渡される引数が `null`ます。</span><span class="sxs-lookup"><span data-stu-id="4116d-223">An argument that is passed to a method is `null`.</span></span>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="4116d-224">引数が有効な値の範囲外です。</span><span class="sxs-lookup"><span data-stu-id="4116d-224">An argument is outside the range of valid values.</span></span>|  
|<xref:System.IO.DirectoryNotFoundException>|<span data-ttu-id="4116d-225">ディレクトリパスの一部が無効です。</span><span class="sxs-lookup"><span data-stu-id="4116d-225">Part of a directory path is not valid.</span></span>|  
|<xref:System.DivideByZeroException>|<span data-ttu-id="4116d-226">整数または <xref:System.Decimal> 除算演算の分母が0です。</span><span class="sxs-lookup"><span data-stu-id="4116d-226">The denominator in an integer or <xref:System.Decimal> division operation is zero.</span></span>|  
|<xref:System.IO.DriveNotFoundException>|<span data-ttu-id="4116d-227">ドライブが使用できないか、または存在しません。</span><span class="sxs-lookup"><span data-stu-id="4116d-227">A drive is unavailable or does not exist.</span></span>|  
|<xref:System.IO.FileNotFoundException>|<span data-ttu-id="4116d-228">ファイルが存在しません。</span><span class="sxs-lookup"><span data-stu-id="4116d-228">A file does not exist.</span></span>|  
|<xref:System.FormatException>|<span data-ttu-id="4116d-229">値が、`Parse`などの変換メソッドによって文字列から変換される適切な形式ではありません。</span><span class="sxs-lookup"><span data-stu-id="4116d-229">A value is not in an appropriate format to be converted from a string by a conversion method such as `Parse`.</span></span>|  
|<xref:System.IndexOutOfRangeException>|<span data-ttu-id="4116d-230">インデックスが配列またはコレクションの範囲外です。</span><span class="sxs-lookup"><span data-stu-id="4116d-230">An index is outside the bounds of an array or collection.</span></span>|  
|<xref:System.InvalidOperationException>|<span data-ttu-id="4116d-231">メソッドの呼び出しは、オブジェクトの現在の状態では無効です。</span><span class="sxs-lookup"><span data-stu-id="4116d-231">A method call is invalid in an object's current state.</span></span>|  
|<xref:System.Collections.Generic.KeyNotFoundException>|<span data-ttu-id="4116d-232">コレクション内のメンバーにアクセスするために指定されたキーが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="4116d-232">The specified key for accessing a member in a collection cannot be found.</span></span>|  
|<xref:System.NotImplementedException>|<span data-ttu-id="4116d-233">メソッドまたは操作が実装されていません。</span><span class="sxs-lookup"><span data-stu-id="4116d-233">A method or operation is not implemented.</span></span>|  
|<xref:System.NotSupportedException>|<span data-ttu-id="4116d-234">メソッドまたは操作はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="4116d-234">A method or operation is not supported.</span></span>|  
|<xref:System.ObjectDisposedException>|<span data-ttu-id="4116d-235">破棄されたオブジェクトに対して操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-235">An operation is performed on an object that has been disposed.</span></span>|  
|<xref:System.OverflowException>|<span data-ttu-id="4116d-236">算術演算、キャスト演算、または変換操作を実行すると、オーバーフローが発生します。</span><span class="sxs-lookup"><span data-stu-id="4116d-236">An arithmetic, casting, or conversion operation results in an overflow.</span></span>|  
|<xref:System.IO.PathTooLongException>|<span data-ttu-id="4116d-237">パスまたはファイル名がシステム定義の最大長を超えています。</span><span class="sxs-lookup"><span data-stu-id="4116d-237">A path or file name exceeds the maximum system-defined length.</span></span>|  
|<xref:System.PlatformNotSupportedException>|<span data-ttu-id="4116d-238">この操作は、現在のプラットフォームではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="4116d-238">The operation is not supported on the current platform.</span></span>|  
|<xref:System.RankException>|<span data-ttu-id="4116d-239">次元の数が正しくない配列がメソッドに渡されました。</span><span class="sxs-lookup"><span data-stu-id="4116d-239">An array with the wrong number of dimensions is passed to a method.</span></span>|  
|<xref:System.TimeoutException>|<span data-ttu-id="4116d-240">操作に割り当てられた時間間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="4116d-240">The time interval allotted to an operation has expired.</span></span>|  
|<xref:System.UriFormatException>|<span data-ttu-id="4116d-241">無効な Uniform Resource Identifier (URI) が使用されています。</span><span class="sxs-lookup"><span data-stu-id="4116d-241">An invalid Uniform Resource Identifier (URI) is used.</span></span>|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a><span data-ttu-id="4116d-242">カスタム例外の実装</span><span class="sxs-lookup"><span data-stu-id="4116d-242">Implementing custom exceptions</span></span>  
 <span data-ttu-id="4116d-243">次の場合、既存の .NET Framework 例外を使用してエラー条件を処理するのは適切ではありません。</span><span class="sxs-lookup"><span data-stu-id="4116d-243">In the following cases, using an existing .NET Framework exception to handle an error condition is not adequate:</span></span>  
  
-   <span data-ttu-id="4116d-244">例外が、既存の .NET Framework 例外にマップできない一意のプログラムエラーを反映した場合。</span><span class="sxs-lookup"><span data-stu-id="4116d-244">When the exception reflects a unique program error that cannot be mapped to an existing .NET Framework exception.</span></span>  
  
-   <span data-ttu-id="4116d-245">既存の .NET Framework 例外に適した処理とは異なる処理が例外に必要な場合、または同様の例外から例外を明確する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="4116d-245">When the exception requires handling that is different from the handling that is appropriate for an existing .NET Framework exception, or the exception must be disambiguated from a similar exception.</span></span> <span data-ttu-id="4116d-246">たとえば、ターゲットの整数型の範囲外にある文字列の数値表現を解析するときに <xref:System.ArgumentOutOfRangeException> 例外をスローした場合、呼び出し元が適切なを提供しないというエラーに対して同じ例外を使用することはできません。メソッドを呼び出すときの制約値。</span><span class="sxs-lookup"><span data-stu-id="4116d-246">For example, if you throw an <xref:System.ArgumentOutOfRangeException> exception when parsing the numeric representation of a string that is out of range of the target integral type, you would not want to use the same exception for an error that results from the caller not supplying the appropriate constrained values when calling the method.</span></span>  
  
 <span data-ttu-id="4116d-247"><xref:System.Exception> クラスは、.NET Framework 内のすべての例外の基本クラスです。</span><span class="sxs-lookup"><span data-stu-id="4116d-247">The <xref:System.Exception> class is the base class of all exceptions in the .NET Framework.</span></span> <span data-ttu-id="4116d-248">多くの派生クラスは、<xref:System.Exception> クラスのメンバーの継承された動作に依存しています。<xref:System.Exception>のメンバーをオーバーライドしたり、一意のメンバーを定義したりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4116d-248">Many derived classes rely on the inherited behavior of the members of the <xref:System.Exception> class; they do not override the members of <xref:System.Exception>, nor do they define any unique members.</span></span>  
  
 <span data-ttu-id="4116d-249">独自の例外クラスを定義するには、次のようにします。</span><span class="sxs-lookup"><span data-stu-id="4116d-249">To define your own exception class:</span></span>  
  
1.  <span data-ttu-id="4116d-250"><xref:System.Exception>から継承するクラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-250">Define a class that inherits from <xref:System.Exception>.</span></span> <span data-ttu-id="4116d-251">必要に応じて、クラスに必要な一意のメンバーを定義して、例外に関する追加情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-251">If necessary, define any unique members needed by your class to provide additional information about the exception.</span></span> <span data-ttu-id="4116d-252">たとえば、<xref:System.ArgumentException> クラスには、引数によって例外が発生したパラメーターの名前を指定する <xref:System.ArgumentException.ParamName%2A> プロパティと、タイムアウト間隔を示す <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> プロパティが <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> プロパティに含まれています。</span><span class="sxs-lookup"><span data-stu-id="4116d-252">For example, the <xref:System.ArgumentException> class includes a <xref:System.ArgumentException.ParamName%2A> property that specifies the name of the parameter whose argument caused the exception, and the <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> property includes a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> property that indicates the time-out interval.</span></span>  
  
2.  <span data-ttu-id="4116d-253">必要に応じて、変更または変更する機能を持つ継承されたメンバーをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="4116d-253">If necessary, override any inherited members whose functionality you want to change or modify.</span></span> <span data-ttu-id="4116d-254"><xref:System.Exception> の既存の派生クラスのほとんどは、継承されたメンバーの動作をオーバーライドしないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-254">Note that most existing derived classes of <xref:System.Exception> do not override the behavior of inherited members.</span></span>  
  
3.  <span data-ttu-id="4116d-255">カスタム例外オブジェクトがシリアル化可能であるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="4116d-255">Determine whether your custom exception object is serializable.</span></span> <span data-ttu-id="4116d-256">シリアル化を使用すると、例外に関する情報を保存し、例外情報をサーバーとクライアントプロキシがリモート処理コンテキストで共有できるようになります。</span><span class="sxs-lookup"><span data-stu-id="4116d-256">Serialization enables you to save information about the exception and permits exception information to be shared by a server and a client proxy in a remoting context.</span></span> <span data-ttu-id="4116d-257">例外オブジェクトをシリアル化できるようにするには、<xref:System.SerializableAttribute> 属性でマークします。</span><span class="sxs-lookup"><span data-stu-id="4116d-257">To make the exception object serializable, mark it with the <xref:System.SerializableAttribute> attribute.</span></span>  
  
4.  <span data-ttu-id="4116d-258">Exception クラスのコンストラクターを定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-258">Define the constructors of your exception class.</span></span> <span data-ttu-id="4116d-259">通常、例外クラスには、次のコンストラクターが1つ以上含まれています。</span><span class="sxs-lookup"><span data-stu-id="4116d-259">Typically, exception classes have one or more of the following constructors:</span></span>  
  
    -   <span data-ttu-id="4116d-260"><xref:System.Exception.%23ctor>、既定値を使用して新しい exception オブジェクトのプロパティを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-260"><xref:System.Exception.%23ctor>, which uses default values to initialize the properties of a new exception object.</span></span>  
  
    -   <span data-ttu-id="4116d-261"><xref:System.Exception.%23ctor%28System.String%29>。指定したエラーメッセージを使用して新しい例外オブジェクトを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-261"><xref:System.Exception.%23ctor%28System.String%29>, which initializes a new exception object with a specified error message.</span></span>  
  
    -   <span data-ttu-id="4116d-262"><xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>。指定したエラーメッセージと内部例外を使用して、新しい例外オブジェクトを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-262"><xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, which initializes a new exception object with a specified error message and inner exception.</span></span>  
  
    -   <span data-ttu-id="4116d-263"><xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>。これは、シリアル化されたデータから新しい例外オブジェクトを初期化する `protected` コンストラクターです。</span><span class="sxs-lookup"><span data-stu-id="4116d-263"><xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, which is a `protected` constructor that initializes a new exception object from serialized data.</span></span> <span data-ttu-id="4116d-264">例外オブジェクトをシリアル化可能にすることを選択した場合は、このコンストラクターを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-264">You should implement this constructor if you've chosen to make your exception object serializable.</span></span>  
  
 <span data-ttu-id="4116d-265">次の例は、カスタム例外クラスの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-265">The following example illustrates the use of a custom exception class.</span></span> <span data-ttu-id="4116d-266">これは、クライアントが素数ではない開始番号を指定して素数のシーケンスを取得しようとしたときにスローされる `NotPrimeException` 例外を定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-266">It defines a `NotPrimeException` exception that is thrown when a client tries to retrieve a sequence of prime numbers by specifying a starting number that is not prime.</span></span> <span data-ttu-id="4116d-267">例外は、例外の原因となった素数以外の数値を返す新しいプロパティ `NonPrime`を定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-267">The exception defines a new property, `NonPrime`, that returns the non-prime number that caused the exception.</span></span> <span data-ttu-id="4116d-268">保護されたパラメーターなしのコンストラクターと、シリアル化のために <xref:System.Runtime.Serialization.SerializationInfo> パラメーターと <xref:System.Runtime.Serialization.StreamingContext> パラメーターを持つコンストラクターを実装するだけでなく、`NotPrimeException` クラスは、`NonPrime` プロパティをサポートするために3つの追加のコンストラクターを定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-268">Besides implementing a protected parameterless constructor and a constructor with <xref:System.Runtime.Serialization.SerializationInfo> and <xref:System.Runtime.Serialization.StreamingContext> parameters for serialization, the `NotPrimeException` class defines three additional constructors to support the `NonPrime` property.</span></span>  <span data-ttu-id="4116d-269">各コンストラクターは、非素数の値を保持するだけでなく、基底クラスのコンストラクターも呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4116d-269">Each constructor calls a base class constructor in addition to preserving the value of the non-prime number.</span></span> <span data-ttu-id="4116d-270">`NotPrimeException` クラスは、<xref:System.SerializableAttribute> 属性でもマークされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-270">The `NotPrimeException` class is also marked with the <xref:System.SerializableAttribute> attribute.</span></span>  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 <span data-ttu-id="4116d-271">次の例に示す `PrimeNumberGenerator` クラスでは、ありのエラトステネスを使用して、2からの素数のシーケンスを、クラスコンストラクターの呼び出しでクライアントによって指定された制限に計算します。</span><span class="sxs-lookup"><span data-stu-id="4116d-271">The `PrimeNumberGenerator` class shown in the following example uses the Sieve of Eratosthenes to calculate the sequence of prime numbers from 2 to a limit specified by the client in the call to its class constructor.</span></span> <span data-ttu-id="4116d-272">`GetPrimesFrom` メソッドは、指定された下限を超えるすべての素数を返しますが、下限の値が素数でない場合は `NotPrimeException` をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-272">The `GetPrimesFrom` method returns all prime numbers that are greater than or equal to a specified lower limit, but throws a `NotPrimeException` if that lower limit is not a prime number.</span></span>  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 <span data-ttu-id="4116d-273">次の例では、`GetPrimesFrom` メソッドに2つの呼び出しを行います。素数以外の数値が含まれています。その1つは、アプリケーションドメインの境界を越えています。</span><span class="sxs-lookup"><span data-stu-id="4116d-273">The following example makes two calls to the `GetPrimesFrom` method with non-prime numbers, one of which crosses application domain boundaries.</span></span> <span data-ttu-id="4116d-274">どちらの場合も、例外がスローされ、クライアントコードで正常に処理されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-274">In both cases, the exception is thrown and successfully handled in client code.</span></span>  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenet_v451includesnet-v451-mdmd"></a><span data-ttu-id="4116d-275">Windows ランタイムと [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="4116d-275">Windows Runtime and [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span></span>  
 <span data-ttu-id="4116d-276">[!INCLUDE[win8](~/includes/win8-md.md)]の [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] では、non-.NET Framework スタックフレームを通じて例外が伝達されると、通常、一部の例外情報が失われます。</span><span class="sxs-lookup"><span data-stu-id="4116d-276">In [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] for [!INCLUDE[win8](~/includes/win8-md.md)], some exception information is typically lost when an exception is propagated through non-.NET Framework stack frames.</span></span> <span data-ttu-id="4116d-277">[!INCLUDE[net_v451](~/includes/net-v451-md.md)] と [!INCLUDE[win81](~/includes/win81-md.md)]以降、共通言語ランタイムは、non-.NET Framework スタックフレームで例外が変更されていない限り、スローされた元の <xref:System.Exception> オブジェクトを引き続き使用します。</span><span class="sxs-lookup"><span data-stu-id="4116d-277">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)] and [!INCLUDE[win81](~/includes/win81-md.md)], the common language runtime continues to use the original <xref:System.Exception> object that was thrown unless that exception was modified in a non-.NET Framework stack frame.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-278">次の例は、<xref:System.ArithmeticException> エラーを処理するように定義されている `catch` ブロックを示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-278">The following example demonstrates a `catch` block that is defined to handle <xref:System.ArithmeticException> errors.</span></span> <span data-ttu-id="4116d-279">また、この `catch` ブロックは <xref:System.DivideByZeroException> エラーをキャッチします。これは <xref:System.DivideByZeroException> が <xref:System.ArithmeticException> から派生し、`catch` エラーに対して明示的に定義された <xref:System.DivideByZeroException> ブロックがないためです。</span><span class="sxs-lookup"><span data-stu-id="4116d-279">This `catch` block also catches <xref:System.DivideByZeroException> errors, because <xref:System.DivideByZeroException> derives from <xref:System.ArithmeticException> and there is no `catch` block explicitly defined for <xref:System.DivideByZeroException> errors.</span></span>  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md"><span data-ttu-id="4116d-280">例外の処理とスロー</span><span class="sxs-lookup"><span data-stu-id="4116d-280">Handling and Throwing Exceptions</span></span></related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md"><span data-ttu-id="4116d-281">デスクトップ アプリケーションでのリソースのパッケージ化と配置</span><span class="sxs-lookup"><span data-stu-id="4116d-281">Packaging and Deploying Resources in Desktop Apps</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1"><span data-ttu-id="4116d-282">マネージド コードのアサーション</span><span class="sxs-lookup"><span data-stu-id="4116d-282">Assertions in Managed Code</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4116d-283"><see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-283">Initializes a new instance of the <see cref="T:System.Exception" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4116d-284"><see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-284">Initializes a new instance of the <see cref="T:System.Exception" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-285">このコンストラクターは、新しいインスタンスの <xref:System.Exception.Message%2A> プロパティを初期化して、その値として、現在のシステムのカルチャを反映した、エラーを説明するシステム提供のメッセージを指定します。</span><span class="sxs-lookup"><span data-stu-id="4116d-285">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance to a system-supplied message that describes the error and takes into account the current system culture.</span></span>  
  
 <span data-ttu-id="4116d-286">すべての派生クラスは、このパラメーターなしのコンストラクターを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-286">All the derived classes should provide this parameterless constructor.</span></span> <span data-ttu-id="4116d-287"><xref:System.Exception> インスタンスの初期プロパティ値を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-287">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="4116d-288">プロパティ</span><span class="sxs-lookup"><span data-stu-id="4116d-288">Property</span></span>|<span data-ttu-id="4116d-289">[値]</span><span class="sxs-lookup"><span data-stu-id="4116d-289">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="4116d-290">null 参照 (Visual Basic の場合は `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="4116d-290">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="4116d-291">システム提供のローカライズされた説明。</span><span class="sxs-lookup"><span data-stu-id="4116d-291">A system-supplied localized description.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4116d-292">次のコード例では、定義済みのメッセージを使用する `Exception` を派生させることができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-292">The following code example derives an `Exception` that uses a predefined message.</span></span> <span data-ttu-id="4116d-293">このコードは、派生クラスと基本 `Exception` クラスのパラメーターなしのコンストラクターの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-293">The code demonstrates the use of the parameterless constructor for the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="4116d-294">エラーを説明するメッセージ。</span><span class="sxs-lookup"><span data-stu-id="4116d-294">The message that describes the error.</span></span></param>
        <summary><span data-ttu-id="4116d-295">指定したエラー メッセージを使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-295">Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-296">このコンストラクターは、`message` パラメーターを使用して、新しいインスタンスの <xref:System.Exception.Message%2A> プロパティを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-296">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance by using the `message` parameter.</span></span> <span data-ttu-id="4116d-297">`message` パラメーターが `null`の場合、これは <xref:System.Exception.%23ctor%2A> コンストラクターを呼び出すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="4116d-297">If the `message` parameter is `null`, this is the same as calling the <xref:System.Exception.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="4116d-298"><xref:System.Exception> インスタンスの初期プロパティ値を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-298">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="4116d-299">プロパティ</span><span class="sxs-lookup"><span data-stu-id="4116d-299">Property</span></span>|<span data-ttu-id="4116d-300">[値]</span><span class="sxs-lookup"><span data-stu-id="4116d-300">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="4116d-301">null 参照 (Visual Basic の場合は `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="4116d-301">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="4116d-302">エラー メッセージ文字列。</span><span class="sxs-lookup"><span data-stu-id="4116d-302">The error message string.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4116d-303">次のコード例では、特定の条件の `Exception` を派生させることができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-303">The following code example derives an `Exception` for a specific condition.</span></span> <span data-ttu-id="4116d-304">このコードは、派生クラスと基本 `Exception` クラスの両方について、呼び出し元が指定したメッセージをパラメーターとして受け取るコンストラクターの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-304">The code demonstrates the use of the constructor that takes a caller-specified message as a parameter, for both the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="4116d-305">スローされている例外に関するシリアル化済みオブジェクト データを保持している <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span><span class="sxs-lookup"><span data-stu-id="4116d-305">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</span></span></param>
        <param name="context"><span data-ttu-id="4116d-306">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</span><span class="sxs-lookup"><span data-stu-id="4116d-306">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</span></span></param>
        <summary><span data-ttu-id="4116d-307">シリアル化したデータを使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-307">Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-308">このコンストラクターは、逆シリアル化中に、ストリームで送信された例外オブジェクトを再構築するために呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-308">This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</span></span> <span data-ttu-id="4116d-309">詳細については、次を参照してください。 [XML および SOAP シリアル化](~/docs/standard/serialization/xml-and-soap-serialization.md)します。</span><span class="sxs-lookup"><span data-stu-id="4116d-309">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-310">次のコード例では、派生シリアル化可能な `Exception` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-310">The following code example defines a derived serializable `Exception` class.</span></span> <span data-ttu-id="4116d-311">このコードでは、0除算エラーが強制的に発生し、(<xref:System.Runtime.Serialization.SerializationInfo>、<xref:System.Runtime.Serialization.StreamingContext>) コンストラクターを使用して、派生例外のインスタンスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-311">The code forces a divide-by-0 error and then creates an instance of the derived exception using the (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) constructor.</span></span> <span data-ttu-id="4116d-312">このコードは、インスタンスをファイルにシリアル化し、そのファイルを新しい例外にシリアル化解除して、例外のデータをキャッチして表示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-312">The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</span></span>  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4116d-313"><paramref name="info" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="4116d-313"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="4116d-314">クラス名が <see langword="null" /> であるか、<see cref="P:System.Exception.HResult" /> が 0 です。</span><span class="sxs-lookup"><span data-stu-id="4116d-314">The class name is <see langword="null" /> or <see cref="P:System.Exception.HResult" /> is zero (0).</span></span></exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md"><span data-ttu-id="4116d-315">XML シリアル化および SOAP シリアル化</span><span class="sxs-lookup"><span data-stu-id="4116d-315">XML and SOAP Serialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="4116d-316">例外の原因を説明するエラー メッセージ。</span><span class="sxs-lookup"><span data-stu-id="4116d-316">The error message that explains the reason for the exception.</span></span></param>
        <param name="innerException"><span data-ttu-id="4116d-317">現在の例外の原因である例外。内部例外が指定されていない場合は null 参照 (Visual Basic では、<see langword="Nothing" />)。</span><span class="sxs-lookup"><span data-stu-id="4116d-317">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" /> in Visual Basic) if no inner exception is specified.</span></span></param>
        <summary><span data-ttu-id="4116d-318">指定したエラー メッセージおよびこの例外の原因となった内部例外への参照を使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4116d-318">Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-319">前の例外の直接の結果としてスローされる例外については、<xref:System.Exception.InnerException%2A> プロパティに、前の例外への参照を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-319">An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <xref:System.Exception.InnerException%2A> property.</span></span> <span data-ttu-id="4116d-320"><xref:System.Exception.InnerException%2A> プロパティは、コンストラクターに渡されたものと同じ値を返します。内部例外値がコンストラクターに渡されなかった場合、<xref:System.Exception.InnerException%2A> プロパティはnull 参照 (Visual Basic の場合は `Nothing`) を返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-320">The <xref:System.Exception.InnerException%2A> property returns the same value that is passed into the constructor, or a null reference (`Nothing` in Visual Basic) if the <xref:System.Exception.InnerException%2A> property does not supply the inner exception value to the constructor.</span></span>  
  
 <span data-ttu-id="4116d-321"><xref:System.Exception> インスタンスの初期プロパティ値を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-321">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="4116d-322">プロパティ</span><span class="sxs-lookup"><span data-stu-id="4116d-322">Property</span></span>|<span data-ttu-id="4116d-323">[値]</span><span class="sxs-lookup"><span data-stu-id="4116d-323">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="4116d-324">内部例外の参照。</span><span class="sxs-lookup"><span data-stu-id="4116d-324">The inner exception reference.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="4116d-325">エラー メッセージ文字列。</span><span class="sxs-lookup"><span data-stu-id="4116d-325">The error message string.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4116d-326">次のコード例では、特定の条件の `Exception` を派生させることができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-326">The following code example derives an `Exception` for a specific condition.</span></span> <span data-ttu-id="4116d-327">このコードは、派生クラスと基本 `Exception` クラスの両方について、メッセージと内部例外をパラメーターとして受け取るコンストラクターの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-327">The code demonstrates the use of the constructor that takes a message and an inner exception as parameters, for both the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-328">例外に関する追加のユーザー定義情報を提供する、キー/値ペアのコレクションを取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-328">Gets a collection of key/value pairs that provide additional user-defined information about the exception.</span></span></summary>
        <value><span data-ttu-id="4116d-329"><see cref="T:System.Collections.IDictionary" /> インターフェイスを実装し、ユーザー定義のキー/値ペアのコレクションを格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="4116d-329">An object that implements the <see cref="T:System.Collections.IDictionary" /> interface and contains a collection of user-defined key/value pairs.</span></span> <span data-ttu-id="4116d-330">既定値は空のコレクションです。</span><span class="sxs-lookup"><span data-stu-id="4116d-330">The default is an empty collection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-331"><xref:System.Exception.Data%2A> プロパティによって返される <xref:System.Collections.IDictionary?displayProperty=nameWithType> オブジェクトを使用して、例外に関連する補足情報を格納および取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-331">Use the <xref:System.Collections.IDictionary?displayProperty=nameWithType> object returned by the <xref:System.Exception.Data%2A> property to store and retrieve supplementary information relevant to the exception.</span></span> <span data-ttu-id="4116d-332">この情報は、任意の数のユーザー定義のキーと値のペアの形式になっています。</span><span class="sxs-lookup"><span data-stu-id="4116d-332">The information is in the form of an arbitrary number of user-defined key/value pairs.</span></span> <span data-ttu-id="4116d-333">各キーと値のペアの主要なコンポーネントは、通常、識別文字列です。一方、ペアの値コンポーネントは任意の型のオブジェクトにすることができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-333">The key component of each key/value pair is typically an identifying string, whereas the value component of the pair can be any type of object.</span></span>  
  
## <a name="keyvalue-pair-security"></a><span data-ttu-id="4116d-334">キー/値ペアのセキュリティ</span><span class="sxs-lookup"><span data-stu-id="4116d-334">Key/Value Pair Security</span></span>  
 <span data-ttu-id="4116d-335"><xref:System.Exception.Data%2A> プロパティによって返されたコレクションに格納されているキーと値のペアはセキュリティで保護されていません。</span><span class="sxs-lookup"><span data-stu-id="4116d-335">The key/value pairs stored in the collection returned by the <xref:System.Exception.Data%2A> property are not secure.</span></span> <span data-ttu-id="4116d-336">入れ子になった一連のルーチンをアプリケーションが呼び出し、各ルーチンに例外ハンドラーが含まれている場合、結果として得られる呼び出し履歴には、これらの例外ハンドラーの階層が含まれます。</span><span class="sxs-lookup"><span data-stu-id="4116d-336">If your application calls a nested series of routines, and each routine contains exception handlers, the resulting call stack contains a hierarchy of those exception handlers.</span></span> <span data-ttu-id="4116d-337">下位レベルのルーチンが例外をスローした場合、コールスタック階層内の上位レベルの例外ハンドラーは、他の例外ハンドラーによってコレクションに格納されているキーと値のペアの読み取りや変更を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-337">If a lower-level routine throws an exception, any upper-level exception handler in the call stack hierarchy can read and/or modify the key/value pairs stored in the collection by any other exception handler.</span></span> <span data-ttu-id="4116d-338">つまり、キーと値のペアの情報が機密情報ではないこと、およびキーと値のペアの情報が破損している場合にアプリケーションが正しく動作することを保証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-338">This means you must guarantee that the information in the key/value pairs is not confidential and that your application will operate correctly if the information in the key/value pairs is corrupted.</span></span>  
  
## <a name="key-conflicts"></a><span data-ttu-id="4116d-339">キーの競合</span><span class="sxs-lookup"><span data-stu-id="4116d-339">Key Conflicts</span></span>  
 <span data-ttu-id="4116d-340">キーの競合は、キーと値のペアにアクセスするために異なる例外ハンドラーが同じキーを指定した場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="4116d-340">A key conflict occurs when different exception handlers specify the same key to access a key/value pair.</span></span> <span data-ttu-id="4116d-341">アプリケーションを開発するときは注意が必要です。これは、キーの競合の結果として、下位レベルの例外ハンドラーが、より上位レベルの例外ハンドラーと誤って通信する可能性があるためです。この通信により、プログラムエラーが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-341">Use caution when developing your application because the consequence of a key conflict is that lower-level exception handlers can inadvertently communicate with higher-level exception handlers, and this communication might cause subtle program errors.</span></span> <span data-ttu-id="4116d-342">ただし、注意が必要な場合は、キーの競合を使用してアプリケーションを強化できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-342">However, if you are cautious you can use key conflicts to enhance your application.</span></span>  
  
## <a name="avoiding-key-conflicts"></a><span data-ttu-id="4116d-343">キーの競合を回避する</span><span class="sxs-lookup"><span data-stu-id="4116d-343">Avoiding Key Conflicts</span></span>  
 <span data-ttu-id="4116d-344">キーと値のペアに一意のキーを生成するための名前付け規則を採用することで、キーの競合を回避します。</span><span class="sxs-lookup"><span data-stu-id="4116d-344">Avoid key conflicts by adopting a naming convention to generate unique keys for key/value pairs.</span></span> <span data-ttu-id="4116d-345">たとえば、名前付け規則によって、ピリオドで区切られたアプリケーションの名前、ペアに関する補足情報を提供するメソッド、および一意の識別子で構成されるキーが生成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-345">For example, a naming convention might yield a key that consists of the period-delimited name of your application, the method that provides supplementary information for the pair, and a unique identifier.</span></span>  
  
 <span data-ttu-id="4116d-346">"Products" と "仕入先" という名前の2つのアプリケーションがあり、それぞれ Sales という名前のメソッドがあるとします。</span><span class="sxs-lookup"><span data-stu-id="4116d-346">Suppose two applications, named Products and Suppliers, each has a method named Sales.</span></span> <span data-ttu-id="4116d-347">Products アプリケーションの Sales メソッドは、製品の識別番号 (Stock Keeping Unit または SKU) を提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-347">The Sales method in the Products application provides the identification number (the stock keeping unit or SKU) of a product.</span></span> <span data-ttu-id="4116d-348">Supplier アプリケーションの Sales メソッドは、仕入先の id 番号 (SID) を提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-348">The Sales method in the Suppliers application provides the identification number, or SID, of a supplier.</span></span> <span data-ttu-id="4116d-349">そのため、この例の命名規則では、"Products. Sales. SKU" と "仕入先. Sales. SID" というキーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-349">Consequently, the naming convention for this example yields the keys, "Products.Sales.SKU" and "Suppliers.Sales.SID".</span></span>  
  
## <a name="exploiting-key-conflicts"></a><span data-ttu-id="4116d-350">キーの競合の悪用</span><span class="sxs-lookup"><span data-stu-id="4116d-350">Exploiting Key Conflicts</span></span>  
 <span data-ttu-id="4116d-351">1つ以上の特殊な既定キーを使用して処理を制御することで、キーの競合を悪用します。</span><span class="sxs-lookup"><span data-stu-id="4116d-351">Exploit key conflicts by using the presence of one or more special, prearranged keys to control processing.</span></span> <span data-ttu-id="4116d-352">1つのシナリオで、コールスタック階層内の最上位レベルの例外ハンドラーが、下位レベルの例外ハンドラーによってスローされたすべての例外をキャッチするとします。</span><span class="sxs-lookup"><span data-stu-id="4116d-352">Suppose, in one scenario, the highest level exception handler in the call stack hierarchy catches all exceptions thrown by lower-level exception handlers.</span></span> <span data-ttu-id="4116d-353">特殊なキーを持つキーと値のペアが存在する場合、高レベルの例外ハンドラーによって、<xref:System.Collections.IDictionary> オブジェクト内の残りのキーと値のペアが非標準的な方法で書式設定されます。それ以外の場合、残りのキーと値のペアは通常の方法で書式設定されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-353">If a key/value pair with a special key exists, the high-level exception handler formats the remaining key/value pairs in the <xref:System.Collections.IDictionary> object in some nonstandard way; otherwise, the remaining key/value pairs are formatted in some normal manner.</span></span>  
  
 <span data-ttu-id="4116d-354">次に、別のシナリオで、コールスタック階層の各レベルの例外ハンドラーが、次の下位レベルの例外ハンドラーによってスローされた例外をキャッチしたとします。</span><span class="sxs-lookup"><span data-stu-id="4116d-354">Now suppose, in another scenario, the exception handler at each level of the call stack hierarchy catches the exception thrown by the next lower-level exception handler.</span></span> <span data-ttu-id="4116d-355">さらに、<xref:System.Exception.Data%2A> プロパティによって返されるコレクションには、既定のキーセットを使用してアクセスできるキーと値のペアのセットが含まれていることが、各例外ハンドラーによって認識されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-355">In addition, each exception handler knows the collection returned by the <xref:System.Exception.Data%2A> property contains a set of key/value pairs that can be accessed with a prearranged set of keys.</span></span>  
  
 <span data-ttu-id="4116d-356">各例外ハンドラーは、キーの既定セットを使用して、対応するキー/値ペアの値コンポーネントを、その例外ハンドラーに固有の情報で更新します。</span><span class="sxs-lookup"><span data-stu-id="4116d-356">Each exception handler uses the prearranged set of keys to update the value component of the corresponding key/value pair with information unique to that exception handler.</span></span> <span data-ttu-id="4116d-357">更新プロセスが完了すると、例外ハンドラーは次の上位レベルの例外ハンドラーに例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-357">After the update process is complete, the exception handler throws the exception to the next higher-level exception handler.</span></span> <span data-ttu-id="4116d-358">最後に、最上位レベルの例外ハンドラーがキーと値のペアにアクセスし、すべての下位レベルの例外ハンドラーから統合された更新情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-358">Finally, the highest level exception handler accesses the key/value pairs and displays the consolidated update information from all the lower-level exception handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-359">次の例では、<xref:System.Exception.Data%2A> プロパティを使用して情報を追加および取得する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-359">The following example demonstrates how to add and retrieve information using the <xref:System.Exception.Data%2A> property.</span></span>  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4116d-360">派生クラスでオーバーライドされた場合、それ以後に発生する 1 つ以上の例外の根本原因である <see cref="T:System.Exception" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-360">When overridden in a derived class, returns the <see cref="T:System.Exception" /> that is the root cause of one or more subsequent exceptions.</span></span></summary>
        <returns><span data-ttu-id="4116d-361">例外のチェインでスローされた最初の例外。</span><span class="sxs-lookup"><span data-stu-id="4116d-361">The first exception thrown in a chain of exceptions.</span></span> <span data-ttu-id="4116d-362">現在の例外の <see cref="P:System.Exception.InnerException" /> プロパティが null 参照 (Visual Basic の場合は <see langword="Nothing" />) である場合、このプロパティは現在の例外を返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-362">If the <see cref="P:System.Exception.InnerException" /> property of the current exception is a null reference (<see langword="Nothing" /> in Visual Basic), this property returns the current exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-363">例外のチェーンは、その `InnerException` プロパティで参照される例外の直接的な結果として、チェーン内の各例外がスローされた例外のセットで構成されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-363">A chain of exceptions consists of a set of exceptions such that each exception in the chain was thrown as a direct result of the exception referenced in its `InnerException` property.</span></span> <span data-ttu-id="4116d-364">特定のチェーンに対して、チェーン内の他のすべての例外の根本原因である例外を1つだけ指定できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-364">For a given chain, there can be exactly one exception that is the root cause of all other exceptions in the chain.</span></span> <span data-ttu-id="4116d-365">この例外は、基本例外と呼ばれ、その `InnerException` プロパティには常に null 参照が含まれます。</span><span class="sxs-lookup"><span data-stu-id="4116d-365">This exception is called the base exception and its `InnerException` property always contains a null reference.</span></span>  
  
 <span data-ttu-id="4116d-366">例外チェーン内のすべての例外について、`GetBaseException` メソッドは同じオブジェクト (基本例外) を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-366">For all exceptions in a chain of exceptions, the `GetBaseException` method must return the same object (the base exception).</span></span>  
  
 <span data-ttu-id="4116d-367">`GetBaseException` メソッドは、例外の根本原因を特定するときに、現在の例外と最初の例外の間で発生した可能性がある例外に関する情報を必要としない場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="4116d-367">Use the `GetBaseException` method when you want to find the root cause of an exception but do not need information about exceptions that may have occurred between the current exception and the first exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-368">次のコード例では、2つの派生 `Exception` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-368">The following code example defines two derived `Exception` classes.</span></span> <span data-ttu-id="4116d-369">例外が強制的に発生し、派生した各クラスで再びスローされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-369">It forces an exception and then throws it again with each of the derived classes.</span></span> <span data-ttu-id="4116d-370">このコードは、`GetBaseException` メソッドを使用して元の例外を取得する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-370">The code shows the use of the `GetBaseException` method to retrieve the original exception.</span></span>  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4116d-371"><see langword="GetBaseException" /> メソッドは、例外の内容または形式に対する制御を必要とするクラスでオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-371">The <see langword="GetBaseException" /> method is overridden in classes that require control over the exception content or format.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="4116d-372">スローされている例外に関するシリアル化済みオブジェクト データを保持している <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span><span class="sxs-lookup"><span data-stu-id="4116d-372">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</span></span></param>
        <param name="context"><span data-ttu-id="4116d-373">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</span><span class="sxs-lookup"><span data-stu-id="4116d-373">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</span></span></param>
        <summary><span data-ttu-id="4116d-374">派生クラスでオーバーライドされた場合は、その例外に関する情報を使用して <see cref="T:System.Runtime.Serialization.SerializationInfo" /> を設定します。</span><span class="sxs-lookup"><span data-stu-id="4116d-374">When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-375">`GetObjectData` は、シリアル化する対象のすべての例外オブジェクト データを使用して、<xref:System.Runtime.Serialization.SerializationInfo> を設定します。</span><span class="sxs-lookup"><span data-stu-id="4116d-375">`GetObjectData` sets a <xref:System.Runtime.Serialization.SerializationInfo> with all the exception object data targeted for serialization.</span></span> <span data-ttu-id="4116d-376">逆シリアル化中に、ストリームで転送された `SerializationInfo` から例外が再構成されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-376">During deserialization, the exception is reconstituted from the `SerializationInfo` transmitted over the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-377">次のコード例では、`GetObjectData`を実装する、派生シリアル化可能な `Exception` クラスを定義します。これにより、2つのプロパティに対して軽微な変更を行い、シリアル化を実行するために基本クラスを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4116d-377">The following code example defines a derived serializable `Exception` class that implements `GetObjectData`, which makes minor changes to two properties and then calls the base class to perform the serialization.</span></span> <span data-ttu-id="4116d-378">この例では、0除算エラーが強制的に発生し、派生した例外のインスタンスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-378">The example forces a divide-by-0 error and then creates an instance of the derived exception.</span></span> <span data-ttu-id="4116d-379">このコードは、インスタンスをファイルにシリアル化し、そのファイルを新しい例外にシリアル化解除して、例外のデータをキャッチして表示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-379">The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</span></span>  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4116d-380"><paramref name="info" /> パラメーターが null 参照 (Visual Basic の場合は <see langword="Nothing" />) です。</span><span class="sxs-lookup"><span data-stu-id="4116d-380">The <paramref name="info" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4116d-381">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="4116d-381">requires full trust for the immediate caller.</span></span> <span data-ttu-id="4116d-382">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="4116d-382">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4116d-383">現在のインスタンスのランタイム型を取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-383">Gets the runtime type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="4116d-384">現在のインスタンスの正確なランタイム型を表す <see cref="T:System.Type" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="4116d-384">A <see cref="T:System.Type" /> object that represents the exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-385"><xref:System.Exception.GetType%2A> メソッドは、.NET Framework インフラストラクチャをサポートするために存在し、内部的には <xref:System.Object.GetType%2A?displayProperty=nameWithType>の基本的なメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4116d-385">The <xref:System.Exception.GetType%2A> method exists to support the .NET Framework infrastructure, and internally invokes the fundamental method, <xref:System.Object.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-386">この例外に関連付けられているヘルプ ファイルへのリンクを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="4116d-386">Gets or sets a link to the help file associated with this exception.</span></span></summary>
        <value><span data-ttu-id="4116d-387">URN (Uniform Resource Name) または URL (Uniform Resource Locator)。</span><span class="sxs-lookup"><span data-stu-id="4116d-387">The Uniform Resource Name (URN) or Uniform Resource Locator (URL).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-388">ヘルプ ファイルを表す戻り値は、URN または URL です。</span><span class="sxs-lookup"><span data-stu-id="4116d-388">The return value, which represents a help file, is a URN or URL.</span></span> <span data-ttu-id="4116d-389">たとえば、`HelpLink` の値は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="4116d-389">For example, the `HelpLink` value could be:</span></span>  
  
 <span data-ttu-id="4116d-390">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</span><span class="sxs-lookup"><span data-stu-id="4116d-390">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-391">次のコード例では、コンストラクターの `HelpLink` プロパティを設定し、例外をキャッチして `HelpLink`を表示する `Exception` をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-391">The following code example throws an `Exception` that sets the `HelpLink` property in its constructor and then catches the exception and displays `HelpLink`.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberSignature Language="C#" Value="public int HResult { get; set; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HResult { int get(); void set(int value); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="protected int HResult { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Protected Property HResult As Integer" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int HResult { int get(); void set(int value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-392">特定の例外に割り当てられているコード化数値である HRESULT を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="4116d-392">Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception.</span></span></summary>
        <value><span data-ttu-id="4116d-393">HRESULT 値。</span><span class="sxs-lookup"><span data-stu-id="4116d-393">The HRESULT value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-394">HRESULTは32ビット値で、3つの異なるフィールド（重大度コード、機能コード、およびエラーコード）に分割されています。</span><span class="sxs-lookup"><span data-stu-id="4116d-394">HRESULT is a 32-bit value, divided into three different fields: a severity code, a facility code, and an error code.</span></span> <span data-ttu-id="4116d-395">重大度コードは、戻り値が情報、警告、またはエラーのどれを表しているかを示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-395">The severity code indicates whether the return value represents information, warning, or error.</span></span> <span data-ttu-id="4116d-396">機能コードは、エラーの原因となっているシステムの領域を識別します。</span><span class="sxs-lookup"><span data-stu-id="4116d-396">The facility code identifies the area of the system responsible for the error.</span></span> <span data-ttu-id="4116d-397">エラーコードは、例外を表すために割り当てられた一意の番号です。</span><span class="sxs-lookup"><span data-stu-id="4116d-397">The error code is a unique number that is assigned to represent the exception.</span></span> <span data-ttu-id="4116d-398">各例外は個別の HRESULT にマッピングされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-398">Each exception is mapped to a distinct HRESULT.</span></span> <span data-ttu-id="4116d-399">マネージコードが例外をスローすると、ランタイムは HRESULT を COM クライアントに渡します。</span><span class="sxs-lookup"><span data-stu-id="4116d-399">When managed code throws an exception, the runtime passes the HRESULT to the COM client.</span></span> <span data-ttu-id="4116d-400">アンマネージコードがエラーを返すと、HRESULTが例外に変換され、ランタイムによってスローされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-400">When unmanaged code returns an error, the HRESULT is converted to an exception, which is then thrown by the runtime.</span></span> <span data-ttu-id="4116d-401">HRESULT値とそれに対応する .NET Framework の例外についてはについては [Hresult に例外を割り当てる方法](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-401">For information about HRESULT values and their corresponding .NET Framework exceptions, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span> <span data-ttu-id="4116d-402">発生する可能性が最も高い値のリストについては、Windowsドキュメントの [共通の HRESULT 値](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-402">See [Common HRESULT Values](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) in the Windows documentation for a list of the values you are most likely to encounter.</span></span>  
  
 <span data-ttu-id="4116d-403">[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降では、<xref:System.Exception.HResult%2A> プロパティの setter アクセス操作子は protected、そして getter メソッドは public です。</span><span class="sxs-lookup"><span data-stu-id="4116d-403">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Exception.HResult%2A> property's setter is protected, whereas its getter is public.</span></span>  <span data-ttu-id="4116d-404">以前のバージョンの .NET Framework では、getter と setter の両方が保護されています。</span><span class="sxs-lookup"><span data-stu-id="4116d-404">In previous versions of the .NET Framework, both getter and setter are protected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-405">次のコード例では、`HResult` プロパティをコンストラクター内のカスタム値に設定する派生 `Exception` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-405">The following code example defines a derived `Exception` class that sets the `HResult` property to a custom value in its constructor.</span></span>  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9"><span data-ttu-id="4116d-406">方法: HRESULT に例外を割り当てる</span><span class="sxs-lookup"><span data-stu-id="4116d-406">How to: Map HRESULTs and Exceptions</span></span></related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx"><span data-ttu-id="4116d-407">一般的な HRESULT 値</span><span class="sxs-lookup"><span data-stu-id="4116d-407">Common HRESULT Values</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-408">現在の例外の原因となる <see cref="T:System.Exception" /> インスタンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-408">Gets the <see cref="T:System.Exception" /> instance that caused the current exception.</span></span></summary>
        <value><span data-ttu-id="4116d-409">現在の例外を発生させたエラーを説明するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="4116d-409">An object that describes the error that caused the current exception.</span></span> <span data-ttu-id="4116d-410"><see cref="P:System.Exception.InnerException" /> プロパティは、 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> コンストラクターに渡されたものと同じ値を返します。内部例外の値がコンストラクターに渡されなかった場合は <see langword="null" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-410">The <see cref="P:System.Exception.InnerException" /> property returns the same value as was passed into the <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> constructor, or <see langword="null" /> if the inner exception value was not supplied to the constructor.</span></span> <span data-ttu-id="4116d-411">このプロパティは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="4116d-411">This property is read-only.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-412">前の例外 `Y`の直接的な結果として例外 `X` がスローされた場合、`X` の <xref:System.Exception.InnerException%2A> プロパティに `Y`への参照が含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-412">When an exception `X` is thrown as a direct result of a previous exception `Y`, the <xref:System.Exception.InnerException%2A> property of `X` should contain a reference to `Y`.</span></span>  
  
 <span data-ttu-id="4116d-413"><xref:System.Exception.InnerException%2A> プロパティを使用して、現在の例外の原因になった例外のセットを取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-413">Use the <xref:System.Exception.InnerException%2A> property to obtain the set of exceptions that led to the current exception.</span></span>  
  
 <span data-ttu-id="4116d-414">以前の例外をキャッチする新しい例外を作成できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-414">You can create a new exception that catches an earlier exception.</span></span> <span data-ttu-id="4116d-415">2つ目の例外を処理するコードは、エラーをより適切に処理するために、前の例外の追加情報を使用できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-415">The code that handles the second exception can make use of the additional information from the earlier exception to handle the error more appropriately.</span></span>  
  
 <span data-ttu-id="4116d-416">ファイルを読み取り、そのファイルのデータを書式設定する関数があるとします。</span><span class="sxs-lookup"><span data-stu-id="4116d-416">Suppose that there is a function that reads a file and formats the data from that file.</span></span> <span data-ttu-id="4116d-417">この例では、コードがファイルを読み取ろうとすると、<xref:System.IO.IOException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-417">In this example, as the code tries to read the file, an <xref:System.IO.IOException> is thrown.</span></span> <span data-ttu-id="4116d-418">関数は、<xref:System.IO.IOException> をキャッチし、<xref:System.IO.FileNotFoundException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-418">The function catches the <xref:System.IO.IOException> and throws a <xref:System.IO.FileNotFoundException>.</span></span> <span data-ttu-id="4116d-419"><xref:System.IO.IOException> を <xref:System.IO.FileNotFoundException>の <xref:System.Exception.InnerException%2A> プロパティに保存すると、<xref:System.IO.FileNotFoundException> をキャッチしたコードで最初のエラーの原因を調べることができます。</span><span class="sxs-lookup"><span data-stu-id="4116d-419">The <xref:System.IO.IOException> could be saved in the <xref:System.Exception.InnerException%2A> property of the <xref:System.IO.FileNotFoundException>, enabling the code that catches the <xref:System.IO.FileNotFoundException> to examine the cause of the initial error.</span></span>  
  
 <span data-ttu-id="4116d-420">内部例外への参照を保持する <xref:System.Exception.InnerException%2A> プロパティは、exception オブジェクトの初期化時に設定されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-420">The <xref:System.Exception.InnerException%2A> property, which holds a reference to the inner exception, is set upon initialization of the exception object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-421">次の例は、内部例外を参照する例外をスローしてキャッチする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-421">The following example demonstrates throwing and catching an exception that references an inner exception.</span></span>  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-422">現在の例外を説明するメッセージを取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-422">Gets a message that describes the current exception.</span></span></summary>
        <value><span data-ttu-id="4116d-423">例外の理由を説明するエラー メッセージ、または空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="4116d-423">The error message that explains the reason for the exception, or an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-424">エラーメッセージは、例外を処理している開発者を対象としています。</span><span class="sxs-lookup"><span data-stu-id="4116d-424">Error messages target the developer who is handling the exception.</span></span> <span data-ttu-id="4116d-425"><xref:System.Exception.Message%2A> プロパティのテキストは、エラーを完全に説明する必要があります。また、可能であれば、エラーの修正方法についても説明します。</span><span class="sxs-lookup"><span data-stu-id="4116d-425">The text of the <xref:System.Exception.Message%2A> property should completely describe the error and, when possible, should also explain how to correct the error.</span></span> <span data-ttu-id="4116d-426">最上位レベルの例外ハンドラーでは、エンドユーザーにメッセージが表示される場合があります。そのため、文法が正しいことと、メッセージの各文がピリオドで終わっていることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-426">Top-level exception handlers may display the message to end-users, so you should ensure that it is grammatically correct and that each sentence of the message ends with a period.</span></span> <span data-ttu-id="4116d-427">疑問符や感嘆符は使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="4116d-427">Do not use question marks or exclamation points.</span></span> <span data-ttu-id="4116d-428">アプリケーションでローカライズされた例外メッセージを使用する場合は、それらが正確に翻訳されていることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-428">If your application uses localized exception messages, you should ensure that they are accurately translated.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4116d-429">適切なアクセス許可を確認せずに、例外メッセージに機密情報を開示しないようにします。</span><span class="sxs-lookup"><span data-stu-id="4116d-429">Do not disclose sensitive information in exception messages without checking for the appropriate permissions.</span></span>  
  
 <span data-ttu-id="4116d-430"><xref:System.Exception.Message%2A> プロパティの値は、<xref:System.Exception.ToString%2A>によって返される情報に含まれます。<xref:System.Exception.Message%2A> プロパティは、<xref:System.Exception>の作成時にのみ設定されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-430">The value of the <xref:System.Exception.Message%2A> property is included in the information returned by <xref:System.Exception.ToString%2A>.The <xref:System.Exception.Message%2A> property is set only when creating an <xref:System.Exception>.</span></span> <span data-ttu-id="4116d-431">現在のインスタンスのコンストラクターにメッセージが指定されていない場合、システムは、現在のシステムカルチャを使用して書式設定された既定のメッセージを提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-431">If no message was supplied to the constructor for the current instance, the system supplies a default message that is formatted using the current system culture.</span></span>  
  
## <a name="windows-runtime-and-includenet_v451includesnet-v451-mdmd"></a><span data-ttu-id="4116d-432">Windows ランタイムと [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="4116d-432">Windows Runtime and [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span></span>  
 <span data-ttu-id="4116d-433">[!INCLUDE[net_v451](~/includes/net-v451-md.md)] と [!INCLUDE[win81](~/includes/win81-md.md)]以降では、.NET Framework の一部ではない Windows ランタイム型およびメンバーから伝達された例外からのエラーメッセージの忠実性が向上しています。</span><span class="sxs-lookup"><span data-stu-id="4116d-433">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)] and [!INCLUDE[win81](~/includes/win81-md.md)], the fidelity of error messages from exceptions that are propagated from Windows Runtime types and members that are not part of the .NET Framework is improved.</span></span> <span data-ttu-id="4116d-434">特に、Visual C++ component extensions (C++/cx) からの例外メッセージは .NET Framework <xref:System.Exception> オブジェクトに反映されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="4116d-434">In particular, exception messages from Visual C++ component extensions (C++/CX) are now propagated back into .NET Framework <xref:System.Exception> objects.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-435">次のコード例では、<xref:System.Exception> 例外をスローしてキャッチし、<xref:System.Exception.Message%2A> プロパティを使用して例外のテキストメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-435">The following code example throws and then catches an <xref:System.Exception> exception and displays the exception's text message using the <xref:System.Exception.Message%2A> property.</span></span>
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4116d-436">プロパティから例外をスローし、設定または取得したプロパティ引数に <see cref="P:System.Exception.Message" /> のテキストを参照する必要がある場合は、プロパティ引数の名前として "value" を使用します。</span><span class="sxs-lookup"><span data-stu-id="4116d-436">If you throw an exception from a property, and you need to refer in the text of <see cref="P:System.Exception.Message" /> to the property argument that you set or get, use "value" as the name of the property argument.</span></span></para></block>
        <block subset="none" type="overrides"><para><span data-ttu-id="4116d-437"><see cref="P:System.Exception.Message" /> プロパティは、メッセージの内容または形式を制御する必要があるクラスでオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-437">The <see cref="P:System.Exception.Message" /> property is overridden in classes that require control over message content or format.</span></span> <span data-ttu-id="4116d-438">通常、アプリケーションコードは、キャッチされた例外に関する情報を表示する必要があるときに、このプロパティにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="4116d-438">Application code typically accesses this property when it needs to display information about an exception that has been caught.</span></span>  
  
<span data-ttu-id="4116d-439">エラーメッセージはローカライズされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-439">The error message should be localized.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-440">例外がシリアル化され、例外に関するシリアル化されたデータを含む例外状態オブジェクトが作成されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="4116d-440">Occurs when an exception is serialized to create an exception state object that contains serialized data about the exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-441">例外状態オブジェクトは、<xref:System.Runtime.Serialization.ISafeSerializationData> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="4116d-441">The exception state object implements the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.</span></span>  
  
 <span data-ttu-id="4116d-442"><xref:System.Exception.SerializeObjectState> イベントがサブスクライブされると、例外が逆シリアル化され、空の例外として作成されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-442">When the <xref:System.Exception.SerializeObjectState> event is subscribed to, the exception is deserialized and created as an empty exception.</span></span> <span data-ttu-id="4116d-443">例外のコンストラクターは実行されず、例外の状態も逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-443">The exception's constructor is not run, and the exception state is also deserialized.</span></span> <span data-ttu-id="4116d-444">その後、例外状態オブジェクトの <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> コールバックメソッドに通知され、逆シリアル化されたデータを空の例外にプッシュできるようになります。</span><span class="sxs-lookup"><span data-stu-id="4116d-444">The <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> callback method of the exception state object is then notified so that it can push deserialized data into the empty exception.</span></span>  
  
 <span data-ttu-id="4116d-445"><xref:System.Exception.SerializeObjectState> イベントを使用すると、透過的な例外の種類で例外データをシリアル化および逆シリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-445">The <xref:System.Exception.SerializeObjectState> event enables transparent exception types to serialize and deserialize exception data.</span></span> <span data-ttu-id="4116d-446">透過的なコードは、操作中のアクセス許可セットの境界内でコマンドを実行できますが、実行、呼び出し、派生、またはクリティカルコードを含むことはできません。</span><span class="sxs-lookup"><span data-stu-id="4116d-446">Transparent code can execute commands within the bounds of the permission set it is operating within, but cannot execute, call, derive from, or contain critical code.</span></span>  
  
 <span data-ttu-id="4116d-447"><xref:System.Exception.SerializeObjectState> イベントがサブスクライブされていない場合、逆シリアル化は、<xref:System.Exception.%23ctor%2A> コンストラクターを使用して通常どおり実行されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-447">If the <xref:System.Exception.SerializeObjectState> event is not subscribed to, deserialization occurs as usual using the <xref:System.Exception.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="4116d-448">通常、<xref:System.Exception.SerializeObjectState> イベントのハンドラーは、例外のコンストラクターに追加され、シリアル化を提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-448">Typically, a handler for the <xref:System.Exception.SerializeObjectState> event is added in the exception's constructor to provide for its serialization.</span></span> <span data-ttu-id="4116d-449">ただし、<xref:System.Exception.SerializeObjectState> イベントハンドラーの実行時にコンストラクターは実行されないため、逆シリアル化された例外をシリアル化すると、例外を逆シリアル化しようとすると <xref:System.Runtime.Serialization.SerializationException> 例外がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-449">But because the constructor is not executed when the <xref:System.Exception.SerializeObjectState> event handler executes, serializing a deserialized exception can throw a <xref:System.Runtime.Serialization.SerializationException> exception when you try to deserialize the exception.</span></span> <span data-ttu-id="4116d-450">これを回避するには、<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> メソッドに <xref:System.Exception.SerializeObjectState> イベントのハンドラーも追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-450">To avoid this, you should also add the handler for the <xref:System.Exception.SerializeObjectState> event in the <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4116d-451">例については、「例」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-451">See the Examples section for an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-452">次の例では、<xref:System.Exception.SerializeObjectState> イベントを処理する `BadDivisionException` を定義します。</span><span class="sxs-lookup"><span data-stu-id="4116d-452">The following example defines a `BadDivisionException` that handles the <xref:System.Exception.SerializeObjectState> event.</span></span> <span data-ttu-id="4116d-453">また、状態オブジェクトも含まれています。これは、<xref:System.Runtime.Serialization.ISafeSerializationData> インターフェイスを実装する `BadDivisionExceptionState` という名前の入れ子構造です。</span><span class="sxs-lookup"><span data-stu-id="4116d-453">It also contains a state object, which is a nested structure named `BadDivisionExceptionState` that implements the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.</span></span>  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 <span data-ttu-id="4116d-454">`BadDivisionException` 例外は、浮動小数点除算が0で発生した場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-454">The `BadDivisionException` exception is thrown when a floating-point division by zero occurs.</span></span> <span data-ttu-id="4116d-455">最初の0除算では、`BadDivisionException` オブジェクトをインスタンス化し、シリアル化して、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-455">During the first division by zero, the example instantiates a `BadDivisionException` object, serializes it, and throws the exception.</span></span> <span data-ttu-id="4116d-456">後続の除算が0の場合、この例では、以前にシリアル化されたオブジェクトを逆シリアル化し、そのオブジェクトを再シリアル化して、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-456">When subsequent divisions by zero occur, the example deserializes the  previously serialized object, reserializes it, and throws the exception.</span></span> <span data-ttu-id="4116d-457">オブジェクトのシリアル化、逆シリアル化、再シリアル化、および逆シリアル化を提供するために、この例では、`BadDivisionException` クラスコンストラクターと <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> 実装の両方に <xref:System.Exception.SerializeObjectState> イベントハンドラーを追加します。</span><span class="sxs-lookup"><span data-stu-id="4116d-457">To provide for object serialization, deserialization, reserialization, and deserialization, the example adds the <xref:System.Exception.SerializeObjectState> event handler both in the `BadDivisionException` class constructor and in the <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4116d-458">このイベントがサブスクライブされて使用されている場合は、継承階層内の後続のすべての派生型が同じシリアル化機構を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-458">If this event is subscribed to and used, all derived types that follow in the inheritance hierarchy must implement the same serialization mechanism.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-459">エラーの原因となるアプリケーションまたはオブジェクトの名前を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="4116d-459">Gets or sets the name of the application or the object that causes the error.</span></span></summary>
        <value><span data-ttu-id="4116d-460">エラーの原因となるアプリケーションまたはオブジェクトの名前。</span><span class="sxs-lookup"><span data-stu-id="4116d-460">The name of the application or the object that causes the error.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-461"><xref:System.Exception.Source%2A> プロパティが明示的に設定されていない場合は、ランタイムによって、例外が発生したアセンブリの名前に自動的に設定されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-461">If the <xref:System.Exception.Source%2A> property is not set explicitly, the runtime automatically sets it to the name of the assembly in which the exception originated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-462">次の例では、コンストラクターの `Source` プロパティを設定し、例外をキャッチして `Source`を表示する `Exception` をスローします。</span><span class="sxs-lookup"><span data-stu-id="4116d-462">The following example throws an `Exception` that sets the `Source` property in its constructor and then catches the exception and displays `Source`.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4116d-463">このオブジェクトはランタイム <see cref="N:System.Reflection" /> オブジェクトでなければなりません。</span><span class="sxs-lookup"><span data-stu-id="4116d-463">The object must be a runtime <see cref="N:System.Reflection" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-464">呼び出し履歴で直前のフレームの文字列形式を取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-464">Gets a string representation of the immediate frames on the call stack.</span></span></summary>
        <value><span data-ttu-id="4116d-465">呼び出し履歴の直前のフレームを説明する文字列。</span><span class="sxs-lookup"><span data-stu-id="4116d-465">A string that describes the immediate frames of the call stack.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-466">実行スタックは、指定された時点で実行されているすべてのメソッドを追跡します。</span><span class="sxs-lookup"><span data-stu-id="4116d-466">The execution stack keeps track of all the methods that are in execution at a given instant.</span></span> <span data-ttu-id="4116d-467">メソッド呼び出しのトレースは、スタック トレースと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="4116d-467">A trace of the method calls is called a stack trace.</span></span> <span data-ttu-id="4116d-468">スタックトレースリストは、例外が発生したメソッド内の行番号にコールスタックをたどる方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="4116d-468">The stack trace listing provides a way to follow the call stack to the line number in the method where the exception occurs.</span></span>  
  
 <span data-ttu-id="4116d-469"><xref:System.Exception.StackTrace%2A> プロパティは、例外がスローされた場所で発生したコールスタックのフレームを返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-469">The <xref:System.Exception.StackTrace%2A> property returns the frames of the call stack that originate at the location where the exception was thrown.</span></span> <span data-ttu-id="4116d-470"><xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> クラスの新しいインスタンスを作成し、その <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> メソッドを使用することによって、呼び出し履歴の追加フレームに関する情報を取得できます。</span><span class="sxs-lookup"><span data-stu-id="4116d-470">You can obtain information about additional frames in the call stack by creating a new instance of the <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> class and using its <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="4116d-471">共通言語ランタイム (CLR) は、アプリケーションコードで例外がスローされるたびに (`throw` キーワードを使用して) スタックトレースを更新します。</span><span class="sxs-lookup"><span data-stu-id="4116d-471">The common language runtime (CLR) updates the stack trace whenever an exception is thrown in application code (by using the `throw` keyword).</span></span> <span data-ttu-id="4116d-472">最初にスローされたメソッドとは異なるメソッドで例外が再スローされた場合、スタックトレースには、例外が最初にスローされたメソッド内の場所と、例外が発生したメソッド内の場所の両方が含まれます。再スロー.</span><span class="sxs-lookup"><span data-stu-id="4116d-472">If the exception was rethrown in a method that is different than the method where it was originally thrown, the stack trace contains both the location in the method where the exception was originally thrown, and the location in the method where the exception was rethrown.</span></span> <span data-ttu-id="4116d-473">例外がスローされ、後で再スローされた場合、同じメソッドでスタックトレースには、例外が再スローされた場所だけが含まれ、例外が最初にスローされた場所は含まれません。</span><span class="sxs-lookup"><span data-stu-id="4116d-473">If the exception is thrown, and later rethrown, in the same method, the stack trace only contains the location where the exception was rethrown and does not include the location where the exception was originally thrown.</span></span>  
  
 <span data-ttu-id="4116d-474"><xref:System.Exception.StackTrace%2A> プロパティでは、最適化時にインライン展開などのコード変換が発生するため、予想どおりに多くのメソッド呼び出しが報告されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-474">The <xref:System.Exception.StackTrace%2A> property may not report as many method calls as expected because of code transformations, such as inlining, that occur during optimization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-475">次のコード例では、`Exception` をスローし、それをキャッチして、`StackTrace` プロパティを使用してスタックトレースを表示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-475">The following code example throws an `Exception` and then catches it and displays a stack trace using the `StackTrace` property.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4116d-476"><see langword="StackTrace" /> プロパティは、スタックトレースの内容または形式に対する制御を必要とするクラスでオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-476">The <see langword="StackTrace" /> property is overridden in classes that require control over the stack trace content or format.</span></span>  
  
<span data-ttu-id="4116d-477">既定では、例外オブジェクトがスローされる直前にスタックトレースがキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="4116d-477">By default, the stack trace is captured immediately before an exception object is thrown.</span></span> <span data-ttu-id="4116d-478">例外がスローされない場合にスタックトレース情報を取得するには、<see cref="P:System.Environment.StackTrace" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="4116d-478">Use <see cref="P:System.Environment.StackTrace" /> to get stack trace information when no exception is being thrown.</span></span></para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4116d-479">現在の例外がスローされたメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-479">Gets the method that throws the current exception.</span></span></summary>
        <value><span data-ttu-id="4116d-480">現在の例外をスローした <see cref="T:System.Reflection.MethodBase" />。</span><span class="sxs-lookup"><span data-stu-id="4116d-480">The <see cref="T:System.Reflection.MethodBase" /> that threw the current exception.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-481">この例外をスローするメソッドが使用できず、スタックトレースが null 参照 (Visual Basic で`Nothing`) でない場合、<xref:System.Exception.TargetSite%2A> はスタックトレースからメソッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-481">If the method that throws this exception is not available and the stack trace is not a null reference (`Nothing` in Visual Basic), <xref:System.Exception.TargetSite%2A> obtains the method from the stack trace.</span></span> <span data-ttu-id="4116d-482">スタック トレースが null 参照であると、<xref:System.Exception.TargetSite%2A> も null 参照を返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-482">If the stack trace is a null reference, <xref:System.Exception.TargetSite%2A> also returns a null reference.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4116d-483">例外ハンドラーがアプリケーションドメインの境界を越えて例外を処理する場合、<xref:System.Exception.TargetSite%2A> プロパティは、例外がスローされたメソッドの名前を正確に報告できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="4116d-483">The <xref:System.Exception.TargetSite%2A> property may not accurately report the name of the method in which an exception was thrown if the exception handler handles an exception across application domain boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-484">次のコード例では、`Exception` をスローし、それをキャッチして、`TargetSite` プロパティを使用して、元のメソッドを表示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-484">The following code example throws an `Exception` and then catches it and displays the originating method using the `TargetSite` property.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4116d-485">現在の例外の文字列形式を作成して返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-485">Creates and returns a string representation of the current exception.</span></span></summary>
        <returns><span data-ttu-id="4116d-486">現在の例外の文字列形式。</span><span class="sxs-lookup"><span data-stu-id="4116d-486">A string representation of the current exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4116d-487"><xref:System.Exception.ToString%2A> は、人間によって認識されることを意図した現在の例外の表現を返します。</span><span class="sxs-lookup"><span data-stu-id="4116d-487"><xref:System.Exception.ToString%2A> returns a representation of the current exception that is intended to be understood by humans.</span></span> <span data-ttu-id="4116d-488">例外にカルチャに依存するデータが含まれている場合、`ToString` によって返される文字列形式は、現在のシステムカルチャを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4116d-488">Where the exception contains culture-sensitive data, the string representation returned by `ToString` is required to take into account the current system culture.</span></span> <span data-ttu-id="4116d-489">返される文字列の形式については正確な要件はありませんが、ユーザーが認識したオブジェクトの値を反映しようとします。</span><span class="sxs-lookup"><span data-stu-id="4116d-489">Although there are no exact requirements for the format of the returned string, it should attempt to reflect the value of the object as perceived by the user.</span></span>  
  
 <span data-ttu-id="4116d-490"><xref:System.Exception.ToString%2A> の既定の実装では、現在の例外をスローしたクラスの名前、メッセージ、内部例外で <xref:System.Exception.ToString%2A> を呼び出した結果、および <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>を呼び出した結果を取得します。</span><span class="sxs-lookup"><span data-stu-id="4116d-490">The default implementation of <xref:System.Exception.ToString%2A> obtains the name of the class that threw the current exception, the message, the result of calling <xref:System.Exception.ToString%2A> on the inner exception, and the result of calling <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4116d-491">これらのメンバーのいずれかが `null`場合、その値は返される文字列に含まれません。</span><span class="sxs-lookup"><span data-stu-id="4116d-491">If any of these members is `null`, its value is not included in the returned string.</span></span>  
  
 <span data-ttu-id="4116d-492">エラーメッセージがない場合、または空の文字列 ("") の場合は、エラーメッセージは返されません。</span><span class="sxs-lookup"><span data-stu-id="4116d-492">If there is no error message or if it is an empty string (""), then no error message is returned.</span></span> <span data-ttu-id="4116d-493">内部例外の名前とスタックトレースは、`null`されていない場合にのみ返されます。</span><span class="sxs-lookup"><span data-stu-id="4116d-493">The name of the inner exception and the stack trace are returned only if they are not `null`.</span></span>  
  
 <span data-ttu-id="4116d-494">このメソッドは、<xref:System.Object.ToString%2A?displayProperty=nameWithType> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="4116d-494">This method overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4116d-495">次の例では、例外を発生させ、その例外に対して <xref:System.Exception.ToString%2A> を呼び出した結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="4116d-495">The following example causes an exception and displays the result of calling <xref:System.Exception.ToString%2A> on that exception.</span></span> <span data-ttu-id="4116d-496"><xref:System.Exception.ToString%2A?displayProperty=nameWithType> メソッドは、例外クラスのインスタンスが <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> メソッドの引数リストに存在する場合に、暗黙的に呼び出されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4116d-496">Note that the <xref:System.Exception.ToString%2A?displayProperty=nameWithType> method is called implicitly when the Exception class instance appears in the argument list of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
