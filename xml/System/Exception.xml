<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1cbaac51e2d67a2a333fc68e2a9e671bf8377ab9" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73400008" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アプリケーションの実行中に発生したエラーを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスは、すべての例外の基本クラスです。 エラーが発生した場合、システムまたは現在実行中のアプリケーションは、エラーに関する情報を含む例外をスローすることによって、エラーを報告します。 例外がスローされた後は、アプリケーションまたは既定の例外ハンドラーによって処理されます。  
  
 このセクションの内容:  
  
 [エラーと例外](#Errors)   
 [Try/catch ブロック](#TryCatch)   
 [例外の種類の機能](#Features)   
 [Exception クラスのプロパティ](#Properties)   
 [パフォーマンスに関する考慮事項](#Performance)   
 [例外を再スロー](#Rethrow)   
 [標準例外の選択](#Standard)   
 [カスタム例外の実装](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>エラーと例外  
 実行時エラーは、さまざまな理由で発生する可能性があります。 ただし、すべてのエラーをコード内で例外として処理する必要はありません。 ここでは、実行時に発生する可能性があるエラーのカテゴリと、それらに対処するための適切な方法を示します。  
  
-   **使用エラー。** 使用エラーは、例外が発生する可能性があるプログラムロジックのエラーを表します。 ただし、エラーは例外処理ではなく、問題のあるコードを変更することによって対処する必要があります。 たとえば、次の例の <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドのオーバーライドは、`obj` 引数が常に null 以外である必要があることを前提としています。  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     `obj` が `null` 場合に結果として生成される <xref:System.NullReferenceException> 例外は、<xref:System.Object.Equals%2A?displayProperty=nameWithType> のオーバーライドを呼び出して再コンパイルする前に、null を明示的にテストするようにソースコードを変更することで排除できます。 次の例には、`null` の引数を処理する、修正されたソースコードが含まれています。  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     使用エラーに対して例外処理を使用する代わりに、<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> メソッドを使用してデバッグビルドの使用エラーを識別し、<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> メソッドを使用してデバッグビルドとリリースビルドの両方で使用エラーを識別できます。 詳細については、「[マネージド コードのアサーション](/visualstudio/debugger/assertions-in-managed-code)」を参照してください。  
  
-   **プログラムエラーです。** プログラムエラーは、バグのないコードを記述することによって必ずしも回避できないランタイムエラーです。  
  
     場合によっては、プログラムエラーによって予期されるエラー条件またはルーチンエラーが反映されることがあります。 この場合、プログラムエラーに対処するために例外処理を使用せずに、操作を再試行することができます。 たとえば、ユーザーが特定の形式で日付を入力することが想定されている場合、<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> メソッドを呼び出すことによって日付文字列を解析できます。このメソッドは、<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> メソッドを使用する代わりに、解析操作が成功したかどうかを示す <xref:System.Boolean> 値を返します。日付文字列を <xref:System.DateTime> 値に変換できない場合に <xref:System.FormatException> 例外をスローします。 同様に、存在しないファイルを開こうとした場合は、最初に <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> メソッドを呼び出して、ファイルが存在するかどうかを確認し、存在しない場合は、ユーザーに作成を希望するかどうかを確認するメッセージを表示することができます。  
  
     それ以外の場合、プログラムエラーには、コードで処理できる予期しないエラー状態が反映されます。 たとえば、ファイルが存在することを確認した場合でも、ファイルを開く前に削除するか、破損している可能性があります。 この場合、<xref:System.IO.StreamReader> オブジェクトをインスタンス化するか、<xref:System.IO.File.Open%2A> メソッドを呼び出すことによってファイルを開こうとすると、<xref:System.IO.FileNotFoundException> 例外がスローされる可能性があります。 このような場合は、例外処理を使用してエラーから復旧する必要があります。  
  
-   **システムエラー。** システム障害は、プログラムによって意味のない方法で処理できない実行時エラーです。 たとえば、共通言語ランタイムが追加のメモリを割り当てられない場合、どのメソッドでも <xref:System.OutOfMemoryException> 例外がスローされる可能性があります。 通常、システム障害は例外処理を使用しても処理されません。 代わりに、<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> などのイベントを使用して、<xref:System.Environment.FailFast%2A?displayProperty=nameWithType> メソッドを呼び出して例外情報をログに記録し、アプリケーションが終了する前にエラーをユーザーに通知することができます。  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try ブロックと catch ブロック  
 共通言語ランタイムは、例外をオブジェクトとして表現し、プログラムコードと例外処理コードを `try` ブロックと `catch` ブロックに分離することに基づいて、例外処理モデルを提供します。 1つまたは複数の `catch` ブロックがあり、それぞれが特定の種類の例外を処理するように設計されています。または、別のブロックよりも具体的な例外をキャッチするように設計された1つのブロックを指定できます。  
  
 アプリケーションコードのブロックの実行中に発生した例外をアプリケーションが処理する場合は、コードを `try` ステートメント内に配置し、`try` ブロックと呼ばれる必要があります。 `try` ブロックによってスローされた例外を処理するアプリケーションコードは、`catch` ステートメント内に配置され、`catch` ブロックと呼ばれます。 0個以上の `catch` ブロックが `try` ブロックに関連付けられており、各 `catch` ブロックには、処理する例外の種類を決定する型フィルターが含まれています。  
  
 `try` ブロックで例外が発生すると、システムは、例外を処理する `catch` ブロックを見つけるまで、関連付けられている `catch` ブロックをアプリケーションコードに出現する順序で検索します。 Catch ブロックの型フィルターで `T` またはその派生元で `T` あるすべての型が指定されている場合、`catch` ブロックは型 `T` の例外を処理します。 例外を処理する最初の `catch` ブロックが検出されると、システムは検索を停止します。 このため、アプリケーションコードでは、このセクションの後の例に示すように、型を処理する `catch` ブロックを、その基本型を処理する `catch` ブロックの前に指定する必要があります。 `System.Exception` を処理する catch ブロックが最後に指定されます。  
  
 現在の `try` ブロックに関連付けられている `catch` ブロックで例外がハンドルされず、現在の `try` ブロックが現在の呼び出しの他の `try` ブロック内に入れ子になっている場合は、次に外側にある `catch` ブロックに関連付けられている `try` ブロック。検索されます。 例外の `catch` ブロックが見つからない場合は、現在の呼び出しで前の入れ子レベルが検索されます。 現在の呼び出しで例外の `catch` ブロックが見つからない場合は、例外が呼び出し履歴に渡され、例外を処理する `catch` ブロックの前のスタックフレームが検索されます。 呼び出し履歴の検索は、例外が処理されるか、または呼び出し履歴にフレームが存在しなくなるまで続行されます。 例外を処理する `catch` ブロックを検出せずにコールスタックの一番上に到達した場合、既定の例外ハンドラーはそれを処理してアプリケーションを終了します。  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>例外の種類の機能  
 例外の種類では、次の機能がサポートされます。  
  
-   人間が判読できる、エラーを説明するテキスト。 例外が発生すると、ランタイムは、エラーの性質をユーザーに通知し、問題を解決するためのアクションを提案するためのテキストメッセージを使用できるようにします。 このテキストメッセージは、exception オブジェクトの <xref:System.Exception.Message%2A> プロパティに保持されます。 例外オブジェクトの作成時に、その特定の例外の詳細を記述するテキスト文字列をコンストラクターに渡すことができます。 コンストラクターにエラーメッセージ引数が指定されていない場合は、既定のエラーメッセージが使用されます。 詳細については、<xref:System.Exception.Message%2A> プロパティを参照してください。  
  
-   例外がスローされたときの呼び出し履歴の状態。 <xref:System.Exception.StackTrace%2A> プロパティには、コード内でエラーが発生した場所を判断するために使用できるスタックトレースが含まれています。 スタックトレースでは、呼び出されたすべてのメソッドと、呼び出しが行われたソースファイル内の行番号が一覧表示されます。  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Exception クラスのプロパティ  
 <xref:System.Exception> クラスには、コードの場所、種類、ヘルプファイル、例外の理由 (<xref:System.Exception.StackTrace%2A>、<xref:System.Exception.InnerException%2A>、<xref:System.Exception.Message%2A>、<xref:System.Exception.HelpLink%2A>、<xref:System.Exception.HResult%2A>、<xref:System.Exception.Source%2A>、<xref:System.Exception.TargetSite%2A>) を識別するためのプロパティが多数含まれています。、、および <xref:System.Exception.Data%2A>ます。  
  
 2つ以上の例外の間に因果関係が存在する場合、<xref:System.Exception.InnerException%2A> プロパティはこの情報を保持します。 外側の例外は、この内部例外に応答してスローされます。 外側の例外を処理するコードでは、前の内部例外の情報を使用して、エラーをより適切に処理できます。 例外に関する補足情報は、<xref:System.Exception.Data%2A> プロパティにキーと値のペアのコレクションとして格納できます。  
  
 例外オブジェクトの作成時にコンストラクターに渡されるエラーメッセージ文字列はローカライズされ、<xref:System.Resources.ResourceManager> クラスを使用してリソースファイルから渡すことができます。 ローカライズされたリソースの詳細については、「[サテライトアセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)」および「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」のトピックを参照してください。  
  
 例外が発生した理由に関する詳細情報をユーザーに提供するために、<xref:System.Exception.HelpLink%2A> プロパティは、ヘルプファイルへの URL (または URN) を保持できます。  
  
 <xref:System.Exception> クラスでは、値0x80131500 を持つ HRESULT COR_E_EXCEPTION を使用します。  
  
 <xref:System.Exception> クラスのインスタンスの初期プロパティ値の一覧については、「<xref:System.Exception.%23ctor%2A> コンストラクター」を参照してください。  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 例外をスローまたは処理すると、大量のシステムリソースと実行時間が消費されます。 例外をスローするのは、予測可能なイベントやフロー制御を処理するのではなく、本当に特別な条件を処理する場合のみです。 たとえば、クラスライブラリを開発している場合など、メソッドの引数が無効である場合は例外をスローすることが妥当です。有効なパラメーターを使用してメソッドを呼び出すことが想定されているためです。 無効なメソッド引数が使用エラーの結果でない場合は、異常が発生したことを意味します。 逆に、ユーザーの入力が無効な場合は、ユーザーが無効なデータを頻繁に入力することが予想されるため、例外をスローしません。 代わりに、ユーザーが有効な入力を入力できるように再試行メカニズムを提供します。 また、例外を使用して使用エラーを処理する必要もありません。 代わりに、[アサーション](/visualstudio/debugger/assertions-in-managed-code)を使用して、使用エラーを特定し、修正します。  
  
 また、リターンコードが十分である場合は、例外をスローしないでください。リターンコードを例外に変換しないでください。また、例外を定期的にキャッチせず、無視して処理を続行することもありません。  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>例外の再スロー  
 多くの場合、例外ハンドラーは、例外を呼び出し元に渡すだけです。 これは、最も頻繁に発生します。  
  
-   さらに、クラスライブラリは、.NET Framework クラスライブラリまたはその他のクラスライブラリのメソッドの呼び出しをラップします。  
  
-   致命的な例外が発生したアプリケーションまたはライブラリ。 例外ハンドラーは例外をログに記録し、例外を再スローすることができます。  
  
 例外を再スローするには、のC# [throw](~/docs/csharp/language-reference/keywords/throw.md)ステートメントと、式を含まない Visual Basic の[throw](~/docs/visual-basic/language-reference/statements/throw-statement.md)ステートメントを使用することをお勧めします。 これにより、例外が呼び出し元に反映されるときに、すべてのコールスタック情報が保持されます。 次に例を示します。 文字列の拡張メソッド `FindOccurrences`は、引数を事前に検証せずに、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> の1つ以上の呼び出しをラップします。  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 その後、呼び出し元は `FindOccurrences` を2回呼び出します。 `FindOccurrences`の2回目の呼び出しでは、呼び出し元は検索文字列として `null` を渡します。この場合、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> メソッドは <xref:System.ArgumentNullException> 例外をスローします。 この例外は、`FindOccurrences` メソッドによって処理され、呼び出し元に渡されます。 Throw ステートメントは式なしで使用されるため、この例の出力は、呼び出し履歴が保持されていることを示しています。  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 これに対し、を使用して例外が再スローされる場合は、  
  
```csharp
throw e;
```  
  
```vb  
Throw e  
```  
  
 ステートメント、完全な呼び出し履歴は保持されず、例では次の出力が生成されます。  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 もう少し厄介な方法は、新しい例外をスローし、元の例外の呼び出し履歴情報を内部例外で保持することです。 呼び出し元は、新しい例外の <xref:System.Exception.InnerException%2A> プロパティを使用して、元の例外に関するスタックフレームやその他の情報を取得できます。 この場合、throw ステートメントは次のようになります。  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 次の例外ハンドラーに示すように、例外を処理するユーザーコードは、<xref:System.Exception.InnerException%2A> プロパティに元の例外に関する情報が含まれていることを認識している必要があります。  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>標準例外の選択  
 例外をスローする必要がある場合は、カスタム例外を実装するのではなく、.NET Framework で既存の例外の種類を使用することがよくあります。 次の2つの条件下では、標準の例外の種類を使用する必要があります。  
  
-   使用エラー (つまり、メソッドを呼び出している開発者によって作成されたプログラムロジックのエラー) によって発生した例外をスローしています。 通常は、<xref:System.ArgumentException>、<xref:System.ArgumentNullException>、<xref:System.InvalidOperationException>、<xref:System.NotSupportedException>などの例外をスローします。 例外オブジェクトをインスタンス化するときに例外オブジェクトのコンストラクターに渡す文字列は、開発者が修正できるようにエラーを記述する必要があります。 詳細については、<xref:System.Exception.Message%2A> プロパティを参照してください。  
  
-   既存の .NET Framework 例外を使用して呼び出し元に伝達できるエラーを処理しています。 できるだけ多くの派生された例外をスローする必要があります。 たとえば、メソッドで引数が列挙型の有効なメンバーである必要がある場合は、<xref:System.ArgumentException>ではなく <xref:System.ComponentModel.InvalidEnumArgumentException> (最も派生クラス) をスローする必要があります。  
  
 次の表に、一般的な例外の種類と、それらをスローする条件を示します。  
  
|例外|条件|  
|---------------|---------------|  
|<xref:System.ArgumentException>|メソッドに渡された null 以外の引数が無効です。|  
|<xref:System.ArgumentNullException>|メソッドに渡される引数が `null`ます。|  
|<xref:System.ArgumentOutOfRangeException>|引数が有効な値の範囲外です。|  
|<xref:System.IO.DirectoryNotFoundException>|ディレクトリパスの一部が無効です。|  
|<xref:System.DivideByZeroException>|整数または <xref:System.Decimal> 除算演算の分母が0です。|  
|<xref:System.IO.DriveNotFoundException>|ドライブが使用できないか、または存在しません。|  
|<xref:System.IO.FileNotFoundException>|ファイルが存在しません。|  
|<xref:System.FormatException>|値が、`Parse`などの変換メソッドによって文字列から変換される適切な形式ではありません。|  
|<xref:System.IndexOutOfRangeException>|インデックスが配列またはコレクションの範囲外です。|  
|<xref:System.InvalidOperationException>|メソッドの呼び出しは、オブジェクトの現在の状態では無効です。|  
|<xref:System.Collections.Generic.KeyNotFoundException>|コレクション内のメンバーにアクセスするために指定されたキーが見つかりません。|  
|<xref:System.NotImplementedException>|メソッドまたは操作が実装されていません。|  
|<xref:System.NotSupportedException>|メソッドまたは操作はサポートされていません。|  
|<xref:System.ObjectDisposedException>|破棄されたオブジェクトに対して操作が実行されます。|  
|<xref:System.OverflowException>|算術演算、キャスト演算、または変換操作を実行すると、オーバーフローが発生します。|  
|<xref:System.IO.PathTooLongException>|パスまたはファイル名がシステム定義の最大長を超えています。|  
|<xref:System.PlatformNotSupportedException>|この操作は、現在のプラットフォームではサポートされていません。|  
|<xref:System.RankException>|次元の数が正しくない配列がメソッドに渡されました。|  
|<xref:System.TimeoutException>|操作に割り当てられた時間間隔が経過しました。|  
|<xref:System.UriFormatException>|無効な Uniform Resource Identifier (URI) が使用されています。|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>カスタム例外の実装  
 次の場合、既存の .NET Framework 例外を使用してエラー条件を処理するのは適切ではありません。  
  
-   例外が、既存の .NET Framework 例外にマップできない一意のプログラムエラーを反映した場合。  
  
-   既存の .NET Framework 例外に適した処理とは異なる処理が例外に必要な場合、または同様の例外から例外を明確する必要がある場合。 たとえば、ターゲットの整数型の範囲外にある文字列の数値表現を解析するときに <xref:System.ArgumentOutOfRangeException> 例外をスローした場合、呼び出し元が適切なを提供しないというエラーに対して同じ例外を使用することはできません。メソッドを呼び出すときの制約値。  
  
 <xref:System.Exception> クラスは、.NET Framework 内のすべての例外の基本クラスです。 多くの派生クラスは、<xref:System.Exception> クラスのメンバーの継承された動作に依存しています。<xref:System.Exception>のメンバーをオーバーライドしたり、一意のメンバーを定義したりすることはありません。  
  
 独自の例外クラスを定義するには、次のようにします。  
  
1.  <xref:System.Exception>から継承するクラスを定義します。 必要に応じて、クラスに必要な一意のメンバーを定義して、例外に関する追加情報を提供します。 たとえば、<xref:System.ArgumentException> クラスには、引数によって例外が発生したパラメーターの名前を指定する <xref:System.ArgumentException.ParamName%2A> プロパティと、タイムアウト間隔を示す <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> プロパティが <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> プロパティに含まれています。  
  
2.  必要に応じて、変更または変更する機能を持つ継承されたメンバーをオーバーライドします。 <xref:System.Exception> の既存の派生クラスのほとんどは、継承されたメンバーの動作をオーバーライドしないことに注意してください。  
  
3.  カスタム例外オブジェクトがシリアル化可能であるかどうかを判断します。 シリアル化を使用すると、例外に関する情報を保存し、例外情報をサーバーとクライアントプロキシがリモート処理コンテキストで共有できるようになります。 例外オブジェクトをシリアル化できるようにするには、<xref:System.SerializableAttribute> 属性でマークします。  
  
4.  Exception クラスのコンストラクターを定義します。 通常、例外クラスには、次のコンストラクターが1つ以上含まれています。  
  
    -   <xref:System.Exception.%23ctor>、既定値を使用して新しい exception オブジェクトのプロパティを初期化します。  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>。指定したエラーメッセージを使用して新しい例外オブジェクトを初期化します。  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>。指定したエラーメッセージと内部例外を使用して、新しい例外オブジェクトを初期化します。  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>。これは、シリアル化されたデータから新しい例外オブジェクトを初期化する `protected` コンストラクターです。 例外オブジェクトをシリアル化可能にすることを選択した場合は、このコンストラクターを実装する必要があります。  
  
 次の例は、カスタム例外クラスの使用方法を示しています。 これは、クライアントが素数ではない開始番号を指定して素数のシーケンスを取得しようとしたときにスローされる `NotPrimeException` 例外を定義します。 例外は、例外の原因となった素数以外の数値を返す新しいプロパティ `NonPrime`を定義します。 保護されたパラメーターなしのコンストラクターと、シリアル化のために <xref:System.Runtime.Serialization.SerializationInfo> パラメーターと <xref:System.Runtime.Serialization.StreamingContext> パラメーターを持つコンストラクターを実装するだけでなく、`NotPrimeException` クラスは、`NonPrime` プロパティをサポートするために3つの追加のコンストラクターを定義します。  各コンストラクターは、非素数の値を保持するだけでなく、基底クラスのコンストラクターも呼び出します。 `NotPrimeException` クラスは、<xref:System.SerializableAttribute> 属性でもマークされます。  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 次の例に示す `PrimeNumberGenerator` クラスでは、ありのエラトステネスを使用して、2からの素数のシーケンスを、クラスコンストラクターの呼び出しでクライアントによって指定された制限に計算します。 `GetPrimesFrom` メソッドは、指定された下限を超えるすべての素数を返しますが、下限の値が素数でない場合は `NotPrimeException` をスローします。  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 次の例では、`GetPrimesFrom` メソッドに2つの呼び出しを行います。素数以外の数値が含まれています。その1つは、アプリケーションドメインの境界を越えています。 どちらの場合も、例外がスローされ、クライアントコードで正常に処理されます。  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenet_v451includesnet-v451-mdmd"></a>Windows ランタイムと [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 [!INCLUDE[win8](~/includes/win8-md.md)]の [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] では、non-.NET Framework スタックフレームを通じて例外が伝達されると、通常、一部の例外情報が失われます。 [!INCLUDE[net_v451](~/includes/net-v451-md.md)] と [!INCLUDE[win81](~/includes/win81-md.md)]以降、共通言語ランタイムは、non-.NET Framework スタックフレームで例外が変更されていない限り、スローされた元の <xref:System.Exception> オブジェクトを引き続き使用します。  
  
   
  
## Examples  
 次の例は、<xref:System.ArithmeticException> エラーを処理するように定義されている `catch` ブロックを示しています。 また、この `catch` ブロックは <xref:System.DivideByZeroException> エラーをキャッチします。これは <xref:System.DivideByZeroException> が <xref:System.ArithmeticException> から派生し、`catch` エラーに対して明示的に定義された <xref:System.DivideByZeroException> ブロックがないためです。  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">例外の処理とスロー</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">デスクトップ アプリケーションでのリソースのパッケージ化と配置</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">マネージド コードのアサーション</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、新しいインスタンスの <xref:System.Exception.Message%2A> プロパティを初期化して、その値として、現在のシステムのカルチャを反映した、エラーを説明するシステム提供のメッセージを指定します。  
  
 すべての派生クラスは、このパラメーターなしのコンストラクターを提供する必要があります。 <xref:System.Exception> インスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 参照 (Visual Basic の場合は `Nothing`)。|  
|<xref:System.Exception.Message%2A>|システム提供のローカライズされた説明。|  
  
   
  
## Examples  
 次のコード例では、定義済みのメッセージを使用する `Exception` を派生させることができます。 このコードは、派生クラスと基本 `Exception` クラスのパラメーターなしのコンストラクターの使用方法を示しています。  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">エラーを説明するメッセージ。</param>
        <summary>指定したエラー メッセージを使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、`message` パラメーターを使用して、新しいインスタンスの <xref:System.Exception.Message%2A> プロパティを初期化します。 `message` パラメーターが `null`の場合、これは <xref:System.Exception.%23ctor%2A> コンストラクターを呼び出すことと同じです。  
  
 <xref:System.Exception> インスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 参照 (Visual Basic の場合は `Nothing`)。|  
|<xref:System.Exception.Message%2A>|エラー メッセージ文字列。|  
  
   
  
## Examples  
 次のコード例では、特定の条件の `Exception` を派生させることができます。 このコードは、派生クラスと基本 `Exception` クラスの両方について、呼び出し元が指定したメッセージをパラメーターとして受け取るコンストラクターの使用方法を示しています。  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">スローされている例外に関するシリアル化済みオブジェクト データを保持している <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</param>
        <summary>シリアル化したデータを使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、逆シリアル化中に、ストリームで送信された例外オブジェクトを再構築するために呼び出されます。 詳細については、次を参照してください。 [XML および SOAP シリアル化](~/docs/standard/serialization/xml-and-soap-serialization.md)します。  
  
   
  
## Examples  
 次のコード例では、派生シリアル化可能な `Exception` クラスを定義します。 このコードでは、0除算エラーが強制的に発生し、(<xref:System.Runtime.Serialization.SerializationInfo>、<xref:System.Runtime.Serialization.StreamingContext>) コンストラクターを使用して、派生例外のインスタンスが作成されます。 このコードは、インスタンスをファイルにシリアル化し、そのファイルを新しい例外にシリアル化解除して、例外のデータをキャッチして表示します。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">クラス名が <see langword="null" /> であるか、<see cref="P:System.Exception.HResult" /> が 0 です。</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML シリアル化および SOAP シリアル化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">例外の原因を説明するエラー メッセージ。</param>
        <param name="innerException">現在の例外の原因である例外。内部例外が指定されていない場合は null 参照 (Visual Basic では、<see langword="Nothing" />)。</param>
        <summary>指定したエラー メッセージおよびこの例外の原因となった内部例外への参照を使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 前の例外の直接の結果としてスローされる例外については、<xref:System.Exception.InnerException%2A> プロパティに、前の例外への参照を含める必要があります。 <xref:System.Exception.InnerException%2A> プロパティは、コンストラクターに渡されたものと同じ値を返します。内部例外値がコンストラクターに渡されなかった場合、<xref:System.Exception.InnerException%2A> プロパティはnull 参照 (Visual Basic の場合は `Nothing`) を返します。  
  
 <xref:System.Exception> インスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部例外の参照。|  
|<xref:System.Exception.Message%2A>|エラー メッセージ文字列。|  
  
   
  
## Examples  
 次のコード例では、特定の条件の `Exception` を派生させることができます。 このコードは、派生クラスと基本 `Exception` クラスの両方について、メッセージと内部例外をパラメーターとして受け取るコンストラクターの使用方法を示しています。  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外に関する追加のユーザー定義情報を提供する、キー/値ペアのコレクションを取得します。</summary>
        <value><see cref="T:System.Collections.IDictionary" /> インターフェイスを実装し、ユーザー定義のキー/値ペアのコレクションを格納するオブジェクト。 既定値は空のコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.Data%2A> プロパティによって返される <xref:System.Collections.IDictionary?displayProperty=nameWithType> オブジェクトを使用して、例外に関連する補足情報を格納および取得します。 この情報は、任意の数のユーザー定義のキーと値のペアの形式になっています。 各キーと値のペアの主要なコンポーネントは、通常、識別文字列です。一方、ペアの値コンポーネントは任意の型のオブジェクトにすることができます。  
  
## <a name="keyvalue-pair-security"></a>キー/値ペアのセキュリティ  
 <xref:System.Exception.Data%2A> プロパティによって返されたコレクションに格納されているキーと値のペアはセキュリティで保護されていません。 入れ子になった一連のルーチンをアプリケーションが呼び出し、各ルーチンに例外ハンドラーが含まれている場合、結果として得られる呼び出し履歴には、これらの例外ハンドラーの階層が含まれます。 下位レベルのルーチンが例外をスローした場合、コールスタック階層内の上位レベルの例外ハンドラーは、他の例外ハンドラーによってコレクションに格納されているキーと値のペアの読み取りや変更を行うことができます。 つまり、キーと値のペアの情報が機密情報ではないこと、およびキーと値のペアの情報が破損している場合にアプリケーションが正しく動作することを保証する必要があります。  
  
## <a name="key-conflicts"></a>キーの競合  
 キーの競合は、キーと値のペアにアクセスするために異なる例外ハンドラーが同じキーを指定した場合に発生します。 アプリケーションを開発するときは注意が必要です。これは、キーの競合の結果として、下位レベルの例外ハンドラーが、より上位レベルの例外ハンドラーと誤って通信する可能性があるためです。この通信により、プログラムエラーが発生する可能性があります。 ただし、注意が必要な場合は、キーの競合を使用してアプリケーションを強化できます。  
  
## <a name="avoiding-key-conflicts"></a>キーの競合を回避する  
 キーと値のペアに一意のキーを生成するための名前付け規則を採用することで、キーの競合を回避します。 たとえば、名前付け規則によって、ピリオドで区切られたアプリケーションの名前、ペアに関する補足情報を提供するメソッド、および一意の識別子で構成されるキーが生成される場合があります。  
  
 "Products" と "仕入先" という名前の2つのアプリケーションがあり、それぞれ Sales という名前のメソッドがあるとします。 Products アプリケーションの Sales メソッドは、製品の識別番号 (Stock Keeping Unit または SKU) を提供します。 Supplier アプリケーションの Sales メソッドは、仕入先の id 番号 (SID) を提供します。 そのため、この例の命名規則では、"Products. Sales. SKU" と "仕入先. Sales. SID" というキーが生成されます。  
  
## <a name="exploiting-key-conflicts"></a>キーの競合の悪用  
 1つ以上の特殊な既定キーを使用して処理を制御することで、キーの競合を悪用します。 1つのシナリオで、コールスタック階層内の最上位レベルの例外ハンドラーが、下位レベルの例外ハンドラーによってスローされたすべての例外をキャッチするとします。 特殊なキーを持つキーと値のペアが存在する場合、高レベルの例外ハンドラーによって、<xref:System.Collections.IDictionary> オブジェクト内の残りのキーと値のペアが非標準的な方法で書式設定されます。それ以外の場合、残りのキーと値のペアは通常の方法で書式設定されます。  
  
 次に、別のシナリオで、コールスタック階層の各レベルの例外ハンドラーが、次の下位レベルの例外ハンドラーによってスローされた例外をキャッチしたとします。 さらに、<xref:System.Exception.Data%2A> プロパティによって返されるコレクションには、既定のキーセットを使用してアクセスできるキーと値のペアのセットが含まれていることが、各例外ハンドラーによって認識されます。  
  
 各例外ハンドラーは、キーの既定セットを使用して、対応するキー/値ペアの値コンポーネントを、その例外ハンドラーに固有の情報で更新します。 更新プロセスが完了すると、例外ハンドラーは次の上位レベルの例外ハンドラーに例外をスローします。 最後に、最上位レベルの例外ハンドラーがキーと値のペアにアクセスし、すべての下位レベルの例外ハンドラーから統合された更新情報を表示します。  
  
   
  
## Examples  
 次の例では、<xref:System.Exception.Data%2A> プロパティを使用して情報を追加および取得する方法を示します。  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、それ以後に発生する 1 つ以上の例外の根本原因である <see cref="T:System.Exception" /> を返します。</summary>
        <returns>例外のチェインでスローされた最初の例外。 現在の例外の <see cref="P:System.Exception.InnerException" /> プロパティが null 参照 (Visual Basic の場合は <see langword="Nothing" />) である場合、このプロパティは現在の例外を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外のチェーンは、その `InnerException` プロパティで参照される例外の直接的な結果として、チェーン内の各例外がスローされた例外のセットで構成されます。 特定のチェーンに対して、チェーン内の他のすべての例外の根本原因である例外を1つだけ指定できます。 この例外は、基本例外と呼ばれ、その `InnerException` プロパティには常に null 参照が含まれます。  
  
 例外チェーン内のすべての例外について、`GetBaseException` メソッドは同じオブジェクト (基本例外) を返す必要があります。  
  
 `GetBaseException` メソッドは、例外の根本原因を特定するときに、現在の例外と最初の例外の間で発生した可能性がある例外に関する情報を必要としない場合に使用します。  
  
   
  
## Examples  
 次のコード例では、2つの派生 `Exception` クラスを定義します。 例外が強制的に発生し、派生した各クラスで再びスローされます。 このコードは、`GetBaseException` メソッドを使用して元の例外を取得する方法を示しています。  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="GetBaseException" /> メソッドは、例外の内容または形式に対する制御を必要とするクラスでオーバーライドされます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">スローされている例外に関するシリアル化済みオブジェクト データを保持している <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</param>
        <summary>派生クラスでオーバーライドされた場合は、その例外に関する情報を使用して <see cref="T:System.Runtime.Serialization.SerializationInfo" /> を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` は、シリアル化する対象のすべての例外オブジェクト データを使用して、<xref:System.Runtime.Serialization.SerializationInfo> を設定します。 逆シリアル化中に、ストリームで転送された `SerializationInfo` から例外が再構成されます。  
  
   
  
## Examples  
 次のコード例では、`GetObjectData`を実装する、派生シリアル化可能な `Exception` クラスを定義します。これにより、2つのプロパティに対して軽微な変更を行い、シリアル化を実行するために基本クラスを呼び出します。 この例では、0除算エラーが強制的に発生し、派生した例外のインスタンスが作成されます。 このコードは、インスタンスをファイルにシリアル化し、そのファイルを新しい例外にシリアル化解除して、例外のデータをキャッチして表示します。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> パラメーターが null 参照 (Visual Basic の場合は <see langword="Nothing" />) です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスのランタイム型を取得します。</summary>
        <returns>現在のインスタンスの正確なランタイム型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A> メソッドは、.NET Framework インフラストラクチャをサポートするために存在し、内部的には <xref:System.Object.GetType%2A?displayProperty=nameWithType>の基本的なメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この例外に関連付けられているヘルプ ファイルへのリンクを取得または設定します。</summary>
        <value>URN (Uniform Resource Name) または URL (Uniform Resource Locator)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ヘルプ ファイルを表す戻り値は、URN または URL です。 たとえば、`HelpLink` の値は次のようになります。  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 次のコード例では、コンストラクターの `HelpLink` プロパティを設定し、例外をキャッチして `HelpLink`を表示する `Exception` をスローします。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberSignature Language="C#" Value="public int HResult { get; set; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HResult { int get(); void set(int value); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="protected int HResult { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Protected Property HResult As Integer" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int HResult { int get(); void set(int value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の例外に割り当てられているコード化数値である HRESULT を取得または設定します。</summary>
        <value>HRESULT 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULTは32ビット値で、3つの異なるフィールド（重大度コード、機能コード、およびエラーコード）に分割されています。 重大度コードは、戻り値が情報、警告、またはエラーのどれを表しているかを示します。 機能コードは、エラーの原因となっているシステムの領域を識別します。 エラーコードは、例外を表すために割り当てられた一意の番号です。 各例外は個別の HRESULT にマッピングされます。 マネージコードが例外をスローすると、ランタイムは HRESULT を COM クライアントに渡します。 アンマネージコードがエラーを返すと、HRESULTが例外に変換され、ランタイムによってスローされます。 HRESULT値とそれに対応する .NET Framework の例外についてはについては [Hresult に例外を割り当てる方法](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md) を参照してください。 発生する可能性が最も高い値のリストについては、Windowsドキュメントの [共通の HRESULT 値](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) を参照してください。  
  
 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降では、<xref:System.Exception.HResult%2A> プロパティの setter アクセス操作子は protected、そして getter メソッドは public です。  以前のバージョンの .NET Framework では、getter と setter の両方が保護されています。  
  
   
  
## Examples  
 次のコード例では、`HResult` プロパティをコンストラクター内のカスタム値に設定する派生 `Exception` クラスを定義します。  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">方法: HRESULT に例外を割り当てる</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">一般的な HRESULT 値</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外の原因となる <see cref="T:System.Exception" /> インスタンスを取得します。</summary>
        <value>現在の例外を発生させたエラーを説明するオブジェクト。 <see cref="P:System.Exception.InnerException" /> プロパティは、 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> コンストラクターに渡されたものと同じ値を返します。内部例外の値がコンストラクターに渡されなかった場合は <see langword="null" /> を返します。 このプロパティは読み取り専用です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 前の例外 `Y`の直接的な結果として例外 `X` がスローされた場合、`X` の <xref:System.Exception.InnerException%2A> プロパティに `Y`への参照が含まれている必要があります。  
  
 <xref:System.Exception.InnerException%2A> プロパティを使用して、現在の例外の原因になった例外のセットを取得します。  
  
 以前の例外をキャッチする新しい例外を作成できます。 2つ目の例外を処理するコードは、エラーをより適切に処理するために、前の例外の追加情報を使用できます。  
  
 ファイルを読み取り、そのファイルのデータを書式設定する関数があるとします。 この例では、コードがファイルを読み取ろうとすると、<xref:System.IO.IOException> がスローされます。 関数は、<xref:System.IO.IOException> をキャッチし、<xref:System.IO.FileNotFoundException>をスローします。 <xref:System.IO.IOException> を <xref:System.IO.FileNotFoundException>の <xref:System.Exception.InnerException%2A> プロパティに保存すると、<xref:System.IO.FileNotFoundException> をキャッチしたコードで最初のエラーの原因を調べることができます。  
  
 内部例外への参照を保持する <xref:System.Exception.InnerException%2A> プロパティは、exception オブジェクトの初期化時に設定されます。  
  
   
  
## Examples  
 次の例は、内部例外を参照する例外をスローしてキャッチする方法を示しています。  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外を説明するメッセージを取得します。</summary>
        <value>例外の理由を説明するエラー メッセージ、または空の文字列 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 エラーメッセージは、例外を処理している開発者を対象としています。 <xref:System.Exception.Message%2A> プロパティのテキストは、エラーを完全に説明する必要があります。また、可能であれば、エラーの修正方法についても説明します。 最上位レベルの例外ハンドラーでは、エンドユーザーにメッセージが表示される場合があります。そのため、文法が正しいことと、メッセージの各文がピリオドで終わっていることを確認する必要があります。 疑問符や感嘆符は使用しないでください。 アプリケーションでローカライズされた例外メッセージを使用する場合は、それらが正確に翻訳されていることを確認する必要があります。  
  
> [!IMPORTANT]
>  適切なアクセス許可を確認せずに、例外メッセージに機密情報を開示しないようにします。  
  
 <xref:System.Exception.Message%2A> プロパティの値は、<xref:System.Exception.ToString%2A>によって返される情報に含まれます。<xref:System.Exception.Message%2A> プロパティは、<xref:System.Exception>の作成時にのみ設定されます。 現在のインスタンスのコンストラクターにメッセージが指定されていない場合、システムは、現在のシステムカルチャを使用して書式設定された既定のメッセージを提供します。  
  
## <a name="windows-runtime-and-includenet_v451includesnet-v451-mdmd"></a>Windows ランタイムと [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 [!INCLUDE[net_v451](~/includes/net-v451-md.md)] と [!INCLUDE[win81](~/includes/win81-md.md)]以降では、.NET Framework の一部ではない Windows ランタイム型およびメンバーから伝達された例外からのエラーメッセージの忠実性が向上しています。 特に、Visual C++ component extensions (C++/cx) からの例外メッセージは .NET Framework <xref:System.Exception> オブジェクトに反映されるようになりました。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Exception> 例外をスローしてキャッチし、<xref:System.Exception.Message%2A> プロパティを使用して例外のテキストメッセージを表示します。
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>プロパティから例外をスローし、設定または取得したプロパティ引数に <see cref="P:System.Exception.Message" /> のテキストを参照する必要がある場合は、プロパティ引数の名前として "value" を使用します。</para></block>
        <block subset="none" type="overrides"><para><see cref="P:System.Exception.Message" /> プロパティは、メッセージの内容または形式を制御する必要があるクラスでオーバーライドされます。 通常、アプリケーションコードは、キャッチされた例外に関する情報を表示する必要があるときに、このプロパティにアクセスします。  
  
エラーメッセージはローカライズされている必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外がシリアル化され、例外に関するシリアル化されたデータを含む例外状態オブジェクトが作成されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外状態オブジェクトは、<xref:System.Runtime.Serialization.ISafeSerializationData> インターフェイスを実装します。  
  
 <xref:System.Exception.SerializeObjectState> イベントがサブスクライブされると、例外が逆シリアル化され、空の例外として作成されます。 例外のコンストラクターは実行されず、例外の状態も逆シリアル化されます。 その後、例外状態オブジェクトの <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> コールバックメソッドに通知され、逆シリアル化されたデータを空の例外にプッシュできるようになります。  
  
 <xref:System.Exception.SerializeObjectState> イベントを使用すると、透過的な例外の種類で例外データをシリアル化および逆シリアル化できます。 透過的なコードは、操作中のアクセス許可セットの境界内でコマンドを実行できますが、実行、呼び出し、派生、またはクリティカルコードを含むことはできません。  
  
 <xref:System.Exception.SerializeObjectState> イベントがサブスクライブされていない場合、逆シリアル化は、<xref:System.Exception.%23ctor%2A> コンストラクターを使用して通常どおり実行されます。  
  
 通常、<xref:System.Exception.SerializeObjectState> イベントのハンドラーは、例外のコンストラクターに追加され、シリアル化を提供します。 ただし、<xref:System.Exception.SerializeObjectState> イベントハンドラーの実行時にコンストラクターは実行されないため、逆シリアル化された例外をシリアル化すると、例外を逆シリアル化しようとすると <xref:System.Runtime.Serialization.SerializationException> 例外がスローされる可能性があります。 これを回避するには、<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> メソッドに <xref:System.Exception.SerializeObjectState> イベントのハンドラーも追加する必要があります。 例については、「例」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Exception.SerializeObjectState> イベントを処理する `BadDivisionException` を定義します。 また、状態オブジェクトも含まれています。これは、<xref:System.Runtime.Serialization.ISafeSerializationData> インターフェイスを実装する `BadDivisionExceptionState` という名前の入れ子構造です。  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` 例外は、浮動小数点除算が0で発生した場合にスローされます。 最初の0除算では、`BadDivisionException` オブジェクトをインスタンス化し、シリアル化して、例外をスローします。 後続の除算が0の場合、この例では、以前にシリアル化されたオブジェクトを逆シリアル化し、そのオブジェクトを再シリアル化して、例外をスローします。 オブジェクトのシリアル化、逆シリアル化、再シリアル化、および逆シリアル化を提供するために、この例では、`BadDivisionException` クラスコンストラクターと <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> 実装の両方に <xref:System.Exception.SerializeObjectState> イベントハンドラーを追加します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>このイベントがサブスクライブされて使用されている場合は、継承階層内の後続のすべての派生型が同じシリアル化機構を実装する必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エラーの原因となるアプリケーションまたはオブジェクトの名前を取得または設定します。</summary>
        <value>エラーの原因となるアプリケーションまたはオブジェクトの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.Source%2A> プロパティが明示的に設定されていない場合は、ランタイムによって、例外が発生したアセンブリの名前に自動的に設定されます。  
  
   
  
## Examples  
 次の例では、コンストラクターの `Source` プロパティを設定し、例外をキャッチして `Source`を表示する `Exception` をスローします。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このオブジェクトはランタイム <see cref="N:System.Reflection" /> オブジェクトでなければなりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し履歴で直前のフレームの文字列形式を取得します。</summary>
        <value>呼び出し履歴の直前のフレームを説明する文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実行スタックは、指定された時点で実行されているすべてのメソッドを追跡します。 メソッド呼び出しのトレースは、スタック トレースと呼ばれます。 スタックトレースリストは、例外が発生したメソッド内の行番号にコールスタックをたどる方法を提供します。  
  
 <xref:System.Exception.StackTrace%2A> プロパティは、例外がスローされた場所で発生したコールスタックのフレームを返します。 <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> クラスの新しいインスタンスを作成し、その <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> メソッドを使用することによって、呼び出し履歴の追加フレームに関する情報を取得できます。  
  
 共通言語ランタイム (CLR) は、アプリケーションコードで例外がスローされるたびに (`throw` キーワードを使用して) スタックトレースを更新します。 最初にスローされたメソッドとは異なるメソッドで例外が再スローされた場合、スタックトレースには、例外が最初にスローされたメソッド内の場所と、例外が発生したメソッド内の場所の両方が含まれます。再スロー. 例外がスローされ、後で再スローされた場合、同じメソッドでスタックトレースには、例外が再スローされた場所だけが含まれ、例外が最初にスローされた場所は含まれません。  
  
 <xref:System.Exception.StackTrace%2A> プロパティでは、最適化時にインライン展開などのコード変換が発生するため、予想どおりに多くのメソッド呼び出しが報告されない場合があります。  
  
   
  
## Examples  
 次のコード例では、`Exception` をスローし、それをキャッチして、`StackTrace` プロパティを使用してスタックトレースを表示します。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="StackTrace" /> プロパティは、スタックトレースの内容または形式に対する制御を必要とするクラスでオーバーライドされます。  
  
既定では、例外オブジェクトがスローされる直前にスタックトレースがキャプチャされます。 例外がスローされない場合にスタックトレース情報を取得するには、<see cref="P:System.Environment.StackTrace" /> を使用します。</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外がスローされたメソッドを取得します。</summary>
        <value>現在の例外をスローした <see cref="T:System.Reflection.MethodBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この例外をスローするメソッドが使用できず、スタックトレースが null 参照 (Visual Basic で`Nothing`) でない場合、<xref:System.Exception.TargetSite%2A> はスタックトレースからメソッドを取得します。 スタック トレースが null 参照であると、<xref:System.Exception.TargetSite%2A> も null 参照を返します。  
  
> [!NOTE]
>  例外ハンドラーがアプリケーションドメインの境界を越えて例外を処理する場合、<xref:System.Exception.TargetSite%2A> プロパティは、例外がスローされたメソッドの名前を正確に報告できないことがあります。  
  
   
  
## Examples  
 次のコード例では、`Exception` をスローし、それをキャッチして、`TargetSite` プロパティを使用して、元のメソッドを表示します。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の例外の文字列形式を作成して返します。</summary>
        <returns>現在の例外の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> は、人間によって認識されることを意図した現在の例外の表現を返します。 例外にカルチャに依存するデータが含まれている場合、`ToString` によって返される文字列形式は、現在のシステムカルチャを考慮する必要があります。 返される文字列の形式については正確な要件はありませんが、ユーザーが認識したオブジェクトの値を反映しようとします。  
  
 <xref:System.Exception.ToString%2A> の既定の実装では、現在の例外をスローしたクラスの名前、メッセージ、内部例外で <xref:System.Exception.ToString%2A> を呼び出した結果、および <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>を呼び出した結果を取得します。 これらのメンバーのいずれかが `null`場合、その値は返される文字列に含まれません。  
  
 エラーメッセージがない場合、または空の文字列 ("") の場合は、エラーメッセージは返されません。 内部例外の名前とスタックトレースは、`null`されていない場合にのみ返されます。  
  
 このメソッドは、<xref:System.Object.ToString%2A?displayProperty=nameWithType> をオーバーライドします。  
  
   
  
## Examples  
 次の例では、例外を発生させ、その例外に対して <xref:System.Exception.ToString%2A> を呼び出した結果を表示します。 <xref:System.Exception.ToString%2A?displayProperty=nameWithType> メソッドは、例外クラスのインスタンスが <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> メソッドの引数リストに存在する場合に、暗黙的に呼び出されることに注意してください。  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
