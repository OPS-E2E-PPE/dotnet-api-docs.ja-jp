<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7fef904577d04b32b33e58ae8584c9ebb4f953e6" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73400847" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>静的メソッドまたはクラス インスタンスとそのクラスのインスタンス メソッドを参照するデータ構造体であるデリゲートを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> クラスは、デリゲート型の基本クラスです。 ただし、システムとコンパイラだけを <xref:System.Delegate> クラスまたは <xref:System.MulticastDelegate> クラスから明示的に派生させることができます。 また、デリゲート型から新しい型を派生させることもできません。 <xref:System.Delegate> クラスは、デリゲート型とは見なされません。これは、デリゲート型を派生させるために使用されるクラスです。  
  
 ほとんどの言語では `delegate` キーワードが実装されており、これらの言語のコンパイラは、<xref:System.MulticastDelegate> クラスから派生できます。そのため、ユーザーは、言語によって提供される `delegate` キーワードを使用する必要があります。  
  
> [!NOTE]
>  共通言語ランタイムは、デリゲートと同じシグネチャを持つデリゲート型ごとに `Invoke` メソッドを提供します。 このメソッドは、コンパイラによって自動的にC#呼び出されるため、、 C++Visual Basic、またはビジュアルから明示的に呼び出す必要はありません。 `Invoke` メソッドは、デリゲート型のシグネチャを検索する場合に、[リフレクション](~/docs/framework/reflection-and-codedom/reflection.md)に役立ちます。  
  
 共通言語ランタイムは、デリゲートの非同期呼び出しを可能にするために、`BeginInvoke` および `EndInvoke` メソッドを使用して各デリゲート型を提供します。 これらのメソッドの詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
 デリゲート型の宣言は、1つまたは複数のメソッドのシグネチャを指定するコントラクトを確立します。 デリゲートは、への参照を持つデリゲート型のインスタンスです。  
  
-   型のインスタンスメソッドとターゲットオブジェクトは、その型に割り当てることができます。  
  
-   型のインスタンスメソッドです。非表示の `this` パラメーターは、仮パラメーターリストで公開されています。 デリゲートは、オープンインスタンスデリゲートと呼ばれます。  
  
-   静的メソッド。  
  
-   静的メソッドとターゲットオブジェクトは、メソッドの最初のパラメーターに割り当てることができます。 デリゲートは、最初の引数に対して閉じられると言います。  
  
 デリゲートバインディングの詳細については、「<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> メソッドのオーバーロード」を参照してください。  
  
> [!NOTE]
>  .NET Framework バージョン1.0 および1.1 では、デリゲートはメソッドのシグネチャがデリゲート型によって指定されたシグネチャと完全に一致する場合にのみメソッドを表すことができます。 したがって、上記のリストの最初と3番目の箇条書きのみがサポートされており、最初の箇条書きでは正確な型の一致が必要です。  
  
 デリゲートが最初の引数に対して閉じたインスタンスメソッドを表す場合 (最も一般的なケース)、デリゲートは、メソッドのエントリポイントへの参照と、ターゲットと呼ばれるオブジェクトへの参照を格納します。これは、b. デリゲートがオープンインスタンスメソッドを表す場合は、メソッドのエントリポイントへの参照を格納します。 デリゲートシグネチャには、非表示の `this` パラメーターを仮パラメーターリストに含める必要があります。この場合、デリゲートにはターゲットオブジェクトへの参照がなく、デリゲートの呼び出し時にターゲットオブジェクトを指定する必要があります。  
  
 デリゲートが静的メソッドを表す場合、デリゲートはメソッドのエントリポイントへの参照を格納します。 デリゲートが最初の引数に対して閉じた静的メソッドを表す場合、デリゲートはメソッドのエントリポイントへの参照と、メソッドの最初の引数の型に割り当て可能なターゲットオブジェクトへの参照を格納します。 デリゲートが呼び出されると、静的メソッドの最初の引数はターゲットオブジェクトを受け取ります。  
  
 デリゲートの呼び出しリストは、リストの各要素がデリゲートによって表されるメソッドの1つを厳密に呼び出すデリゲートの順序付きセットです。 呼び出しリストには、重複するメソッドを含めることができます。 呼び出し時に、メソッドは呼び出しリストに出現する順序で呼び出されます。 デリゲートは、呼び出しリスト内のすべてのメソッドを呼び出そうとします。重複は、呼び出しリストに出現するたびに1回呼び出されます。 デリゲートは変更できません。作成されると、デリゲートの呼び出しリストは変更されません。  
  
 デリゲートは1つ以上のメソッドを呼び出すことができ、組み合わせ操作で使用できるため、デリゲートはマルチキャスト (組み合わせ可能) と呼ばれます。  
  
 <xref:System.Delegate.Combine%2A> や <xref:System.Delegate.Remove%2A>などの組み合わせ操作では、既存のデリゲートを変更しません。 代わりに、このような操作では、操作の結果、変更されていないデリゲート、または `null`を含む新しいデリゲートが返されます。 結合操作は、操作の結果が1つ以上のメソッドを参照しないデリゲートである場合に `null` を返します。 結合操作は、要求された操作に影響がない場合に、変更されていないデリゲートを返します。  
  
> [!NOTE]
>  マネージ言語では、<xref:System.Delegate.Combine%2A> メソッドと <xref:System.Delegate.Remove%2A> メソッドを使用して、デリゲート操作を実装します。 例としては、Visual Basic 内の `AddHandler` および `RemoveHandler` ステートメントと、のC#デリゲート型に対する + = 演算子および-= 演算子があります。  
  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、ジェネリックデリゲート型にバリアント型パラメーターを含めることができます。 反変の型パラメーターは、デリゲートのパラメーターの型として使用できます。また、共変の型パラメーターを戻り値の型として使用することもできます。 この機能により、同じジェネリック型定義から構築されたジェネリックデリゲート型は、型引数が継承関係を持つ参照型である場合は、[共変性と反変性で説明されているように、割り当て互換になります。](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  分散によって割り当て互換性がある汎用デリゲートは、必ずしも組み合わせ可能であるとは限りません。 組み合わせ可能にするには、型が正確に一致している必要があります。 たとえば、`Derived` という名前のクラスが `Base`という名前のクラスから派生しているとします。 型 `Action<Base>` (Visual Basic 内の`Action(Of Base)`) のデリゲートは `Action<Derived>`型の変数に割り当てることができますが、型が正確に一致しないため、2つのデリゲートを組み合わせることはできません。  
  
 呼び出されたメソッドが例外をスローした場合、メソッドは実行を停止し、例外はデリゲートの呼び出し元に戻され、呼び出しリスト内の残りのメソッドは呼び出されません。 呼び出し元で例外をキャッチしても、この動作は変更されません。  
  
 デリゲートによって呼び出されたメソッドのシグネチャに戻り値が含まれている場合、デリゲートは呼び出しリスト内の最後の要素の戻り値を返します。 シグネチャに参照によって渡されたパラメーターが含まれている場合、パラメーターの最終的な値は、呼び出しリスト内のすべてのメソッドのうち、連続して実行され、パラメーターの値が更新された結果になります。  
  
 C のデリゲートに最も近いものは、関数ポインターです。 デリゲートは、静的メソッドまたはインスタンスメソッドを表すことができます。 デリゲートがインスタンスメソッドを表す場合、デリゲートは、メソッドのエントリポイントへの参照だけでなく、クラスインスタンスへの参照も格納します。 関数ポインターとは異なり、デリゲートはオブジェクト指向でタイプセーフです。  
  
   
  
## Examples  
 次の例は、`myMethodDelegate`という名前のデリゲートを定義する方法を示しています。 このデリゲートのインスタンスは、インスタンスメソッドと入れ子になった `mySampleClass` クラスの静的メソッドに対して作成されます。 インスタンスメソッドのデリゲートには `mySampleClass`のインスタンスが必要です。 `mySampleClass` インスタンスは `mySC`という名前の変数に保存されます。  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">同期メソッドの非同期呼び出し</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">デリゲート (C# プログラミング ガイド)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">デリゲート (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">方法: デリゲートを定義および使用する (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">イベントの処理と発生</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しいデリゲートを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">デリゲートが <paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <summary>指定したインスタンス メソッドを指定のクラス インスタンスに対して呼び出すデリゲートを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、アプリケーションコードでは使用できません。 インスタンスメソッドの名前を指定してデリゲートを作成するには、メソッド名とターゲットオブジェクトを指定する <xref:System.Delegate.CreateDelegate%2A> メソッドのオーバーロードを使用します。 たとえば、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> メソッドオーバーロードは、指定された名前を持つインスタンスメソッドのデリゲートを作成します。  
  
 このコンストラクターは、インスタンスメソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">呼び出し先のメソッドをバインドするときにエラーが発生しました。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target"><paramref name="method" /> を定義するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <summary>指定したクラスから指定の静的メソッドを呼び出すデリゲートを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、アプリケーションコードでは使用できません。 静的メソッドの名前を指定してデリゲートを作成するには、メソッド名を指定し、ターゲットオブジェクトを指定しない <xref:System.Delegate.CreateDelegate%2A> メソッドのオーバーロードを使用します。 たとえば、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> メソッドオーバーロードは、指定された名前を持つメソッドの静的デリゲートを作成します。  
  
 このコンストラクターは、静的メソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="target" /> は、オープン ジェネリック型を表します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>デリゲートの簡易コピーを作成します。</summary>
        <returns>デリゲートの簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複製には、元のデリゲートと同じ <xref:System.Type>、ターゲット、メソッド、および呼び出しリストがあります。  
  
 シャローコピーは、元のオブジェクトと同じ型の新しいインスタンスを作成し、元のオブジェクトの非静的フィールドをコピーします。 フィールドが値型の場合は、フィールドのビットごとのコピーが実行されます。 フィールドが参照型の場合、参照はコピーされますが、参照先のオブジェクトはコピーされません。したがって、元のオブジェクトの参照と複製内の参照は、同じオブジェクトを指します。 これに対し、オブジェクトの詳細コピーでは、オブジェクトのフィールドによって直接的または間接的に参照されるすべてのものが複製されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストを連結します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate[] delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (delegates As Delegate()) As Delegate" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">組み合わせるデリゲートの配列。</param>
        <summary>デリゲートの配列の呼び出しリストを連結します。</summary>
        <returns><paramref name="delegates" /> 配列内のデリゲートの呼び出しリストが連結された単一の呼び出しリストを持つ新しいデリゲート。 <paramref name="delegates" /> が <see langword="null" /> の場合、<paramref name="delegates" /> の要素が 0 個の場合、または <paramref name="delegates" /> のすべてのエントリが <see langword="null" /> の場合は、<see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `delegates` 配列に `null`れるエントリが含まれている場合、それらのエントリは無視されます。  
  
 呼び出しリストには、重複するエントリを含めることができます。つまり、同じオブジェクトで同じメソッドを参照するエントリです。  
  
> [!NOTE]
>  分散によって割り当て互換性がある汎用デリゲートは、必ずしも組み合わせ可能であるとは限りません。 組み合わせ可能にするには、型が正確に一致している必要があります。 たとえば、`Derived` という名前のクラスが `Base`という名前のクラスから派生しているとします。 `Action<Base>` (Visual Basic 内の`Action(Of Base)`) のデリゲートは `Action<Derived>`型の変数に割り当てることができますが、「[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)」で説明されていますが、型が正確に一致しないため、2つのデリゲートを組み合わせることはできません。  
  
 <xref:System.Delegate.Combine%2A> は、イベントが発生するたびに複数のメソッドを呼び出すイベントハンドラーを作成する場合に便利です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="delegates" /> 内の null でないすべてのエントリが同じデリゲート型のインスタンスではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">連結後のリスト内で前に配置する呼び出しリストを持つデリゲート。</param>
        <param name="b">連結後のリスト内で後に配置する呼び出しリストを持つデリゲート。</param>
        <summary>2 つのデリゲートの呼び出しリストを連結します。</summary>
        <returns><paramref name="a" /> と <paramref name="b" /> の呼び出しリストをこの順番で連結した単一の呼び出しリストを持つ新しいデリゲート。 <paramref name="b" /> が <see langword="null" /> の場合は <paramref name="a" /> を、<paramref name="a" /> が null 参照の場合は <paramref name="b" /> を返します。また、<paramref name="a" /> と <paramref name="b" /> の両方が null 参照の場合は null 参照を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しリストには、重複するエントリを含めることができます。つまり、同じオブジェクトで同じメソッドを参照するエントリです。  
  
> [!NOTE]
>  分散によって割り当て互換性がある汎用デリゲートは、必ずしも組み合わせ可能であるとは限りません。 組み合わせ可能にするには、型が正確に一致している必要があります。 たとえば、`Derived` という名前のクラスが `Base`という名前のクラスから派生しているとします。 `Action<Base>` (Visual Basic 内の`Action(Of Base)`) のデリゲートは `Action<Derived>`型の変数に割り当てることができますが、「[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)」で説明されていますが、型が正確に一致しないため、2つのデリゲートを組み合わせることはできません。  
  
 <xref:System.Delegate.Combine%2A> は、イベントが発生するたびに複数のメソッドを呼び出すイベントハンドラーを作成する場合に便利です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="a" /> と <paramref name="b" /> の両方が <see langword="null" /> ではなく、<paramref name="a" /> と <paramref name="b" /> が同じデリゲート型のインスタンスではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">現在のマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストの末尾に追加される呼び出しリストを持つマルチキャスト (組み合わせ可能) デリゲート。</param>
        <summary>指定したマルチキャスト (組み合わせ可能) デリゲートと現在のマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストを連結します。</summary>
        <returns>現在のマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストと <paramref name="d" /> の呼び出しリストを連結した単一の呼び出しリストを持つ新しいマルチキャスト (組み合わせ可能) デリゲート。<paramref name="d" /> が <see langword="null" /> の場合は、現在のマルチキャスト (組み合わせ可能) デリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のデリゲートがマルチキャスト (組み合わせ可能) である場合にのみ適用されます。  
  
 現在の実装では、単に <xref:System.MulticastNotSupportedException>がスローされます。  
  
 呼び出しリストには、重複するエントリを含めることができます。つまり、同じオブジェクトで同じメソッドを参照するエントリです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">常にスローされます。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型のデリゲートを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を記述する <see cref="T:System.Reflection.MethodInfo" />。 .NET Framework Version 1.0 および 1.1 では、静的メソッドのみサポートされます。</param>
        <summary>指定した静的メソッドを表すために、指定した型のデリゲートを作成します。</summary>
        <returns>指定した静的メソッドを表すための、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework バージョン1.0 および1.1 では、このメソッドオーバーロードは静的メソッドに対してのみデリゲートを作成します。 .NET Framework バージョン2.0 では、このメソッドオーバーロードは、オープンインスタンスメソッドデリゲートを作成することもできます。つまり、インスタンスメソッドの非表示の最初の引数を明示的に指定するデリゲート。 詳細については、「メソッドの <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 一般的なオーバーロード」を参照してください。これにより、インスタンスまたは静的メソッドのオープンまたはクローズデリゲートのすべての組み合わせを作成できます。また、必要に応じて、最初の引数を指定することもできます。  
  
> [!NOTE]
>  このメソッドオーバーロードは、デリゲートが最初の引数に対して閉じられていない場合に使用する必要があります。これは、その場合は多少高速になるためです。  
  
 このメソッドのオーバーロードは、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`throwOnBindFailure`に `true` を指定することと同じです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 .NET Framework バージョン2.0 では、このメソッドオーバーロードを使用して作成されたデリゲートのパラメーターの型と戻り値の型は、デリゲートが表すメソッドのパラメーターの型および戻り値の型と互換性がある必要があります。型が正確に一致する必要はありません。 これは .NET Framework バージョン1.0 および1.1 でのバインディング動作の緩和を表します。この場合、型は正確に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型 <xref:System.Collections.Hashtable> のパラメーターと <xref:System.Object> の戻り値の型を持つデリゲートは、<xref:System.Object> 型のパラメーターと <xref:System.Collections.Hashtable>型の戻り値を持つメソッドを表すことができます。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例は、このメソッドオーバーロードを使用して作成できる2種類のデリゲートを示しています。これは、インスタンスメソッドを開き、静的メソッドで開くことができます。  
  
 2番目のコード例は、互換性のあるパラメーターの型と戻り値の型を示しています。  
  
 **例1**  
  
 次のコード例は、<xref:System.Delegate.CreateDelegate%2A> メソッドのこのオーバーロードを使用してデリゲートを作成する2つの方法を示しています。  
  
> [!NOTE]
>  最初の引数ではなく <xref:System.Reflection.MethodInfo> を指定する <xref:System.Delegate.CreateDelegate%2A> メソッドのオーバーロードが2つあります。これらの機能は同じですが、バインドに失敗した場合にをスローするかどうかを指定でき、もう1つは常にをスローします。 このコード例では、両方のオーバーロードを使用します。  
  
 この例では、静的メソッド `M2`、インスタンスメソッド `M1`、および2つのデリゲート型を使用して `C` クラスを宣言します。 `D1` は、`C` と文字列のインスタンスを受け取り、`D2` は文字列を受け取ります。  
  
 `Example` という名前の2番目のクラスには、デリゲートを作成するコードが含まれています。  
  
-   オープンインスタンスメソッドを表す `D1`型のデリゲートが、インスタンスメソッド `M1`に対して作成されます。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   オープンな静的メソッドを表す `D2`型のデリゲートは、静的メソッド `M2`に対して作成されます。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例2**  
  
 次のコード例は、パラメーターの型と戻り値の型の互換性を示しています。  
  
 このコード例では、`Base` という名前の基底クラスと、`Base`から派生する `Derived` という名前のクラスを定義しています。 派生クラスには、`Base` 型の1つのパラメーターと `Derived`の戻り値の型を持つ `MyMethod` という名前の `static` (`Shared` Visual Basic) メソッドがあります。 このコード例では、`Derived` 型の1つのパラメーターと `Base`の戻り値の型を持つ `Example` という名前のデリゲートも定義します。  
  
 このコード例は、`Example` という名前のデリゲートを使用して、メソッド `MyMethod`を表すことができることを示しています。 メソッドは、次の理由によりデリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) は `MyMethod` (`Base`) のパラメーターの型よりも制限が厳しいため、デリゲートの引数を常に `MyMethod`に渡すことが安全です。  
  
-   `MyMethod` (`Derived`) の戻り値の型は、デリゲートのパラメーターの型 (`Base`) よりも制限が厳しいため、メソッドの戻り値の型をデリゲートの戻り値の型に常にキャストできます。  
  
 このコード例では、出力は生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> は静的メソッドではなく、.NET Framework バージョンは 1.0 または 1.1 です。  
  
- または - 
 <paramref name="method" /> はバインドできません。  
  
- または - 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="firstArgument">デリゲートのバインド先のオブジェクト。<paramref name="method" /> を <see langword="static" /> (Visual Basic の場合は <see langword="Shared" />) として扱う場合は <see langword="null" />。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を記述する <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>指定された静的メソッドまたはインスタンス メソッドを表す、指定した型のデリゲートを、第 1 引数を指定して作成します。</summary>
        <returns>指定した静的メソッドまたはインスタンス メソッドを表すための、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`throwOnBindFailure`に `true` を指定することと同じです。 これらの2つのオーバーロードは、最も柔軟なデリゲートを作成する方法を提供します。 これらのメソッドを使用して、静的メソッドまたはインスタンスメソッドのデリゲートを作成できます。また、必要に応じて、最初の引数を指定することもできます。  
  
> [!NOTE]
>  最初の引数を指定しない場合は、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> メソッドのオーバーロードを使用してパフォーマンスを向上させます。  
  
 デリゲート型とメソッドは、互換性のある戻り値の型を持っている必要があります。 つまり、`method` の戻り値の型は `type`の戻り値の型に割り当て可能である必要があります。  
  
 `firstArgument` が指定されている場合、デリゲートが呼び出されるたびに `method` に渡されます。`firstArgument` はデリゲートにバインドされており、デリゲートは最初の引数に対して閉じられていると言います。 `method` が `static` (Visual Basic で`Shared`) の場合、デリゲートを呼び出すときに指定される引数リストには、最初のパラメーターを除くすべてのパラメーターが含まれます。`method` がインスタンスメソッドの場合、`firstArgument` は非表示のインスタンスパラメーターに渡されます (のC#`this` によって表されるか、Visual Basic で `Me`)。  
  
 `firstArgument` が指定されている場合、`method` の最初のパラメーターは参照型である必要があり、`firstArgument` はその型と互換性がある必要があります。  
  
> [!IMPORTANT]
>  `method` が `static` (Visual Basic で`Shared`) で、その最初のパラメーターの型が <xref:System.Object> または <xref:System.ValueType>の場合は、`firstArgument` 値型にすることができます。 この場合、`firstArgument` は自動的にボックス化されます。 C#または Visual Basic 関数呼び出しの場合と同様に、他の引数に対して自動ボックス化は行われません。  
  
 `firstArgument` が null 参照で、`method` がインスタンスメソッドの場合、結果は `method`のデリゲート型 `type` およびのシグネチャに依存します。  
  
-   `type` のシグネチャに `method`の最初の非表示パラメーターが明示的に含まれている場合、デリゲートはオープンインスタンスメソッドを表していると言います。 デリゲートが呼び出されると、引数リストの最初の引数が `method`の非表示インスタンスパラメーターに渡されます。  
  
-   `method` と `type` のシグネチャが一致する場合 (つまり、すべてのパラメーターの型に互換性がある場合)、デリゲートは null 参照に対して閉じられると言われます。 デリゲートの呼び出しは、null インスタンスでのインスタンスメソッドの呼び出しと似ていますが、これは特に便利な操作ではありません。  
  
 `firstArgument` が null 参照で `method` が静的である場合、結果は `method`のデリゲート型 `type` およびのシグネチャに依存します。  
  
-   `method` と `type` のシグネチャが一致する場合 (つまり、すべてのパラメーターの型に互換性がある場合)、デリゲートはオープンな静的メソッドを表すと言います。 これは、静的メソッドの最も一般的な例です。 この場合、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> メソッドのオーバーロードを使用すると、パフォーマンスが若干向上します。  
  
-   `type` のシグネチャが `method` の2番目のパラメーターで始まり、その他のパラメーターの型に互換性がある場合、デリゲートは null 参照で閉じられていると言います。 デリゲートが呼び出されると、`method`の最初のパラメーターに null 参照が渡されます。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 デリゲートのパラメーターの型と戻り値の型は、デリゲートが表すメソッドのパラメーターの型および戻り値の型と互換性がある必要があります。型が正確に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework バージョン1.0 および1.1 では、型は正確に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型 <xref:System.Collections.Hashtable> のパラメーターと <xref:System.Object> の戻り値の型を持つデリゲートは、<xref:System.Object> 型のパラメーターと <xref:System.Collections.Hashtable>型の戻り値を持つメソッドを表すことができます。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>デリゲートが表すことができるメソッドの決定  
 <xref:System.Delegate.CreateDelegate%2A> のこのオーバーロードによって提供される柔軟性を考慮するもう1つの便利な方法として、特定のデリゲートは、メソッドシグネチャとメソッドの種類 (静的とインスタンス) の4種類の組み合わせを表すことができます。 `C`型の引数を1つ持つ `D` デリゲート型を考えてみます。 次の例では、すべての場合に一致する必要があるため、戻り値の型を無視して `D` が表すことができるメソッドについて説明します。  
  
-   `D` は、インスタンスメソッドが属する型に関係なく、`C`型の引数を1つだけ持つインスタンスメソッドを表すことができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は `method` が属している型のインスタンスになり、結果として得られるデリゲートはそのインスタンス上で閉じられると言います。 (`firstArgument` が null 参照である場合は、`D` を null 参照に対しても閉じることができます)。  
  
-   `D` は、引数を持たない `C` のインスタンスメソッドを表すことができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は null 参照になります。 結果として得られるデリゲートは、オープンインスタンスメソッドを表します。 `C` のインスタンスは、呼び出されるたびに指定する必要があります。  
  
-   `D` は、`C`型の1つの引数を受け取る静的メソッドを表すことができ、そのメソッドは任意の型に属することができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は null 参照になります。 結果として得られるデリゲートは、オープンな静的メソッドを表します。 `C` のインスタンスは、呼び出されるたびに指定する必要があります。  
  
-   `D` は、型 `F` に属し、型 `F` および型 `C`の2つの引数を持つ静的メソッドを表すことができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は `F`のインスタンスになります。 生成されるデリゲートは、`F`のそのインスタンスで閉じられる静的メソッドを表します。 `F` と `C` が同じ型である場合、静的メソッドにはその型の2つの引数があります。 (この場合、`firstArgument` が null 参照である場合、`D` は null 参照に対して閉じられます)。  
  
   
  
## Examples  
 ここでは、3つのコード例について説明します。 最初の例では、作成可能な4種類のデリゲートを示しています。これは、インスタンスメソッドで終了し、インスタンスメソッドを開いて、静的メソッドを開いた後、静的メソッドで終了します。  
  
 2番目のコード例は、互換性のあるパラメーターの型と戻り値の型を示しています。  
  
 3番目のコード例では、単一のデリゲート型を定義し、デリゲート型が表すことができるすべてのメソッドを示します。  
  
 **例1**  
  
 次のコード例は、<xref:System.Delegate.CreateDelegate%2A> メソッドのこのオーバーロードを使用してデリゲートを作成する4つの方法を示しています。  
  
> [!NOTE]
>  `firstArgument` と <xref:System.Reflection.MethodInfo>を指定する <xref:System.Delegate.CreateDelegate%2A> メソッドには、2つのオーバーロードがあります。これらの機能は同じですが、バインドに失敗した場合にをスローするかどうかを指定でき、もう1つは常にをスローします。 このコード例では、両方のオーバーロードを使用します。  
  
 この例では、静的メソッド `M2` とインスタンスメソッド `M1`、および3つのデリゲート型を使用して `C` クラスを宣言します。 `D1` は、`C` のインスタンスと文字列を受け取り、`D2` は引数を受け取りません。`D3`  
  
 `Example` という名前の2番目のクラスには、デリゲートを作成するコードが含まれています。  
  
-   `C`のインスタンスで終了した `D2`型のデリゲートが、インスタンスメソッド `M1`に対して作成されます。 `C` のバインドされたインスタンスが常に使用されることを示すために、異なる文字列を使用して呼び出されます。  
  
-   オープンインスタンスメソッドを表す `D1`型のデリゲートが、インスタンスメソッド `M1`に対して作成されます。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   オープンな静的メソッドを表す `D2`型のデリゲートは、静的メソッド `M2`に対して作成されます。  
  
-   最後に、文字列に対して閉じられた `D3`型のデリゲートが、静的メソッド `M2`に対して作成されます。 メソッドは、バインドされた文字列を使用していることを示すために呼び出されます。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例2**  
  
 次のコード例は、パラメーターの型と戻り値の型の互換性を示しています。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> メソッドのオーバーロードを使用します。 <xref:System.Reflection.MethodInfo> を受け取る他のオーバーロードの使用は似ています。  
  
 このコード例では、`Base` という名前の基底クラスと、`Base`から派生する `Derived` という名前のクラスを定義しています。 派生クラスには、`Base` 型の1つのパラメーターと `Derived`の戻り値の型を持つ `MyMethod` という名前の `static` (`Shared` Visual Basic) メソッドがあります。 このコード例では、`Derived` 型の1つのパラメーターと `Base`の戻り値の型を持つ `Example` という名前のデリゲートも定義します。  
  
 このコード例は、`Example` という名前のデリゲートを使用して、メソッド `MyMethod`を表すことができることを示しています。 メソッドは、次の理由によりデリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) は `MyMethod` (`Base`) のパラメーターの型よりも制限が厳しいため、デリゲートの引数を常に `MyMethod`に渡すことが安全です。  
  
-   `MyMethod` (`Derived`) の戻り値の型は、デリゲートのパラメーターの型 (`Base`) よりも制限が厳しいため、メソッドの戻り値の型をデリゲートの戻り値の型に常にキャストできます。  
  
 このコード例では、出力は生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **例3**  
  
 次のコード例は、デリゲートを作成するために <xref:System.Delegate.CreateDelegate%2A> メソッドを使用して、1つのデリゲート型が表すことができるすべてのメソッドを示しています。  
  
> [!NOTE]
>  `firstArgument` と <xref:System.Reflection.MethodInfo>を指定する <xref:System.Delegate.CreateDelegate%2A> メソッドには、2つのオーバーロードがあります。これらの機能は同じですが、バインドに失敗した場合にをスローするかどうかを指定でき、もう1つは常にをスローします。 このコード例では、両方のオーバーロードを使用します。  
  
 このコード例では、`C` と `F`の2つのクラスと、`C`型の引数を1つ持つ `D` デリゲート型を定義しています。 クラスは、静的メソッドとインスタンスメソッド `M1`、`M3`、および `M4`に一致します。また、クラス `C` には、引数を持たないインスタンスメソッド `M2` もあります。  
  
 `Example` という名前の3番目のクラスには、デリゲートを作成するコードが含まれています。  
  
-   デリゲートは、インスタンスメソッド `M1` `C` 型および型 `F`; に対して作成されます。各は、それぞれの型のインスタンスに対して閉じられます。 `C` 型のメソッド `M1` は、バインドされたインスタンスと引数の `ID` プロパティを表示します。  
  
-   `C`型のメソッド `M2` に対してデリゲートが作成されます。 これはオープンインスタンスデリゲートであり、デリゲートの引数はインスタンスメソッドの非表示の最初の引数を表します。 メソッドに他の引数はありません。 静的メソッドであるかのように呼び出されます。  
  
-   デリゲートは、型 `C` 型および型 `F`; の静的メソッド `M3` に対して作成されます。これらはオープンスタティックデリゲートです。  
  
-   最後に、`C` 型および型 `F`; の静的メソッド `M4` に対してデリゲートが作成されます。各メソッドには、最初の引数として宣言する型があり、型のインスタンスが指定されているため、デリゲートは最初の引数に対して閉じられます。 `C` 型のメソッド `M4` は、バインドされたインスタンスと引数の `ID` プロパティを表示します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> はバインドできません。  
  
- または - 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <summary>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インスタンスメソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバーロードは、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`throwOnBindFailure`の `ignoreCase` と `true` に `false` を指定した場合と同じです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> はインスタンス メソッドではありません。  
  
- または - 
 <paramref name="method" /> をバインドできません (たとえば、これが見つからないなど)。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を記述する <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された静的メソッドを表す、指定された型のデリゲートを、バインドに失敗した場合の動作を指定して作成します。</summary>
        <returns>指定した静的メソッドを表すための、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドオーバーロードは、開いている静的メソッドデリゲートを作成し、インスタンスメソッドデリゲートを開くことができます。つまり、インスタンスメソッドの非表示の最初の引数を公開するデリゲートです。 詳細については、「メソッドの <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 一般的なオーバーロード」を参照してください。これにより、インスタンスまたは静的メソッドに対して、オープンまたはクローズされたデリゲートのすべての組み合わせを作成できます。  
  
> [!NOTE]
>  このメソッドオーバーロードは、デリゲートが最初の引数に対して閉じられていない場合に使用する必要があります。これは、その場合は多少高速になるためです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 デリゲートのパラメーターの型と戻り値の型は、デリゲートが表すメソッドのパラメーターの型および戻り値の型と互換性がある必要があります。型が正確に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework バージョン1.0 および1.1 では、型は正確に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型 <xref:System.Collections.Hashtable> のパラメーターと <xref:System.Object> の戻り値の型を持つデリゲートは、<xref:System.Object> 型のパラメーターと <xref:System.Collections.Hashtable>型の戻り値を持つメソッドを表すことができます。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例は、このメソッドオーバーロードを使用して作成できる2種類のデリゲートを示しています。これは、インスタンスメソッドを開き、静的メソッドで開くことができます。  
  
 2番目のコード例は、互換性のあるパラメーターの型と戻り値の型を示しています。  
  
 **例1**  
  
 次のコード例は、<xref:System.Delegate.CreateDelegate%2A> メソッドのこのオーバーロードを使用してデリゲートを作成する2つの方法を示しています。  
  
> [!NOTE]
>  最初の引数ではなく <xref:System.Reflection.MethodInfo> を指定する <xref:System.Delegate.CreateDelegate%2A> メソッドのオーバーロードが2つあります。これらの機能は同じですが、バインドに失敗した場合にをスローするかどうかを指定でき、もう1つは常にをスローします。 このコード例では、両方のオーバーロードを使用します。  
  
 この例では、静的メソッド `M2`、インスタンスメソッド `M1`、および2つのデリゲート型を使用して `C` クラスを宣言します。 `D1` は、`C` と文字列のインスタンスを受け取り、`D2` は文字列を受け取ります。  
  
 `Example` という名前の2番目のクラスには、デリゲートを作成するコードが含まれています。  
  
-   オープンインスタンスメソッドを表す `D1`型のデリゲートが、インスタンスメソッド `M1`に対して作成されます。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   オープンな静的メソッドを表す `D2`型のデリゲートは、静的メソッド `M2`に対して作成されます。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例2**  
  
 次のコード例は、パラメーターの型と戻り値の型の互換性を示しています。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> メソッドのオーバーロードを使用します。 <xref:System.Reflection.MethodInfo> を受け取る他のオーバーロードの使用は似ています。  
  
 このコード例では、`Base` という名前の基底クラスと、`Base`から派生する `Derived` という名前のクラスを定義しています。 派生クラスには、`Base` 型の1つのパラメーターと `Derived`の戻り値の型を持つ `MyMethod` という名前の `static` (`Shared` Visual Basic) メソッドがあります。 このコード例では、`Derived` 型の1つのパラメーターと `Base`の戻り値の型を持つ `Example` という名前のデリゲートも定義します。  
  
 このコード例は、`Example` という名前のデリゲートを使用して、メソッド `MyMethod`を表すことができることを示しています。 メソッドは、次の理由によりデリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) は `MyMethod` (`Base`) のパラメーターの型よりも制限が厳しいため、デリゲートの引数を常に `MyMethod`に渡すことが安全です。  
  
-   `MyMethod` (`Derived`) の戻り値の型は、デリゲートのパラメーターの型 (`Base`) よりも制限が厳しいため、メソッドの戻り値の型をデリゲートの戻り値の型に常にキャストできます。  
  
 このコード例では、出力は生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> はバインドできず、<paramref name="throwOnBindFailure" /> は <see langword="true" /> です。  
  
- または - 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を実装するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <summary>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバーロードは、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`throwOnBindFailure`の `ignoreCase` と `true` に `false` を指定した場合と同じです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="target" /> が <see langword="RuntimeType" /> ではありません。  
  
- または - 
 <paramref name="target" /> はオープン ジェネリック型です。 つまり、その <see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="static" /> メソッド (Visual Basic では <see langword="Shared" /> メソッド) ではありません。  
  
- または - 
 見つからないなどの原因により、<paramref name="method" /> をバインドできません。また、<paramref name="throwOnBindFailure" /> が <see langword="true" /> です。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの型を表す <see cref="T:System.Type" />。</param>
        <param name="firstArgument">デリゲートが表すメソッドの第 1 引数である <see cref="T:System.Object" />。 インスタンス メソッドの場合は、そのインスタンスの型との互換性が必要です。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を保持する <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された静的メソッドまたはインスタンス メソッドを表す、指定した型のデリゲートを、第 1 引数およびバインドに失敗したときの動作を指定して作成します。</summary>
        <returns>指定された静的メソッドまたはインスタンス メソッドを表す、指定された型のデリゲート。<paramref name="throwOnBindFailure" /> が <see langword="false" /> で、デリゲートを <paramref name="method" /> にバインドできない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバーロードと <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> メソッドのオーバーロードは、バインドに失敗した場合は常にをスローします。これにより、デリゲートを作成するための最も柔軟な方法が提供されます。 これらのメソッドを使用すると、最初の引数の有無にかかわらず、静的メソッドまたはインスタンスメソッドのデリゲートを作成できます。  
  
> [!NOTE]
>  最初の引数を指定しない場合は、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> メソッドのオーバーロードを使用してパフォーマンスを向上させます。  
  
 デリゲート型とメソッドは、互換性のある戻り値の型を持っている必要があります。 つまり、`method` の戻り値の型は `type`の戻り値の型に割り当て可能である必要があります。  
  
 `firstArgument` が指定されている場合、デリゲートが呼び出されるたびに `method` に渡されます。`firstArgument` はデリゲートにバインドされており、デリゲートは最初の引数に対して閉じられていると言います。 `method` が `static` (Visual Basic で`Shared`) の場合、デリゲートを呼び出すときに指定される引数リストには、最初のパラメーターを除くすべてのパラメーターが含まれます。`method` がインスタンスメソッドの場合、`firstArgument` は非表示のインスタンスパラメーターに渡されます (のC#`this` によって表されるか、Visual Basic で `Me`)。  
  
 `firstArgument` が指定されている場合、`method` の最初のパラメーターは参照型である必要があり、`firstArgument` はその型と互換性がある必要があります。  
  
> [!IMPORTANT]
>  `method` が `static` (Visual Basic で`Shared`) で、その最初のパラメーターの型が <xref:System.Object> または <xref:System.ValueType>の場合は、`firstArgument` 値型にすることができます。 この場合、`firstArgument` は自動的にボックス化されます。 C#または Visual Basic 関数呼び出しの場合と同様に、他の引数に対して自動ボックス化は行われません。  
  
 `firstArgument` が null 参照で、`method` がインスタンスメソッドの場合、結果は `method`のデリゲート型 `type` およびのシグネチャに依存します。  
  
-   `type` のシグネチャに `method`の最初の非表示パラメーターが明示的に含まれている場合、デリゲートはオープンインスタンスメソッドを表していると言います。 デリゲートが呼び出されると、引数リストの最初の引数が `method`の非表示インスタンスパラメーターに渡されます。  
  
-   `method` と `type` のシグネチャが一致する場合 (つまり、すべてのパラメーターの型に互換性がある場合)、デリゲートは null 参照に対して閉じられると言われます。 デリゲートの呼び出しは、null インスタンスでのインスタンスメソッドの呼び出しと似ていますが、これは特に便利な操作ではありません。  
  
 `firstArgument` が null 参照で `method` が静的である場合、結果は `method`のデリゲート型 `type` およびのシグネチャに依存します。  
  
-   `method` と `type` のシグネチャが一致する場合 (つまり、すべてのパラメーターの型に互換性がある場合)、デリゲートはオープンな静的メソッドを表すと言います。 これは、静的メソッドの最も一般的な例です。 この場合、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> メソッドのオーバーロードを使用すると、パフォーマンスが若干向上します。  
  
-   `type` のシグネチャが `method` の2番目のパラメーターで始まり、その他のパラメーターの型に互換性がある場合、デリゲートは null 参照で閉じられていると言います。 デリゲートが呼び出されると、`method`の最初のパラメーターに null 参照が渡されます。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 デリゲートのパラメーターの型と戻り値の型は、デリゲートが表すメソッドのパラメーターの型および戻り値の型と互換性がある必要があります。型が正確に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework バージョン1.0 および1.1 では、型は正確に一致している必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型 <xref:System.Collections.Hashtable> のパラメーターと <xref:System.Object> の戻り値の型を持つデリゲートは、<xref:System.Object> 型のパラメーターと <xref:System.Collections.Hashtable>型の戻り値を持つメソッドを表すことができます。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>デリゲートが表すことができるメソッドの決定  
 <xref:System.Delegate.CreateDelegate%2A> のこのオーバーロードによって提供される柔軟性を考慮するもう1つの便利な方法として、特定のデリゲートは、メソッドシグネチャとメソッドの種類 (静的とインスタンス) の4種類の組み合わせを表すことができます。 `C`型の引数を1つ持つ `D` デリゲート型を考えてみます。 次の例では、すべての場合に一致する必要があるため、戻り値の型を無視して `D` が表すことができるメソッドについて説明します。  
  
-   `D` は、インスタンスメソッドが属する型に関係なく、`C`型の引数を1つだけ持つインスタンスメソッドを表すことができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は `method` が属している型のインスタンスになり、結果として得られるデリゲートはそのインスタンス上で閉じられると言います。 (`firstArgument` が `null`ている場合は、null 参照を使用して `D` することもできます)。  
  
-   `D` は、引数を持たない `C` のインスタンスメソッドを表すことができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は null 参照になります。 結果として得られるデリゲートは、オープンインスタンスメソッドを表します。 `C` のインスタンスは、呼び出されるたびに指定する必要があります。  
  
-   `D` は、`C`型の1つの引数を受け取る静的メソッドを表すことができ、そのメソッドは任意の型に属することができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は null 参照になります。 結果として得られるデリゲートは、オープンな静的メソッドを表します。 `C` のインスタンスは、呼び出されるたびに指定する必要があります。  
  
-   `D` は、型 `F` に属し、型 `F` および型 `C`の2つの引数を持つ静的メソッドを表すことができます。 <xref:System.Delegate.CreateDelegate%2A> が呼び出されると、`firstArgument` は `F`のインスタンスになります。 生成されるデリゲートは、`F`のそのインスタンスで閉じられる静的メソッドを表します。 `F` と `C` が同じ型である場合、静的メソッドにはその型の2つの引数があります。 (この場合、`firstArgument` が `null`場合、`D` は null 参照に対して閉じられます)。  
  
   
  
## Examples  
 ここでは、3つのコード例について説明します。 最初の例では、作成可能な4種類のデリゲートを示しています。これは、インスタンスメソッドで終了し、インスタンスメソッドを開いて、静的メソッドを開いた後、静的メソッドで終了します。  
  
 2番目のコード例は、互換性のあるパラメーターの型と戻り値の型を示しています。  
  
 3番目のコード例では、単一のデリゲート型を定義し、デリゲート型が表すことができるすべてのメソッドを示します。  
  
 **例1**  
  
 次のコード例は、<xref:System.Delegate.CreateDelegate%2A> メソッドのこのオーバーロードを使用してデリゲートを作成する4つの方法を示しています。  
  
> [!NOTE]
>  `firstArgument` と <xref:System.Reflection.MethodInfo>を指定する <xref:System.Delegate.CreateDelegate%2A> メソッドには、2つのオーバーロードがあります。これらの機能は同じですが、バインドに失敗した場合にをスローするかどうかを指定でき、もう1つは常にをスローします。 このコード例では、両方のオーバーロードを使用します。  
  
 この例では、静的メソッド `M2` とインスタンスメソッド `M1`、および3つのデリゲート型を使用して `C` クラスを宣言します。 `D1` は、`C` のインスタンスと文字列を受け取り、`D2` は引数を受け取りません。`D3`  
  
 `Example` という名前の2番目のクラスには、デリゲートを作成するコードが含まれています。  
  
-   `C`のインスタンスで終了した `D2`型のデリゲートが、インスタンスメソッド `M1`に対して作成されます。 `C` のバインドされたインスタンスが常に使用されることを示すために、異なる文字列を使用して呼び出されます。  
  
-   オープンインスタンスメソッドを表す `D1`型のデリゲートが、インスタンスメソッド `M1`に対して作成されます。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   オープンな静的メソッドを表す `D2`型のデリゲートは、静的メソッド `M2`に対して作成されます。  
  
-   最後に、文字列に対して閉じられた `D3`型のデリゲートが、静的メソッド `M2`に対して作成されます。 メソッドは、バインドされた文字列を使用していることを示すために呼び出されます。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例2**  
  
 次のコード例は、パラメーターの型と戻り値の型の互換性を示しています。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> メソッドのオーバーロードを使用します。 <xref:System.Reflection.MethodInfo> を受け取る他のオーバーロードの使用は似ています。  
  
 このコード例では、`Base` という名前の基底クラスと、`Base`から派生する `Derived` という名前のクラスを定義しています。 派生クラスには、`Base` 型の1つのパラメーターと `Derived`の戻り値の型を持つ `MyMethod` という名前の `static` (`Shared` Visual Basic) メソッドがあります。 このコード例では、`Derived` 型の1つのパラメーターと `Base`の戻り値の型を持つ `Example` という名前のデリゲートも定義します。  
  
 このコード例は、`Example` という名前のデリゲートを使用して、メソッド `MyMethod`を表すことができることを示しています。 メソッドは、次の理由によりデリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) は `MyMethod` (`Base`) のパラメーターの型よりも制限が厳しいため、デリゲートの引数を常に `MyMethod`に渡すことが安全です。  
  
-   `MyMethod` (`Derived`) の戻り値の型は、デリゲートのパラメーターの型 (`Base`) よりも制限が厳しいため、メソッドの戻り値の型をデリゲートの戻り値の型に常にキャストできます。  
  
 このコード例では、出力は生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **例3**  
  
 次のコード例は、単一のデリゲート型が表すことができるすべてのメソッドを示しています。  
  
> [!NOTE]
>  `firstArgument` と <xref:System.Reflection.MethodInfo>を指定する <xref:System.Delegate.CreateDelegate%2A> メソッドには、2つのオーバーロードがあります。これらの機能は同じですが、バインドに失敗した場合にをスローするかどうかを指定でき、もう1つは常にをスローします。 このコード例では、両方のオーバーロードを使用します。  
  
 このコード例では、`C` と `F`の2つのクラスと、`C`型の引数を1つ持つ `D` デリゲート型を定義しています。 クラスは、静的メソッドとインスタンスメソッド `M1`、`M3`、および `M4`に一致します。また、クラス `C` には、引数を持たないインスタンスメソッド `M2` もあります。  
  
 `Example` という名前の3番目のクラスには、デリゲートを作成するコードが含まれています。  
  
-   デリゲートは、インスタンスメソッド `M1` `C` 型および型 `F`; に対して作成されます。各は、それぞれの型のインスタンスに対して閉じられます。 `C` 型のメソッド `M1` は、バインドされたインスタンスと引数の `ID` プロパティを表示します。  
  
-   `C`型のメソッド `M2` に対してデリゲートが作成されます。 これはオープンインスタンスデリゲートであり、デリゲートの引数はインスタンスメソッドの非表示の最初の引数を表します。 メソッドに他の引数はありません。  
  
-   デリゲートは、型 `C` 型および型 `F`; の静的メソッド `M3` に対して作成されます。これらはオープンスタティックデリゲートです。  
  
-   最後に、`C` 型および型 `F`; の静的メソッド `M4` に対してデリゲートが作成されます。各メソッドには、最初の引数として宣言する型があり、型のインスタンスが指定されているため、デリゲートは最初の引数に対して閉じられます。 `C` 型のメソッド `M4` は、バインドされたインスタンスと引数の `ID` プロパティを表示します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> はバインドできず、<paramref name="throwOnBindFailure" /> は <see langword="true" /> です。  
  
- または - 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <summary>大文字と小文字の区別方法を指定して、指定したクラス インスタンスに対して呼び出す指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インスタンスメソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバーロードは、`throwOnBindFailure`に `true` を指定して <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出すことと同じです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> はインスタンス メソッドではありません。  
  
- または - 
 <paramref name="method" /> をバインドできません (たとえば、これが見つからないなど)。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を実装するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <summary>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲートを、大文字と小文字の区別方法を指定して作成します。</summary>
        <returns>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバーロードは、`throwOnBindFailure`に `true` を指定して <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出すことと同じです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="target" /> が <see langword="RuntimeType" /> ではありません。  
  
- または - 
 <paramref name="target" /> はオープン ジェネリック型です。 つまり、その <see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="static" /> メソッド (Visual Basic では <see langword="Shared" /> メソッド) ではありません。  
  
- または - 
 <paramref name="method" /> をバインドできません (たとえば、これが見つからないなど)。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>大文字と小文字の区別方法およびバインドに失敗したときの動作を指定して、指定したクラス インスタンスに対して呼び出す指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インスタンスメソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> はインスタンス メソッドではありません。  
  
- または - 
 見つからないなどの原因により、<paramref name="method" /> をバインドできません。また、<paramref name="throwOnBindFailure" /> が <see langword="true" /> です。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を実装するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>大文字と小文字の区別方法およびバインドに失敗したときの動作を指定して、指定したクラスの指定した静的メソッドを表す、指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドに対してのみデリゲートを作成します。 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されていて、非パブリックメソッドの許可セットが呼び出し元の許可セットに制限されている場合に、このメソッドを使用して非パブリックメソッドにアクセスできます。、またはそのサブセット。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="target" /> が <see langword="RuntimeType" /> ではありません。  
  
- または - 
 <paramref name="target" /> はオープン ジェネリック型です。 つまり、その <see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="static" /> メソッド (Visual Basic では <see langword="Shared" /> メソッド) ではありません。  
  
- または - 
 見つからないなどの原因により、<paramref name="method" /> をバインドできません。また、<paramref name="throwOnBindFailure" /> が <see langword="true" /> です。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberSignature Language="C#" Value="public object DynamicInvoke (object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (args As Object()) As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">現在のデリゲートが表すメソッドに渡される引数であるオブジェクトの配列。  
  
- または - 
 現在のデリゲートが表すメソッドが引数を必要としない場合は <see langword="null" />。</param>
        <summary>現在のデリゲートが表すメソッドを動的に呼び出します (遅延バインディング)。</summary>
        <returns>デリゲートが表すメソッドによって返されるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Delegate.DynamicInvokeImpl%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。  
  
- または - 
<paramref name="args" /> にリストされているパラメーターの数、順序、または型が無効です。</exception>
        <exception cref="T:System.ArgumentException">デリゲートが表すメソッドが、そのメソッドをサポートしないオブジェクトまたはクラスに対して呼び出されています。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">デリゲートが表すメソッドがインスタンス メソッドであり、対象オブジェクトが <see langword="null" /> です。  
  
- または - 
カプセル化されたメソッドの 1 つが例外をスローします。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">現在のデリゲートが表すメソッドに渡される引数であるオブジェクトの配列。  
  
- または - 
 現在のデリゲートが表すメソッドが引数を必要としない場合は <see langword="null" />。</param>
        <summary>現在のデリゲートが表すメソッドを動的に呼び出します (遅延バインディング)。</summary>
        <returns>デリゲートが表すメソッドによって返されるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 <xref:System.Delegate.DynamicInvoke%2A> メソッドを実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。  
  
- または - 
<paramref name="args" /> にリストされているパラメーターの数、順序、または型が無効です。</exception>
        <exception cref="T:System.ArgumentException">デリゲートが表すメソッドが、そのメソッドをサポートしないオブジェクトまたはクラスに対して呼び出されています。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">デリゲートが表すメソッドがインスタンス メソッドであり、対象オブジェクトが <see langword="null" /> です。  
  
- または - 
カプセル化されたメソッドの 1 つが例外をスローします。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在のデリゲートと比較するオブジェクト。</param>
        <summary>指定したオブジェクトと現在のデリゲートが同じ型を持ち、同じターゲット、メソッド、および呼び出しリストを共有しているかどうかを確認します。</summary>
        <returns><paramref name="obj" /> と現在のデリゲートが、同じターゲット、メソッド、および呼び出しリストを共有している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2つのデリゲートが同じ型ではない場合は、等価と見なされません。  
  
> [!IMPORTANT]
>  .NET Framework バージョン1.0 および1.1 では、デリゲートの型が異なる場合でも、ターゲット、メソッド、および呼び出しリストが等しい場合は、2つのデリゲートが等しいと見なされました。  
  
 次のように、メソッドとターゲットの等価性が比較されます。  
  
-   比較する2つのメソッドが両方とも静的であり、同じクラスのメソッドである場合、メソッドは等しいと見なされ、ターゲットも等しいと見なされます。  
  
-   比較対象の2つのメソッドがインスタンスメソッドであり、同じオブジェクトのメソッドが同じである場合、メソッドは等しいと見なされ、ターゲットも等しいと見なされます。  
  
-   それ以外の場合、メソッドは等しくないと見なされ、ターゲットも等しいとは見なされません。  
  
 2つの呼び出しリストは、順序が同じで、2つのリストの対応する要素が同じメソッドとターゲットを表している場合にのみ同一と見なされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>デリゲートのハッシュ コードを返します。</summary>
        <returns>デリゲートのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの戻り値は、2つの理由で永続化することはできません。 まず、クラスのハッシュ関数が変更されて、より適切な分布が生成され、以前のハッシュ関数の値が役に立たなくなります。 第2に、このクラスの既定の実装では、同じ値が異なるインスタンスによって返されることは保証されません。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>デリゲートの呼び出しリストを返します。</summary>
        <returns>現在のデリゲートの呼び出しリストを表すデリゲートの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列内の各デリゲートは、1つのメソッドのみを表します。  
  
 配列内のデリゲートの順序は、そのデリゲートが表すメソッドを現在のデリゲートが呼び出す順序と同じです。  
  
   
  
## Examples  
 次の例では、デリゲートに3つのメソッドを割り当てます。 次に、<xref:System.Delegate.GetInvocationList%2A> メソッドを呼び出して、デリゲートに割り当てられたメソッドの合計数を取得し、逆の順序でデリゲートを実行し、名前に部分文字列 "File" を含まないメソッドを実行します。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のデリゲートによって表される静的メソッドを取得します。</summary>
        <returns>現在のデリゲートによって表される静的メソッドについて説明する <see cref="T:System.Reflection.MethodInfo" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のデリゲートが静的メソッドを表す場合にのみ適用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">サポートされていません。</param>
        <param name="context">サポートされていません。</param>
        <summary>サポートされていません。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドはサポートされていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デリゲートによって表されるメソッドを取得します。</summary>
        <value>デリゲートによって表されるメソッドについて説明する <see cref="T:System.Reflection.MethodInfo" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">比較する最初のデリゲート。</param>
        <param name="d2">比較する 2 番目のデリゲート。</param>
        <summary>指定したデリゲートが等しいかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="d1" /> に等しい場合は <paramref name="d2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じ型の同じターゲット、メソッド、および呼び出しリストを持つ2つのデリゲートが等しいと見なされます。  
  
 2つのデリゲートが同じ型ではない場合は、等価と見なされません。  
  
> [!IMPORTANT]
>  .NET Framework バージョン1.0 および1.1 では、デリゲートの型が異なる場合でも、ターゲット、メソッド、および呼び出しリストが等しい場合は、2つのデリゲートが等しいと見なされました。  
  
 次のように、メソッドとターゲットの等価性が比較されます。  
  
-   比較する2つのメソッドが両方とも静的であり、同じクラスのメソッドである場合、メソッドは等しいと見なされ、ターゲットも等しいと見なされます。  
  
-   比較対象の2つのメソッドがインスタンスメソッドであり、同じオブジェクトのメソッドが同じである場合、メソッドは等しいと見なされ、ターゲットも等しいと見なされます。  
  
-   それ以外の場合、メソッドは等しくないと見なされ、ターゲットも等しいとは見なされません。  
  
 2つの呼び出しリストは同じ順序で、2つのリストの対応する要素が同じメソッドとターゲットを表している場合、同一と見なされます。  
  
 この演算子の同等の方法は <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">比較する最初のデリゲート。</param>
        <param name="d2">比較する 2 番目のデリゲート。</param>
        <summary>指定したデリゲートが等しくないかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="d1" /> と等しくない場合は <paramref name="d2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2つのデリゲートは、型が異なる場合、または異なるメソッド、異なるターゲット、または異なる呼び出しリストがある場合、等しくないと見なされます。  
  
 2つのデリゲートが同じ型ではない場合は、等価と見なされません。  
  
> [!IMPORTANT]
>  .NET Framework バージョン1.0 および1.1 では、デリゲートの型が異なる場合でも、ターゲット、メソッド、および呼び出しリストが等しい場合は、2つのデリゲートが等しいと見なされます。  
  
 次のように、メソッドとターゲットの等価性が比較されます。  
  
-   比較する2つのメソッドが両方とも静的であり、同じクラスのメソッドである場合、メソッドは等しいと見なされ、ターゲットも等しいと見なされます。  
  
-   比較対象の2つのメソッドがインスタンスメソッドであり、同じオブジェクトのメソッドが同じである場合、メソッドは等しいと見なされ、ターゲットも等しいと見なされます。  
  
-   それ以外の場合、メソッドは等しくないと見なされ、ターゲットも等しいとは見なされません。  
  
 2つの呼び出しリストは、サイズが異なる場合、異なる順序で並べ替えられている場合、または1つのリストの少なくとも1つの要素が、他のリストの対応する要素によって表されるメソッドまたはターゲットを表している場合は、等しくありません。  
  
 この演算子の同等の方法は <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><paramref name="value" /> の呼び出しリストの削除元のデリゲート。</param>
        <param name="value"><paramref name="source" /> の呼び出しリストから削除される呼び出しリストを持つデリゲート。</param>
        <summary>一方のデリゲートの呼び出しリストから、最後に出現した他方のデリゲートの呼び出しリストを削除します。</summary>
        <returns><paramref name="source" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に存在する場合は、<paramref name="value" /> の呼び出しリストから、最後に出現した <paramref name="source" /> の呼び出しリストを削除して得られる呼び出しリストを持つ新しいデリゲート。 <paramref name="source" /> が <see langword="null" /> の場合、または <paramref name="value" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に見つからない場合は <paramref name="source" /> を返します。 <paramref name="value" /> の呼び出しリストが <paramref name="source" /> の呼び出しリストと等しい場合、または <paramref name="source" /> が null 参照の場合は、null 参照を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` の呼び出しリストが `source`の呼び出しリスト内の一連の連続する要素と一致する場合、`value` の呼び出しリストは `source`の呼び出しリスト内で発生すると言われます。 `value` の呼び出しリストが `source`の呼び出しリストに複数回出現する場合は、最後に見つかったものが削除されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <exception cref="T:System.ArgumentException">デリゲートの型が一致しません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><paramref name="value" /> の呼び出しリストの削除元のデリゲート。</param>
        <param name="value"><paramref name="source" /> の呼び出しリストから削除される呼び出しリストを持つデリゲート。</param>
        <summary>一方のデリゲートの呼び出しリストから、そこに出現する他方のデリゲートの呼び出しリストをすべて削除します。</summary>
        <returns><paramref name="source" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に存在する場合は、<paramref name="value" /> の呼び出しリストから、そこに出現する <paramref name="source" /> の呼び出しリストをすべて削除して得られる呼び出しリストを持つ新しいデリゲート。 <paramref name="source" /> が <see langword="null" /> の場合、または <paramref name="value" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に見つからない場合は <paramref name="source" /> を返します。 <paramref name="value" /> の呼び出しリストが <paramref name="source" /> の呼び出しリストに等しい場合、<paramref name="source" /> の呼び出しリストに等しい一連の呼び出しリストだけが <paramref name="value" /> に含まれる場合、または <paramref name="source" /> が null 参照の場合は null 参照を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` の呼び出しリストが `source`の呼び出しリスト内の一連の連続する要素と一致する場合、`value` の呼び出しリストは `source`の呼び出しリスト内で発生すると言われます。 `value` の呼び出しリストが `source`の呼び出しリストに複数回出現する場合、すべての発生が削除されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <exception cref="T:System.ArgumentException">デリゲートの型が一致しません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">現在のデリゲートの呼び出しリストから削除される呼び出しリストを持つデリゲート。</param>
        <summary>一方のデリゲートの呼び出しリストから、他方のデリゲートの呼び出しリストを削除します。</summary>
        <returns>現在のデリゲートの呼び出しリストを取得し、そのリスト内に <paramref name="value" /> の呼び出しリストがある場合は、現在のデリゲートのリストから <paramref name="value" /> の呼び出しリストを削除した結果のリストを持つ新しいデリゲート。 <paramref name="value" /> が <see langword="null" /> の場合、または <paramref name="value" /> の呼び出しリストが現在のデリゲートの呼び出しリスト内で見つからなかった場合は現在のデリゲートを返します。 <paramref name="value" /> の呼び出しリストが現在のデリゲートの呼び出しリストと等しい場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` の呼び出しリストが現在のデリゲートの呼び出しリスト内の連続する要素のセットと一致する場合、`value` の呼び出しリストは、現在のデリゲートの呼び出しリスト内で発生すると言います。 `value` の呼び出しリストが現在のデリゲートの呼び出しリストに複数回出現する場合は、最後に出現したが削除されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のデリゲートがインスタンス メソッドを呼び出す対象のクラス インスタンスを取得します。</summary>
        <value>現在のデリゲートがインスタンス メソッドを表す場合は、デリゲートがインスタンス メソッドを呼び出す対象のオブジェクト。デリゲートが静的メソッドを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスメソッドは、クラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 デリゲートが1つ以上のインスタンスメソッドを呼び出す場合、このプロパティは、呼び出しリスト内の最後のインスタンスメソッドのターゲットを返します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> などの機構を使用して遅延バインディングで呼び出された場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
